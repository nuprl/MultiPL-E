language: rs
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp61_ddyiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut is_balanced = false;\n\
    \    for el in q {\n        if el > max_sum {\n            max_sum = el;\n   \
    \     }\n        if el == max_sum {\n            is_balanced = true;\n       \
    \ }\n    }\n    if !is_balanced {\n        return false;\n    }\n    if max_sum\
    \ == w {\n        return true;\n    }\n    let mut sum = 0;\n    for el in q {\n\
    \        sum += el;\n    }\n    if sum == w {\n        return true;\n    }\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmpcixuttou.rs:28:15\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for el in q {\n    |               -\n    |\
    \               |\n    |               `q` moved due to this implicit call to\
    \ `.into_iter()`\n    |               help: consider borrowing to avoid moving\
    \ into the for loop: `&q`\n...\n28  |     for el in q {\n    |               ^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp61_ddyiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        max_weight = if sum > w {\n      \
    \      max_weight\n        } else {\n            sum\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplo__m0q0.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n        return\
    \ true;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut sum\
    \ = 0;\n    let mut max_weight = 0;\n    for v in q {\n        sum += v;\n   \
    \     if sum > max_weight {\n            max_weight = sum;\n        }\n    }\n\
    \    if sum == max_weight {\n        return true;\n    }\n    if sum < w {\n \
    \       return false;\n    }\n    let mut sum = 0;\n    let mut max_weight = 0;\n\
    \    for v in q {\n        sum += v;\n        if sum > max_weight {\n        \
    \    max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n       \
    \ return true;\n    }\n    if sum < w {\n        return false;\n    }\n    let\
    \ mut sum = 0;\n    let mut max_weight = 0;\n    for v in q {\n        sum +=\
    \ v;\n        if sum > max_weight {\n            max_weight = sum;\n        }\n\
    \    }\n    if sum == max_weight {\n        return true;\n    }\n    if sum <\
    \ w {\n        return false;\n    }\n    let mut sum = 0;\n    let mut max_weight\
    \ = 0;\n    for v in q {\n        sum += v;\n        if sum > max_weight {\n \
    \           max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n\
    \        return true;\n    }\n    if sum < w {\n        return false;\n    }\n\
    \    let mut sum = 0;\n    let mut max_weight = 0;\n    for v in q {\n       \
    \ sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n  \
    \      }\n    }\n    if sum == max_weight {\n        return true;\n    }\n   \
    \ if sum < w {\n        return false;\n    }\n    let mut sum = 0;\n    let mut\
    \ max_weight = 0;\n    for v in q {\n        sum += v;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if sum == max_weight\
    \ {\n        return true;\n    }\n    if sum < w {\n        return false;\n  \
    \  }\n    let mut sum = 0;\n    let mut max_weight = 0;\n    for v in q {\n  \
    \      sum += v;\n        if sum > max_weight {\n            max_weight = sum;\n\
    \        }\n    }\n    if sum == max_weight {\n        return true;\n    }\n \
    \   if sum < w {\n        return false;\n    }\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for v in q {\n        sum += v;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if sum\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpvsbkke4k.rs:132:1\n    |\n\
    131 |     if sum\n    |     -- this `if` expression has a condition, but no block\n\
    132 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == w {\n            is_balanced = false;\n        }\n    }\n    is_balanced\
    \ && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7z2dc220.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_palindromic(q) && sum >= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp7y5gtmb1.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7y5gtmb1.rs:12:9\n   |\n12 |     for &i in q\
    \ {\n   |         ^^    - this expression has type `isize`\n   |         |\n \
    \  |         expected `isize`, found reference\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut balanced = true;\n\
    \    for e in q {\n        if e > max_weight {\n            max_weight = e;\n\
    \        }\n        if e < w {\n            balanced = false;\n        }\n   \
    \ }\n    balanced && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsrfyw48j.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum == w {\n            balanced\
    \ = true;\n        }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi9h3g1tp.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q.iter() {\n        sum += v;\n        if sum > max_weight {\n    \
    \        max_weight = sum;\n        }\n    }\n    if sum == w {\n        return\
    \ true;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    let mut j = q.len() - 1;\n    while i <= j {\n        if q[i] > q[j]\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplrvz__6g.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_palindromic(q) && sum <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp5yjycs2z.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ <= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut is_balanced = true;\n\
    \    for &i in q {\n        let mut sum = 0;\n        for &j in q {\n        \
    \    sum += j;\n        }\n        if sum > max_sum {\n            max_sum = sum;\n\
    \        }\n        if sum == w {\n            is_balanced = false;\n        }\n\
    \    }\n    is_balanced && max_sum <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp7cbimf6.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp7cbimf6.rs:15:13\n   |\n15 |         for &j in q {\n \
    \  |             ^^    - this expression has type `isize`\n   |             |\n\
    \   |             expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     max_weight\n        } else {\n            sum\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7a3gbmje.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = w;\n    let mut balanced = true;\n\
    \    let mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum >\
    \ max_weight {\n            max_weight = sum;\n        }\n        if sum < max_weight\
    \ {\n            balanced = false;\n        }\n    }\n    balanced && sum == max_weight\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkclb4bl.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n        if sum == w {\n           \
    \ balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvdzf8uc1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp4_lrfh48.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum >= w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcpcthvvv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdhp25ar.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        if sum > max_weight {\n          \
    \  max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    if j == q.len() {\n        return false;\n    }\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len() {\n       \
    \ if q[i] > q[j] {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n    if i == q.len() {\n        return false;\n    }\n    if\
    \ j == q.len() {\n        return true;\n    }\n    if q[i] > q[j] {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg76pxbeb.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpn8v06uvr.rs:136:3\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n120 |  \
    \   while i < q.len() && j < q.len() {\n    |                                \
    \      - unclosed delimiter\n...\n123 |         } else {\n    |              \
    \  - this delimiter might not be properly closed...\n...\n126 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n136 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n   --> /tmp/tmpn8v06uvr.rs:120:5\n    |\n10  |\
    \   fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |                 \
    \                             ---- expected `bool` because of return type\n...\n\
    120 | /     while i < q.len() && j < q.len() {\n121 | |         if q[i] > q[j]\
    \ {\n122 | |             i += 1;\n123 | |         } else {\n...   |\n135 | | \
    \    assert_eq!(candidate(vec![5], 5), true);\n136 | | }\n    | |__^ expected\
    \ `bool`, found `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut balanced = false;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum == w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptxuy0eec.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut balanced = true;\n  \
    \  for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum < w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8eveyub5.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum < w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfol354te.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q.iter() {\n       \
    \ sum += v;\n    }\n    if sum == w {\n        return true;\n    }\n    if sum\
    \ > w {\n        return false;\n    }\n    let mut max_weight = w;\n    let mut\
    \ max_weight2 = w;\n    let mut max_weight3 = w;\n    let mut max_weight4 = 0;\n\
    \    let mut max_weight5 = 0;\n    let mut max_weight6 = 0;\n    let mut max_weight7\
    \ = 0;\n    let mut max_weight8 = 0;\n    let mut max_weight9 = 0;\n    let mut\
    \ max_weight10 = 0;\n    let mut max_weight11 = 0;\n    let mut max_weight12 =\
    \ 0;\n    let mut max_weight13 = 0;\n    let mut max_weight14 = 0;\n    let mut\
    \ max_weight15 = 0;\n    let mut max_weight16 = 0;\n    let mut max_weight17 =\
    \ 0;\n    let mut max_weight18 = 0;\n    let mut max_weight19 = 0;\n    let mut\
    \ max_weight20 = 0;\n    let mut max_weight21 = 0;\n    let mut max_weight22 =\
    \ 0;\n    let mut max_weight23 = 0;\n    let mut max_weight24 = 0;\n    let mut\
    \ max_weight25 = 0;\n    let mut max_weight26 = 0;\n    let mut max_weight27 =\
    \ 0;\n    let mut max_weight28 = 0;\n    let mut max_weight29 = 0;\n    let mut\
    \ max_weight30 = 0;\n    let mut max_weight31 = 0;\n    let mut max_weight32 =\
    \ 0;\n    let mut max_weight33 = 0;\n    let mut max_weight34 = 0;\n    let mut\
    \ max_weight35 = 0;\n    let mut max_weight36 = 0;\n    let mut max_weight37 =\
    \ 0;\n    let mut max_weight38 = 0;\n    let mut max_weight39 = 0;\n    let mut\
    \ max_weight40 = 0;\n    let mut max_weight41 = 0;\n    let mut max_weight42 =\
    \ 0;\n    let mut max_weight43 = 0;\n    let mut max_weight44 = 0;\n    let mut\
    \ max_weight45 = 0;\n    let mut max_weight46 = 0;\n    let mut max_weight47 =\
    \ 0;\n    let mut max_weight48 = 0;\n    let mut max_weight49 = 0;\n    let mut\
    \ max_weight50 = 0;\n    let mut max_weight51 = 0;\n    let mut max_weight52 =\
    \ 0;\n    let mut max_weight53 = 0;\n    let mut max_weight54 = 0;\n    let mut\
    \ max_weight55 = 0;\n    let mut max_weight56 = 0;\n    let mut max_weight57 =\
    \ 0;\n    let mut max_weight58 = 0;\n    let mut max_weight59 = 0;\n    let mu\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9v9nws0z.rs:80:11\n   |\n\
    80 |     let mu\n   |           ^ help: add `;` here\n81 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9v9nws0z.rs:10:44\n \
    \  |\n10 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------\
    \                             ^^^^ expected `bool`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max = 0;\n    for x in\
    \ q {\n        sum += x;\n        if sum > max {\n            max = sum;\n   \
    \     }\n    }\n    sum == max && is_balanced(q, w)\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpebz0atqu.rs:19:19\n\
    \   |\n19 |     sum == max && is_balanced(q, w)\n   |                   ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for &i in q {\n        sum += i;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == w {\n            is_balanced = false;\n            break;\n        }\n  \
    \  }\n    is_balanced && max_weight <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7e9ghoy.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     sum\n        } else {\n            max_weight\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6vd1z761.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q.iter() {\n       \
    \ sum += v;\n    }\n    sum < w && is_palindromic(q) && sum >= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpndilpb5n.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        max_weight = if sum > w {\n      \
    \      max_weight\n        } else {\n            sum\n        };\n    }\n    sum\
    \ == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy6zqpr4x.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q.iter() {\n        sum += v;\n        if sum > max_weight {\n    \
    \        max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n     \
    \   return false;\n    }\n    let mut is_balanced = true;\n    for v in q.iter()\
    \ {\n        if v != q.iter().rev().next().unwrap() {\n            is_balanced\
    \ = false;\n            break;\n        }\n    }\n    if is_balanced {\n     \
    \   true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzg_8tfqb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_sum = 0;\n    let\
    \ mut is_balanced = true;\n    for x in q {\n        sum += x;\n        if sum\
    \ > max_sum {\n            max_sum = sum;\n        }\n        if sum < w {\n \
    \           is_balanced = false;\n        }\n    }\n    is_balanced && max_sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp082wby2j.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut max_sum\
    \ = 0;\n    for x in q {\n        max_sum += x;\n    }\n    if max_sum == w {\n\
    \        return true;\n    }\n    if max_sum > w {\n        return false;\n  \
    \  }\n    let mut max_weight = 0;\n    for x in q {\n        max_weight = max(max_weight,\
    \ x);\n    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ > w {\n        return false;\n    }\n    let mut max_weight_index = 0;\n   \
    \ for x in q {\n        if x == max_weight {\n            max_weight_index = q.iter().position(|&x|\
    \ x == max_weight).unwrap();\n            break;\n        }\n    }\n    let mut\
    \ max_weight_index = max_weight_index - 1;\n    let mut max_weight_value = q[max_weight_index];\n\
    \    for x in q.iter().rev() {\n        if x == max_weight_value {\n         \
    \   max_weight_index += 1;\n            max_weight_value = q[max_weight_index];\n\
    \            break;\n        }\n    }\n    if max_weight_index == 0 {\n      \
    \  return true;\n    }\n    if max_weight_index == q.len() - 1 {\n        return\
    \ false;\n    }\n    let mut max_weight_value = q[max_weight_index];\n    for\
    \ x in q.iter().rev() {\n        if x == max_weight_value {\n            max_weight_index\
    \ -= 1;\n            max_weight_value = q[max_weight_index];\n            break;\n\
    \        }\n    }\n    if max_weight_index == 0 {\n        return true;\n    }\n\
    \    if max_weight_index == q.len() - 1 {\n        return false;\n    }\n    let\
    \ mut max_weight_value = q[max_weight_index];\n    for x in q.iter().rev() {\n\
    \        if x == max_weight_value {\n            max_weight_index += 1;\n    \
    \        max_weight_value = q[max_weight_index];\n            break;\n       \
    \ }\n    }\n    if max_weight_index == 0 {\n        return true;\n    }\n    if\
    \ max_weight_index == q.len() - 1 {\n        return false;\n    }\n    let mut\
    \ max_weight_value = q[max_weight_index];\n    for x in q.iter().rev() {\n   \
    \     if x == max_weight_value {\n            max_weight_index -= 1;\n       \
    \     max_weight_value = q[max_weight_index];\n            break;\n        }\n\
    \    }\n    if max_weight_index == 0 {\n        return true;\n    }\n    if max_weight_index\
    \ == q.len() - 1 {\n        return false;\n    }\n    let mut max_weight_value\
    \ = q[max_weight_index];\n    for x in q.iter().rev() {\n        if x == max_weight_value\
    \ {\n            max_weight_index += 1;\n            max_weight_value = q[max_weight_index];\n\
    \            break;\n        }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp10kxwgd7.rs:119:3\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n103 |  \
    \   for x in q.iter().rev() {\n    |                             - this delimiter\
    \ might not be properly closed...\n...\n109 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n119 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find function `max` in this scope\n  --> /tmp/tmp10kxwgd7.rs:30:22\n   |\n30\
    \ |         max_weight = max(max_weight, x);\n   |                      ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp10kxwgd7.rs:48:14\n   |\n48 |         if x == max_weight_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp10kxwgd7.rs:62:14\n\
    \   |\n62 |         if x == max_weight_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp10kxwgd7.rs:76:14\n   |\n76 |         if x == max_weight_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n    "
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     sum\n        } else {\n            max_weight\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6vd1z761.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut is_balanced = true;\n\
    \    for v in q.iter() {\n        if v > max_sum {\n            max_sum = v;\n\
    \        }\n        if v == max_sum {\n            is_balanced = false;\n    \
    \    }\n    }\n    if !is_balanced {\n        return false;\n    }\n    let mut\
    \ sum = 0;\n    for v in q.iter() {\n        sum += v;\n    }\n    if sum == w\
    \ {\n        return true;\n    }\n    if sum > w {\n        return false;\n  \
    \  }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > max_weight\
    \ {\n            max_weight = v;\n        }\n    }\n    if max_weight == w {\n\
    \        return true;\n    }\n    if max_weight > w {\n        return false;\n\
    \    }\n    let mut max_weight = 0;\n    for v in q.iter() {\n        if v > \n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqky2sd8z.rs:143:3\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n131 |  \
    \   for v in q.iter() {\n    |                       - this delimiter might not\
    \ be properly closed...\n132 |         if v > \n133 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n143 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpqky2sd8z.rs:133:1\n    |\n133 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqky2sd8z.rs:14:16\n\
    \   |\n14 |         if v > max_sum {\n   |                ^^^^^^^\n   |      \
    \          |\n   |                expected `&isize`, found integer\n   |     \
    \           help: consider borrowing here: `&max_sum`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqky2sd8z.rs:15:23\n   |\n11 |     let mut max_sum = 0;\n\
    \   |                       - expected due to this value\n...\n15 |          \
    \   max_sum = v;\n   |                       ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |             max_sum\
    \ = *v;\n   |                       +\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpqky2sd8z.rs:17:14\n   |\n17 |         if v ==\
    \ max_sum {\n   |              ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqky2sd8z.rs:36:16\n\
    \   |\n36 |         if v > max_weight {\n   |                ^^^^^^^^^^\n   |\
    \                |\n   |                expected `&isize`, found integer\n   |\
    \                help: consider borrowing here: `&max_weight`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqky2sd8z.rs:37:26\n   |\n34 |     let mut max_"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut is_balanced = true;\n\
    \    for x in q {\n        sum += x;\n        is_balanced = is_balanced && sum\
    \ >= w;\n    }\n    is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphwy2uy3d.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpkuxcwdbz.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut balanced = true;\n\
    \    for &i in q {\n        max_sum += i;\n        if max_sum > w {\n        \
    \    balanced = false;\n            break;\n        }\n    }\n    balanced &&\
    \ max_sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgq50xgzu.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        if sum > max_weight {\n          \
    \  max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut sum = 0;\n    while i < q.len() {\n        sum +=\
    \ q[i];\n        i += 1;\n    }\n    if sum == max_weight {\n        return true;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return false;\n\
    \    }\n    let mut sum = 0;\n    while i < q.len() {\n        sum += q[i];\n\
    \        i += 1;\n    }\n    if sum == max_weight {\n        return true;\n  \
    \  }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return false;\n\
    \    }\n    let mut sum = 0;\n    while i < q.len() {\n        sum += q[i];\n\
    \        i += 1;\n    }\n    if sum == max_weight {\n        return true;\n  \
    \  }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return false;\n\
    \    }\n    let mut sum = 0;\n    while i < q.len() {\n        sum += q[i];\n\
    \        i += 1;\n    }\n    if sum == max_weight {\n        return true;\n  \
    \  }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return false;\n\
    \    }\n    let mut sum = 0;\n    while i < q.len() {\n        sum += q[i];\n\
    \        i += 1;\n    }\n    if sum == max_weight {\n        return true;\n  \
    \  }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvkg2_uvz.rs:136:3\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n124 |  \
    \   while i < q.len() && j < q.len() {\n    |                                \
    \      - this delimiter might not be properly closed...\n125 |         if q[i]\
    \ > q[j\n126 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n136 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpvkg2_uvz.rs:126:1\n\
    \    |\n125 |         if q[i] > q[j\n    |         -- this `if` expression has\
    \ a condition, but no block\n126 | }\n    | ^ expected `{`\n\nerror: mismatched\
    \ closing delimiter: `}`\n   --> /tmp/tmpvkg2_uvz.rs:125:20\n    |\n10  | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n    |                                     \
    \            - closing delimiter possibly meant for this\n...\n125 |         if\
    \ q[i] > q[j\n    |                    ^ unclosed delimiter\n126 | }\n    | ^\
    \ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvkg2_uvz.rs:13:9\n\
    \   |\n13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvkg2_uvz.rs:10:44\n   |\n10 | fn will_it_fly(q: Vec<isize>, w:\
    \ isize) -> bool {\n   |    -----------                             ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_sum = 0;\n    for\
    \ x in q {\n        sum += x;\n        max_sum = max_sum.max(sum);\n    }\n  \
    \  max_sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp42thb5qr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_palindromic(q) && sum >= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp7y5gtmb1.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7y5gtmb1.rs:12:9\n   |\n12 |     for &i in q\
    \ {\n   |         ^^    - this expression has type `isize`\n   |         |\n \
    \  |         expected `isize`, found reference\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    sum == max_weight && is_balanced(q,\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpd7wo92dk.rs:19:26\n\
    \   |\n19 |     sum == max_weight && is_balanced(q, w)\n   |                 \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_palindromic(q) && sum >= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpshpydxxz.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut reversed_q = q.iter().rev();\n    let mut sum = 0;\n    let\
    \ mut max_weight = 0;\n    for x in reversed_q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ sum < w {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpyjp9hu0g.rs:22:9\n\
    \   |\n22 |     let mut reversed_q = q.iter().rev();\n   |         ----^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpyjp9hu0g.rs:22:26\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n22  |     let mut reversed_q\
    \ = q.iter().rev();\n    |                          ^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `q`\n    = note: borrow occurs due to deref coercion to `[isize]`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |     for x in &q {\n    |              +\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut balanced = false;\n \
    \   for v in q {\n        sum += v;\n        if sum >= w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm8eourrs.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzc8isf6x.rs:136:3\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n120 |  \
    \   while i < q.len() && j < q.len() {\n    |                                \
    \      - unclosed delimiter\n...\n123 |         } else {\n    |              \
    \  - this delimiter might not be properly closed...\n...\n126 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n136 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n   --> /tmp/tmpzc8isf6x.rs:120:5\n    |\n10  |\
    \   fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |                 \
    \                             ---- expected `bool` because of return type\n...\n\
    120 | /     while i < q.len() && j < q.len() {\n121 | |         if q[i] > q[j]\
    \ {\n122 | |             i += 1;\n123 | |         } else {\n...   |\n135 | | \
    \    assert_eq!(candidate(vec![5], 5), true);\n136 | | }\n    | |__^ expected\
    \ `bool`, found `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ < w {\n            is_balanced = false;\n            break;\n        }\n   \
    \ }\n    if is_balanced {\n        true\n    } else {\n        max_weight <= w\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpquge04wv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        if sum > max_weight {\n          \
    \  max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n        return\
    \ true;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    let mut j = q.len();\n    while i < j {\n        if q[i] != q[j] {\n\
    \            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpouqtrkqz.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = true;\n    let mut sum = 0;\n  \
    \  for x in q {\n        sum += x;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4fx27pwp.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for i in q.iter() {\n        sum += i;\n        if sum == w {\n          \
    \  balanced = true;\n        }\n    }\n    balanced\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq8js9s00.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q.iter() {\n       \
    \ sum += v;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp2hpcsua5.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum < w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpge_knjvo.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for el in q {\n        sum += el;\n        if sum > max_weight {\n         \
    \   max_weight = sum;\n        }\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut is_balanced = true;\n    let mut max_sum = 0;\n    for el\
    \ in q {\n        if el > max_sum {\n            max_sum = el;\n        }\n  \
    \      if el != max_sum {\n            is_balanced = false;\n            break;\n\
    \        }\n    }\n    if is_balanced {\n        max_sum == w\n    } else {\n\
    \        max_sum > w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmprisdogz5.rs:24:15\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for el in q {\n    |               - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n24  |     for el in q {\n\
    \    |               ^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n13  |     for el in &q {\n    |               +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum == w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ahwaami.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w { max_weight\
    \ } else { max_weight + x };\n    }\n    sum == w && max_weight <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxh89na_i.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for &i in q {\n        sum += i;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ < w {\n            is_balanced = false;\n            break;\n        }\n   \
    \ }\n    if is_balanced {\n        true\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdknu_qaq.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum == w {\n        true\n    }\
    \ else if sum < w {\n        false\n    } else {\n        max_weight < w\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1118vzda.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_palindromic(q) && sum == w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpr1yzufdr.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == max_weight {\n            is_balanced = false;\n        }\n    }\n    if\
    \ is_balanced {\n        true\n    } else {\n        max_weight <= w && is_balanced\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppuepsgmg.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max = 0;\n    for x in\
    \ q {\n        sum += x;\n        if sum > max {\n            max = sum;\n   \
    \     }\n    }\n    sum == max && is_balanced(q, w)\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpebz0atqu.rs:19:19\n\
    \   |\n19 |     sum == max && is_balanced(q, w)\n   |                   ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_palindromic(q) && sum == w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpxqooqbxn.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > max_weight {\
    \ max_weight } else { sum };\n    }\n    max_weight <= w && is_balanced(q, max_weight)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpan0y65k1.rs:17:24\n\
    \   |\n17 |     max_weight <= w && is_balanced(q, max_weight)\n   |          \
    \              ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp4tc95aa8.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp4tc95aa8.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for v in q.iter() {\n        sum += v;\n  \
    \      if sum > max_weight {\n            max_weight = sum;\n        }\n     \
    \   if sum == w {\n            is_balanced = false;\n        }\n    }\n    is_balanced\
    \ && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmperyeyibj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum >= w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcpcthvvv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   let mut max_weight = 0;\n    for el in q {\n        sum += el;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ sum < w {\n        balanced = false;\n    } else {\n        balanced = true;\n\
    \    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4dytmjg7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx72hx3hb.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum >= w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc8az8oiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = true;\n    let mut sum = 0;\n  \
    \  for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph08daz2h.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w { max_weight\
    \ } else { max_weight + x };\n    }\n    sum == w && max_weight <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxh89na_i.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut is_balanced = true;\n\
    \    for x in q {\n        if x > w {\n            is_balanced = false;\n    \
    \        break;\n        }\n        max_sum += x;\n    }\n    if max_sum < w {\n\
    \        is_balanced = false;\n    }\n    is_balanced\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5i36pphn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = w;\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for i in q.iter() {\n        sum += i;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == max_weight {\n            balanced = true;\n        }\n    }\n    balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpat95aui7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   let mut max_weight = 0;\n    for i in q {\n        sum += i;\n        if sum\
    \ > max_weight {\n            max_weight = sum;\n        }\n        if sum ==\
    \ w {\n            balanced = true;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8se7ltj3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = true;\n    let mut sum = 0;\n  \
    \  for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph08daz2h.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for el in q {\n        sum += el;\n        max_weight = if sum > max_weight\
    \ { max_weight } else { sum };\n    }\n    sum == max_weight && is_balanced(q,\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp1nmdwfn6.rs:17:26\n\
    \   |\n17 |     sum == max_weight && is_balanced(q, w)\n   |                 \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_palindromic(q) && sum == w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpxqooqbxn.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return true;\n\
    \    }\n    if j == q.len() {\n        return false;\n    }\n    if q[i] != q[j]\
    \ {\n        return false;\n    }\n    if max_weight == w {\n        return true;\n\
    \    }\n    if max_weight < w {\n        return false;\n    }\n    if max_weight\
    \ == w {\n        return true;\n    }\n    if max_weight < w {\n        return\
    \ false;\n    }\n    if max_weight == w {\n        return true;\n    }\n    if\
    \ max_weight < w {\n        return false;\n    }\n    if max_weight == w {\n \
    \       return true;\n    }\n    if max_weight < w {\n        return false;\n\
    \    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ < w {\n        return false;\n    }\n    if max_weight == w {\n        return\
    \ true;\n    }\n    if max_weight < w {\n        return false;\n    }\n    if\
    \ max_weight == w {\n        return true;\n    }\n    if max_weight < w {\n  \
    \      return false;\n    }\n    if max_weight == w {\n        return true;\n\
    \    }\n    if max_weight < w {\n        return false;\n    }\n    if max_weight\
    \ == w {\n        return true;\n    }\n    if max_weight < w {\n        return\
    \ false;\n    }\n    if max_weight == w {\n        return true;\n    }\n    if\
    \ max_weight < w {\n        return false;\n    }\n    if max_weight == w {\n \
    \       return true;\n    }\n    if max_weight < w {\n        return false;\n\
    \    }\n    if max_weight == w {\n        return true;\n    }\n    if max_weight\
    \ < w {\n        return false;\n    }\n    if max_weight == w {\n        return\
    \ true;\n    }\n    if max_weight < w {\n        return false;\n    }\n    if\
    \ max_weight == w {\n        return true;\n    }\n    if max_weight < w {\n  \
    \      return false;\n    }\n    if max_weight == w {\n        return true;\n\
    \    }\n    if max_weight < w {\n        return false;\n    }\n    if max_weight\
    \ == w {\n        return true;\n    }\n    if max_weight < w {\n        return\
    \ false;\n    }\n    if max_weight == w {\n        return true;\n    }\n    if\
    \ max_weight < w {\n        return false;\n    }\n    if max_weight == w {\n \
    \       return true;\n    }\n    if max_weight \n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpz1vaw7dq.rs:146:1\n    |\n\
    145 |     if max_weight \n    |     -- this `if` expression has a condition, but\
    \ no block\n146 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr7k5yr1v.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n    let mut sum = 0;\n    for v in q.iter() {\n        sum += v;\n  \
    \      if sum > max_weight {\n            max_weight = sum;\n        }\n     \
    \   if sum < w {\n            is_balanced = false;\n        }\n    }\n    is_balanced\
    \ && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp586qfrdd.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for el in q {\n        sum += el;\n        if sum > max_weight {\n         \
    \   max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len()\
    \ && j < q.len() {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    if i == q.len() {\n        return\
    \ true;\n    }\n    if j == q.len() {\n        return false;\n    }\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len() {\n       \
    \ if q[i] < q[j] {\n            i += 1;\n        } else {\n            j += 1;\n\
    \        }\n    }\n    if i == q.len() {\n        return false;\n    }\n    if\
    \ j == q.len() {\n        return true;\n    }\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n \
    \           i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    if i == q.len() {\n        return false;\n    }\n    if j == q.len() {\n\
    \        return true;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < q.len() && j < q.len() {\n        if q[i] < q[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    if i == q.len()\
    \ {\n        return true;\n    }\n    if j == q.len() {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return true;\n\
    \    }\n    if j == q.len() {\n        return false;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] <\
    \ q[j] {\n            i += 1;\n        } else {\n            j += 1;\n       \
    \ }\n    }\n    if i == q.len() {\n        return true;\n    }\n    if j == q.len()\
    \ {\n        return false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  while i < q.len() && j < q.len() {\n        if q[i] > q[j] {\n            i\
    \ += 1;\n        } else {\n            j += 1;\n        }\n    }\n    if i ==\
    \ q.len() {\n        return true;\n    }\n    if j == q.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < \n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpgkuttt8i.rs:130:1\n\
    \    |\n129 |     while i < \n    |     ----- while parsing the condition of this\
    \ `while` expression\n130 | }\n    | ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut is_balanced = true;\n\
    \    for x in q {\n        if x != 0 {\n            sum += x;\n        }\n   \
    \ }\n    if sum < w {\n        is_balanced = false;\n    }\n    is_balanced &&\
    \ is_palindromic(q) && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpugh2drq5.rs:21:20\n   |\n21 |     is_balanced && is_palindromic(q) &&\
    \ sum <= w\n   |                    ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum == w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ahwaami.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        if sum > max_weight {\n          \
    \  max_weight = sum;\n        }\n    }\n    sum == max_weight\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphvwysv3w.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = w;\n    let mut balanced = true;\n\
    \    let mut sum = 0;\n    for &i in q {\n        sum += i;\n        if sum >\
    \ max_weight {\n            max_weight = sum;\n        }\n        if sum < max_weight\
    \ {\n            balanced = false;\n            break;\n        }\n    }\n   \
    \ balanced && sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbvnyoogl.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        max_weight = if sum > w { max_weight\
    \ } else { max_weight + i };\n    }\n    sum == w && max_weight <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv2vlmgza.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n    for el in q {\n        if el > max_weight {\n            max_weight\
    \ = el;\n        }\n        if el != q[q.len() - 1 - el] {\n            is_balanced\
    \ = false;\n            break;\n        }\n    }\n    if is_balanced && max_weight\
    \ <= w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj9mxgr3_.rs:17:34\n   |\n\
    17 |         if el != q[q.len() - 1 - el] {\n   |                            \
    \      ^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpj9mxgr3_.rs:17:32\n   |\n17 |         if el != q[q.len()\
    \ - 1 - el] {\n   |                                ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp1gsxmpa1.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp1gsxmpa1.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1gsxmpa1.rs:12:9\n   |\n12 |     for &i in q {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == w {\n            is_balanced = false;\n        }\n    }\n    is_balanced\
    \ && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7z2dc220.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum >= w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc8az8oiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpkuxcwdbz.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q {\n        sum +=\
    \ v;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp6apmbgi0.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp6apmbgi0.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q {\n        sum +=\
    \ v;\n    }\n    sum < w && is_palindromic(q) && sum == w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpoe44nqdh.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ == w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum >= w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc8az8oiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = w;\n    let mut balanced = true;\n\
    \    for el in q.iter() {\n        if el > max_weight {\n            max_weight\
    \ = el;\n        }\n        if el != q.len() - 1 {\n            if el != q.len()\
    \ - 2 {\n                balanced = false;\n                break;\n         \
    \   }\n        }\n    }\n    balanced && max_weight <= w\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqyq1_goy.rs:14:17\n   |\n\
    14 |         if el > max_weight {\n   |                 ^^^^^^^^^^\n   |     \
    \            |\n   |                 expected `&isize`, found `isize`\n   |  \
    \               help: consider borrowing here: `&max_weight`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqyq1_goy.rs:15:26\n   |\n11 |     let mut max_weight\
    \ = w;\n   |                          - expected due to this value\n...\n15 |\
    \             max_weight = el;\n   |                          ^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |  \
    \           max_weight = *el;\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqyq1_goy.rs:17:18\n   |\n17 |         if el\
    \ != q.len() - 1 {\n   |                  ^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n  --> /tmp/tmpqyq1_goy.rs:17:15\n\
    \   |\n17 |         if el != q.len() - 1 {\n   |               ^^ no implementation\
    \ for `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqyq1_goy.rs:18:22\n   |\n18 |             if el != q.len() - 2 {\n \
    \  |                      ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `usize`\n  --> /tmp/tmpqyq1_goy.rs:18:19\n   |\n\
    18 |             if el != q.len() - 2 {\n   |                   ^^ no implementation\
    \ for `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 6 previous erro"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     max_weight\n        } else {\n            sum\n        };\n    }\n    if\
    \ max_weight == w {\n        true\n    } else {\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg6bn_g8v.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q.iter() {\n        sum += x;\n  \
    \      if sum > max_weight {\n            max_weight = sum;\n        }\n     \
    \   if sum < w {\n            is_balanced = false;\n            break;\n     \
    \   }\n    }\n    if is_balanced {\n        true\n    } else {\n        max_weight\
    \ <= w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpub664wdp.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for i in q.iter() {\n        sum += i;\n        if sum == w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0wdz_mf7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q) && sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpszkrthng.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && sum <= w\n \
    \  |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindromic` in this scope\n  --> /tmp/tmpszkrthng.rs:15:34\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && sum <= w\n \
    \  |                                  ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    if sum == w {\n        return true;\n    }\n    if sum > w {\n\
    \        return false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = q.len();\n    while i < k {\n        if q[i] > q[j] {\n            return\
    \ false;\n        }\n        if q[i] < q[j] {\n            i += 1;\n        }\
    \ else {\n            j += 1;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaclow_im.rs:12:9\n   |\n\
    12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    while i < q.len() {\n        if q[i] != q[q.len()\
    \ - 1 - i] {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpzu37ia_7.rs:23:15\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for v in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n23  |     while i < q.len()\
    \ {\n    |               ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `q`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |     for v in &q {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum > w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvvkisss1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == max_weight {\n            is_balanced = false;\n        }\n    }\n    sum\
    \ == max_weight && is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp39vbieuj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for &i in q {\n        sum += i;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ < w {\n            is_balanced = false;\n            break;\n        }\n   \
    \ }\n    if is_balanced {\n        true\n    } else {\n        max_weight <= w\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5yktlfre.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return true;\n\
    \    }\n    if j == q.len() {\n        return false;\n    }\n    if q[i] == q[j]\
    \ {\n        return will_it_fly(q.iter().rev(), w);\n    }\n    if q[i] > q[j]\
    \ {\n        return will_it_fly(q.iter().rev(), w);\n    }\n    return will_it_fly(q.iter().rev(),\
    \ w);\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb__6drlt.rs:38:28\n   |\n\
    38 |         return will_it_fly(q.iter().rev(), w);\n   |                    \
    \        ^^^^^^^^^^^^^^ expected struct `Vec`, found struct `Rev`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb__6drlt.rs:41:28\n\
    \   |\n41 |         return will_it_fly(q.iter().rev(), w);\n   |             \
    \               ^^^^^^^^^^^^^^ expected struct `Vec`, found struct `Rev`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb__6drlt.rs:43:24\n\
    \   |\n43 |     return will_it_fly(q.iter().rev(), w);\n   |                 \
    \       ^^^^^^^^^^^^^^ expected struct `Vec`, found struct `Rev`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q {\n        sum +=\
    \ v;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp6apmbgi0.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp6apmbgi0.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q {\n        sum += v;\n        if sum == w {\n            balanced\
    \ = true;\n        }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpebd1svw8.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if max_weight < w {\n        return\
    \ false;\n    }\n    let mut is_balanced = true;\n    let mut q_rev = q;\n   \
    \ q_rev.reverse();\n    for x in q_rev {\n        if x != q[0] {\n           \
    \ is_balanced = false;\n            break;\n        }\n    }\n    if is_balanced\
    \ {\n        true\n    } else {\n        will_it_fly(q, w)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmptpf1yk6x.rs:23:21\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n23  |     let mut q_rev =\
    \ q;\n    |                     ^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n13  |     for x in &q {\n    |              +\n\nerror[E0382]:\
    \ borrow of moved value: `q`\n  --> /tmp/tmptpf1yk6x.rs:26:17\n   |\n10 | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n   |                - move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n23 |\
    \     let mut q_rev = q;\n   |                     - value moved here\n...\n26\
    \ |         if x != q[0] {\n   |                 ^ value borrowed here after move\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     sum\n        } else {\n            max_weight\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6vd1z761.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr7k5yr1v.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum >= w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcpcthvvv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for i in q.iter() {\n        sum += i;\n        if sum == w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0wdz_mf7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ < w {\n            is_balanced = false;\n        }\n    }\n    is_balanced &&\
    \ max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnijd9a0s.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum == w {\n        return true;\n\
    \    }\n    if sum < w {\n        return false;\n    }\n    let mut i = 0;\n \
    \   let mut j = 0;\n    let mut k = q.len();\n    while i < k {\n        if q[i]\
    \ > q[j] {\n            i += 1;\n        } else {\n            j += 1;\n     \
    \   }\n        if i == k {\n            break;\n        }\n    }\n    if i ==\
    \ k {\n        return false;\n    }\n    let mut sum = 0;\n    while i < k {\n\
    \        sum += q[i];\n        i += 1;\n    }\n    if sum == w {\n        return\
    \ true;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    let mut k = q.len();\n    while i < k {\n    \
    \    if q[i] > q[j] {\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n        if i == k {\n            break;\n        }\n    }\n \
    \   if i == k {\n        return false;\n    }\n    let mut sum = 0;\n    while\
    \ i < k {\n        sum += q[i];\n        i += 1;\n    }\n    if sum == w {\n \
    \       return true;\n    }\n    if sum < w {\n        return false;\n    }\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = q.len();\n    while i\
    \ < k {\n        if q[i] > q[j] {\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n        if i == k {\n            break;\n      \
    \  }\n    }\n    if i == k {\n        return false;\n    }\n    let mut sum =\
    \ 0;\n    while i < k {\n        sum += q[i];\n        i += 1;\n    }\n    if\
    \ sum == w {\n        return true;\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = q.len();\n   \
    \ while i < k {\n        if q[i] > q[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n        if i == k {\n            break;\n\
    \        }\n    }\n    if i == k {\n        return false;\n    }\n    let mut\
    \ sum = 0;\n    while i < k {\n        sum += q[i];\n        i += 1;\n    }\n\
    \    if sum == w {\n        return true;\n    }\n    if sum < w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = q.len();\n\
    \    while i < k {\n        if q[i] > q[j\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmptfpxls4v.rs:148:3\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n136 |  \
    \   while i < k {\n    |                 - this delimiter might not be properly\
    \ closed...\n137 |         if q[i] > q[j\n138 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n148 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmptfpxls4v.rs:138:1\n    |\n137 |         if q[i]\
    \ > q[j\n    |         -- this `if` expression has a condition, but no block\n\
    138 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  \
    \ --> /tmp/tmptfpxls4v.rs:137:20\n    |\n10  | fn will_it_fly(q: Vec<isize>, w:\
    \ isize) -> bool {\n    |                                                 - closing\
    \ delimiter possibly meant for this\n...\n137 |         if q[i] > q[j\n    | \
    \                   ^ unclosed delimiter\n138 | }\n    | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptfpxls4v.rs:10:44\n\
    \   |\n10 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------\
    \                             ^^^^ expected `bool`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut max_sum\
    \ = 0;\n    let mut max_weight = 0;\n    for x in q {\n        max_sum += x;\n\
    \        if max_sum > w {\n            return false;\n        }\n        if max_sum\
    \ > max_weight {\n            max_weight = max_sum;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmphv5860ia.rs:20:14\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n11  |     let mut sum = 0;\n12  |     for x in q {\n    |\
    \              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     for x in q {\n    |              ^ value used here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `q`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for x in &q {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     max_weight\n        } else {\n            sum\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7a3gbmje.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     max_weight\n        } else {\n            sum\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7a3gbmje.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = true;\n    let mut sum = 0;\n  \
    \  for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph08daz2h.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for v in q.iter() {\n        sum += v;\n  \
    \      if sum > max_weight {\n            max_weight = sum;\n        }\n     \
    \   if sum < w {\n            is_balanced = false;\n            break;\n     \
    \   }\n    }\n    if is_balanced {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd8ndxq25.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpkuxcwdbz.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n    let mut was_it_balanced\
    \ = false;\n    let mut was_it_balanced_rev = false;\n    let mut max_possible\
    \ = w;\n    let mut max_possible_rev = w;\n    let mut sum = 0;\n    for x in\
    \ q {\n        sum += x;\n        if sum > max_possible {\n            max_possible\
    \ = sum;\n        }\n        if sum > max_possible_rev {\n            max_possible_rev\
    \ = sum;\n        }\n    }\n    if max_possible == w {\n        was_it_balanced\
    \ = true;\n    }\n    if max_possible_rev == w {\n        was_it_balanced_rev\
    \ = true;\n    }\n    if was_it_balanced && was_it_balanced_rev {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj3miny7z.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ false;\n    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n    }\n    if\
    \ max_weight <= w {\n        is_balanced = true;\n    }\n    sum == max_weight\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcuw8qki1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum == w {\n        true\n    }\
    \ else if sum < w {\n        false\n    } else {\n        max_weight <= w\n  \
    \  }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2kxjnm4w.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr7k5yr1v.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum >= w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcpcthvvv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = true;\n    let mut sum = 0;\n  \
    \  for x in q {\n        sum += x;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4fx27pwp.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdhp25ar.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpuwltiyws.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindromic` in this scope\n  --> /tmp/tmpuwltiyws.rs:15:34\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                                  ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_less_or_equal_to_max` in this\
    \ scope\n  --> /tmp/tmpuwltiyws.rs:15:55\n   |\n15 |     sum < w && is_balanced(q)\
    \ && is_palindromic(q) && is_less_or_equal_to_max(w, sum)\n   |              \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvtkma0ce.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749427
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for i in q {\n        sum += i;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_qgwvhb8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp1gsxmpa1.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp1gsxmpa1.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1gsxmpa1.rs:12:9\n   |\n12 |     for &i in q {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for el in q {\n        sum += el;\n        max_weight = if sum > max_weight\
    \ { max_weight } else { sum };\n    }\n    sum == max_weight && is_balanced(q,\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp1nmdwfn6.rs:17:26\n\
    \   |\n17 |     sum == max_weight && is_balanced(q, w)\n   |                 \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q) && sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpszkrthng.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && sum <= w\n \
    \  |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindromic` in this scope\n  --> /tmp/tmpszkrthng.rs:15:34\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && sum <= w\n \
    \  |                                  ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q) && is_less_than_or_equal_to_max(w,\
    \ sum)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpbjir59fc.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_than_or_equal_to_max(w,\
    \ sum)\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindromic` in this scope\n  --> /tmp/tmpbjir59fc.rs:15:34\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_than_or_equal_to_max(w,\
    \ sum)\n   |                                  ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_less_than_or_equal_to_max` in\
    \ this scope\n  --> /tmp/tmpbjir59fc.rs:15:55\n   |\n15 |     sum < w && is_balanced(q)\
    \ && is_palindromic(q) && is_less_than_or_equal_to_max(w, sum)\n   |         \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut is_balanced = true;\n\
    \    for x in q {\n        if x > w {\n            is_balanced = false;\n    \
    \        break;\n        }\n        max_sum += x;\n    }\n    if max_sum < w {\n\
    \        is_balanced = false;\n    }\n    is_balanced\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5i36pphn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n    }\n    if max_weight <= w {\n\
    \        return false;\n    }\n    let mut q_rev = q.iter().rev();\n    let mut\
    \ sum_rev = 0;\n    for x in q_rev {\n        sum_rev += x;\n        if sum_rev\
    \ > max_weight {\n            max_weight = sum_rev;\n        }\n    }\n    if\
    \ max_weight <= w {\n        return true;\n    }\n    if sum_rev > w {\n     \
    \   return false;\n    }\n    if sum_rev == w {\n        return true;\n    }\n\
    \    if sum_rev < w {\n        let mut q_rev_reversed = q_rev.iter().rev();\n\
    \        let mut sum_rev_reversed = 0;\n        for x in q_rev_reversed {\n  \
    \          sum_rev_reversed += x;\n            if sum_rev_reversed > w {\n   \
    \             return false;\n            }\n        }\n        return true;\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Rev` in the current\
    \ scope\n  --> /tmp/tmpi_p8rhh4.rs:41:40\n   |\n41 |         let mut q_rev_reversed\
    \ = q_rev.iter().rev();\n   |                                        ^^^^ private\
    \ field, not a method\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max = 0;\n    for i in\
    \ q {\n        sum += i;\n        if sum > max {\n            max = sum;\n   \
    \     }\n    }\n    sum == max && q.iter().rev().all(|&i| i <= w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp7c6401g2.rs:19:19\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for i in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n19  |     sum == max && q.iter().rev().all(|&i|\
    \ i <= w)\n    |                   ^^^^^^^^ value borrowed here after move\n \
    \   |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q`\n    = note: borrow occurs due to deref coercion to `[isize]`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n13  |     for i in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ let mut is_balanced = true;\n    for x in q {\n        if x > max_weight {\n\
    \            max_weight = x;\n        }\n        sum += x;\n    }\n    if sum\
    \ < w {\n        is_balanced = false;\n    }\n    sum == w && is_balanced\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpngm1fq37.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp_5j0wwnp.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp_5j0wwnp.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for x in q {\n        sum += x;\n        max_weight = if sum > w {\n       \
    \     max_weight\n        } else {\n            sum\n        };\n    }\n    if\
    \ max_weight <= w {\n        true\n    } else {\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx_tbs9er.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum == w {\n            balanced\
    \ = true;\n        }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwwoom5dn.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   let mut max_weight = 0;\n    for &i in q {\n        sum += i;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ == w {\n            balanced = true;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkubncgv_.rs:14:9\n   |\n\
    14 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp61_ddyiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = w;\n    let mut is_balanced =\
    \ true;\n    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            is_balanced = false;\n            break;\n \
    \       }\n    }\n    if is_balanced {\n        true\n    } else {\n        max_weight\
    \ < sum\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq9aokw_r.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        max_weight = if sum > w {\n      \
    \      max_weight\n        } else {\n            sum\n        };\n    }\n    sum\
    \ == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy6zqpr4x.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n    let mut sum =\
    \ 0;\n    for x in q_rev {\n        sum += x;\n        if sum >= w {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcczs_u97.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < q.len() && j < q.len() {\n        if q[i] <\
    \ q[j] {\n            i += 1;\n        } else {\n            j += 1;\n       \
    \ }\n    }\n    i == q.len() || j == q.len() || q[i] == q[j]\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpadib2g_9.rs:20:15\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n11  |     let mut sum = 0;\n12  |     for x in q {\n    |\
    \              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    20  |     while i < q.len() && j < q.len() {\n    |               ^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n12  |   \
    \  for x in &q {\n    |              +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q.iter() {\n       \
    \ sum += v;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp2hpcsua5.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut is_balanced = true;\n\
    \    for x in q.iter() {\n        let mut sum = 0;\n        for y in q.iter()\
    \ {\n            sum += y;\n        }\n        if sum > max_sum {\n          \
    \  max_sum = sum;\n        }\n        if x == y {\n            is_balanced = false;\n\
    \        }\n    }\n    if max_sum == w {\n        is_balanced\n    } else {\n\
    \        is_balanced && max_sum <= w\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmpk4hx9yod.rs:21:17\n\
    \   |\n21 |         if x == y {\n   |                 ^ help: a local variable\
    \ with a similar name exists: `q`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for i in q.iter() {\n        sum += i;\n        if sum > w {\n           \
    \ balanced = false;\n            break;\n        }\n    }\n    balanced && sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu9v0wlxd.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum >= w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcpcthvvv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for v in q {\n        sum += v;\n        if sum >= w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptpg8sgve.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpkuxcwdbz.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut balanced = true;\n\
    \    for &i in q {\n        if i > max_weight {\n            max_weight = i;\n\
    \        }\n        if i > w {\n            balanced = false;\n            break;\n\
    \        }\n    }\n    balanced && max_weight <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5wu0950.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpexona_42.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexona_42.rs:12:9\n\
    \   |\n12 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        if sum > max_weight {\n          \
    \  max_weight = sum;\n        }\n    }\n    if sum < w {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    while i < q.len() && j < q.len()\
    \ {\n        if q[i] < q[j] {\n            i += 1;\n        } else {\n       \
    \     j += 1;\n        }\n    }\n    if i == q.len() {\n        return true;\n\
    \    }\n    if j == q.len() {\n        return false;\n    }\n    if q[i] < q[j]\
    \ {\n        return false;\n    }\n    if max_weight - q[i] > w {\n        return\
    \ false;\n    }\n    will_it_fly(q[i..j], w)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6bkr04py.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6bkr04py.rs:43:17\n   |\n43 |     will_it_fly(q[i..j], w)\n   |\
    \                 ^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                 |\n   |                 expected struct `Vec`, found slice\
    \ `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n               found\
    \ slice `[isize]`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut is_balanced =\
    \ true;\n    let mut sum = 0;\n    for x in q {\n        sum += x;\n        if\
    \ sum > max_weight {\n            max_weight = sum;\n        }\n        if sum\
    \ < w {\n            is_balanced = false;\n        }\n    }\n    return is_balanced\
    \ && max_weight <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvk6gewvg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp61_ddyiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpuwltiyws.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindromic` in this scope\n  --> /tmp/tmpuwltiyws.rs:15:34\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                                  ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_less_or_equal_to_max` in this\
    \ scope\n  --> /tmp/tmpuwltiyws.rs:15:55\n   |\n15 |     sum < w && is_balanced(q)\
    \ && is_palindromic(q) && is_less_or_equal_to_max(w, sum)\n   |              \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max = 0;\n    for &i\
    \ in q {\n        sum += i;\n        if sum > max {\n            max = sum;\n\
    \        }\n    }\n    sum == max && q.iter().rev().all(|&i| i < w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr7oix_wh.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut balanced = false;\n \
    \   for v in q.iter() {\n        sum += v;\n        if sum == w {\n          \
    \  balanced = true;\n            break;\n        }\n    }\n    balanced\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptxuy0eec.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    sum == max_weight && is_balanced(q,\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpqhaocc9e.rs:19:26\n\
    \   |\n19 |     sum == max_weight && is_balanced(q, w)\n   |                 \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum == w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrnom1l9.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for &i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp1gsxmpa1.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp1gsxmpa1.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1gsxmpa1.rs:12:9\n   |\n12 |     for &i in q {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = true;\n    let mut sum = 0;\n  \
    \  for &i in q {\n        sum += i;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph08daz2h.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for &i in q {\n        sum += i;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr7k5yr1v.rs:13:9\n   |\n\
    13 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for x in q {\n        sum +=\
    \ x;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpuwltiyws.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindromic` in this scope\n  --> /tmp/tmpuwltiyws.rs:15:34\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q) && is_less_or_equal_to_max(w,\
    \ sum)\n   |                                  ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_less_or_equal_to_max` in this\
    \ scope\n  --> /tmp/tmpuwltiyws.rs:15:55\n   |\n15 |     sum < w && is_balanced(q)\
    \ && is_palindromic(q) && is_less_or_equal_to_max(w, sum)\n   |              \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q.iter() {\n        sum += v;\n        if sum > max_weight {\n    \
    \        max_weight = sum;\n        }\n    }\n    if sum == max_weight {\n   \
    \     return true;\n    }\n    if sum < max_weight {\n        return false;\n\
    \    }\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    while i <= j {\n\
    \        if q[i] != q[j] {\n            return false;\n        }\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7sfshxl1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_balanced(q) && is_palindromic(q)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp4tc95aa8.rs:15:16\n\
    \   |\n15 |     sum < w && is_balanced(q) && is_palindromic(q)\n   |         \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindromic` in this scope\n  --> /tmp/tmp4tc95aa8.rs:15:34\n   |\n15 |\
    \     sum < w && is_balanced(q) && is_palindromic(q)\n   |                   \
    \               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976570
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for el in q {\n        sum += el;\n        max_weight = if sum > max_weight\
    \ {\n            sum\n        } else {\n            max_weight\n        };\n \
    \   }\n    if sum < w {\n        return false;\n    }\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    let mut k = q.len() - 1;\n    while i <= k {\n        if\
    \ q[j] != q[i] {\n            return false;\n        }\n        i += 1;\n    \
    \    j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp70smo7wm.rs:26:9\n\
    \   |\n26 |     let mut k = q.len() - 1;\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp70smo7wm.rs:26:17\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for el in q {\n    |               - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n26  |     let mut k = q.len()\
    \ - 1;\n    |                 ^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `q`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |     for el in &q {\n    |               +\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut balanced = false;\n\
    \    let mut sum = 0;\n    for v in q {\n        sum += v;\n        if sum > max_weight\
    \ {\n            max_weight = sum;\n        }\n        if sum == w {\n       \
    \     balanced = true;\n        }\n    }\n    balanced && max_weight <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph0f62ehx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max = 0;\n    for i in\
    \ q.iter() {\n        sum += i;\n        if sum > max {\n            max = sum;\n\
    \        }\n    }\n    sum == max && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6ionaqam.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = false;\n    let mut sum = 0;\n \
    \   for x in q {\n        sum += x;\n        if sum == w {\n            balanced\
    \ = true;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp61_ddyiv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749428
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q.iter() {\n        sum += v;\n        max_weight = if sum > w {\n\
    \            max_weight\n        } else {\n            sum\n        };\n    }\n\
    \    sum == max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6za0ot2q.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for &i in q {\n        sum += i;\n        if sum > max_weight {\n          \
    \  max_weight = sum;\n        }\n    }\n    sum == max_weight && is_balanced(q,\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp11i2trut.rs:19:26\n\
    \   |\n19 |     sum == max_weight && is_balanced(q, w)\n   |                 \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp11i2trut.rs:13:9\n   |\n13 |     for &i in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q_rev = q.iter().rev();\n    let mut sum =\
    \ 0;\n    let mut max_weight = 0;\n    let mut is_balanced = true;\n    for el\
    \ in q_rev {\n        sum += el;\n        if sum > max_weight {\n            max_weight\
    \ = sum;\n        }\n        if sum < w {\n            is_balanced = false;\n\
    \            break;\n        }\n    }\n    if is_balanced {\n        true\n  \
    \  } else {\n        max_weight <= w\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwajjmql0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max = 0;\n    for x in\
    \ q {\n        sum += x;\n        if sum > max {\n            max = sum;\n   \
    \     }\n    }\n    sum == max && q.iter().rev().all(|x| x <= w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfrlb0ans.rs:19:47\n   |\n\
    19 |     sum == max && q.iter().rev().all(|x| x <= w)\n   |                  \
    \                             ^\n   |                                        \
    \       |\n   |                                               expected `&isize`,\
    \ found `isize`\n   |                                               help: consider\
    \ borrowing here: `&w`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut balanced = true;\n    let mut sum = 0;\n  \
    \  for x in q {\n        sum += x;\n        if sum > w {\n            balanced\
    \ = false;\n            break;\n        }\n    }\n    balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf_4il8q5.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_sum = 0;\n    let mut balanced = false;\n\
    \    for v in q.iter() {\n        let sum = v + max_sum;\n        if sum > w {\n\
    \            balanced = false;\n            break;\n        }\n        if sum\
    \ == w {\n            balanced = true;\n            break;\n        }\n      \
    \  max_sum = sum;\n    }\n    balanced\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl3bo8eo5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for v in q {\n        sum +=\
    \ v;\n    }\n    if sum < w {\n        return false;\n    }\n    let mut sum =\
    \ 0;\n    for v in q.iter() {\n        sum += v;\n    }\n    if sum == w {\n \
    \       return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpgpdq6iof.rs:19:14\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n11  |     let mut sum = 0;\n12  |     for v in q {\n    |\
    \              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    19  |     for v in q.iter() {\n    |              ^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `q`\n    = note: borrow occurs due to deref coercion to `[isize]`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for v in &q {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum == 0 || sum > w {\n        return\
    \ false;\n    }\n    let mut is_balanced = true;\n    let mut max_sum = 0;\n \
    \   for v in q {\n        if v > max_sum {\n            max_sum = v;\n       \
    \ }\n        if v != max_sum {\n            is_balanced = false;\n           \
    \ break;\n        }\n    }\n    if is_balanced {\n        true\n    } else {\n\
    \        max_weight < w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmphied8lia.rs:24:14\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for v in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n24  |     for v in q {\n \
    \   |              ^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n13  |     for v in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q {\n        sum +=\
    \ i;\n    }\n    sum < w && is_palindromic(q) && sum >= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmp_drsqxih.rs:15:16\n   |\n15 |     sum < w && is_palindromic(q) && sum\
    \ >= w\n   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for e in q {\n        sum += e;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    sum == max_weight && is_palindromic(q)\
    \ && is_balanced(q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpd88pu10z.rs:19:26\n   |\n19 |     sum == max_weight && is_palindromic(q)\
    \ && is_balanced(q, w)\n   |                          ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_balanced` in this scope\n\
    \  --> /tmp/tmpd88pu10z.rs:19:47\n   |\n19 |     sum == max_weight && is_palindromic(q)\
    \ && is_balanced(q, w)\n   |                                               ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        max_weight = if sum > w {\n       \
    \     sum\n        } else {\n            max_weight\n        };\n    }\n    sum\
    \ == w && max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsioyf02r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976572
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut max_weight = 0;\n   \
    \ for v in q {\n        sum += v;\n        if sum > max_weight {\n           \
    \ max_weight = sum;\n        }\n    }\n    if sum == w {\n        true\n    }\
    \ else if sum < w {\n        false\n    } else {\n        max_weight < w\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppe8honfx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976571
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut max_weight = 0;\n    let mut balanced = false;\n\
    \    for x in q {\n        if x > max_weight {\n            max_weight = x;\n\
    \        }\n        if x == max_weight {\n            balanced = true;\n     \
    \   }\n    }\n    if balanced {\n        let mut sum = 0;\n        for x in q\
    \ {\n            sum += x;\n        }\n        return sum <= w;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmph1v2y01j.rs:23:18\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for x in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n23  |         for x in q {\n\
    \    |                  ^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n13  |     for x in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976571
