language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut substring_end\
    \ = substring_iter.end();\n    while let Some(substring_pos) = substring_iter.next()\
    \ {\n        if substring_pos == substring_end {\n            break;\n       \
    \ }\n        let mut substring_start = substring_pos;\n        while let Some(string_pos)\
    \ = string_iter.next() {\n            if string_pos == string_end {\n        \
    \        break;\n            }\n            if string_pos > substring_end {\n\
    \                break;\n            }\n            if string_pos < substring_start\
    \ {\n                continue;\n            }\n            if string_iter\n  \
    \              .next()\n                .unwrap()\n                .unwrap()\n\
    \                == substring_iter\n                    .next()\n            \
    \        .unwrap()\n                    .unwrap()\n            {\n           \
    \     counter += 1;\n            }\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `string_end` in this scope\n  --> /tmp/tmp85665nqf.rs:13:30\n\
    \   |\n13 |             if string_pos == string_end {\n   |                  \
    \            ^^^^^^^^^^ help: a local variable with a similar name exists: `string_pos`\n\
    \nerror[E0599]: no method named `end` found for struct `CharIndices` in the current\
    \ scope\n --> /tmp/tmp85665nqf.rs:6:44\n  |\n6 |     let mut substring_end = substring_iter.end();\n\
    \  |                                            ^^^ method not found in `CharIndices<'_>`\n\
    \nerror[E0599]: no method named `unwrap` found for tuple `(usize, char)` in the\
    \ current scope\n  --> /tmp/tmp85665nqf.rs:25:18\n   |\n25 |                 .unwrap()\n\
    \   |                  ^^^^^^ method not found in `(usize, char)`\n\nerror[E0599]:\
    \ no method named `unwrap` found for tuple `(usize, char)` in the current scope\n\
    \  --> /tmp/tmp85665nqf.rs:29:22\n   |\n29 |                     .unwrap()\n \
    \  |                      ^^^^^^ method not found in `(usize, char)`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.as_bytes()[pos] {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk58f2vq_.rs:8:21\n  |\n8 |\
    \             if c == substring.as_bytes()[pos] {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `u8`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end_pos = string.find(substring, pos);\n\
    \        if end_pos == String::npos {\n            break;\n        }\n       \
    \ pos = end_pos + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpahxypyhb.rs:6:34\n     |\n6    |         let mut end_pos = string.find(substring,\
    \ pos);\n     |                                  ^^^^ ---------  --- supplied\
    \ 2 arguments\n     |                                  |\n     |             \
    \                     expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpahxypyhb.rs:7:31\n  |\n7\
    \ |         if end_pos == String::npos {\n  |                               ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpahxypyhb.rs:10:23\n   |\n10 |\
    \         pos = end_pos + 1;\n   |               ------- ^ - {integer}\n   | \
    \              |\n   |               Option<usize>\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    loop {\n        if\
    \ let Some((start, end)) = string_iter.next() {\n            if let Some((start,\
    \ end)) = substring_iter.next() {\n                if start < end {\n        \
    \            count += 1;\n                }\n            }\n        }\n      \
    \  if !string_iter.next().is_some() {\n            break;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcckesro7.rs:9:28\n  |\n9 |\
    \                 if start < end {\n  |                            ^^^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring {\n            i += 1;\n        }\n        if i ==\
    \ string.len() {\n            break;\n        }\n        count += 1;\n       \
    \ pos = i + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpnylf1sd4.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring {\n  |    \
    \                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.len();\n        if end >\
    \ pos {\n            end = pos;\n        }\n        if string.contains(&substring,\
    \ start, end) {\n            count += 1;\n        }\n        pos = end;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found built-in attribute `start`\n  --> /tmp/tmpoir0bjyb.rs:10:40\n\
    \   |\n10 |         if string.contains(&substring, start, end) {\n   |       \
    \                                 ^^^^^ not a value\n\nerror[E0061]: this function\
    \ takes 1 argument but 3 arguments were supplied\n   --> /tmp/tmpoir0bjyb.rs:10:19\n\
    \    |\n10  |         if string.contains(&substring, start, end) {\n    |    \
    \               ^^^^^^^^ ----------  -----  --- supplied 3 arguments\n    |  \
    \                 |\n    |                   expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                found = true;\n              \
    \  break;\n            }\n            if c == substring.chars()[pos - 1] {\n \
    \               found = true;\n                break;\n            }\n       \
    \ }\n        if found {\n            counter += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp0hiicwo3.rs:12:21\n\
    \   |\n12 |             if c == substring.chars()[pos - 1] {\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.chars().any(|c| c == substring[pos])\
    \ {\n            count += 1;\n            pos += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp2gk_frsa.rs:6:40\n\
    \  |\n6 |         if string.chars().any(|c| c == substring[pos]) {\n  |      \
    \                                  ^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
