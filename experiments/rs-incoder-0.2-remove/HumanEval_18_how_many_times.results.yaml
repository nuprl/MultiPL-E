language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut substring_end\
    \ = substring_iter.end();\n    while let Some(substring_pos) = substring_iter.next()\
    \ {\n        if substring_pos == substring_end {\n            break;\n       \
    \ }\n        let mut substring_start = substring_pos;\n        while let Some(string_pos)\
    \ = string_iter.next() {\n            if string_pos == string_end {\n        \
    \        break;\n            }\n            if string_pos > substring_end {\n\
    \                break;\n            }\n            if string_pos < substring_start\
    \ {\n                continue;\n            }\n            if string_iter\n  \
    \              .next()\n                .unwrap()\n                .unwrap()\n\
    \                == substring_iter\n                    .next()\n            \
    \        .unwrap()\n                    .unwrap()\n            {\n           \
    \     counter += 1;\n            }\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `string_end` in this scope\n  --> /tmp/tmp85665nqf.rs:13:30\n\
    \   |\n13 |             if string_pos == string_end {\n   |                  \
    \            ^^^^^^^^^^ help: a local variable with a similar name exists: `string_pos`\n\
    \nerror[E0599]: no method named `end` found for struct `CharIndices` in the current\
    \ scope\n --> /tmp/tmp85665nqf.rs:6:44\n  |\n6 |     let mut substring_end = substring_iter.end();\n\
    \  |                                            ^^^ method not found in `CharIndices<'_>`\n\
    \nerror[E0599]: no method named `unwrap` found for tuple `(usize, char)` in the\
    \ current scope\n  --> /tmp/tmp85665nqf.rs:25:18\n   |\n25 |                 .unwrap()\n\
    \   |                  ^^^^^^ method not found in `(usize, char)`\n\nerror[E0599]:\
    \ no method named `unwrap` found for tuple `(usize, char)` in the current scope\n\
    \  --> /tmp/tmp85665nqf.rs:29:22\n   |\n29 |                     .unwrap()\n \
    \  |                      ^^^^^^ method not found in `(usize, char)`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.as_bytes()[pos] {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk58f2vq_.rs:8:21\n  |\n8 |\
    \             if c == substring.as_bytes()[pos] {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `u8`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end_pos = string.find(substring, pos);\n\
    \        if end_pos == String::npos {\n            break;\n        }\n       \
    \ pos = end_pos + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpahxypyhb.rs:6:34\n     |\n6    |         let mut end_pos = string.find(substring,\
    \ pos);\n     |                                  ^^^^ ---------  --- supplied\
    \ 2 arguments\n     |                                  |\n     |             \
    \                     expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpahxypyhb.rs:7:31\n  |\n7\
    \ |         if end_pos == String::npos {\n  |                               ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpahxypyhb.rs:10:23\n   |\n10 |\
    \         pos = end_pos + 1;\n   |               ------- ^ - {integer}\n   | \
    \              |\n   |               Option<usize>\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    loop {\n        if\
    \ let Some((start, end)) = string_iter.next() {\n            if let Some((start,\
    \ end)) = substring_iter.next() {\n                if start < end {\n        \
    \            count += 1;\n                }\n            }\n        }\n      \
    \  if !string_iter.next().is_some() {\n            break;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcckesro7.rs:9:28\n  |\n9 |\
    \                 if start < end {\n  |                            ^^^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring {\n            i += 1;\n        }\n        if i ==\
    \ string.len() {\n            break;\n        }\n        count += 1;\n       \
    \ pos = i + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpnylf1sd4.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring {\n  |    \
    \                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.len();\n        if end >\
    \ pos {\n            end = pos;\n        }\n        if string.contains(&substring,\
    \ start, end) {\n            count += 1;\n        }\n        pos = end;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found built-in attribute `start`\n  --> /tmp/tmpoir0bjyb.rs:10:40\n\
    \   |\n10 |         if string.contains(&substring, start, end) {\n   |       \
    \                                 ^^^^^ not a value\n\nerror[E0061]: this function\
    \ takes 1 argument but 3 arguments were supplied\n   --> /tmp/tmpoir0bjyb.rs:10:19\n\
    \    |\n10  |         if string.contains(&substring, start, end) {\n    |    \
    \               ^^^^^^^^ ----------  -----  --- supplied 3 arguments\n    |  \
    \                 |\n    |                   expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                found = true;\n              \
    \  break;\n            }\n            if c == substring.chars()[pos - 1] {\n \
    \               found = true;\n                break;\n            }\n       \
    \ }\n        if found {\n            counter += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp0hiicwo3.rs:12:21\n\
    \   |\n12 |             if c == substring.chars()[pos - 1] {\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.chars().any(|c| c == substring[pos])\
    \ {\n            count += 1;\n            pos += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp2gk_frsa.rs:6:40\n\
    \  |\n6 |         if string.chars().any(|c| c == substring[pos]) {\n  |      \
    \                                  ^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcmnidqda.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut current_substring_iter\
    \ = substring_iter.next();\n    while let Some(current_substring) = current_substring_iter\
    \ {\n        if current_substring.start < string_iter.start() {\n            count\
    \ += 1;\n            current_substring_iter = substring_iter.next();\n       \
    \ } else {\n            if current_substring.start == string_iter.start() {\n\
    \                if current_substring.end == string_iter.end() {\n           \
    \         count += 1;\n                } else {\n                    count +=\
    \ 1;\n                    current_substring_iter = substring_iter.next();\n  \
    \              }\n            } else {\n                if current_substring.end\
    \ == string_iter.end() {\n                    count += 1;\n                  \
    \  current_substring_iter = substring_iter.next();\n                } else {\n\
    \                    count += 1;\n                    current_substring_iter =\
    \ substring_iter.next();\n                }\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `start` on type `(usize, char)`\n --> /tmp/tmpku5ngods.rs:8:30\n\
    \  |\n8 |         if current_substring.start < string_iter.start() {\n  |    \
    \                          ^^^^^\n\nerror[E0599]: no method named `start` found\
    \ for struct `CharIndices` in the current scope\n --> /tmp/tmpku5ngods.rs:8:50\n\
    \  |\n8 |         if current_substring.start < string_iter.start() {\n  |    \
    \                                              ^^^^^ method not found in `CharIndices<'_>`\n\
    \nerror[E0609]: no field `start` on type `(usize, char)`\n  --> /tmp/tmpku5ngods.rs:12:34\n\
    \   |\n12 |             if current_substring.start == string_iter.start() {\n\
    \   |                                  ^^^^^\n\nerror[E0599]: no method named\
    \ `start` found for struct `CharIndices` in the current scope\n  --> /tmp/tmpku5ngods.rs:12:55\n\
    \   |\n12 |             if current_substring.start == string_iter.start() {\n\
    \   |                                                       ^^^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror[E0609]: no field `end` on type `(usize, char)`\n\
    \  --> /tmp/tmpku5ngods.rs:13:38\n   |\n13 |                 if current_substring.end\
    \ == string_iter.end() {\n   |                                      ^^^\n\nerror[E0599]:\
    \ no method named `end` found for struct `CharIndices` in the current scope\n\
    \  --> /tmp/tmpku5ngods.rs:13:57\n   |\n13 |                 if current_substring.end\
    \ == string_iter.end() {\n   |                                               \
    \          ^^^ method not found in `CharIndices<'_>`\n\nerror[E0609]: no field\
    \ `end` on type `(usize, char)`\n  --> /tmp/tmpku5ngods.rs:20:38\n   |\n20 | \
    \                if current_substring.end == string_iter.end() {\n   |       \
    \                               ^^^\n\nerror[E0599]: no method named `end` found\
    \ for struct `CharIndices` in the current scope\n  --> /tmp/tmpku5ngods.rs:20:57\n\
    \   |\n20 |                 if current_substring.end == string_iter.end() {\n\
    \   |                                                         ^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror: aborting due to 8 previous errors\n\nSome errors\
    \ hav"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    loop {\n        let\
    \ (mut string_pos, mut substring_pos) = (None, None);\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if let Some(substring_pos) = substring_iter.next()\
    \ {\n                if string_pos == substring_pos {\n                    count++;\n\
    \                }\n            }\n        }\n        if let Some(substring_pos)\
    \ = substring_iter.next() {\n            if string_pos == substring_pos {\n  \
    \              count++;\n            }\n        }\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if substring_pos == string_pos {\n     \
    \           count++;\n            }\n        }\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if substring_pos == string_pos {\n     \
    \           count++;\n            }\n        }\n        if let Some(substring_pos)\
    \ = substring_iter.next() {\n            if string_pos == substring_pos {\n  \
    \              count++;\n            }\n        }\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if substring_pos == string_pos {\n     \
    \           count++;\n            }\n        }\n        if let Some(substring_pos)\
    \ = substring_iter.next() {\n            if string_pos == substring_pos {\n  \
    \              count++;\n            }\n        }\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if substring_pos == string_pos {\n     \
    \           count++;\n            }\n        }\n        if let Some(substring_pos)\
    \ = substring_iter.next() {\n            if string_pos == substring_pos {\n  \
    \              count++;\n            }\n        }\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if substring_pos == string_pos {\n     \
    \           count++;\n            }\n        }\n        if let Some(substring_pos)\
    \ = substring_iter.next() {\n            if string_pos == substring_pos {\n  \
    \              count++;\n            }\n        }\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if substring_pos == string_pos {\n     \
    \           count++;\n            }\n        }\n        if let Some(substring_pos)\
    \ = substring_iter.next() {\n            if string_pos == substring_pos {\n  \
    \              count++;\n            }\n        }\n        if let Some(string_pos)\
    \ = string_iter.next() {\n            if substring_pos == string_pos {\n     \
    \           count++;\n            }\n        }\n        if let Some(substring_pos)\
    \ = substring_iter.next() {\n            if string_pos == substring_pos {\n  \
    \              count++;\n            }\n        }\n        if \n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpyke8gxx5.rs:94:3\n\
    \   |\n2  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n6  |     loop {\n   |          - this delimiter might not be\
    \ properly closed...\n...\n86 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n94 | }\n   |   ^\n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpyke8gxx5.rs:11:26\n   |\n11 |                     count++;\n  \
    \ |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n11 |                     { let tmp = count; count += 1;\
    \ tmp };\n   |                     +++++++++++      ~~~~~~~~~~~~~~~~~~~\n11 -\
    \                     count++;\n11 +                     count += 1;\n   | \n\n\
    error: Rust has no postfix increment operator\n  --> /tmp/tmpyke8gxx5.rs:17:22\n\
    \   |\n17 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n17 -                 count++;\n17 +                 count\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpyke8gxx5.rs:22:22\n\
    \   |\n22 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n22 -                 count++;\n22 +                 count\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpyke8gxx5.rs:27:22\n\
    \   |\n27 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n27 -                 count++;\n27 +                 count\
    \ += 1;\n   | \n\nerror: Rust has no postfix increme"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                found = true;\n              \
    \  break;\n            }\n            if c == substring.chars().nth(pos - 1) {\n\
    \                count += 1;\n                pos += 1;\n                found\
    \ = true;\n                break;\n            }\n        }\n        if !found\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpthk8qe8h.rs:12:21\n   |\n\
    12 |             if c == substring.chars().nth(pos - 1) {\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n            pos += substring.len();\n        } else {\n\
    \            pos += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpa18hz335.rs:6:19\n     |\n6    |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut pos = string.find(substring, pos);\n \
    \       if pos == String::npos {\n            break;\n        }\n        counter\
    \ += 1;\n        pos += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp37_3vd8v.rs:6:30\n     |\n6    |         let mut pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp37_3vd8v.rs:7:27\n  |\n7 |         if pos == String::npos\
    \ {\n  |                           ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmp37_3vd8v.rs:11:9\n   |\n11 |        \
    \ pos += 1;\n   |         ---^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut index = string.find(substring);\n\
    \    while index != String::npos {\n        counter += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpestbh1sr.rs:4:33\n     |\n4    |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n4    |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n --> /tmp/tmpestbh1sr.rs:5:28\n\
    \  |\n5 |     while index != String::npos {\n  |                            ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n --> /tmp/tmpestbh1sr.rs:7:46\n  |\n7 |    \
    \     index = string.find(substring, index + 1);\n  |                        \
    \                ----- ^ - {integer}\n  |                                    \
    \    |\n  |                                        Option<usize>\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpestbh1sr.rs:7:24\n\
    \     |\n7    |         index = string.find(substring, index + 1);\n     |   \
    \                     ^^^^ ---------  --------- supplied 2 arguments\n     | \
    \                       |\n     |                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut char_iter\
    \ = char_iter();\n    let mut substring_iter = substring_iter.next();\n    while\
    \ let Some(substring_char) = substring_iter {\n        let mut char_iter = char_iter();\n\
    \        let mut substring_iter = substring_iter.next();\n        while let Some(substring_char)\
    \ = substring_iter {\n            if char_iter.next().unwrap() == substring_char\
    \ {\n                count += 1;\n            }\n            char_iter = char_iter();\n\
    \            substring_iter = substring_iter.next();\n        }\n        char_iter\
    \ = char_iter();\n        substring_iter = substring_iter.next();\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_iter` in this scope\n --> /tmp/tmpddvzzg8_.rs:6:25\n\
    \  |\n6 |     let mut char_iter = char_iter();\n  |                         ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `next` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpddvzzg8_.rs:10:49\n   |\n10 | \
    \        let mut substring_iter = substring_iter.next();\n   |               \
    \                                  ^^^^ method not found in `Option<(usize, char)>`\n\
    \nerror[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpddvzzg8_.rs:16:45\n   |\n16 |             substring_iter\
    \ = substring_iter.next();\n   |                                             ^^^^\
    \ method not found in `Option<_>`\n\nerror[E0599]: no method named `next` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpddvzzg8_.rs:19:41\n  \
    \ |\n19 |         substring_iter = substring_iter.next();\n   |              \
    \                           ^^^^ method not found in `Option<_>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring[pos] {\n            i += 1;\n            counter +=\
    \ 1;\n        }\n        pos += 1;\n    }\n    counter\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmprp1a4smu.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring[pos] {\n  |\
    \                                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmprp1a4smu.rs:7:48\n\
    \  |\n7 |         while i < string.len() && string[i] == substring[pos] {\n  |\
    \                                                ^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut string_substring_iter\
    \ = substring.char_indices();\n    let mut substring_string_iter = substring.char_indices();\n\
    \    loop {\n        match string_iter.next() {\n            None => break,\n\
    \            Some((start, end)) => {\n                match substring_iter.next()\
    \ {\n                    None => break,\n                    Some((start, end))\
    \ => {\n                        match string_substring_iter.next() {\n       \
    \                     None => break,\n                            Some((start,\
    \ end)) => {\n                                match substring_string_iter.next()\
    \ {\n                                    None => break,\n                    \
    \                Some((start, end)) => {\n                                   \
    \     count += 1;\n                                    }\n                   \
    \             }\n                            }\n                        }\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpz9ak815d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n    let mut char_iter\
    \ = char_iter();\n    let mut char_iter = char_iter();\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_iter` in this scope\n --> /tmp/tmpg5b8y1h1.rs:6:25\n\
    \  |\n6 |     let mut char_iter = char_iter();\n  |                         ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpg5b8y1h1.rs:2:57\n\
    \  |\n2 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \    --------------                                       ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    for c in string.chars() {\n\
    \        if c.contains(&substring) {\n            counter += 1;\n        }\n \
    \   }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmporf0tyst.rs:5:14\n  |\n5 |         if c.contains(&substring)\
    \ {\n  |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut current_substring_iter\
    \ = substring_iter.next();\n    while let Some(current_substring) = current_substring_iter\
    \ {\n        if current_substring.start < substring.start {\n            count\
    \ += 1;\n        }\n        if current_substring.end > substring.end {\n     \
    \       count += 1;\n        }\n        if current_substring.start < substring.end\
    \ {\n            count += 1;\n        }\n        current_substring_iter = substring_iter.next();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `start` on type `(usize, char)`\n --> /tmp/tmp9nxxgkdb.rs:8:30\n\
    \  |\n8 |         if current_substring.start < substring.start {\n  |        \
    \                      ^^^^^\n\nerror[E0609]: no field `start` on type `String`\n\
    \ --> /tmp/tmp9nxxgkdb.rs:8:48\n  |\n8 |         if current_substring.start <\
    \ substring.start {\n  |                                                ^^^^^\
    \ unknown field\n\nerror[E0609]: no field `end` on type `(usize, char)`\n  -->\
    \ /tmp/tmp9nxxgkdb.rs:11:30\n   |\n11 |         if current_substring.end > substring.end\
    \ {\n   |                              ^^^\n\nerror[E0609]: no field `end` on\
    \ type `String`\n  --> /tmp/tmp9nxxgkdb.rs:11:46\n   |\n11 |         if current_substring.end\
    \ > substring.end {\n   |                                              ^^^ unknown\
    \ field\n\nerror[E0609]: no field `start` on type `(usize, char)`\n  --> /tmp/tmp9nxxgkdb.rs:14:30\n\
    \   |\n14 |         if current_substring.start < substring.end {\n   |       \
    \                       ^^^^^\n\nerror[E0609]: no field `end` on type `String`\n\
    \  --> /tmp/tmp9nxxgkdb.rs:14:48\n   |\n14 |         if current_substring.start\
    \ < substring.end {\n   |                                                ^^^ unknown\
    \ field\n\nerror: aborting due to 6 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.find(substring, pos);\n \
    \       if end == String::npos {\n            count += 1;\n            pos = string.len()\
    \ - 1;\n        } else {\n            count += end - pos;\n            pos = end\
    \ + 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpr13lrnfg.rs:6:30\n     |\n6    |         let mut end = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpr13lrnfg.rs:7:27\n  |\n7 |         if end == String::npos\
    \ {\n  |                           ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0369]: cannot subtract `usize` from `Option<usize>`\n\
    \  --> /tmp/tmpr13lrnfg.rs:11:26\n   |\n11 |             count += end - pos;\n\
    \   |                      --- ^ --- usize\n   |                      |\n   |\
    \                      Option<usize>\n\nerror[E0369]: cannot add `{integer}` to\
    \ `Option<usize>`\n  --> /tmp/tmpr13lrnfg.rs:12:23\n   |\n12 |             pos\
    \ = end + 1;\n   |                   --- ^ - {integer}\n   |                 \
    \  |\n   |                   Option<usize>\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = string.find(substring);\n\
    \    while index != String::npos {\n        count += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpwj3277yh.rs:4:33\n     |\n4    |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n4    |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n --> /tmp/tmpwj3277yh.rs:5:28\n\
    \  |\n5 |     while index != String::npos {\n  |                            ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n --> /tmp/tmpwj3277yh.rs:7:46\n  |\n7 |    \
    \     index = string.find(substring, index + 1);\n  |                        \
    \                ----- ^ - {integer}\n  |                                    \
    \    |\n  |                                        Option<usize>\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpwj3277yh.rs:7:24\n\
    \     |\n7    |         index = string.find(substring, index + 1);\n     |   \
    \                     ^^^^ ---------  --------- supplied 2 arguments\n     | \
    \                       |\n     |                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = string.find(substring, pos);\n\
    \        if found == String::npos {\n            break;\n        }\n        count\
    \ += 1;\n        pos = found + 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp88d5bxkr.rs:6:32\n     |\n6    |         let mut found = string.find(substring,\
    \ pos);\n     |                                ^^^^ ---------  --- supplied 2\
    \ arguments\n     |                                |\n     |                 \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n --> /tmp/tmp88d5bxkr.rs:7:29\n  |\n7\
    \ |         if found == String::npos {\n  |                             ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmp88d5bxkr.rs:11:21\n   |\n11 |         pos\
    \ = found + 1;\n   |               ----- ^ - {integer}\n   |               |\n\
    \   |               Option<usize>\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                found = true;\n              \
    \  break;\n            }\n            if c == substring.chars()[0] {\n       \
    \         found = true;\n                break;\n            }\n            pos\
    \ += 1;\n        }\n        if found {\n            count += 1;\n        }\n \
    \       pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp4mnzkr56.rs:12:21\n\
    \   |\n12 |             if c == substring.chars()[0] {\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n\
    \        if c == substring {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2ocdk0w3.rs:5:17\n  |\n5 |\
    \         if c == substring {\n  |                 ^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut pos = string.find(substring, pos);\n \
    \       if pos == String::npos {\n            break;\n        }\n        count\
    \ += 1;\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpyoyvulti.rs:6:30\n     |\n6    |         let mut pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyoyvulti.rs:7:27\n  |\n7 |         if pos == String::npos\
    \ {\n  |                           ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmpyoyvulti.rs:11:9\n   |\n11 |        \
    \ pos += 1;\n   |         ---^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = string.find(substring);\n\
    \    while i != String::npos {\n        count += 1;\n        i = string.find(substring,\
    \ i + 1);\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp3c299s0g.rs:4:29\n     |\n4    |     let mut i = string.find(substring);\n\
    \     |                        ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                        |\n     |                     \
    \   required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing here\n\
    \     |\n4    |     let mut i = string.find(&substring);\n     |             \
    \                +\n\nerror[E0599]: no function or associated item named `npos`\
    \ found for struct `String` in the current scope\n --> /tmp/tmp3c299s0g.rs:5:24\n\
    \  |\n5 |     while i != String::npos {\n  |                        ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n --> /tmp/tmp3c299s0g.rs:7:38\n  |\n7 |         i = string.find(substring,\
    \ i + 1);\n  |                                    - ^ - {integer}\n  |       \
    \                             |\n  |                                    Option<usize>\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp3c299s0g.rs:7:20\n     |\n7    |         i = string.find(substring,\
    \ i + 1);\n     |                    ^^^^ ---------  ----- supplied 2 arguments\n\
    \     |                    |\n     |                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.len();\n        if end >\
    \ pos {\n            end = pos;\n        }\n        if string.contains(&substring[..end])\
    \ {\n            count += 1;\n        }\n        pos = end;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976089
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut i = 0;\n    while\
    \ i < string.len() {\n        if string.starts_with(substring, i) {\n        \
    \    i += substring.len();\n            counter += 1;\n        }\n        i +=\
    \ 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpngv97xe0.rs:6:19\n     |\n6    |         if string.starts_with(substring,\
    \ i) {\n     |                   ^^^^^^^^^^^ ---------  - supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring {\n            i += 1;\n        }\n        if i ==\
    \ string.len() {\n            break;\n        }\n        count += 1;\n       \
    \ pos = i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpg_j_1q3w.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring {\n  |    \
    \                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzubxn9mr.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                found = true;\n              \
    \  break;\n            }\n            if c == substring.chars()[0] {\n       \
    \         found = true;\n                break;\n            }\n            if\
    \ pos == string.len() - 1 {\n                found = true;\n                break;\n\
    \            }\n            if c == substring.chars()[1] {\n                found\
    \ = true;\n                break;\n            }\n            pos += 1;\n    \
    \    }\n        if found {\n            counter += 1;\n        }\n        pos\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpbn7xqd_f.rs:12:21\n\
    \   |\n12 |             if c == substring.chars()[0] {\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpbn7xqd_f.rs:20:21\n   |\n20 |             if c == substring.chars()[1]\
    \ {\n   |                     ^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut last_pos = 0;\n    while\
    \ last_pos < string.len() {\n        let pos = string.find(substring, last_pos);\n\
    \        if pos == String::npos {\n            break;\n        }\n        last_pos\
    \ = pos + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmps2m0h5_9.rs:6:26\n     |\n6    |         let pos = string.find(substring,\
    \ last_pos);\n     |                          ^^^^ ---------  -------- supplied\
    \ 2 arguments\n     |                          |\n     |                     \
    \     expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n --> /tmp/tmps2m0h5_9.rs:7:27\n  |\n7 |         if pos\
    \ == String::npos {\n  |                           ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmps2m0h5_9.rs:10:24\n   |\n10 |         last_pos = pos + 1;\n   |\
    \                    --- ^ - {integer}\n   |                    |\n   |      \
    \              Option<usize>\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut pos = string.find(substring, pos);\n \
    \       if pos == String::npos {\n            break;\n        }\n        count\
    \ += 1;\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpyoyvulti.rs:6:30\n     |\n6    |         let mut pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyoyvulti.rs:7:27\n  |\n7 |         if pos == String::npos\
    \ {\n  |                           ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `Option<usize>`\n  --> /tmp/tmpyoyvulti.rs:11:9\n   |\n11 |        \
    \ pos += 1;\n   |         ---^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                pos = c.cmp(substring);\n    \
    \        } else {\n                pos = c.cmp(substring, pos);\n            }\n\
    \            if pos == 0 {\n                found = true;\n                break;\n\
    \            }\n        }\n        if found {\n            counter += 1;\n   \
    \     }\n        pos += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqd_towtp.rs:9:29\n  |\n9 |\
    \                 pos = c.cmp(substring);\n  |                             ^^^^^^^^^\
    \ expected `&char`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpqd_towtp.rs:9:23\n  |\n4 |     let mut pos = 0;\n  |           \
    \        - expected due to this value\n...\n9 |                 pos = c.cmp(substring);\n\
    \  |                       ^^^^^^^^^^^^^^^^ expected `usize`, found enum `std::cmp::Ordering`\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpqd_towtp.rs:11:25\n    |\n11  |                 pos = c.cmp(substring,\
    \ pos);\n    |                         ^^^ ---------  --- supplied 2 arguments\n\
    \    |                         |\n    |                         expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqd_towtp.rs:11:23\n   |\n4  |     let mut pos = 0;\n   |      \
    \             - expected due to this value\n...\n11 |                 pos = c.cmp(substring,\
    \ pos);\n   |                       ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ enum `std::cmp::Ordering`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = string.find(substring, pos);\n\
    \        if found == String::npos {\n            count = count + 1;\n        \
    \    pos = string.len();\n        } else {\n            count = count + 1;\n \
    \           pos = found + 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpmcjo0twf.rs:6:32\n     |\n6    |         let mut found = string.find(substring,\
    \ pos);\n     |                                ^^^^ ---------  --- supplied 2\
    \ arguments\n     |                                |\n     |                 \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpmcjo0twf.rs:7:29\n  |\n7\
    \ |         if found == String::npos {\n  |                             ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpmcjo0twf.rs:12:25\n   |\n12 |            \
    \ pos = found + 1;\n   |                   ----- ^ - {integer}\n   |         \
    \          |\n   |                   Option<usize>\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.contains(substring, pos) {\n       \
    \     count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpqb0uz7uz.rs:6:19\n     |\n6    |         if string.contains(substring,\
    \ pos) {\n     |                   ^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.find(substring, pos);\n \
    \       if end == String::npos {\n            end = string.len();\n        }\n\
    \        pos = end + 1;\n        counter += 1;\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp033_i9q2.rs:6:30\n     |\n6    |         let mut end = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp033_i9q2.rs:7:27\n  |\n7 |         if end == String::npos\
    \ {\n  |                           ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp033_i9q2.rs:8:19\n\
    \  |\n6 |         let mut end = string.find(substring, pos);\n  |            \
    \           --------------------------- expected due to this value\n7 |      \
    \   if end == String::npos {\n8 |             end = string.len();\n  |       \
    \            ^^^^^^^^^^^^ expected enum `Option`, found `usize`\n  |\n  = note:\
    \ expected enum `Option<usize>`\n             found type `usize`\nhelp: try wrapping\
    \ the expression in `Some`\n  |\n8 |             end = Some(string.len());\n \
    \ |                   +++++            +\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmp033_i9q2.rs:10:19\n   |\n10 |         pos\
    \ = end + 1;\n   |               --- ^ - {integer}\n   |               |\n   |\
    \               Option<usize>\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308, E0369, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end_pos = string.len();\n        while\
    \ end_pos > pos && string[end_pos - 1] == substring[pos - 1] {\n            end_pos\
    \ -= 1;\n        }\n        if end_pos == pos {\n            count += 1;\n   \
    \     }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmprq3l03ff.rs:7:32\n\
    \  |\n7 |         while end_pos > pos && string[end_pos - 1] == substring[pos\
    \ - 1] {\n  |                                ^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmprq3l03ff.rs:7:55\n\
    \  |\n7 |         while end_pos > pos && string[end_pos - 1] == substring[pos\
    \ - 1] {\n  |                                                       ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    for c in string.chars() {\n\
    \        if substring.contains(&c) {\n            counter += 1;\n        }\n \
    \   }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp35a89x2q.rs:5:31\n\
    \     |\n5    |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n5    |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut pos = string.find(substring, pos);\n \
    \       if pos == String::npos { break; }\n        counter += 1;\n        pos\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpfkoyvccm.rs:6:30\n     |\n6    |         let mut pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpfkoyvccm.rs:7:27\n  |\n7 |         if pos == String::npos\
    \ { break; }\n  |                           ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `Option<usize>`\n --> /tmp/tmpfkoyvccm.rs:9:9\n  |\n9 |    \
    \     pos += 1;\n  |         ---^^^^^\n  |         |\n  |         cannot use `+=`\
    \ on type `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcmnidqda.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = string.find(substring);\n\
    \    while index != String::npos {\n        count += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpwj3277yh.rs:4:33\n     |\n4    |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n4    |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n --> /tmp/tmpwj3277yh.rs:5:28\n\
    \  |\n5 |     while index != String::npos {\n  |                            ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n --> /tmp/tmpwj3277yh.rs:7:46\n  |\n7 |    \
    \     index = string.find(substring, index + 1);\n  |                        \
    \                ----- ^ - {integer}\n  |                                    \
    \    |\n  |                                        Option<usize>\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpwj3277yh.rs:7:24\n\
    \     |\n7    |         index = string.find(substring, index + 1);\n     |   \
    \                     ^^^^ ---------  --------- supplied 2 arguments\n     | \
    \                       |\n     |                        expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring {\n            i += 1;\n        }\n        if i ==\
    \ string.len() {\n            break;\n        }\n        count += 1;\n       \
    \ pos = i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpg_j_1q3w.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring {\n  |    \
    \                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end_pos = string.find(substring, pos);\n\
    \        if end_pos == String::npos {\n            break;\n        }\n       \
    \ pos = end_pos + 1;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpahxypyhb.rs:6:34\n     |\n6    |         let mut end_pos = string.find(substring,\
    \ pos);\n     |                                  ^^^^ ---------  --- supplied\
    \ 2 arguments\n     |                                  |\n     |             \
    \                     expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpahxypyhb.rs:7:31\n  |\n7\
    \ |         if end_pos == String::npos {\n  |                               ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpahxypyhb.rs:10:23\n   |\n10 |\
    \         pos = end_pos + 1;\n   |               ------- ^ - {integer}\n   | \
    \              |\n   |               Option<usize>\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let end = string.find(substring, pos);\n     \
    \   if end == String::npos {\n            count = count + 1;\n            pos\
    \ = string.len();\n        } else {\n            count = count + 1;\n        \
    \    pos = end + 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpjo1rdyo0.rs:6:26\n     |\n6    |         let end = string.find(substring,\
    \ pos);\n     |                          ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                          |\n     |                          expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ function or associated item named `npos` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpjo1rdyo0.rs:7:27\n  |\n7 |         if end == String::npos\
    \ {\n  |                           ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  -->\
    \ /tmp/tmpjo1rdyo0.rs:12:23\n   |\n12 |             pos = end + 1;\n   |     \
    \              --- ^ - {integer}\n   |                   |\n   |             \
    \      Option<usize>\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0369, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.chars();\n\
    \    let mut substring_iter = substring.chars();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let mut char_iter = char_iter();\n\
    \    let mut char_iter = char_iter();\n    let \n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpyrodjj6z.rs:61:1\n  \
    \ |\n61 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find function `char_iter`\
    \ in this scope\n --> /tmp/tmpyrodjj6z.rs:6:25\n  |\n6 |     let mut char_iter\
    \ = char_iter();\n  |                         ^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    for c in string.chars() {\n\
    \        if c.contains(&substring) {\n            counter += 1;\n        }\n \
    \   }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmporf0tyst.rs:5:14\n  |\n5 |         if c.contains(&substring)\
    \ {\n  |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut pos = string.find(substring, pos);\n \
    \       if pos == String::npos { break; }\n        count += 1;\n        pos +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpgl2vb2k6.rs:6:30\n     |\n6    |         let mut pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpgl2vb2k6.rs:7:27\n  |\n7 |         if pos == String::npos\
    \ { break; }\n  |                           ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `Option<usize>`\n --> /tmp/tmpgl2vb2k6.rs:9:9\n  |\n9 |    \
    \     pos += 1;\n  |         ---^^^^^\n  |         |\n  |         cannot use `+=`\
    \ on type `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string.len() {\n        if string.starts_with(substring, i) {\n          \
    \  i += substring.len();\n            count += 1;\n        }\n        i += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpvoe1782_.rs:6:19\n     |\n6    |         if string.starts_with(substring,\
    \ i) {\n     |                   ^^^^^^^^^^^ ---------  - supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring[pos] {\n            i += 1;\n            pos += 1;\n\
    \        }\n        if i == string.len() {\n            break;\n        }\n  \
    \      count += 1;\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp8t2ir3x4.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring[pos] {\n  |\
    \                                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmp8t2ir3x4.rs:7:48\n\
    \  |\n7 |         while i < string.len() && string[i] == substring[pos] {\n  |\
    \                                                ^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n            pos += 1;\n      \
    \  }\n        if found {\n            counter += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2huizhxt.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for ch in string.chars() {\n\
    \        if ch.contains(&substring) {\n            count += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmpyklo331a.rs:5:15\n  |\n5 |         if ch.contains(&substring)\
    \ {\n  |               ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    while let Some((substring_start,\
    \ substring_end)) = substring_iter.next() {\n        let mut string_start = substring_start;\n\
    \        let mut string_end = substring_end;\n        let mut string_char = string_iter.next().unwrap();\n\
    \        while let Some((string_start, string_end)) = string_iter.next() {\n \
    \           if string_start < string_end {\n                if string_char ==\
    \ string_iter.next().unwrap() {\n                    count += 1;\n           \
    \     }\n                string_start = string_end;\n            }\n         \
    \   string_char = string_iter.next().unwrap();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpty0h9bil.rs:11:31\n   |\n\
    11 |             if string_start < string_end {\n   |                        \
    \       ^^^^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpty0h9bil.rs:15:32\n   |\n10 |         while let Some((string_start,\
    \ string_end)) = string_iter.next() {\n   |                         ------------\
    \ expected due to the type of this binding\n...\n15 |                 string_start\
    \ = string_end;\n   |                                ^^^^^^^^^^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for ch in string.chars() {\n\
    \        if ch.contains(&substring) {\n            count += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmpyklo331a.rs:5:15\n  |\n5 |         if ch.contains(&substring)\
    \ {\n  |               ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n\
    \        if substring.contains(&c) {\n            count += 1;\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpl48i40_b.rs:5:31\n\
    \     |\n5    |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n5    |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    while let Some((substring_start,\
    \ substring_end)) = substring_iter.next() {\n        let substring_slice = string.chars()[substring_start..=substring_end];\n\
    \        if substring_slice.contains(&substring) {\n            counter += 1;\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmple8b7qjb.rs:7:64\n  |\n7 |\
    \         let substring_slice = string.chars()[substring_start..=substring_end];\n\
    \  |                                                                ^^^^^^^^^^^^^\
    \ expected `usize`, found `char`\n\nerror[E0608]: cannot index into a value of\
    \ type `Chars<'_>`\n --> /tmp/tmple8b7qjb.rs:7:31\n  |\n7 |         let substring_slice\
    \ = string.chars()[substring_start..=substring_end];\n  |                    \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring[pos] {\n            i += 1;\n            pos += 1;\n\
    \        }\n        if i == string.len() {\n            count += 1;\n        }\n\
    \        pos = i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmper3yl4ee.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring[pos] {\n  |\
    \                                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmper3yl4ee.rs:7:48\n\
    \  |\n7 |         while i < string.len() && string[i] == substring[pos] {\n  |\
    \                                                ^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut current_substring_iter\
    \ = substring_iter.next();\n    let mut current_string_iter = string_iter.next();\n\
    \    while current_substring_iter != substring_iter.end() && current_string_iter\
    \ != string_iter.end() {\n        if current_substring_iter.index() == current_string_iter.index()\
    \ {\n            count += 1;\n        }\n        if current_substring_iter.index()\
    \ < current_string_iter.index() {\n            current_substring_iter = substring_iter.next();\n\
    \        } else {\n            current_string_iter = string_iter.next();\n   \
    \     }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `end` found for struct `CharIndices` in the\
    \ current scope\n --> /tmp/tmpu67oh3k8.rs:8:52\n  |\n8 |     while current_substring_iter\
    \ != substring_iter.end() && current_string_iter != string_iter.end() {\n  | \
    \                                                   ^^^ method not found in `CharIndices<'_>`\n\
    \nerror[E0599]: no method named `end` found for struct `CharIndices` in the current\
    \ scope\n --> /tmp/tmpu67oh3k8.rs:8:96\n  |\n8 |     while current_substring_iter\
    \ != substring_iter.end() && current_string_iter != string_iter.end() {\n  | \
    \                                                                            \
    \                   ^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]:\
    \ no method named `index` found for enum `Option` in the current scope\n --> /tmp/tmpu67oh3k8.rs:9:35\n\
    \  |\n9 |         if current_substring_iter.index() == current_string_iter.index()\
    \ {\n  |                                   ^^^^^ method not found in `Option<(usize,\
    \ char)>`\n\nerror[E0599]: no method named `index` found for enum `Option` in\
    \ the current scope\n --> /tmp/tmpu67oh3k8.rs:9:66\n  |\n9 |         if current_substring_iter.index()\
    \ == current_string_iter.index() {\n  |                                      \
    \                            ^^^^^ method not found in `Option<(usize, char)>`\n\
    \nerror[E0599]: no method named `index` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpu67oh3k8.rs:12:35\n   |\n12 |         if current_substring_iter.index()\
    \ < current_string_iter.index() {\n   |                                   ^^^^^\
    \ method not found in `Option<(usize, char)>`\n\nerror[E0599]: no method named\
    \ `index` found for enum `Option` in the current scope\n  --> /tmp/tmpu67oh3k8.rs:12:65\n\
    \   |\n12 |         if current_substring_iter.index() < current_string_iter.index()\
    \ {\n   |                                                                 ^^^^^\
    \ method not found in `Option<(usize, char)>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut first_substring_iter\
    \ = substring.char_indices();\n    let mut second_substring_iter = substring.char_indices();\n\
    \    let mut first_substring_end = first_substring_iter.end();\n    let mut second_substring_end\
    \ = second_substring_iter.end();\n    let mut first_substring_start = first_substring_iter.start();\n\
    \    let mut second_substring_start = second_substring_iter.start();\n    let\
    \ mut first_substring_char = first_substring_iter.next();\n    let mut second_substring_char\
    \ = second_substring_iter.next();\n    while let Some(first_substring_char) =\
    \ first_substring_char {\n        while let Some(second_substring_char) = second_substring_char\
    \ {\n            if first_substring_char == second_substring_char {\n        \
    \        count += 1;\n                first_substring_char = first_substring_iter.next();\n\
    \                second_substring_char = second_substring_iter.next();\n     \
    \       } else {\n                break;\n            }\n        }\n        if\
    \ first_substring_char == None {\n            break;\n        }\n        count\
    \ += 1;\n        first_substring_start = first_substring_iter.start();\n     \
    \   first_substring_char = first_substring_iter.next();\n    }\n    while let\
    \ Some(second_substring_char) = second_substring_char {\n        if second_substring_char\
    \ == None {\n            break;\n        }\n        count += 1;\n        second_substring_end\
    \ = second_substring_iter.end();\n        second_substring_start = second_substring_iter.start();\n\
    \        second_substring_char = second_substring_iter.next();\n    }\n    while\
    \ let Some(first_substring_char) = first_substring_char {\n        if first_substring_char\
    \ == None {\n            break;\n        }\n        count += 1;\n        first_substring_end\
    \ = first_substring_iter.end();\n        first_substring_start = first_substring_iter.start();\n\
    \        first_substring_char = first_substring_iter.next();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `end` found for struct `CharIndices` in the\
    \ current scope\n --> /tmp/tmp3i4xp8x9.rs:8:56\n  |\n8 |     let mut first_substring_end\
    \ = first_substring_iter.end();\n  |                                         \
    \               ^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]: no\
    \ method named `end` found for struct `CharIndices` in the current scope\n -->\
    \ /tmp/tmp3i4xp8x9.rs:9:58\n  |\n9 |     let mut second_substring_end = second_substring_iter.end();\n\
    \  |                                                          ^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror[E0599]: no method named `start` found for struct\
    \ `CharIndices` in the current scope\n  --> /tmp/tmp3i4xp8x9.rs:10:58\n   |\n\
    10 |     let mut first_substring_start = first_substring_iter.start();\n   | \
    \                                                         ^^^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror[E0599]: no method named `start` found for struct\
    \ `CharIndices` in the current scope\n  --> /tmp/tmp3i4xp8x9.rs:11:60\n   |\n\
    11 |     let mut second_substring_start = second_substring_iter.start();\n   |\
    \                                                            ^^^^^ method not\
    \ found in `CharIndices<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3i4xp8x9.rs:18:40\n\
    \   |\n14 |     while let Some(first_substring_char) = first_substring_char {\n\
    \   |                    -------------------- expected due to the type of this\
    \ binding\n...\n18 |                 first_substring_char = first_substring_iter.next();\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \               found enum `Option<(usize, char)>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3i4xp8x9.rs:19:41\n   |\n15 |         while let Some(second_substring_char)\
    \ = second_substring_char {\n   |                        ---------------------\
    \ expected due to the type of this binding\n...\n19 |                 second_substring_char\
    \ = second_substring_iter.next();\n   |                       "
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == string.len() || c == string[pos] {\n              \
    \  found = true;\n                break;\n            }\n            if c == substring[pos]\
    \ {\n                counter += 1;\n                pos += 1;\n            }\n\
    \        }\n        if !found {\n            break;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp3hy_16f1.rs:8:44\n\
    \  |\n8 |             if pos == string.len() || c == string[pos] {\n  |      \
    \                                      ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3hy_16f1.rs:12:21\n\
    \   |\n12 |             if c == substring[pos] {\n   |                     ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.find(substring, pos);\n \
    \       if end == String::npos {\n            end = string.len();\n        }\n\
    \        pos = end;\n        counter += 1;\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp1h36hqtg.rs:6:30\n     |\n6    |         let mut end = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp1h36hqtg.rs:7:27\n  |\n7 |         if end == String::npos\
    \ {\n  |                           ^^^^ function or associated item not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1h36hqtg.rs:8:19\n\
    \  |\n6 |         let mut end = string.find(substring, pos);\n  |            \
    \           --------------------------- expected due to this value\n7 |      \
    \   if end == String::npos {\n8 |             end = string.len();\n  |       \
    \            ^^^^^^^^^^^^ expected enum `Option`, found `usize`\n  |\n  = note:\
    \ expected enum `Option<usize>`\n             found type `usize`\nhelp: try wrapping\
    \ the expression in `Some`\n  |\n8 |             end = Some(string.len());\n \
    \ |                   +++++            +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1h36hqtg.rs:10:15\n   |\n4  |     let mut pos = 0;\n   |       \
    \            - expected due to this value\n...\n10 |         pos = end;\n   |\
    \               ^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<usize>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcmnidqda.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string.len() {\n        if string.starts_with(substring, i) {\n          \
    \  i += substring.len();\n            count += 1;\n        }\n        i += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpvoe1782_.rs:6:19\n     |\n6    |         if string.starts_with(substring,\
    \ i) {\n     |                   ^^^^^^^^^^^ ---------  - supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n\
    \        if c.contains(substring) {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmp4b03o54l.rs:5:14\n  |\n5 |         if c.contains(substring)\
    \ {\n  |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpmy9fdp8h.rs:6:19\n     |\n6    |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.find(substring, pos);\n \
    \       if end == String::npos { break; }\n        count += 1;\n        pos =\
    \ end + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpn2frgxtq.rs:6:30\n     |\n6    |         let mut end = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpn2frgxtq.rs:7:27\n  |\n7 |         if end == String::npos\
    \ { break; }\n  |                           ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \ --> /tmp/tmpn2frgxtq.rs:9:19\n  |\n9 |         pos = end + 1;\n  |         \
    \      --- ^ - {integer}\n  |               |\n  |               Option<usize>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut pos = string.find(substring, pos);\n \
    \       if pos == String::npos { break; }\n        count += 1;\n        pos +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpgl2vb2k6.rs:6:30\n     |\n6    |         let mut pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpgl2vb2k6.rs:7:27\n  |\n7 |         if pos == String::npos\
    \ { break; }\n  |                           ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `Option<usize>`\n --> /tmp/tmpgl2vb2k6.rs:9:9\n  |\n9 |    \
    \     pos += 1;\n  |         ---^^^^^\n  |         |\n  |         cannot use `+=`\
    \ on type `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string.len() {\n        if string.starts_with(substring, i) {\n          \
    \  i += substring.len();\n            count += 1;\n        }\n        i += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpvoe1782_.rs:6:19\n     |\n6    |         if string.starts_with(substring,\
    \ i) {\n     |                   ^^^^^^^^^^^ ---------  - supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring {\n            i += 1;\n        }\n        if i ==\
    \ string.len() {\n            break;\n        }\n        count += 1;\n       \
    \ pos = i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpg_j_1q3w.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring {\n  |    \
    \                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n\
    \        if c.contains(substring) {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmp4b03o54l.rs:5:14\n  |\n5 |         if c.contains(substring)\
    \ {\n  |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                if c == substring {\n        \
    \            found = true;\n                    break;\n                }\n  \
    \          } else {\n                if c == substring {\n                   \
    \ found = true;\n                    break;\n                }\n            }\n\
    \            pos += 1;\n        }\n        if found {\n            counter +=\
    \ 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpet_xzknc.rs:9:25\n  |\n9 |\
    \                 if c == substring {\n  |                         ^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpet_xzknc.rs:14:25\n\
    \   |\n14 |                 if c == substring {\n   |                        \
    \ ^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcmnidqda.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n\
    \        if c.contains(substring) {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmp4b03o54l.rs:5:14\n  |\n5 |         if c.contains(substring)\
    \ {\n  |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n\
    \        if substring.contains(&c) {\n            count += 1;\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpl48i40_b.rs:5:31\n\
    \     |\n5    |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n5    |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut pos = string.find(substring, pos);\n \
    \       if pos == String::npos { break; }\n        counter += 1;\n        pos\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpfkoyvccm.rs:6:30\n     |\n6    |         let mut pos = string.find(substring,\
    \ pos);\n     |                              ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                              |\n     |                              expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpfkoyvccm.rs:7:27\n  |\n7 |         if pos == String::npos\
    \ { break; }\n  |                           ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `Option<usize>`\n --> /tmp/tmpfkoyvccm.rs:9:9\n  |\n9 |    \
    \     pos += 1;\n  |         ---^^^^^\n  |         |\n  |         cannot use `+=`\
    \ on type `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if pos == 0 {\n                found = true;\n              \
    \  break;\n            }\n            if c == substring.chars()[pos - 1] {\n \
    \               found = true;\n                break;\n            }\n       \
    \ }\n        if found {\n            counter += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp0hiicwo3.rs:12:21\n\
    \   |\n12 |             if c == substring.chars()[pos - 1] {\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.chars();\n\
    \    let mut substring_iter = substring.chars();\n    let mut char_iter = char_iter();\n\
    \    while let Some(char) = char_iter.next() {\n        if let Some(substring)\
    \ = substring_iter.next() {\n            if char == substring {\n            \
    \    count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_iter` in this scope\n --> /tmp/tmpovfh_4i9.rs:6:25\n\
    \  |\n6 |     let mut char_iter = char_iter();\n  |                         ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcmnidqda.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = string.find(substring, pos);\n\
    \        if found == String::npos {\n            break;\n        }\n        pos\
    \ = found + 1;\n        counter += 1;\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpg9ae1415.rs:6:32\n     |\n6    |         let mut found = string.find(substring,\
    \ pos);\n     |                                ^^^^ ---------  --- supplied 2\
    \ arguments\n     |                                |\n     |                 \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpg9ae1415.rs:7:29\n  |\n7\
    \ |         if found == String::npos {\n  |                             ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmpg9ae1415.rs:10:21\n   |\n10 |         pos\
    \ = found + 1;\n   |               ----- ^ - {integer}\n   |               |\n\
    \   |               Option<usize>\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for ch in string.chars() {\n\
    \        if ch.contains(&substring) {\n            count += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmpyklo331a.rs:5:15\n  |\n5 |         if ch.contains(&substring)\
    \ {\n  |               ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    for c in string.chars() {\n\
    \        if c.contains(&substring) {\n            counter += 1;\n        }\n \
    \   }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for type `char` in the current\
    \ scope\n --> /tmp/tmporf0tyst.rs:5:14\n  |\n5 |         if c.contains(&substring)\
    \ {\n  |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut current_substring\
    \ = String::new();\n    let mut current_string = String::new();\n    loop {\n\
    \        if let Some(current_substring) = substring_iter.next() {\n          \
    \  if let Some(current_string) = string_iter.next() {\n                if current_string.contains(&current_substring)\
    \ {\n                    count += 1;\n                }\n            } else {\n\
    \                break;\n            }\n        } else {\n            break;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmpdbh7sgfa.rs:11:35\n   |\n11 |          \
    \       if current_string.contains(&current_substring) {\n   |               \
    \                    ^^^^^^^^ method not found in `(usize, char)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut i = pos;\n        while i < string.len()\
    \ && string[i] == substring {\n            i += 1;\n        }\n        if i ==\
    \ string.len() {\n            break;\n        }\n        count += 1;\n       \
    \ pos = i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpg_j_1q3w.rs:7:35\n\
    \  |\n7 |         while i < string.len() && string[i] == substring {\n  |    \
    \                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_iter = string.char_indices();\n\
    \    let mut substring_iter = substring.char_indices();\n    let mut char_iter\
    \ = char_iter();\n    loop {\n        if let Some((start, end)) = substring_iter.next()\
    \ {\n            if start < end {\n                count += char_iter.count(|c|\
    \ start <= c && c <= end);\n            }\n        }\n        if let Some((start,\
    \ end)) = string_iter.next() {\n            if start < end {\n               \
    \ count += char_iter.count(|c| start <= c && c <= end);\n            }\n     \
    \   }\n        if let Some((start, end)) = char_iter.next() {\n            if\
    \ start < end {\n                count += char_iter.count(|c| start <= c && c\
    \ <= end);\n            }\n        }\n        if let Some((start, end)) = string_iter.next()\
    \ {\n            if start < end {\n                count += char_iter.count(|c|\
    \ start <= c && c <= end);\n            }\n        }\n        if let Some((start,\
    \ end)) = char_iter.next() {\n            if start < end {\n                count\
    \ += char_iter.count(|c| start <= c && c <= end);\n            }\n        }\n\
    \        if let Some((start, end)) = string_iter.next() {\n            if start\
    \ < end {\n                count += char_iter.count(|c| start <= c && c <= end);\n\
    \            }\n        }\n        if let Some((start, end)) = char_iter.next()\
    \ {\n            if start < end {\n                count += char_iter.count(|c|\
    \ start <= c && c <= end);\n            }\n        }\n        if let Some((start,\
    \ end)) = string_iter.next() {\n            if start < end {\n               \
    \ count += char_iter.count(|c| start <= c && c <= end);\n            }\n     \
    \   }\n        if let Some((start, end)) = char_iter.next() {\n            if\
    \ start < end {\n                count += char_iter.count(|c| start <= c && c\
    \ <= end);\n            }\n        }\n        if let Some((start, end)) = string_iter.next()\
    \ {\n            if start < end {\n                count += char_iter.count(|c|\
    \ start <= c && c <= end);\n            }\n        }\n        if let Some((start,\
    \ end)) = char_iter.next() {\n            if start < end {\n                count\
    \ += char_iter.count(|c| start <= c && c <= end);\n            }\n        }\n\
    \        if let Some((start, end)) = string_iter.next() {\n            if start\
    \ < end {\n                count += char_iter.count(|c| start <= c && \n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5a92e416.rs:74:3\n\
    \   |\n2  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n7  |     loop {\n   |          - unclosed delimiter\n...\n63\
    \ |         if let Some((start, end)) = string_iter.next() {\n   |           \
    \                                             - unclosed delimiter\n64 |     \
    \        if start < end {\n   |                            - this delimiter might\
    \ not be properly closed...\n65 |                 count += char_iter.count(|c|\
    \ start <= c && \n66 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n74 | }\n   |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmp5a92e416.rs:66:1\n\
    \   |\n66 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp5a92e416.rs:65:41\n   |\n2  | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                                        \
    \                       - closing delimiter possibly meant for this\n...\n65 |\
    \                 count += char_iter.count(|c| start <= c && \n   |          \
    \                               ^ unclosed delimiter\n66 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0425]: cannot find function `char_iter` in this\
    \ scope\n --> /tmp/tmp5a92e416.rs:6:25\n  |\n6 |     let mut char_iter = char_iter();\n\
    \  |                         ^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5a92e416.rs:9:24\n  |\n9 |             if start\
    \ < end {\n  |                        ^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5a92e416.rs:10:65\n   |\n10 |              \
    \   count += char_iter.count(|c| start <= c && c <= end);\n   |              \
    \                                                   ^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5a92e416.rs:14:24\n\
    \   |\n14 |             if start < end {\n   |                        ^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: m"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.len();\n        if end >\
    \ substring.len() {\n            end = substring.len();\n        }\n        if\
    \ string.contains(&substring[..end]) {\n            count += 1;\n            pos\
    \ += end;\n        } else {\n            pos += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmp26rx6qpc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n            pos += 1;\n      \
    \  }\n        if found {\n            counter += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2huizhxt.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut string_iter = string.chars();\n\
    \    let mut substring_iter = substring.chars();\n    while let Some(substring_char)\
    \ = substring_iter.next() {\n        if let Some(string_char) = string_iter.next()\
    \ {\n            if string_char == substring_char {\n                counter +=\
    \ 1;\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpg2o__z4m.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = false;\n        for c in string.chars()\
    \ {\n            if c == substring.chars().nth(pos) {\n                found =\
    \ true;\n                break;\n            }\n        }\n        if found {\n\
    \            count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzubxn9mr.rs:8:21\n  |\n8 |\
    \             if c == substring.chars().nth(pos) {\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n  |\n  = note: expected type `char`\n\
    \             found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut end = string.len();\n        if end >\
    \ pos {\n            end = pos;\n        }\n        if string.contains(substring,\
    \ start, end) {\n            count += 1;\n        }\n        pos = end;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found built-in attribute `start`\n  --> /tmp/tmpgff3usx_.rs:10:39\n\
    \   |\n10 |         if string.contains(substring, start, end) {\n   |        \
    \                               ^^^^^ not a value\n\nerror[E0061]: this function\
    \ takes 1 argument but 3 arguments were supplied\n    --> /tmp/tmpgff3usx_.rs:10:19\n\
    \     |\n10   |         if string.contains(substring, start, end) {\n     |  \
    \                 ^^^^^^^^ ---------  -----  --- supplied 3 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let mut found = string.find(substring, pos);\n\
    \        if found == String::npos {\n            count += 1;\n            pos\
    \ = string.len();\n        } else {\n            count += found - pos;\n     \
    \       pos = found + 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpqzkm9qj5.rs:6:32\n     |\n6    |         let mut found = string.find(substring,\
    \ pos);\n     |                                ^^^^ ---------  --- supplied 2\
    \ arguments\n     |                                |\n     |                 \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpqzkm9qj5.rs:7:29\n  |\n7\
    \ |         if found == String::npos {\n  |                             ^^^^ function\
    \ or associated item not found in `String`\n\nerror[E0369]: cannot subtract `usize`\
    \ from `Option<usize>`\n  --> /tmp/tmpqzkm9qj5.rs:11:28\n   |\n11 |          \
    \   count += found - pos;\n   |                      ----- ^ --- usize\n   | \
    \                     |\n   |                      Option<usize>\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpqzkm9qj5.rs:12:25\n\
    \   |\n12 |             pos = found + 1;\n   |                   ----- ^ - {integer}\n\
    \   |                   |\n   |                   Option<usize>\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count() +\
    \ 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp5m35sjpu.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5m35sjpu.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.chars().position(|c| c == substring[pos]).is_some()\
    \ {\n            counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpkv_ofwod.rs:6:45\n\
    \  |\n6 |         if string.chars().position(|c| c == substring[pos]).is_some()\
    \ {\n  |                                             ^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        if string.starts_with(substring, pos) {\n    \
    \        count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpzyysyejp.rs:6:19\n    |\n6   |         if string.starts_with(substring,\
    \ pos) {\n    |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \    |                   |\n    |                   expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748248
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos < string.len() {\n        let end = string.find(substring, pos);\n     \
    \   if end == String::npos { break; }\n        count += 1;\n        pos = end\
    \ + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpsb2goon7.rs:6:26\n     |\n6    |         let end = string.find(substring,\
    \ pos);\n     |                          ^^^^ ---------  --- supplied 2 arguments\n\
    \     |                          |\n     |                          expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ function or associated item named `npos` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpsb2goon7.rs:7:27\n  |\n7 |         if end == String::npos\
    \ { break; }\n  |                           ^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \ --> /tmp/tmpsb2goon7.rs:9:19\n  |\n9 |         pos = end + 1;\n  |         \
    \      --- ^ - {integer}\n  |               |\n  |               Option<usize>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976084
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.chars().filter(|c| c == substring).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmppnrb2_zs.rs:3:33\n\
    \  |\n3 |     string.chars().filter(|c| c == substring).count()\n  |         \
    \                        ^^ no implementation for `&char == String`\n  |\n  =\
    \ help: the trait `PartialEq<String>` is not implemented for `&char`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppnrb2_zs.rs:3:5\n  |\n2 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n3 |  \
    \   string.chars().filter(|c| c == substring).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n3 |     string.chars().filter(|c|\
    \ c == substring).count().try_into().unwrap()\n  |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748248
