language: rs
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe1ge0fdq.rs:15:11\n   |\n15 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut closest_integer_dist = std::i32::MAX;\n\
    \    let mut closest_integer_dist_square = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_1\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_2 = std::i32::MAX;\n\
    \    let mut closest_integer_dist_square_minus_3 = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_square_minus_4 = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_5\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_6 = std::i32::MAX;\n\
    \    let mut closest_integer_dist_square_minus_7 = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_square_minus_8 = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_9\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_10 = std::i32::MAX;\n\
    \    let mut closest_integer_dist_square_minus_11 = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_square_minus_12 = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_13\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_14 = std::i32::MAX;\n\
    \    let mut closest_integer_dist_square_minus_15 = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_square_minus_16 = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_17\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_18 = std::i32::MAX;\n\
    \    let mut closest_integer_dist_square_minus_19 = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_square_minus_20 = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_21\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_22 = std::i32::MAX;\n\
    \    let mut closest_integer_dist_square_minus_23 = std::i32::MAX;\n    let mut\
    \ closest_integer_dist_square_minus_24 = std::i32::MAX;\n    let mut closest_integer_dist_square_minus_25\
    \ = std::i32::MAX;\n    let mut closest_integer_dist_\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoq42lq_w.rs:46:34\n   |\n\
    46 |     let mut closest_integer_dist_\n   |                                 \
    \ ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoq42lq_w.rs:10:38\n   |\n10 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805390
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer_to_two = value;\n    let mut closest_integer_to_three\
    \ = value;\n    let mut closest_integer_to_four = value;\n    let mut closest_integer_to_five\
    \ = value;\n    let mut closest_integer_to_six = value;\n    let mut closest_integer_to_seven\
    \ = value;\n    let mut closest_integer_to_eight = value;\n    let mut closest_integer_to_nine\
    \ = value;\n    let mut closest_integer_to_ten = value;\n    let mut closest_integer_to_eleven\
    \ = value;\n    let mut closest_integer_to_twelve = value;\n    let mut closest_integer_to_thirteen\
    \ = value;\n    let mut closest_integer_to_fourteen = value;\n    let mut closest_integer_to_fifteen\
    \ = value;\n    let mut closest_integer_to_sixteen = value;\n    let mut closest_integer_to_seventeen\
    \ = value;\n    let mut closest_integer_to_eighteen = value;\n    let mut closest_integer_to_nineteen\
    \ = value;\n    let mut closest_integer_to_twenty = value;\n    let mut closest_integer_to_twenty_one\
    \ = value;\n    let mut closest_integer_to_twenty_two = value;\n    let mut closest_integer_to_twenty_three\
    \ = value;\n    let mut closest_integer_to_twenty_four = value;\n    let mut closest_integer_to_twenty_five\
    \ = value;\n    let mut closest_integer_to_twenty_six = value;\n    let mut closest_integer_to_twenty_seven\
    \ = value;\n    let mut closest_integer_to_twenty_eight = value;\n    let mut\
    \ closest_integer_to_twenty_nine = value;\n    let mut closest_integer_to_thirty\
    \ = value;\n    let mut closest_integer_to_thirty_one = value;\n    let mut closest_integer_to_thirty_two\
    \ = value;\n    let mut closest_integer_to_thirty_three = value;\n    let mut\
    \ closest_integer_to_thirty_four = value;\n    let mut closest_integer_to_thirty_five\
    \ = value;\n    let mut closest_integer_to_thirty_six = value;\n    let mut closest_integer_to_thirty_seven\
    \ = value;\n    let mut closest_integer_to_thirty_eight = value;\n    let mut\
    \ closest_integer_to_thirty_nine = value;\n    let mut closest_integer_to_forty\
    \ = value;\n    let mut closest_integer_to_forty_one = value;\n    let mut closest_integer_to_forty_two\
    \ = value;\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiceohmnl.rs:10:38\n   |\n\
    10 | fn closest_integer(value: String) -> isize {\n   |    ---------------   \
    \                ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805390
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer = if closest_integer == 0 {\n        closest_integer\n    }\
    \ else {\n        closest_integer - 1\n    };\n    while closest_integer % 2 ==\
    \ 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpc4qz3qh4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = value;\n    let mut closest_integer = if value < 0 {\n        closest_integer\
    \ - 1;\n    } else {\n        closest_integer + 1;\n    };\n    while closest_integer\
    \ % 2 == 0 {\n        closest_integer = closest_integer / 2;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `()` by `{integer}`\n  --> /tmp/tmpn7aaga00.rs:18:27\n\
    \   |\n18 |     while closest_integer % 2 == 0 {\n   |           ---------------\
    \ ^ - {integer}\n   |           |\n   |           ()\n\nerror[E0369]: cannot divide\
    \ `()` by `{integer}`\n  --> /tmp/tmpn7aaga00.rs:19:43\n   |\n19 |         closest_integer\
    \ = closest_integer / 2;\n   |                           --------------- ^ - {integer}\n\
    \   |                           |\n   |                           ()\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn7aaga00.rs:21:5\n   |\n10 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n21 |     closest_integer\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = value;\n    let mut closest_distance = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_integer = isize::MIN;\n    while closest_distance > isize::MAX\
    \ {\n        closest_value = value % closest_value;\n        closest_distance\
    \ = closest_value - closest_integer;\n        closest_integer = closest_value\
    \ + isize::MIN;\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-9223372036854775808`,\n right: `10`', /tmp/tmp2v1whs2j.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value % 2 == 0 {\n\
    \        value = value / 2;\n    }\n    value.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp10gtzk0k.rs:15:11\n   |\n15 |     value.round() as isize\n\
    \   |           ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest: isize\
    \ = 0;\n    let mut closest2 = closest;\n    let mut closest3 = closest2;\n  \
    \  let mut closest4 = closest3;\n    let mut closest5 = closest4;\n    let mut\
    \ closest6 = closest5;\n    let mut closest7 = closest6;\n    let mut closest8\
    \ = closest7;\n    let mut closest9 = closest8;\n    let mut closest10 = closest9;\n\
    \    let mut closest11 = closest10;\n    let mut closest12 = closest11;\n    let\
    \ mut closest13 = closest12;\n    let mut closest14 = closest13;\n    let mut\
    \ closest15 = closest14;\n    let mut closest16 = closest15;\n    let mut closest17\
    \ = closest16;\n    let mut closest18 = closest17;\n    let mut closest19 = closest18;\n\
    \    let mut closest20 = closest19;\n    let mut closest21 = closest20;\n    let\
    \ mut closest22 = closest21;\n    let mut closest23 = closest22;\n    let mut\
    \ closest24 = closest23;\n    let mut closest25 = closest24;\n    let mut closest26\
    \ = closest25;\n    let mut closest27 = closest26;\n    let mut closest28 = closest27;\n\
    \    let mut closest29 = closest28;\n    let mut closest30 = closest29;\n    let\
    \ mut closest31 = closest30;\n    let mut closest32 = closest31;\n    let mut\
    \ closest33 = closest32;\n    let mut closest34 = closest33;\n    let mut closest35\
    \ = closest34;\n    let mut closest36 = closest35;\n    let mut closest37 = closest36;\n\
    \    let mut closest38 = closest37;\n    let mut closest39 = closest38;\n    let\
    \ mut closest40 = closest39;\n    let mut closest41 = closest40;\n    let mut\
    \ closest42 = closest41;\n    let mut closest43 = closest42;\n    let mut closest44\
    \ = closest43;\n    let mut closest45 = closest44;\n    let mut closest46 = closest45;\n\
    \    let mut closest47 = closest46;\n    let mut closest48 = closest47;\n    let\
    \ mut closest49 = closest48;\n    let mut closest50 = closest49;\n    let mut\
    \ closest51 = closest50;\n    let mut closest52 = closest51;\n    let mut closest53\
    \ = closest5\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7smkedh_.rs:64:33\n   |\n\
    64 |     let mut closest53 = closest5\n   |                                 ^\
    \ help: add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7smkedh_.rs:10:38\n   |\n10 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805390
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut min_value = value;\n\
    \    let mut max_value = value;\n    while min_value > max_value {\n        min_value\
    \ -= 1;\n        max_value += 1;\n    }\n    min_value\n}\n\nfn main() {\n   \
    \ let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\"\
    )), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpid3dkx6b.rs:11:44

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe1ge0fdq.rs:15:11\n   |\n15 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value % 2 == 0 {\n        value /= 2;\n  \
    \  } else {\n        value *= 2;\n    }\n    value\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpj0r5vxle.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        value = 0;\n    }\n\
    \    value\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpg45eo49i.rs:11:44

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659805391
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ prev_value = value;\n    while prev_value != value {\n        prev_value = value;\n\
    \        value = closest_integer + 1;\n    }\n    closest_integer\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmplwiufjy_.rs:11:44

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659805391
- exit_code: -1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<isize>().unwrap();\n    let mut closest_integer =\
    \ value;\n    let mut closest_integer_value = value;\n    let mut current_value\
    \ = value;\n    while current_value >= closest_integer_value {\n        closest_integer_value\
    \ -= 1;\n        closest_integer -= 1;\n    }\n    closest_integer\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659805396
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = value;\n    let mut closest_distance = std::f64::MAX;\n    while closest_distance\
    \ > std::f64::EPSILON {\n        let mut new_value = value + 1;\n        if new_value\
    \ > closest_value {\n            new_value = closest_value;\n        }\n     \
    \   closest_value = new_value;\n        closest_distance = std::f64::abs(value\
    \ - closest_value);\n    }\n    closest_value\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpv3wt68z7.rs:20:38\n\
    \   |\n20 |         closest_distance = std::f64::abs(value - closest_value);\n\
    \   |                                      ^^^ not found in `std::f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805390
- exit_code: -1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    let mut closest_integer = value;\n    let mut\
    \ closest_integer_diff = 0;\n    let mut closest_integer_diff_prev = 0;\n    while\
    \ closest_integer != 0 {\n        let mut closest_integer_diff = value - closest_integer;\n\
    \        if closest_integer_diff < closest_integer_diff_prev {\n            closest_integer\
    \ = closest_integer_diff_prev;\n        } else {\n            closest_integer_diff_prev\
    \ = closest_integer_diff;\n            closest_integer = closest_integer_diff_prev\
    \ + closest_integer;\n        }\n    }\n    closest_integer\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659805396
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe1ge0fdq.rs:15:11\n   |\n15 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest: isize = 0;\n    let mut current = value;\n    while current\
    \ > closest {\n        current -= 1;\n        closest += 1;\n    }\n    closest\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmpuoiifhou.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 101
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    if value == 0 {\n        return 0;\n    }\n \
    \   let mut closest_integer = value;\n    let mut prev_value = value;\n    while\
    \ prev_value >= closest_integer {\n        closest_integer += 1;\n        prev_value\
    \ -= 1;\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmp9pewg87z.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n    \
    \    value = -value;\n    }\n    value.round()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `round` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe1ge0fdq.rs:15:11\n   |\n15 |     value.round()\n   | \
    \          ^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805391
