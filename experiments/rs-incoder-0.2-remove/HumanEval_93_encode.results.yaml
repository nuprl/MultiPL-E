language: rs
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message {\n        if letter in vowels\
    \ {\n            encoded.push_str(&letters[vowels.index(letter)].to_string());\n\
    \        } else {\n            encoded.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() + 1].to_string());\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp7dk80q0t.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp7dk80q0t.rs:11:19\n\
    \    |\n11  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n        } else {\n            encoded.push_str(&letter);\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp02mjv_d2.rs:11:28\n\
    \   |\n11 |         if vowels.contains(&letter) {\n   |                      \
    \      ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp02mjv_d2.rs:12:50\n\
    \   |\n12 |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n   |                                                  ^^^^^^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp02mjv_d2.rs:12:72\n   |\n\
    12 |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n   |                                                               \
    \         ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   =\
    \ help: the trait `Fn<(char,)>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&char`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp02mjv_d2.rs:12:81\n\
    \   |\n12 |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n   |                                                            --------------------\
    \ ^ - {integer}\n   |                                                        \
    \    |\n   |                                                            Option<usize>\n\
    \nerror[E02"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter == letters[index] {\n        \
    \    encoded.push_str(&vowels[index]);\n        } else {\n            encoded.push_str(&letters[index]);\n\
    \        }\n        index += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpsq8hfi7d.rs:12:19\n\
    \    |\n12  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'E', 'I', 'O', 'U'];\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ encoded.push_str(\"_\");\n        } else {\n            encoded.push_str(letters[letter\
    \ - 'a']);\n        }\n    }\n    for vowel in vowels {\n        encoded.push_str(vowels[vowel\
    \ - 'a']);\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp5om99h_a.rs:15:45\n\
    \   |\n15 |             encoded.push_str(letters[letter - 'a']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp5om99h_a.rs:19:39\n   |\n\
    19 |         encoded.push_str(vowels[vowel - 'a']);\n   |                    \
    \             ----- ^ --- char\n   |                                 |\n   | \
    \                                char\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == letters.last() {\n            letter_counter += 1;\n   \
    \     }\n        if vowels.contains(&letter) {\n            vowel_counter += 1;\n\
    \        }\n        if letter_counter == 2 && vowel_counter == 2 {\n         \
    \   encoded.push_str(&letters[vowel_counter]);\n            vowel_counter -= 1;\n\
    \            letter_counter -= 1;\n        } else {\n            encoded.push_str(&letters[letter_counter]);\n\
    \            letter_counter += 1;\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hbr19gc.rs:14:22\n   |\n\
    14 |         if letter == letters.last() {\n   |                      ^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3hbr19gc.rs:17:28\n   |\n17 |         if vowels.contains(&letter)\
    \ {\n   |                            ^^^^^^^ expected `&str`, found `char`\n \
    \  |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c) + 1)));\n \
    \       } else {\n            result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ - 1)));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpk4xythbc.rs:11:25\n\
    \   |\n11 |             result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ + 1)));\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpk4xythbc.rs:13:25\n   |\n13 |             result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c) - 1)));\n \
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nerror[E0599]: no method named `chars` found\
    \ for struct `ToLowercase` in the current scope\n  --> /tmp/tmpk4xythbc.rs:11:62\n\
    \   |\n11 |             result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ + 1)));\n   |                                                              ^^^^^\
    \ method not found in `ToLowercase`\n\nerror[E0599]: no method named `chars` found\
    \ for struct `ToLowercase` in the current scope\n  --> /tmp/tmpk4xythbc.rs:11:91\n\
    \   |\n11 |             result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ + 1)));\n   |                                                              \
    \                             ^^^^^ method not found in `ToLowercase`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `ToLowercase` in the current scope\n\
    \  --> /tmp/tmpk4xythbc.rs:13:62\n   |\n13 |             result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c) - 1)));\n \
    \  |                                                              ^^^^^ method\
    \ not found in `ToLowercase`\n\nerror[E0599]: no method named `chars` found for\
    \ struct `ToLowercase` in the current scope\n  --> /tmp/tmpk4xythbc.rs:13:91\n\
    \   |\n13 |             result.push((c.to_lowercase() + "
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message\
    \ {\n        if letter in vowels {\n            encoded.push_str(&letters[vowels.index(&letter)].to_string());\n\
    \        } else {\n            encoded.push_str(&letters[letters.iter().position(|x|\
    \ *x == letter).unwrap()].to_string());\n        }\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmptrvudmxg.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmptrvudmxg.rs:11:19\n\
    \    |\n11  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = vec![0];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels_index[vowels.iter().position(|&x| x ==\
    \ letter).unwrap()] {\n            encoded.push_str(&vowels[vowels_index[index\
    \ + 1]]);\n            vowels_index[index + 1] += 2;\n        } else {\n     \
    \       encoded.push_str(&vowels[vowels_index[0]]);\n            vowels_index[0]\
    \ += 2;\n        }\n        letter_counter[0] += 1;\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpoag_04wa.rs:13:73\n\
    \   |\n13 |         if let Some(index) = vowels_index[vowels.iter().position(|&x|\
    \ x == letter).unwrap()] {\n   |                                             \
    \                            ^^ no implementation for `&str == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoag_04wa.rs:13:16\n   |\n13 |         if let\
    \ Some(index) = vowels_index[vowels.iter().position(|&x| x == letter).unwrap()]\
    \ {\n   |                ^^^^^^^^^^^ expected integer, found enum `Option`\n \
    \  |\n   = note: expected type `{integer}`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    for letter\
    \ in message.chars() {\n        if let Some(index) = vowels.find(letter) {\n \
    \           encoded.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ } else {\n            encoded.push_str(&letters[letters.find(letter)!]);\n \
    \       }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `!`\n  -->\
    \ /tmp/tmpe3glz_l8.rs:16:59\n   |\n16 |             encoded.push_str(&letters[letters.find(letter)!]);\n\
    \   |                                                           ^ expected one\
    \ of `.`, `?`, `]`, or an operator\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpe3glz_l8.rs:14:31\n   |\n14 |             encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<usize>` for `str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n\
    \    let mut letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n\
    \    let mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n\
    \    let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\
    \ = 0;\n    let mut letter_counter_index36 = 0;\n    let mut letter_counter_index37\
    \ = 0;\n    let mut letter_counter_index38 = 0;\n    let mut letter_counter_index39\
    \ = 0;\n    let mut letter_counter_index40 = 0;\n    let mut letter_counter_index41\
    \ = 0;\n    let mut letter_counter_index42 = 0;\n    let mut letter_counter_index43\
    \ = 0;\n    let mut letter_counter_index44 = 0;\n    let mut letter_counter_index45\
    \ = 0;\n    let mut letter_counter_index46 = 0;\n    let mut letter_counter_index47\
    \ = 0;\n    let mut letter_counter_index48 = 0;\n    let mut letter_counter_index49\
    \ = 0;\n    let mut letter_counter_index50 = 0;\n    let mut letter_counter_index51\
    \ = 0;\n    let mut letter_counter_index52 = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpr7slw4tc.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index_2 = String::new();\n\
    \    let mut vowels_index_3 = String::new();\n    let mut vowels_index_4 = String::new();\n\
    \    let mut vowels_index_5 = String::new();\n    let mut vowels_index_6 = String::new();\n\
    \    let mut vowels_index_7 = String::new();\n    let mut vowels_index_8 = String::new();\n\
    \    let mut vowels_index_9 = String::new();\n    let mut vowels_index_10 = String::new();\n\
    \    let mut vowels_index_11 = String::new();\n    let mut vowels_index_12 = String::new();\n\
    \    let mut vowels_index_13 = String::new();\n    let mut vowels_index_14 = String::new();\n\
    \    let mut vowels_index_15 = String::new();\n    let mut vowels_index_16 = String::new();\n\
    \    let mut vowels_index_17 = String::new();\n    let mut vowels_index_18 = String::new();\n\
    \    let mut vowels_index_19 = String::new();\n    let mut vowels_index_20 = String::new();\n\
    \    let mut vowels_index_21 = String::new();\n    let mut vowels_index_22 = String::new();\n\
    \    let mut vowels_index_23 = String::new();\n    let mut vowels_index_24 = String::new();\n\
    \    let mut vowels_index_25 = String::new();\n    let mut vowels_index_26 = String::new();\n\
    \    let mut vowels_index_27 = String::new();\n    let mut vowels_index_28 = String::new();\n\
    \    let mut vowels_index_29 = String::new();\n    let mut vowels_index_30 = String::new();\n\
    \    let mut vowels_index_31 = String::new();\n    let mut vowels_index_32 = String::new();\n\
    \    let mut vowels_index_33 = String::new();\n    let mut vowels_index_34 = String::new();\n\
    \    let mut vowels_index_35 = String::new();\n    let mut vowels_index_36 = String::new();\n\
    \    let mut vowels_index_37 = String::new();\n    let mut vowels_index_38 = String::new();\n\
    \    let mut vowels_index_39 = String\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpno0tp9dv.rs:48:37\n   |\n\
    48 |     let mut vowels_index_39 = String\n   |                              \
    \       ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found struct `String`\n   --> /tmp/tmpno0tp9dv.rs:48:31\n  \
    \  |\n48  |       let mut vowels_index_39 = String\n    |                    \
    \             ^^^^^^ help: use struct literal syntax instead: `String { vec: val\
    \ }`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpno0tp9dv.rs:7:31\n  |\n7\
    \ | fn encode(message: String) -> String {\n  |    ------                    \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[vowel + 2]);\n        } else {\n      \
    \      encoded.push_str(&letters[letter]);\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpnq0bxhy1.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: the type `[&str]` cannot be indexed by `char`\n\
    \  --> /tmp/tmpnq0bxhy1.rs:15:31\n   |\n15 |             encoded.push_str(&letters[letter]);\n\
    \   |                               ^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<&str>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            encoded.push_str(\"_\");\n        } else {\n         \
    \   if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n        \
    \        encoded.push_str(&letters[vowel + index]);\n            } else {\n  \
    \              encoded.push_str(&letters[letter + index2]);\n            }\n \
    \       }\n        index += 1;\n        index2 += 1;\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpqz6c7u4l.rs:17:64\n\
    \   |\n17 |             if let Some(vowel) = vowels.iter().position(|&x| x ==\
    \ letter) {\n   |                                                            \
    \    ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n\nerror[E0369]: cannot add `{integer}` to `char`\n\
    \  --> /tmp/tmpqz6c7u4l.rs:20:50\n   |\n20 |                 encoded.push_str(&letters[letter\
    \ + index2]);\n   |                                           ------ ^ ------\
    \ {integer}\n   |                                           |\n   |          \
    \                                 char\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_pairs = vec!['AEIOU', 'AEIOU'];\n \
    \   let mut letter_pairs_iter = letter_pairs.iter();\n    let mut letter_pair\
    \ = letter_pairs_iter.next();\n    let mut letter_pair2 = letter_pairs_iter.next();\n\
    \    let mut letter_pair3 = letter_pairs_iter.next();\n    let mut letter_pair4\
    \ = letter_pairs_iter.next();\n    let mut letter_pair5 = letter_pairs_iter.next();\n\
    \    let mut letter_pair6 = letter_pairs_iter.next();\n    let mut letter_pair7\
    \ = letter_pairs_iter.next();\n    let mut letter_pair8 = letter_pairs_iter.next();\n\
    \    let mut letter_pair9 = letter_pairs_iter.next();\n    let mut letter_pair10\
    \ = letter_pairs_iter.next();\n    let mut letter_pair11 = letter_pairs_iter.next();\n\
    \    let mut letter_pair12 = letter_pairs_iter.next();\n    let mut letter_pair13\
    \ = letter_pairs_iter.next();\n    let mut letter_pair14 = letter_pairs_iter.next();\n\
    \    let mut letter_pair15 = letter_pairs_iter.next();\n    let mut letter_pair16\
    \ = letter_pairs_iter.next();\n    let mut letter_pair17 = letter_pairs_iter.next();\n\
    \    let mut letter_pair18 = letter_pairs_iter.next();\n    let mut letter_pair19\
    \ = letter_pairs_iter.next();\n    let mut letter_pair20 = letter_pairs_iter.next();\n\
    \    let mut letter_pair21 = letter_pairs_iter.next();\n    let mut letter_pair22\
    \ = letter_pairs_iter.next();\n    let mut letter_pair23 = letter_pairs_iter.next();\n\
    \    let mut letter_pair24 = letter_pairs_iter.next();\n    let mut letter_pair25\
    \ = letter_pairs_iter.next();\n    let mut letter_pair26 = letter_pairs_iter.next();\n\
    \    let mut letter_pair27 = letter_pairs_iter.next();\n    let mut letter_pair28\
    \ = letter_pairs_iter.next();\n    let mut letter_pair29 = letter_pairs_iter.next();\n\
    \    let mut letter_pair30 = letter_pairs_iter.next();\n    let mut letter_pair31\
    \ = letter_pairs_iter.next();\n    let mut letter_pair32 = letter_pairs_iter.next();\n\
    \    let mut letter_pair33 = letter_pairs_iter.next();\n    let mut letter_pair34\
    \ = letter_pairs_iter.next();\n    let mut letter_pair35 = letter_pairs_iter.next();\n\
    \    let mut letter_pair36 = letter_pairs_iter.next();\n\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpgjsr4e_h.rs:10:33\n\
    \   |\n10 |     let mut letter_pairs = vec!['AEIOU', 'AEIOU'];\n   |         \
    \                        ^^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n10 |     let mut letter_pairs = vec![\"AEIOU\", 'AEIOU'];\n\
    \   |                                 ~~~~~~~\n\nerror: character literal may\
    \ only contain one codepoint\n  --> /tmp/tmpgjsr4e_h.rs:10:42\n   |\n10 |    \
    \ let mut letter_pairs = vec!['AEIOU', 'AEIOU'];\n   |                       \
    \                   ^^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n10 |     let mut letter_pairs = vec!['AEIOU', \"AEIOU\"\
    ];\n   |                                          ~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpgjsr4e_h.rs:7:31\n  |\n7 | fn encode(message: String) ->\
    \ String {\n  |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"?\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_encoded\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters_encoded = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for\
    \ letter in message.chars() {\n        if letter == ' ' {\n            encoded.push_str(\"\
    _\");\n        } else {\n            encoded.push_str(letters_encoded.iter().position(|x|\
    \ x == letter).unwrap());\n        }\n    }\n    for vowel in vowels {\n     \
    \   if vowel == ' ' {\n            encoded.push_str(\"_\");\n        } else {\n\
    \            encoded.push_str(vowels_encoded.iter().position(|x| x == vowel).unwrap());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp8d4wn_8_.rs:17:68\n\
    \   |\n17 |             encoded.push_str(letters_encoded.iter().position(|x| x\
    \ == letter).unwrap());\n   |                                                \
    \                    ^^ no implementation for `&&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8d4wn_8_.rs:17:30\n   |\n17 |             encoded.push_str(letters_encoded.iter().position(|x|\
    \ x == letter).unwrap());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \  --> /tmp/tmp8d4wn_8_.rs:21:18\n   |\n21 |         if vowel == ' ' {\n   | \
    \                 ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n\nerror[E0277]: can't\
    \ compare `&str` with `str`\n  --> /tmp/tmp8d4wn_8_.rs:24:67\n   |\n24 |     \
    \        encoded.push_str(vowels_encoded.iter().position(|x| x == vowel).unwrap());\n\
    \   |                                                                   ^^ no\
    \ implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8d4wn_8_.rs:24:30\n   |\n24 |             encoded.push_str(vowels_encoded.iter().position(|x|\
    \ x == vowel).unwrap());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter in vowels {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n        } else {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n            result.push_str(&vowels[index\
    \ % vowels.len()]);\n            index += 1;\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp36j26s4_.rs:13:19\n\
    \   |\n13 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp36j26s4_.rs:12:19\n\
    \    |\n12  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_idx = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&vowels[vowels_idx[i++]]);\n         \
    \   result.push_str(&letters[letters_idx[i++]]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp37c8x8xk.rs:18:50\n\
    \   |\n18 |             result.push_str(&vowels[vowels_idx[i++]]);\n   |     \
    \                                             ^ expected expression\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\"_\");\n       \
    \ } else {\n            result.push_str(&letters[letters.iter().position(|x| x\
    \ == &letter).unwrap() + 2]);\n        }\n    }\n    for vowel in vowels {\n \
    \       result.push_str(&vowels[vowels.iter().position(|x| x == &vowel).unwrap()\
    \ + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmptnrx3f1f.rs:15:68\n\
    \   |\n15 |             result.push_str(&letters[letters.iter().position(|x| x\
    \ == &letter).unwrap() + 2]);\n   |                                          \
    \                          ^^ no implementation for `&str == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&str`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<&char>` for `&&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded1 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded2 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded3 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded4 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded5 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded6 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded7 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded8\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded9 = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded10 = vec![\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded11 = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded12 = vec![\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"];\n    let mut vowels_encoded13 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded14 = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"];\n    let mut vowels_encoded15 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded16 = vec![\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    let mut vowels_encoded17 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded18 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded19 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n   \
    \ let mut vowels_encoded20 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded21 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded22 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded23\
    \ = vec![\"a\", \"e\", \"\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpb8tmzx38.rs:42:109\n\
    \   |\n42 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    43 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747236
