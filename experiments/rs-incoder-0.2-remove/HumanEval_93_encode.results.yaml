language: rs
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message {\n        if letter in vowels\
    \ {\n            encoded.push_str(&letters[vowels.index(letter)].to_string());\n\
    \        } else {\n            encoded.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() + 1].to_string());\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp7dk80q0t.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp7dk80q0t.rs:11:19\n\
    \    |\n11  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n        } else {\n            encoded.push_str(&letter);\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp02mjv_d2.rs:11:28\n\
    \   |\n11 |         if vowels.contains(&letter) {\n   |                      \
    \      ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp02mjv_d2.rs:12:50\n\
    \   |\n12 |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n   |                                                  ^^^^^^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp02mjv_d2.rs:12:72\n   |\n\
    12 |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n   |                                                               \
    \         ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   =\
    \ help: the trait `Fn<(char,)>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&char`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp02mjv_d2.rs:12:81\n\
    \   |\n12 |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n   |                                                            --------------------\
    \ ^ - {integer}\n   |                                                        \
    \    |\n   |                                                            Option<usize>\n\
    \nerror[E02"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter == letters[index] {\n        \
    \    encoded.push_str(&vowels[index]);\n        } else {\n            encoded.push_str(&letters[index]);\n\
    \        }\n        index += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpsq8hfi7d.rs:12:19\n\
    \    |\n12  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'E', 'I', 'O', 'U'];\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ encoded.push_str(\"_\");\n        } else {\n            encoded.push_str(letters[letter\
    \ - 'a']);\n        }\n    }\n    for vowel in vowels {\n        encoded.push_str(vowels[vowel\
    \ - 'a']);\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp5om99h_a.rs:15:45\n\
    \   |\n15 |             encoded.push_str(letters[letter - 'a']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp5om99h_a.rs:19:39\n   |\n\
    19 |         encoded.push_str(vowels[vowel - 'a']);\n   |                    \
    \             ----- ^ --- char\n   |                                 |\n   | \
    \                                char\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == letters.last() {\n            letter_counter += 1;\n   \
    \     }\n        if vowels.contains(&letter) {\n            vowel_counter += 1;\n\
    \        }\n        if letter_counter == 2 && vowel_counter == 2 {\n         \
    \   encoded.push_str(&letters[vowel_counter]);\n            vowel_counter -= 1;\n\
    \            letter_counter -= 1;\n        } else {\n            encoded.push_str(&letters[letter_counter]);\n\
    \            letter_counter += 1;\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hbr19gc.rs:14:22\n   |\n\
    14 |         if letter == letters.last() {\n   |                      ^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3hbr19gc.rs:17:28\n   |\n17 |         if vowels.contains(&letter)\
    \ {\n   |                            ^^^^^^^ expected `&str`, found `char`\n \
    \  |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c) + 1)));\n \
    \       } else {\n            result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ - 1)));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpk4xythbc.rs:11:25\n\
    \   |\n11 |             result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ + 1)));\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmpk4xythbc.rs:13:25\n   |\n13 |             result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c) - 1)));\n \
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nerror[E0599]: no method named `chars` found\
    \ for struct `ToLowercase` in the current scope\n  --> /tmp/tmpk4xythbc.rs:11:62\n\
    \   |\n11 |             result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ + 1)));\n   |                                                              ^^^^^\
    \ method not found in `ToLowercase`\n\nerror[E0599]: no method named `chars` found\
    \ for struct `ToLowercase` in the current scope\n  --> /tmp/tmpk4xythbc.rs:11:91\n\
    \   |\n11 |             result.push((c.to_lowercase() + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c)\
    \ + 1)));\n   |                                                              \
    \                             ^^^^^ method not found in `ToLowercase`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `ToLowercase` in the current scope\n\
    \  --> /tmp/tmpk4xythbc.rs:13:62\n   |\n13 |             result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(c.to_lowercase().chars().index(c) - 1)));\n \
    \  |                                                              ^^^^^ method\
    \ not found in `ToLowercase`\n\nerror[E0599]: no method named `chars` found for\
    \ struct `ToLowercase` in the current scope\n  --> /tmp/tmpk4xythbc.rs:13:91\n\
    \   |\n13 |             result.push((c.to_lowercase() + "
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message\
    \ {\n        if letter in vowels {\n            encoded.push_str(&letters[vowels.index(&letter)].to_string());\n\
    \        } else {\n            encoded.push_str(&letters[letters.iter().position(|x|\
    \ *x == letter).unwrap()].to_string());\n        }\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmptrvudmxg.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmptrvudmxg.rs:11:19\n\
    \    |\n11  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = vec![0];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels_index[vowels.iter().position(|&x| x ==\
    \ letter).unwrap()] {\n            encoded.push_str(&vowels[vowels_index[index\
    \ + 1]]);\n            vowels_index[index + 1] += 2;\n        } else {\n     \
    \       encoded.push_str(&vowels[vowels_index[0]]);\n            vowels_index[0]\
    \ += 2;\n        }\n        letter_counter[0] += 1;\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpoag_04wa.rs:13:73\n\
    \   |\n13 |         if let Some(index) = vowels_index[vowels.iter().position(|&x|\
    \ x == letter).unwrap()] {\n   |                                             \
    \                            ^^ no implementation for `&str == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoag_04wa.rs:13:16\n   |\n13 |         if let\
    \ Some(index) = vowels_index[vowels.iter().position(|&x| x == letter).unwrap()]\
    \ {\n   |                ^^^^^^^^^^^ expected integer, found enum `Option`\n \
    \  |\n   = note: expected type `{integer}`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    for letter\
    \ in message.chars() {\n        if let Some(index) = vowels.find(letter) {\n \
    \           encoded.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ } else {\n            encoded.push_str(&letters[letters.find(letter)!]);\n \
    \       }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `!`\n  -->\
    \ /tmp/tmpe3glz_l8.rs:16:59\n   |\n16 |             encoded.push_str(&letters[letters.find(letter)!]);\n\
    \   |                                                           ^ expected one\
    \ of `.`, `?`, `]`, or an operator\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpe3glz_l8.rs:14:31\n   |\n14 |             encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<usize>` for `str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n\
    \    let mut letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n\
    \    let mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n\
    \    let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\
    \ = 0;\n    let mut letter_counter_index36 = 0;\n    let mut letter_counter_index37\
    \ = 0;\n    let mut letter_counter_index38 = 0;\n    let mut letter_counter_index39\
    \ = 0;\n    let mut letter_counter_index40 = 0;\n    let mut letter_counter_index41\
    \ = 0;\n    let mut letter_counter_index42 = 0;\n    let mut letter_counter_index43\
    \ = 0;\n    let mut letter_counter_index44 = 0;\n    let mut letter_counter_index45\
    \ = 0;\n    let mut letter_counter_index46 = 0;\n    let mut letter_counter_index47\
    \ = 0;\n    let mut letter_counter_index48 = 0;\n    let mut letter_counter_index49\
    \ = 0;\n    let mut letter_counter_index50 = 0;\n    let mut letter_counter_index51\
    \ = 0;\n    let mut letter_counter_index52 = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpr7slw4tc.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index_2 = String::new();\n\
    \    let mut vowels_index_3 = String::new();\n    let mut vowels_index_4 = String::new();\n\
    \    let mut vowels_index_5 = String::new();\n    let mut vowels_index_6 = String::new();\n\
    \    let mut vowels_index_7 = String::new();\n    let mut vowels_index_8 = String::new();\n\
    \    let mut vowels_index_9 = String::new();\n    let mut vowels_index_10 = String::new();\n\
    \    let mut vowels_index_11 = String::new();\n    let mut vowels_index_12 = String::new();\n\
    \    let mut vowels_index_13 = String::new();\n    let mut vowels_index_14 = String::new();\n\
    \    let mut vowels_index_15 = String::new();\n    let mut vowels_index_16 = String::new();\n\
    \    let mut vowels_index_17 = String::new();\n    let mut vowels_index_18 = String::new();\n\
    \    let mut vowels_index_19 = String::new();\n    let mut vowels_index_20 = String::new();\n\
    \    let mut vowels_index_21 = String::new();\n    let mut vowels_index_22 = String::new();\n\
    \    let mut vowels_index_23 = String::new();\n    let mut vowels_index_24 = String::new();\n\
    \    let mut vowels_index_25 = String::new();\n    let mut vowels_index_26 = String::new();\n\
    \    let mut vowels_index_27 = String::new();\n    let mut vowels_index_28 = String::new();\n\
    \    let mut vowels_index_29 = String::new();\n    let mut vowels_index_30 = String::new();\n\
    \    let mut vowels_index_31 = String::new();\n    let mut vowels_index_32 = String::new();\n\
    \    let mut vowels_index_33 = String::new();\n    let mut vowels_index_34 = String::new();\n\
    \    let mut vowels_index_35 = String::new();\n    let mut vowels_index_36 = String::new();\n\
    \    let mut vowels_index_37 = String::new();\n    let mut vowels_index_38 = String::new();\n\
    \    let mut vowels_index_39 = String\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpno0tp9dv.rs:48:37\n   |\n\
    48 |     let mut vowels_index_39 = String\n   |                              \
    \       ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found struct `String`\n   --> /tmp/tmpno0tp9dv.rs:48:31\n  \
    \  |\n48  |       let mut vowels_index_39 = String\n    |                    \
    \             ^^^^^^ help: use struct literal syntax instead: `String { vec: val\
    \ }`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpno0tp9dv.rs:7:31\n  |\n7\
    \ | fn encode(message: String) -> String {\n  |    ------                    \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[vowel + 2]);\n        } else {\n      \
    \      encoded.push_str(&letters[letter]);\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpnq0bxhy1.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: the type `[&str]` cannot be indexed by `char`\n\
    \  --> /tmp/tmpnq0bxhy1.rs:15:31\n   |\n15 |             encoded.push_str(&letters[letter]);\n\
    \   |                               ^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<&str>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            encoded.push_str(\"_\");\n        } else {\n         \
    \   if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n        \
    \        encoded.push_str(&letters[vowel + index]);\n            } else {\n  \
    \              encoded.push_str(&letters[letter + index2]);\n            }\n \
    \       }\n        index += 1;\n        index2 += 1;\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpqz6c7u4l.rs:17:64\n\
    \   |\n17 |             if let Some(vowel) = vowels.iter().position(|&x| x ==\
    \ letter) {\n   |                                                            \
    \    ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n\nerror[E0369]: cannot add `{integer}` to `char`\n\
    \  --> /tmp/tmpqz6c7u4l.rs:20:50\n   |\n20 |                 encoded.push_str(&letters[letter\
    \ + index2]);\n   |                                           ------ ^ ------\
    \ {integer}\n   |                                           |\n   |          \
    \                                 char\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_pairs = vec!['AEIOU', 'AEIOU'];\n \
    \   let mut letter_pairs_iter = letter_pairs.iter();\n    let mut letter_pair\
    \ = letter_pairs_iter.next();\n    let mut letter_pair2 = letter_pairs_iter.next();\n\
    \    let mut letter_pair3 = letter_pairs_iter.next();\n    let mut letter_pair4\
    \ = letter_pairs_iter.next();\n    let mut letter_pair5 = letter_pairs_iter.next();\n\
    \    let mut letter_pair6 = letter_pairs_iter.next();\n    let mut letter_pair7\
    \ = letter_pairs_iter.next();\n    let mut letter_pair8 = letter_pairs_iter.next();\n\
    \    let mut letter_pair9 = letter_pairs_iter.next();\n    let mut letter_pair10\
    \ = letter_pairs_iter.next();\n    let mut letter_pair11 = letter_pairs_iter.next();\n\
    \    let mut letter_pair12 = letter_pairs_iter.next();\n    let mut letter_pair13\
    \ = letter_pairs_iter.next();\n    let mut letter_pair14 = letter_pairs_iter.next();\n\
    \    let mut letter_pair15 = letter_pairs_iter.next();\n    let mut letter_pair16\
    \ = letter_pairs_iter.next();\n    let mut letter_pair17 = letter_pairs_iter.next();\n\
    \    let mut letter_pair18 = letter_pairs_iter.next();\n    let mut letter_pair19\
    \ = letter_pairs_iter.next();\n    let mut letter_pair20 = letter_pairs_iter.next();\n\
    \    let mut letter_pair21 = letter_pairs_iter.next();\n    let mut letter_pair22\
    \ = letter_pairs_iter.next();\n    let mut letter_pair23 = letter_pairs_iter.next();\n\
    \    let mut letter_pair24 = letter_pairs_iter.next();\n    let mut letter_pair25\
    \ = letter_pairs_iter.next();\n    let mut letter_pair26 = letter_pairs_iter.next();\n\
    \    let mut letter_pair27 = letter_pairs_iter.next();\n    let mut letter_pair28\
    \ = letter_pairs_iter.next();\n    let mut letter_pair29 = letter_pairs_iter.next();\n\
    \    let mut letter_pair30 = letter_pairs_iter.next();\n    let mut letter_pair31\
    \ = letter_pairs_iter.next();\n    let mut letter_pair32 = letter_pairs_iter.next();\n\
    \    let mut letter_pair33 = letter_pairs_iter.next();\n    let mut letter_pair34\
    \ = letter_pairs_iter.next();\n    let mut letter_pair35 = letter_pairs_iter.next();\n\
    \    let mut letter_pair36 = letter_pairs_iter.next();\n\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpgjsr4e_h.rs:10:33\n\
    \   |\n10 |     let mut letter_pairs = vec!['AEIOU', 'AEIOU'];\n   |         \
    \                        ^^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n10 |     let mut letter_pairs = vec![\"AEIOU\", 'AEIOU'];\n\
    \   |                                 ~~~~~~~\n\nerror: character literal may\
    \ only contain one codepoint\n  --> /tmp/tmpgjsr4e_h.rs:10:42\n   |\n10 |    \
    \ let mut letter_pairs = vec!['AEIOU', 'AEIOU'];\n   |                       \
    \                   ^^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n10 |     let mut letter_pairs = vec!['AEIOU', \"AEIOU\"\
    ];\n   |                                          ~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpgjsr4e_h.rs:7:31\n  |\n7 | fn encode(message: String) ->\
    \ String {\n  |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"?\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_encoded\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters_encoded = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for\
    \ letter in message.chars() {\n        if letter == ' ' {\n            encoded.push_str(\"\
    _\");\n        } else {\n            encoded.push_str(letters_encoded.iter().position(|x|\
    \ x == letter).unwrap());\n        }\n    }\n    for vowel in vowels {\n     \
    \   if vowel == ' ' {\n            encoded.push_str(\"_\");\n        } else {\n\
    \            encoded.push_str(vowels_encoded.iter().position(|x| x == vowel).unwrap());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp8d4wn_8_.rs:17:68\n\
    \   |\n17 |             encoded.push_str(letters_encoded.iter().position(|x| x\
    \ == letter).unwrap());\n   |                                                \
    \                    ^^ no implementation for `&&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8d4wn_8_.rs:17:30\n   |\n17 |             encoded.push_str(letters_encoded.iter().position(|x|\
    \ x == letter).unwrap());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \  --> /tmp/tmp8d4wn_8_.rs:21:18\n   |\n21 |         if vowel == ' ' {\n   | \
    \                 ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n\nerror[E0277]: can't\
    \ compare `&str` with `str`\n  --> /tmp/tmp8d4wn_8_.rs:24:67\n   |\n24 |     \
    \        encoded.push_str(vowels_encoded.iter().position(|x| x == vowel).unwrap());\n\
    \   |                                                                   ^^ no\
    \ implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8d4wn_8_.rs:24:30\n   |\n24 |             encoded.push_str(vowels_encoded.iter().position(|x|\
    \ x == vowel).unwrap());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter in vowels {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n        } else {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n            result.push_str(&vowels[index\
    \ % vowels.len()]);\n            index += 1;\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp36j26s4_.rs:13:19\n\
    \   |\n13 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp36j26s4_.rs:12:19\n\
    \    |\n12  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_idx\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_idx = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&vowels[vowels_idx[i++]]);\n         \
    \   result.push_str(&letters[letters_idx[i++]]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp37c8x8xk.rs:18:50\n\
    \   |\n18 |             result.push_str(&vowels[vowels_idx[i++]]);\n   |     \
    \                                             ^ expected expression\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\"_\");\n       \
    \ } else {\n            result.push_str(&letters[letters.iter().position(|x| x\
    \ == &letter).unwrap() + 2]);\n        }\n    }\n    for vowel in vowels {\n \
    \       result.push_str(&vowels[vowels.iter().position(|x| x == &vowel).unwrap()\
    \ + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmptnrx3f1f.rs:15:68\n\
    \   |\n15 |             result.push_str(&letters[letters.iter().position(|x| x\
    \ == &letter).unwrap() + 2]);\n   |                                          \
    \                          ^^ no implementation for `&str == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&str`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<&char>` for `&&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded1 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded2 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded3 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded4 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded5 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded6 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded7 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded8\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded9 = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded10 = vec![\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded11 = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded12 = vec![\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"];\n    let mut vowels_encoded13 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded14 = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"];\n    let mut vowels_encoded15 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded16 = vec![\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    let mut vowels_encoded17 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded18 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded19 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n   \
    \ let mut vowels_encoded20 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded21 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded22 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded23\
    \ = vec![\"a\", \"e\", \"\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpb8tmzx38.rs:42:109\n\
    \   |\n42 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    43 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut encoded = String::new();\n        let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n        let mut vowels_2 = vec!['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \        for vowel in vowels {\n            encoded.push_str(&vowels[vowels.iter().position(|x|\
    \ x == &vowel).unwrap()]);\n        }\n        for vowel in vowels_2 {\n     \
    \       encoded.push_str(&vowels[vowels.iter().position(|x| x == &vowel).unwrap()]);\n\
    \        }\n        encoded.push_str(&c);\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdk5_ilbo.rs:14:30\n   |\n\
    14 |             encoded.push_str(&vowels[vowels.iter().position(|x| x == &vowel).unwrap()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdk5_ilbo.rs:17:30\n   |\n17 |             encoded.push_str(&vowels[vowels.iter().position(|x|\
    \ x == &vowel).unwrap()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdk5_ilbo.rs:19:26\n   |\n19 |         encoded.push_str(&c);\n   |  \
    \                        ^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letter_counter = 0;\n    for letter in message {\n        if vowels.contains(&letter)\
    \ {\n            encoded.push_str(&vowels[letter_counter..letter_counter + 2]);\n\
    \            letter_counter += 2;\n        } else {\n            encoded.push_str(&letter);\n\
    \            letter_counter += 1;\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpszheh_rz.rs:11:19\n\
    \   |\n11 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpszheh_rz.rs:11:9\n   |\n11 |     for letter in message {\n   |     \
    \    ^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: all local variables must have\
    \ a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n   --> /tmp/tmpszheh_rz.rs:11:19\n    |\n11  |     for letter\
    \ in message {\n    |                   ^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Option`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpszheh_rz.rs:11:5\n    |\n11  |\
    \ /     for letter in message {\n12  | |         if vowels.contains(&letter) {\n\
    13  | |             encoded.push_str(&vowels[letter_counter..letter_counter +\
    \ 2]);\n14  | |             letter_counter += 2;\n...   |\n18  | |         }\n\
    19  | |     }\n    | |_____^ doesn't have a size known at compile-time\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `None`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut i = 0;\n \
    \   while i < message.len() {\n        let mut j = i;\n        while j < message.len()\
    \ {\n            if message[j] == vowels[i] {\n                encoded.push(letters[i\
    \ + (j - i)]);\n                i += 1;\n                j += 1;\n           \
    \ } else {\n                encoded.push(message[j]);\n                j += 1;\n\
    \            }\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0qg19tdw.rs:15:16\n\
    \   |\n15 |             if message[j] == vowels[i] {\n   |                ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0qg19tdw.rs:16:30\n\
    \   |\n16 |                 encoded.push(letters[i + (j - i)]);\n   |        \
    \                      ^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0qg19tdw.rs:20:30\n\
    \   |\n20 |                 encoded.push(message[j]);\n   |                  \
    \            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == c) {\n    \
    \        encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index\
    \ + 2) % vowels.len()]);\n            index += 2;\n        } else {\n        \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&c);\n\
    \            index += 1;\n        }\n    }\n    encoded\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpi7bwi9l7.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == c) {\n\
    \   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi7bwi9l7.rs:18:30\n   |\n18 |             encoded.push_str(&c);\n\
    \   |                              ^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph2srw6fj.rs:43:11\n   |\n\
    43 |     let mu\n   |           ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmph2srw6fj.rs:7:31\n  |\n\
    7 | fn encode(message: String) -> String {\n  |    ------                    \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push((c.to_lowercase()\
    \ + c.to_uppercase()).to_string());\n        } else {\n            result.push((c.to_lowercase()\
    \ + c.to_uppercase()).to_string());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `ToUppercase` to `ToLowercase`\n  --> /tmp/tmpx01i_hrp.rs:11:43\n\
    \   |\n11 |             result.push((c.to_lowercase() + c.to_uppercase()).to_string());\n\
    \   |                          ---------------- ^ ---------------- ToUppercase\n\
    \   |                          |\n   |                          ToLowercase\n\n\
    error[E0369]: cannot add `ToUppercase` to `ToLowercase`\n  --> /tmp/tmpx01i_hrp.rs:13:43\n\
    \   |\n13 |             result.push((c.to_lowercase() + c.to_uppercase()).to_string());\n\
    \   |                          ---------------- ^ ---------------- ToUppercase\n\
    \   |                          |\n   |                          ToLowercase\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message.chars()\
    \ {\n        let mut replacement = String::new();\n        for vowel in \"aeiou\"\
    .chars() {\n            if letter == vowel {\n                replacement += vowel;\n\
    \            } else {\n                replacement += vowel.swapcase();\n    \
    \        }\n        }\n        encoded += replacement;\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8lq5065.rs:13:32\n   |\n\
    13 |                 replacement += vowel;\n   |                             \
    \   ^^^^^ expected `&str`, found `char`\n\nerror[E0599]: no method named `swapcase`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpd8lq5065.rs:15:38\n\
    \   |\n15 |                 replacement += vowel.swapcase();\n   |           \
    \                           ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd8lq5065.rs:18:20\n   |\n18 |         encoded\
    \ += replacement;\n   |                    ^^^^^^^^^^^\n   |                 \
    \   |\n   |                    expected `&str`, found struct `String`\n   |  \
    \                  help: consider borrowing here: `&replacement`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for ch in message.chars()\
    \ {\n        match ch {\n            'a' .. 'z' => encoded.push_str(&format!(\"\
    {}{}\", ch.to_lowercase(), ch.to_uppercase())),\n            'A' .. 'Z' => encoded.push_str(&format!(\"\
    {}{}\", ch.to_lowercase(), ch.to_uppercase())),\n            _ => encoded.push_str(&format!(\"\
    {}{}\", ch.to_lowercase(), ch.to_lowercase())),\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp6pae5enm.rs:11:13\n\
    \   |\n11 |             'a' .. 'z' => encoded.push_str(&format!(\"{}{}\", ch.to_lowercase(),\
    \ ch.to_uppercase())),\n   |             ^^^^^^^^^^\n   |\n   = note: see issue\
    \ #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp6pae5enm.rs:12:13\n\
    \   |\n12 |             'A' .. 'Z' => encoded.push_str(&format!(\"{}{}\", ch.to_lowercase(),\
    \ ch.to_uppercase())),\n   |             ^^^^^^^^^^\n   |\n   = note: see issue\
    \ #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpub5kyx71.rs:11:29\n   |\n\
    11 |             result.push_str(&c.to_lowercase());\n   |                   \
    \          ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpub5kyx71.rs:13:29\n   |\n13 |\
    \             result.push_str(&c.to_uppercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"!\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_2 = \"AEIOUaeiou\";\n    let mut letter_2 = \"AEIOUaeiou\"\
    ;\n    let mut letter_1 = \"aeiouAEIOU\";\n    let mut letter_3 = \"AEIOUaeiou\"\
    ;\n    let mut letter_4 = \"aeiouAEIOU\";\n    let mut letter_5 = \"AEIOUaeiou\"\
    ;\n    let mut letter_6 = \"aeiouAEIOU\";\n    let mut letter_7 = \"AEIOUaeiou\"\
    ;\n    let mut letter_8 = \"aeiouAEIOU\";\n    let mut letter_9 = \"AEIOUaeiou\"\
    ;\n    let mut letter_10 = \"AEIOUaeiou\";\n    let mut letter_11 = \"aeiouAEIOU\"\
    ;\n    let mut letter_12 = \"AEIOUaeiou\";\n    let mut letter_13 = \"aeiouAEIOU\"\
    ;\n    let mut letter_14 = \"AEIOUaeiou\";\n    let mut letter_15 = \"AEIOUaeiou\"\
    ;\n    let mut letter_16 = \"aeiouAEIOU\";\n    let mut letter_17 = \"AEIOUaeiou\"\
    ;\n    let mut letter_18 = \"aeiouAEIOU\";\n    let mut letter_19 = \"AEIOUaeiou\"\
    ;\n    let mut letter_20 = \"aeiouAEIOU\";\n    let mut letter_21 = \"AEIOUaeiou\"\
    ;\n    let mut letter_22 = \"aeiouAEIOU\";\n    let mut letter_23 = \"AEIOUaeiou\"\
    ;\n    let mut letter_24 = \"aeiouAEIOU\";\n    let mut letter_25 = \"AEIOUaeiou\"\
    ;\n    let mut letter_26 = \"aeiouAEIOU\";\n    let mut letter_27 = \"AEIOUaeiou\"\
    ;\n    let mut letter_28 = \"aeiouAEIOU\";\n    let mut letter_29 = \"AEIOUaeiou\"\
    ;\n    let mut letter_30 = \"AEIOUaeiou\";\n    let mut letter_31 = \"aeiouAEIOU\"\
    ;\n    let mut letter_32 = \"AEIOUaeiou\";\n    let mut letter_33 = \"aeiouAEIOU\"\
    ;\n    let mut letter_34 = \"aeiouAEIOU\";\n    let mut letter_35 = \"AEIOUaeiou\"\
    ;\n    let mut letter_36 = \"aeiouAEIOU\";\n    let mut letter_37 = \"\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpg83yp5_f.rs:56:109\n\
    \   |\n56 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    57 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[vowel + 1]);\n        } else {\n      \
    \      encoded.push_str(&letters[vowel]);\n        }\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmptkgizp16.rs:15:39\n\
    \   |\n15 |             encoded.push_str(&letters[vowel]);\n   |             \
    \                          ^^^^^ help: a local variable with a similar name exists:\
    \ `vowels`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmptkgizp16.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|x| x == letter) {\n\
    \            result.push_str(&letters[vowel + 2]);\n        } else {\n       \
    \     result.push_str(&letters[letter]);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp0j9e__9k.rs:12:59\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp0j9e__9k.rs:15:30\n   |\n\
    15 |             result.push_str(&letters[letter]);\n   |                    \
    \          ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[letters.iter().position(|&x|\
    \ x == letter).unwrap() + 2]);\n        }\n    }\n    for vowel in vowels {\n\
    \        result.push_str(&vowels[vowels.iter().position(|&x| x == vowel).unwrap()\
    \ + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpzl4pndfn.rs:15:69\n\
    \   |\n15 |             result.push_str(&letters[letters.iter().position(|&x|\
    \ x == letter).unwrap() + 2]);\n   |                                         \
    \                            ^^ no implementation for `&str == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_counts = vec![];\n    let mut letter_counts_index\
    \ = 0;\n    let mut letter_count_index = 0;\n    let mut letter_count_index2 =\
    \ 0;\n    let mut letter_count_index3 = 0;\n    let mut letter_count_index4 =\
    \ 0;\n    let mut letter_count_index5 = 0;\n    let mut letter_count_index6 =\
    \ 0;\n    let mut letter_count_index7 = 0;\n    let mut letter_count_index8 =\
    \ 0;\n    let mut letter_count_index9 = 0;\n    let mut letter_count_index10 =\
    \ 0;\n    let mut letter_count_index11 = 0;\n    let mut letter_count_index12\
    \ = 0;\n    let mut letter_count_index13 = 0;\n    let mut letter_count_index14\
    \ = 0;\n    let mut letter_count_index15 = 0;\n    let mut letter_count_index16\
    \ = 0;\n    let mut letter_count_index17 = 0;\n    let mut letter_count_index18\
    \ = 0;\n    let mut letter_count_index19 = 0;\n    let mut letter_count_index20\
    \ = 0;\n    let mut letter_count_index21 = 0;\n    let mut letter_count_index22\
    \ = 0;\n    let mut letter_count_index23 = 0;\n    let mut letter_count_index24\
    \ = 0;\n    let mut letter_count_index25 = 0;\n    let mut letter_count_index26\
    \ = 0;\n    let mut letter_count_index27 = 0;\n    let mut letter_count_index28\
    \ = 0;\n    let mut letter_count_index29 = 0;\n    let mut letter_count_index30\
    \ = 0;\n    let mut letter_count_index31 = 0;\n    let mut letter_count_index32\
    \ = 0;\n    let mut letter_count_index33 = 0;\n    let mut letter_count_index34\
    \ = 0;\n    let mut letter_count_index35 = 0;\n    let mut letter_count_index36\
    \ = 0;\n    let mut letter_count_index37 = 0;\n    let mut letter_count_index38\
    \ = 0;\n    let mut letter_count_index39 = 0;\n    let mut letter_count_index40\
    \ = 0;\n    let mut letter_count_index41 = 0;\n    let mut letter_count_index42\
    \ = 0;\n    let mut letter_count_index43 = 0;\n    let mut letter_count_index44\
    \ = 0;\n    let mut letter_count_index45 = 0;\n    let mut letter_count_index46\
    \ = 0;\n    let mut letter_count_index47 = 0;\n    let mut letter_count_index48\
    \ = 0;\n    let mut letter_count_index49 = 0;\n    let mut letter_count_index50\
    \ = 0;\n    let mut letter_count_index51 = 0;\n    let mut letter_count_index52\
    \ = 0;\n    let mut letter_\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdnw_ysh_.rs:64:20\n   |\n\
    64 |     let mut letter_\n   |                    ^ help: add `;` here\n65 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdnw_ysh_.rs:7:31\n\
    \  |\n7 | fn encode(message: String) -> String {\n  |    ------              \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.find(letter) {\n            encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            encoded.push_str(&letters[letters.find(letter)!]);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `!`\n  -->\
    \ /tmp/tmp09pd5j8m.rs:15:59\n   |\n15 |             encoded.push_str(&letters[letters.find(letter)!]);\n\
    \   |                                                           ^ expected one\
    \ of `.`, `?`, `]`, or an operator\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp09pd5j8m.rs:13:31\n   |\n13 |             encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut encoded = encoded.clone();\n        if c.is_uppercase() {\n\
    \            encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_lowercase());\n\
    \        } else {\n            encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_uppercase());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2nzov9pk.rs:12:53\n   |\n\
    12 |             encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_lowercase());\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2nzov9pk.rs:14:53\n\
    \   |\n14 |             encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_uppercase());\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        encoded.push_str(&encode(c.to_lowercase()));\n    }\n    return encoded;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuclr7mmd.rs:10:34\n   |\n\
    10 |         encoded.push_str(&encode(c.to_lowercase()));\n   |              \
    \                    ^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |\n   |                               \
    \   expected struct `String`, found struct `ToLowercase`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter in vowels {\n            encoded.push_str(&letters[vowels.index(letter)].to_string());\n\
    \        } else {\n            encoded.push_str(&letters[letters.index(letter)].to_string());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpba82zm1n.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_map\
    \ = HashMap::new();\n    let mut letter_map = HashMap::new();\n    for letter\
    \ in message {\n        if let Some(vowel) = vowels.iter().position(|&x| x ==\
    \ letter) {\n            vowel_map.insert(vowel, letter);\n        }\n       \
    \ if let Some(letter) = letters.iter().position(|&x| x == letter) {\n        \
    \    letter_map.insert(letter, letter);\n        }\n    }\n    for vowel in vowels\
    \ {\n        result.push_str(vowel_map.get(&vowel).unwrap());\n    }\n    for\
    \ letter in letters {\n        result.push_str(letter_map.get(&letter).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphaj04ioy.rs:11:25\n   |\n11 |     let mut vowel_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmphaj04ioy.rs:12:26\n\
    \   |\n12 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]: `String` is\
    \ not an iterator\n  --> /tmp/tmphaj04ioy.rs:13:19\n   |\n13 |     for letter\
    \ in message {\n   |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|x| x == letter) {\n\
    \            encoded.push_str(&letters[vowel + 2]);\n        } else {\n      \
    \      encoded.push_str(&letters[letter]);\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmpb5cj55ko.rs:12:59\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `char`\n  --> /tmp/tmpb5cj55ko.rs:15:31\n   |\n\
    15 |             encoded.push_str(&letters[letter]);\n   |                   \
    \            ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3d902a2d.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3d902a2d.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3d902a2d.rs:19:30\n   |\n19 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3d902a2d.rs:21:30\n   |\n21 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|vowel|\
    \ vowel == letter) {\n            vowels_map.insert(vowel, letter);\n        }\n\
    \    }\n    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|vowel|\
    \ vowel == letter) {\n            encoded.push_str(vowels_map.get(&vowel).unwrap());\n\
    \        } else {\n            encoded.push_str(letter);\n        }\n    }\n \
    \   encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmprrarbrn5.rs:10:26\n   |\n10 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ can't compare `&&str` with `char`\n  --> /tmp/tmprrarbrn5.rs:12:67\n   |\n12\
    \ |         if let Some(vowel) = vowels.iter().position(|vowel| vowel == letter)\
    \ {\n   |                                                                   ^^\
    \ no implementation for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&&str` with `char`\n \
    \ --> /tmp/tmprrarbrn5.rs:17:67\n   |\n17 |         if let Some(vowel) = vowels.iter().position(|vowel|\
    \ vowel == letter) {\n   |                                                   \
    \                ^^ no implementation for `&&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprrarbrn5.rs:20:30\n\
    \   |\n20 |             encoded.push_str(letter);\n   |                     "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowels_2 = \"AEIOUaeiou\".to_string();\n    for c in\
    \ message.chars() {\n        if c.is_uppercase() {\n            encoded.push_str(vowels.chars().next().unwrap());\n\
    \        } else {\n            encoded.push_str(vowels_2.chars().next().unwrap());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3owp6avp.rs:13:30\n   |\n\
    13 |             encoded.push_str(vowels.chars().next().unwrap());\n   |     \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3owp6avp.rs:15:30\n\
    \   |\n15 |             encoded.push_str(vowels_2.chars().next().unwrap());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    for letter\
    \ in message.chars() {\n        if let Some(index) = vowels.find(letter) {\n \
    \           encoded.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ } else {\n            encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpn3lwyyj9.rs:14:31\n\
    \   |\n14 |             encoded.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpn3lwyyj9.rs:16:31\n   |\n16 |             encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut index = 0;\n    \n    for ch in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == ch) {\n   \
    \         encoded.push_str(&vowels[vowel + 2]);\n        } else {\n          \
    \  encoded.push_str(&ch);\n        }\n    }\n    \n    return encoded;\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9od9_8b4.rs:14:30\n   |\n\
    14 |             encoded.push_str(&vowels[vowel + 2]);\n   |                 \
    \             ^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9od9_8b4.rs:16:30\n   |\n16 |             encoded.push_str(&ch);\n\
    \   |                              ^^^ expected `str`, found `char`\n   |\n  \
    \ = note: expected reference `&str`\n              found reference `&char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter in vowels {\n            vowel_counter++;\n        }\n        if letter\
    \ in letters {\n            letter_counter++;\n        }\n    }\n    for letter\
    \ in message {\n        if letter in vowels {\n            if letter_counter ==\
    \ 2 {\n                result.push_str(&vowels[vowel_counter - 2]);\n        \
    \        vowel_counter -= 2;\n            } else {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter++;\n            }\n        } else {\n         \
    \   if letter_counter == 2 {\n                result.push_str(&letters[letter_counter\
    \ - 2]);\n                letter_counter -= 2;\n            } else {\n       \
    \         result.push_str(&letters[letter_counter]);\n                letter_counter++;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmplyv3z3te.rs:14:19\n\
    \   |\n14 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmplyv3z3te.rs:22:19\n\
    \   |\n22 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmplyv3z3te.rs:13:19\n\
    \   |\n13 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmplyv3z3te.rs:21:19\n   |\n21 |   \
    \  for letter in message {\n   |                   ^^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    for c in message.chars() {\n        if vowels.contains(&c.to_string())\
    \ {\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n    \
    \        encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n            encoded.push_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjwbp9n_3.rs:49:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n11 |     for c in message.chars()\
    \ {\n   |                              - unclosed delimiter\n12 |         if vowels.contains(&c.to_string())\
    \ {\n   |                                            - this delimiter might not\
    \ be properly closed...\n...\n40 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n49 | }\n   |   ^\n\nerror[E0277]: the type `str`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpjwbp9n_3.rs:13:31\n   |\n13 |  \
    \           encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n   |     \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpjwbp9n_3.rs:14:31\n   |\n14 |             encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpjwbp9n_3.rs:15:31\n   |\n15 |             encoded.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E02"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'E', 'I', 'O', 'U'];\n\
    \    for letter in message.chars() {\n        if let Some(index) = vowels.iter().position(|x|\
    \ x == letter) {\n            encoded.push_str(&letters[index % letters.len()]);\n\
    \        } else {\n            encoded.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() % letters.len()]);\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefj2ralc.rs:12:59\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpefj2ralc.rs:13:30\n   |\n13 |  \
    \           encoded.push_str(&letters[index % letters.len()]);\n   |         \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefj2ralc.rs:15:69\n\
    \   |\n15 |             encoded.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() % letters.len()]);\n   |                             \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpefj2ralc.rs:15:30\n   |\n15 |             encoded.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() % letters.len()]);\n   |                             \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_position = message.len();\n\
    \    while letter_position > 0 {\n        let mut letter_position = letter_position\
    \ - 1;\n        let mut letter_encoded = String::new();\n        while letter_position\
    \ > 0 {\n            let mut letter_position = letter_position - 1;\n        \
    \    let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new();\n    \
    \        let mut letter_encoded = String::new();\n            let mut letter_encoded\
    \ = String::new();\n            let mut letter_encoded = String::new\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpa7__n_0g.rs:65:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     while letter_position >\
    \ 0 {\n   |                               - unclosed delimiter\n...\n15 |    \
    \     while letter_position > 0 {\n   |                                   - this\
    \ delimiter might not be properly closed...\n...\n56 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n65 | }\n   |   ^\n\nerror: expected\
    \ `;`, found `}`\n  --> /tmp/tmpa7__n_0g.rs:55:49\n   |\n55 |             let\
    \ mut letter_encoded = String::new\n   |                                     \
    \            ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa7__n_0g.rs:12:5\n   |\n7  |   fn encode(message:\
    \ String) -> String {\n   |                                 ------ expected `String`\
    \ because of return type\n...\n12 | /     while letter_position > 0 {\n13 | |\
    \         let mut letter_position = letter_position - 1;\n14 | |         let mut\
    \ letter_encoded = String::new();\n15 | |         while letter_position > 0 {\n\
    ...  |\n64 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n65 | | }\n   | |__^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    \n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.find(|c| c == letter) {\n           \
    \ encoded.push_str(&vowels[vowels_index..index]);\n            vowels_index =\
    \ index;\n        }\n        encoded.push_str(&letter);\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6z9wvbwe.rs:17:26\n   |\n\
    17 |         encoded.push_str(&letter);\n   |                          ^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letter_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if let Some(index) = vowels.iter().position(|&x|\
    \ x == letter) {\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            encoded.push_str(&letter);\n        }\n    }\n\
    \    for letter in encoded.chars() {\n        if let Some(index) = vowels.iter().position(|&x|\
    \ x == letter) {\n            letter_map.insert(letter, vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            letter_map.insert(letter, letter);\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpqoaqbxbc.rs:10:26\n   |\n10 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpqoaqbxbc.rs:12:60\n   |\n12\
    \ |         if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqoaqbxbc.rs:15:30\n   |\n15 |             encoded.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpqoaqbxbc.rs:19:60\n\
    \   |\n19 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n            "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    \n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            encoded.push_str(\"_\");\n      \
    \  } else {\n            encoded.push_str(&letters[letter - 'A']);\n        }\n\
    \    }\n    \n    for vowel in vowels {\n        encoded.push_str(&letters[vowel\
    \ - 'A']);\n    }\n    \n    for letter in letters.iter().rev() {\n        encoded.push_str(&letters[letter\
    \ - 'A']);\n    }\n    \n    return encoded;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp400rhh3u.rs:17:46\n\
    \   |\n17 |             encoded.push_str(&letters[letter - 'A']);\n   |      \
    \                                 ------ ^ --- char\n   |                    \
    \                   |\n   |                                       char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp400rhh3u.rs:22:41\n   |\n\
    22 |         encoded.push_str(&letters[vowel - 'A']);\n   |                  \
    \                 ----- ^ --- char\n   |                                   |\n\
    \   |                                   char\n\nerror[E0369]: cannot subtract\
    \ `char` from `&char`\n  --> /tmp/tmp400rhh3u.rs:26:42\n   |\n26 |         encoded.push_str(&letters[letter\
    \ - 'A']);\n   |                                   ------ ^ --- char\n   |   \
    \                                |\n   |                                   &char\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph2srw6fj.rs:43:11\n   |\n\
    43 |     let mu\n   |           ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmph2srw6fj.rs:7:31\n  |\n\
    7 | fn encode(message: String) -> String {\n  |    ------                    \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_2 = \"AEIOU\";\n    let mut vowels_3 = \"AEIOUaeiou\";\n\
    \    let mut vowels_4 = \"AEIOUaeiouAEIOU\";\n    let mut vowels_5 = \"AEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_6 = \"AEIOUaeiouAEIOUaeiouAEIOU\";\n    let mut vowels_7\
    \ = \"AEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    let mut vowels_8 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_9 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    let\
    \ mut vowels_10 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    let\
    \ mut vowels_11 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n  \
    \  let mut vowels_12 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_13 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_14 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_15 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_16 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_17 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk1vgjj5h.rs:26:20\n   |\n\
    26 |     let mut vowels_\n   |                    ^ help: add `;` here\n27 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk1vgjj5h.rs:7:31\n\
    \  |\n7 | fn encode(message: String) -> String {\n  |    ------              \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\"_\");\n       \
    \ } else {\n            result.push_str(&letters[letters.iter().position(|x| x\
    \ == letter).unwrap() + 2]);\n        }\n    }\n    for vowel in vowels {\n  \
    \      result.push_str(&vowels[vowels.iter().position(|x| x == vowel).unwrap()\
    \ + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp3sqr0e83.rs:15:68\n\
    \   |\n15 |             result.push_str(&letters[letters.iter().position(|x| x\
    \ == letter).unwrap() + 2]);\n   |                                           \
    \                         ^^ no implementation for `&&str == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&&str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `str`\n  --> /tmp/tmp3sqr0e83.rs:19:62\n   |\n19 |         result.push_str(&vowels[vowels.iter().position(|x|\
    \ x == vowel).unwrap() + 1]);\n   |                                          \
    \                    ^^ no implementation for `&str == str`\n   |\n   = help:\
    \ the trait `PartialEq<str>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  let index = letters.iter().position(|&x| x == letter).unwrap();\n         \
    \   result.push_str(&vowels[(index + 1) % vowels.len()]);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkr825nvt.rs:16:29\n   |\n\
    16 |             result.push_str(&vowels[(index + 1) % vowels.len()]);\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    for c in result.chars() {\n        if c.is_lowercase() {\n       \
    \     result.push_str(&c.to_uppercase());\n        } else {\n            result.push_str(&c.to_lowercase());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2a9dz2sn.rs:11:29\n   |\n\
    11 |             result.push_str(&c.to_lowercase());\n   |                   \
    \          ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2a9dz2sn.rs:13:29\n   |\n13 |\
    \             result.push_str(&c.to_uppercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2a9dz2sn.rs:18:29\n   |\n18 |\
    \             result.push_str(&c.to_uppercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2a9dz2sn.rs:20:29\n   |\n20 |\
    \             result.push_str(&c.to_lowercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|vowel|\
    \ vowel == letter) {\n            vowels_map.insert(vowel, letter);\n        }\n\
    \    }\n    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|vowel|\
    \ vowel == letter) {\n            encoded.push_str(vowels_map.get(vowel).unwrap());\n\
    \        } else {\n            encoded.push_str(letter);\n        }\n    }\n \
    \   encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6hnjyjak.rs:10:26\n   |\n10 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ can't compare `&&str` with `char`\n  --> /tmp/tmp6hnjyjak.rs:12:67\n   |\n12\
    \ |         if let Some(vowel) = vowels.iter().position(|vowel| vowel == letter)\
    \ {\n   |                                                                   ^^\
    \ no implementation for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&&str` with `char`\n \
    \ --> /tmp/tmp6hnjyjak.rs:17:67\n   |\n17 |         if let Some(vowel) = vowels.iter().position(|vowel|\
    \ vowel == letter) {\n   |                                                   \
    \                ^^ no implementation for `&&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6hnjyjak.rs:20:30\n\
    \   |\n20 |             encoded.push_str(letter);\n   |                     "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[index % letters.len()]);\n        } else\
    \ {\n            encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpz8ok294m.rs:12:60\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpz8ok294m.rs:15:70\n   |\n15 |            \
    \ encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n   |                                                               \
    \       ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_counter = 0;\n\
    \    for letter in message {\n        if letter == vowels[vowels_index] {\n  \
    \          vowels_index += 2;\n        } else {\n            encoded.push_str(&vowels[vowels_index]);\n\
    \            vowels_index += 1;\n        }\n        letter_counter += 1;\n   \
    \     if letter_counter == 2 {\n            encoded.push_str(&vowels[vowels_index]);\n\
    \            vowels_index += 1;\n            letter_counter = 0;\n        }\n\
    \    }\n    encoded.push_str(&vowels[vowels_index]);\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp0tjh6o3s.rs:12:19\n\
    \   |\n12 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp0tjh6o3s.rs:13:22\n\
    \   |\n13 |         if letter == vowels[vowels_index] {\n   |                \
    \      ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmp0tjh6o3s.rs:16:31\n \
    \  |\n16 |             encoded.push_str(&vowels[vowels_index]);\n   |        \
    \                       ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp0tjh6o3s.rs:21:31\n\
    \   |\n21 |             encoded.push_str(&vowels[vowels_index]);\n   |       \
    \                        ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp0tjh6o3s.rs:26:23\n\
    \   |\n26 |     encoded.push_str(&vowels[vowels_index]);\n   |               \
    \        ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter in vowels {\n            encoded.push_str(&letters[index\
    \ % letters.len()]);\n            index /= letters.len();\n        } else {\n\
    \            encoded.push_str(&letters[index % letters.len()]);\n            index\
    \ /= letters.len();\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            index /= vowels.len();\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpwd69ebwk.rs:13:19\n\
    \   |\n13 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpwd69ebwk.rs:12:19\n\
    \   |\n12 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph2srw6fj.rs:43:11\n   |\n\
    43 |     let mu\n   |           ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmph2srw6fj.rs:7:31\n  |\n\
    7 | fn encode(message: String) -> String {\n  |    ------                    \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            encoded.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n        } else {\n            encoded.push_str(&letter);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7opktjqw.rs:12:28\n   |\n\
    12 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0277]: can't compare `&&str`\
    \ with `char`\n  --> /tmp/tmp7opktjqw.rs:13:80\n   |\n13 |             encoded.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n   |                                \
    \                                                ^^ no implementation for `&&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7opktjqw.rs:15:30\n   |\n15 |             encoded.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counts = vec![];\n    let mut letter_counts_index =\
    \ vec![];\n    let mut letter_counts_index2 = vec![];\n    let mut letter_counts_index3\
    \ = vec![];\n    let mut letter_counts_index4 = vec![];\n    let mut letter_counts_index5\
    \ = vec![];\n    let mut letter_counts_index6 = vec![];\n    let mut letter_counts_index7\
    \ = vec![];\n    let mut letter_counts_index8 = vec![];\n    let mut letter_counts_index9\
    \ = vec![];\n    let mut letter_counts_index10 = vec![];\n    let mut letter_counts_index11\
    \ = vec![];\n    let mut letter_counts_index12 = vec![];\n    let mut letter_counts_index13\
    \ = vec![];\n    let mut letter_counts_index14 = vec![];\n    let mut letter_counts_index15\
    \ = vec![];\n    let mut letter_counts_index16 = vec![];\n    let mut letter_counts_index17\
    \ = vec![];\n    let mut letter_counts_index18 = vec![];\n    let mut letter_counts_index19\
    \ = vec![];\n    let mut letter_counts_index20 = vec![];\n    let mut letter_counts_index21\
    \ = vec![];\n    let mut letter_counts_index22 = vec![];\n    let mut letter_counts_index23\
    \ = vec![];\n    let mut letter_counts_index24 = vec![];\n    let mut letter_counts_index25\
    \ = vec![];\n    let mut letter_counts_index26 = vec![];\n    let mut letter_counts_index27\
    \ = vec![];\n    let mut letter_counts_index28 = vec![];\n    let mut letter_counts_index29\
    \ = vec![];\n    let mut letter_counts_index30 = vec![];\n    let mut letter_counts_index31\
    \ = vec![];\n    let mut letter_counts_index32 = vec![];\n    let mut letter_counts_index33\
    \ = vec![];\n    let mut letter_counts_index34 = vec![];\n    let mut letter_counts_index35\
    \ = vec![];\n    let mut letter_counts_index36 = vec![];\n    let mut letter_counts_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6ty3cgz2.rs:48:27\n   |\n\
    48 |     let mut letter_counts_\n   |                           ^ help: add `;`\
    \ here\n49 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp6ty3cgz2.rs:7:31\n  |\n7 | fn encode(message: String) -> String {\n\
    \  |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_2 = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_3 =\
    \ vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \    let mut vowels_4 = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\",\
    \ \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"];\n    let mut vowels_5 = vec![\"b\", \"c\", \"d\", \"f\"\
    , \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_6 = vec![\"b\"\
    , \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut\
    \ vowels_7 = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"];\n    let mut vowels_8 = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_9 = vec![\"b\", \"c\", \"d\"\
    , \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_10 = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let\
    \ mut vowels_11 = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"];\n    let mut vowels_12 = vec![\"b\", \"c\", \"d\", \"f\", \"\
    g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp13cjbllu.rs:7:31\n  |\n7 |\
    \ fn encode(message: String) -> String {\n  |    ------                     ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpyx83hy5p.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpub5kyx71.rs:11:29\n   |\n\
    11 |             result.push_str(&c.to_lowercase());\n   |                   \
    \          ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpub5kyx71.rs:13:29\n   |\n13 |\
    \             result.push_str(&c.to_uppercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            encoded.push_str(\" \");\n        } else {\n         \
    \   encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            encoded.push_str(&vowels[index % vowels.len()]);\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjh6rgnch.rs:53:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n11 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n14 |  \
    \       } else {\n   |                - this delimiter might not be properly closed...\n\
    ...\n44 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    53 | }\n   |   ^\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjh6rgnch.rs:15:31\n   |\n15 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpjh6rgnch.rs:16:31\n   |\n16 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpjh6rgnch.rs:17:31\n   |\n17 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpjh6rgnch.rs:18:"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut index = 0;\n    for letter in message\
    \ {\n        if letter in vowels {\n            result.push_str(&vowels[index]);\n\
    \            vowels_index[index] += 1;\n        } else {\n            result.push_str(&letters[index]);\n\
    \            letters_index[index] += 1;\n        }\n        index += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpec3k_zmt.rs:15:19\n\
    \   |\n15 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpec3k_zmt.rs:14:19\n\
    \   |\n14 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"!\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    for letter\
    \ in message.chars() {\n        if let Some(index) = vowels.find(letter) {\n \
    \           encoded.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ } else {\n            encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n        }\n    }\n    \n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpk650whx6.rs:14:31\n\
    \   |\n14 |             encoded.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpk650whx6.rs:16:31\n   |\n16 |             encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_counter = 0;\n    for letter in message.chars()\
    \ {\n        if vowels.contains(&letter) {\n            vowels_counter += 1;\n\
    \        }\n    }\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            encoded.push_str(&vowels[vowels_counter]);\n        } else {\n\
    \            encoded.push_str(&letter);\n        }\n    }\n    return encoded;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzmzcfr2k.rs:18:30\n   |\n\
    18 |             encoded.push_str(&vowels[vowels_counter]);\n   |            \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzmzcfr2k.rs:20:30\n   |\n20 |\
    \             encoded.push_str(&letter);\n   |                              ^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[vowel + 2]);\n        } else {\n      \
    \      encoded.push_str(&letters[letter]);\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpnq0bxhy1.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: the type `[&str]` cannot be indexed by `char`\n\
    \  --> /tmp/tmpnq0bxhy1.rs:15:31\n   |\n15 |             encoded.push_str(&letters[letter]);\n\
    \   |                               ^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<&str>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowels_2 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_3 = \"AEIOUaeiou\".to_string();\n    let mut vowels_4 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_5 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_6 = \"AEIOUaeiou\".to_string();\n    let mut vowels_7 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_8 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_9 = \"AEIOUaeiou\".to_string();\n    let mut vowels_10 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_11 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_12 = \"AEIOUaeiou\".to_string();\n    let mut vowels_13 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_14 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_15 = \"AEIOUaeiou\".to_string();\n    let mut vowels_16 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_17 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_18 = \"AEIOUaeiou\".to_string();\n    let mut vowels_19 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_20 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_21 = \"AEIOUaeiou\".to_string();\n    let mut vowels_22 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_23 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_24 = \"AEIOUaeiou\".to_string();\n    let mut vowels_25 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_26 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_27 = \"AEIOUaeiou\".to_string();\n    let mut vowels_28 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_29 = \"AEIOUaeiou\".to_string();\n    let mut\
    \ vowels_30 = \"AEIOUaeiou\".to_string();\n    let mut vowels_31 = \"AEIOUaeiou\"\
    .to_string();\n    let mut vowels_32\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjrplqc2l.rs:40:22\n   |\n\
    40 |     let mut vowels_32\n   |                      ^ help: add `;` here\n41\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjrplqc2l.rs:7:31\n\
    \  |\n7 | fn encode(message: String) -> String {\n  |    ------              \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter == letters[index] {\n        \
    \    encoded.push_str(&vowels[index]);\n        } else {\n            encoded.push_str(&letters[index]);\n\
    \        }\n        index += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpsq8hfi7d.rs:12:19\n\
    \    |\n12  |     for letter in message {\n    |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter == letters[index] {\n        \
    \    result += letter;\n        } else {\n            result += letters[index];\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmgcmrp__.rs:12:19\n\
    \   |\n12 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if let Some(vowel) = vowels.binary_search(&letter) {\n            let\
    \ index = vowels_index[vowel];\n            encoded.push_str(&vowels[vowel]);\n\
    \            encoded.push_str(&vowels[vowel + 1]);\n            encoded.push_str(&vowels[vowel\
    \ + 2]);\n            encoded.push_str(&vowels[vowel + 3]);\n            encoded.push_str(&vowels[vowel\
    \ + 4]);\n            encoded.push_str(&vowels[vowel + 5]);\n            encoded.push_str(&vowels[vowel\
    \ + 6]);\n            encoded.push_str(&vowels[vowel + 7]);\n            encoded.push_str(&vowels[vowel\
    \ + 8]);\n            encoded.push_str(&vowels[vowel + 9]);\n            encoded.push_str(&vowels[vowel\
    \ + 10]);\n            encoded.push_str(&vowels[vowel + 11]);\n            encoded.push_str(&vowels[vowel\
    \ + 12]);\n            encoded.push_str(&vowels[vowel + 13]);\n            encoded.push_str(&vowels[vowel\
    \ + 14]);\n            encoded.push_str(&vowels[vowel + 15]);\n            encoded.push_str(&vowels[vowel\
    \ + 16]);\n            encoded.push_str(&vowels[vowel + 17]);\n            encoded.push_str(&vowels[vowel\
    \ + 18]);\n            encoded.push_str(&vowels[vowel + 19]);\n            encoded.push_str(&vowels[vowel\
    \ + 20]);\n            encoded.push_str(&vowels[vowel + 21]);\n            encoded.push_str(&vowels[vowel\
    \ + 22]);\n            encoded.push_str(&vowels[vowel + 23]);\n            encoded.push_str(&vowels[vowel\
    \ + 24]);\n            encoded.push_str(&vowels[vowel + 25]);\n            encoded.push_str(&vowels[vowel\
    \ + 26]);\n            encoded.push_str(&vowels[vowel + 27]);\n            encoded.push_str(&vowels[vowel\
    \ + 28]);\n            encoded.push_str(&vowels[vowel + 29]);\n            encoded.push_str(&vowels[vowel\
    \ + 30]);\n            encoded.push_str(&vowels[vowel + 31]);\n            encoded.push_str(&vowels[vowel\
    \ + 32]);\n            encoded.push_str(\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoxyx9qzj.rs:58:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n13 |       \
    \  if let Some(vowel) = vowels.binary_search(&letter) {\n   |                \
    \                                            - this delimiter might not be properly\
    \ closed...\n...\n49 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n58 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpoxyx9qzj.rs:48:29\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n48 |     \
    \        encoded.push_str(\n   |                             ^ unclosed delimiter\n\
    49 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoxyx9qzj.rs:13:51\n   |\n13 |         if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n   |                                                   ^^^^^^^ expected `&str`,\
    \ found `char`\n   |\n   = note: expected reference `&&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoxyx9qzj.rs:13:16\n\
    \   |\n13 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |\
    \                ^^^^^^^^^^^   ----------------------------- this expression has\
    \ type `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpoxyx9qzj.rs:48:21\n\
    \    |\n48  |             encoded.push_str(\n    |                     ^^^^^^^^-\
    \ supplied 0 arguments\n    |                     |\n    |                   \
    \  expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoxyx9qzj.rs:12:5\n   |\n7  |   f"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.find(letter) {\n            encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpqrc8dfpo.rs:13:31\n\
    \   |\n13 |             encoded.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpqrc8dfpo.rs:15:31\n   |\n15 |             encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut letter_pairs = vec![];\n    let mut letter_pair = vec![];\n   \
    \ let mut letter_pair_count = 0;\n    let mut letter_pair_index = -1;\n    let\
    \ mut letter_pair_index2 = -1;\n    let mut letter_pair_index3 = -1;\n    let\
    \ mut letter_pair_index4 = -1;\n    let mut letter_pair_index5 = -1;\n    let\
    \ mut letter_pair_index6 = -1;\n    let mut letter_pair_index7 = -1;\n    let\
    \ mut letter_pair_index8 = -1;\n    let mut letter_pair_index9 = -1;\n    let\
    \ mut letter_pair_index10 = -1;\n    let mut letter_pair_index11 = -1;\n    let\
    \ mut letter_pair_index12 = -1;\n    let mut letter_pair_index13 = -1;\n    let\
    \ mut letter_pair_index14 = -1;\n    let mut letter_pair_index15 = -1;\n    let\
    \ mut letter_pair_index16 = -1;\n    let mut letter_pair_index17 = -1;\n    let\
    \ mut letter_pair_index18 = -1;\n    let mut letter_pair_index19 = -1;\n    let\
    \ mut letter_pair_index20 = -1;\n    let mut letter_pair_index21 = -1;\n    let\
    \ mut letter_pair_index22 = -1;\n    let mut letter_pair_index23 = -1;\n    let\
    \ mut letter_pair_index24 = -1;\n    let mut letter_pair_index25 = -1;\n    let\
    \ mut letter_pair_index26 = -1;\n    let mut letter_pair_index27 = -1;\n    let\
    \ mut letter_pair_index28 = -1;\n    let mut letter_pair_index29 = -1;\n    let\
    \ mut letter_pair_index30 = -1;\n    let mut letter_pair_index31 = -1;\n    let\
    \ mut letter_pair_index32 = -1;\n    let mut letter_pair_index33 = -1;\n    let\
    \ mut letter_pair_index34 = -1;\n    let mut letter_pair_index35 = -1;\n    let\
    \ mut letter_pair_index36 = -1;\n    let mut letter_pair_index37 = -1;\n    let\
    \ mut letter_pair_index38 = -1;\n    let mut letter_pair_index39 = -1;\n    let\
    \ mut letter_pair_index40 = -1;\n    let mut letter_pair_index41 = -1;\n    let\
    \ mut letter_pair_index42 = -1;\n    let mut letter_pair_index43 = -1;\n    let\
    \ mut letter_pair_index44 = -1;\n    let mut letter_pair_index45 = -1;\n    let\
    \ mut letter_pair_index46 = -1;\n    let mut letter_pair_index47 = -1;\n    let\
    \ mut letter_pair\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx0o9tfai.rs:60:24\n   |\n\
    60 |     let mut letter_pair\n   |                        ^ help: add `;` here\n\
    61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpx0o9tfai.rs:7:31\n\
    \  |\n7 | fn encode(message: String) -> String {\n  |    ------              \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowel\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwwr7d2y_.rs:43:18\n   |\n\
    43 |     let mut vowel\n   |                  ^ help: add `;` here\n44 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwwr7d2y_.rs:7:31\n\
    \  |\n7 | fn encode(message: String) -> String {\n  |    ------              \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"!\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    for letter in message.chars() {\n        if let Some(index) = vowels.find(|c|\
    \ c == letter) {\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            encoded.push_str(&letter);\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp59n37_x4.rs:12:31\n\
    \   |\n12 |             encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp59n37_x4.rs:14:30\n\
    \   |\n14 |             encoded.push_str(&letter);\n   |                     \
    \         ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mut \n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpddn_nm1_.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ encoded.push_str(\"_\");\n        } else {\n            encoded.push_str(&vowels[letters.find(&letter).unwrap()\
    \ + 2]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpd1iey30v.rs:15:51\n\
    \     |\n15   |             encoded.push_str(&vowels[letters.find(&letter).unwrap()\
    \ + 2]);\n     |                                              ---- ^^^^^^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                             \
    \                 |\n     |                                              required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\nhelp: consider dereferencing here\n\
    \     |\n15   |             encoded.push_str(&vowels[letters.find(*&letter).unwrap()\
    \ + 2]);\n     |                                                   +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd1iey30v.rs:15:31\n\
    \   |\n15 |             encoded.push_str(&vowels[letters.find(&letter).unwrap()\
    \ + 2]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 =\
    \ vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe5ltc9nf.rs:51:33\n   |\n\
    51 |     let mut letter_count_index40\n   |                                 ^\
    \ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpe5ltc9nf.rs:7:31\n  |\n7 | fn encode(message: String) ->\
    \ String {\n  |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = vowels.len();\n    \n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.find(|x| x == letter) {\n           \
    \ encoded.push_str(&vowels[vowels_index--]);\n        } else {\n            encoded.push_str(&letter);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `]`\n  --> /tmp/tmpxuxwnnwu.rs:14:52\n\
    \   |\n14 |             encoded.push_str(&vowels[vowels_index--]);\n   |     \
    \                                               ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxuxwnnwu.rs:16:30\n   |\n16 |             encoded.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 5];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 6];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 7];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 8];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 9];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 10];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 11];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 12];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 13];\n    let\
    \ mut vowels_index_11 = vec![0, 1, 2, 3, 14];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 15];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 16];\n    let\
    \ mut vowels_index_14 = vec![0, 1, 2, 3, 17];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 18];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 19];\n    let\
    \ mut vowels_index_17 = vec![0, 1, 2, 3, 20];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 21];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 22];\n    let\
    \ mut vowels_index_20 = vec![0, 1, 2, 3, 23];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 24];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 25];\n    let\
    \ mut vowels_index_23 = vec![0, 1, 2, 3, 26];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 27];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 28];\n    let\
    \ mut vowels_index_26 = vec![0, 1, 2, 3, 29];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 30];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 31];\n    let\
    \ mut vowels_index_29 = vec![0, 1, 2, 3, 32];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 33];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 34];\n    let\
    \ mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2zppii1c.rs:41:11\n   |\n\
    41 |     let mu\n   |           ^ help: add `;` here\n42 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2zppii1c.rs:7:31\n  |\n\
    7 | fn encode(message: String) -> String {\n  |    ------                    \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n    \
    \    } else {\n            encoded.push_str(&c);\n        }\n        index +=\
    \ 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpiyle_xzd.rs:12:28\n\
    \     |\n12   |         if vowels.contains(&c) {\n     |                   --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n     |                 \
    \  |\n     |                   required by a bound introduced by this call\n \
    \    |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n \
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n12   |         if vowels.contains(*&c)\
    \ {\n     |                            +\n\nerror[E0277]: the type `str` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpiyle_xzd.rs:13:31\n   |\n13 |         \
    \    encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n   |            \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiyle_xzd.rs:15:30\n\
    \   |\n15 |             encoded.push_str(&c);\n   |                          \
    \    ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    for letter in message.chars() {\n        if let Some(index) = vowels.find(letter)\
    \ {\n            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n    \
    \    } else {\n            encoded.push_str(&letter);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp_88cv091.rs:12:31\n\
    \   |\n12 |             encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_88cv091.rs:14:30\n\
    \   |\n14 |             encoded.push_str(&letter);\n   |                     \
    \         ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            encoded.push_str(\"_\");\n        } else {\n         \
    \   encoded.push_str(&letters[letter - 'A']);\n        }\n    }\n    for vowel\
    \ in vowels {\n        encoded.push_str(&letters[vowel - 'A']);\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmple8ri50g.rs:15:46\n\
    \   |\n15 |             encoded.push_str(&letters[letter - 'A']);\n   |      \
    \                                 ------ ^ --- char\n   |                    \
    \                   |\n   |                                       char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmple8ri50g.rs:19:41\n   |\n\
    19 |         encoded.push_str(&letters[vowel - 'A']);\n   |                  \
    \                 ----- ^ --- char\n   |                                   |\n\
    \   |                                   char\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    \n    for letter in message.chars() {\n        if\
    \ letter == ' ' {\n            result.push_str(\" \");\n        } else {\n   \
    \         result.push_str(&letters[letter - 'a']);\n        }\n    }\n    \n \
    \   for vowel in vowels {\n        result.push_str(&letters[vowel - 'a']);\n \
    \   }\n    \n    for letter in letters.iter().rev() {\n        result.push_str(&letters[letter\
    \ - 'a']);\n    }\n    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp38oo44j0.rs:16:45\n\
    \   |\n16 |             result.push_str(&letters[letter - 'a']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp38oo44j0.rs:21:40\n   |\n\
    21 |         result.push_str(&letters[vowel - 'a']);\n   |                   \
    \               ----- ^ --- char\n   |                                  |\n  \
    \ |                                  char\n\nerror[E0369]: cannot subtract `char`\
    \ from `&char`\n  --> /tmp/tmp38oo44j0.rs:25:41\n   |\n25 |         result.push_str(&letters[letter\
    \ - 'a']);\n   |                                  ------ ^ --- char\n   |    \
    \                              |\n   |                                  &char\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"!\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvdty5plc.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    encoded.push_str(&encode(encode(encoded.clone())));\n\
    \    encoded.push_str(\"\\n\");\n    encoded.push_str(&encode(encode(encode(encoded.clone()))))\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpneh__w29.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpneh__w29.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpneh__w29.rs:19:5\n   |\n7  | fn\
    \ encode(message: String) -> String {\n   |                               ------\
    \ expected `String` because of return type\n...\n19 |     encoded.push_str(&encode(encode(encode(encoded.clone()))))\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmpneh__w29.rs:19:13\n   |\n19 |     encoded.push_str(&encode(encode(encode(encoded.clone()))))\n\
    \   |     ------- ^^^^^^^^ this call modifies `encoded` in-place\n   |     |\n\
    \   |     you probably want to use this value after calling the method...\n  \
    \ = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded1 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded2 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded3 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded4 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded5 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded6 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded7 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded8\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded9 = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded10 = vec![\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded11 = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded12 = vec![\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"];\n    let mut vowels_encoded13 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded14 = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"];\n    let mut vowels_encoded15 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded16 = vec![\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    let mut vowels_encoded17 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded18 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded19 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n   \
    \ let mut vowels_encoded20 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded21 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded22 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded23\
    \ = vec![\"a\", \"e\", \"\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpb8tmzx38.rs:42:109\n\
    \   |\n42 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    43 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqi010joz.rs:101:3\n\
    \    |\n7   | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n89  |     for c in encoded.chars()\
    \ {\n    |                              - unclosed delimiter\n90  |         if\
    \ c.is_uppercase() {\n    |                             - this delimiter might\
    \ not be properly closed...\n91  |             encoded.push_str(&c.to_lowercase());\n\
    92  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    101 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:11:30\n\
    \   |\n11 |             encoded.push_str(&c.to_lowercase());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:19:30\n   |\n19 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:21:30\n   |\n21 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:27:30\n   |\n27 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n        "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index_2 = String::new();\n\
    \    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            vowels_index.push(letter);\n            vowels_index_2.push(vowels_index.len()\
    \ - 2);\n        }\n    }\n    for letter in message.chars() {\n        if vowels_index_2.contains(&letter)\
    \ {\n            encoded.push(vowels[vowels_index_2.index(&letter)].to_string());\n\
    \        } else {\n            encoded.push(letter);\n        }\n    }\n    return\
    \ encoded;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpxe92nsf0.rs:13:28\n\
    \     |\n13   |         if vowels.contains(&letter) {\n     |                \
    \   -------- ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n     | \
    \                  |\n     |                   required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n13   |         if\
    \ vowels.contains(*&letter) {\n     |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxe92nsf0.rs:15:33\n   |\n15 |             vowels_index_2.push(vowels_index.len()\
    \ - 2);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `usize`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found\
    \ `char`\n    --> /tmp/tmpxe92nsf0.rs:19:36\n     |\n19   |         if vowels_index_2.contains(&letter)\
    \ {\n     |                           -------- ^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                           |\n     |          \
    \                 required by a bound introduced by this call\n     |\n     =\
    \ help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n19   |         if vowels_index_2.contains(*&letter)\
    \ {\n     |                                    +\n\nerror[E0599]: no method named\
    \ `index` found for struct `String` in the current scope\n  --> /tmp/tmpxe92nsf0.rs:20:48\n\
    \   |\n20 |             encoded.push(vowels[vowels_index_2.index(&letter)].to_string());\n\
    \   |          "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 =\
    \ vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe5ltc9nf.rs:51:33\n   |\n\
    51 |     let mut letter_count_index40\n   |                                 ^\
    \ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpe5ltc9nf.rs:7:31\n  |\n7 | fn encode(message: String) ->\
    \ String {\n  |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == letter) {\n            encoded.push_str(&letters[vowel\
    \ + 2]);\n        } else {\n            encoded.push_str(&letters[letter]);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnj67etmf.rs:13:30\n   |\n\
    13 |             encoded.push_str(&letters[vowel + 2]);\n   |                \
    \              ^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0277]:\
    \ the type `[char]` cannot be indexed by `char`\n  --> /tmp/tmpnj67etmf.rs:15:31\n\
    \   |\n15 |             encoded.push_str(&letters[letter]);\n   |            \
    \                   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n\
    \    for letter in message.chars() {\n        if letter == vowels[vowel_counter]\
    \ {\n            encoded.push_str(&vowels[vowel_counter]);\n            vowel_counter++;\n\
    \        } else {\n            encoded.push_str(&letters[letter_counter]);\n \
    \           letter_counter++;\n        }\n    }\n    return encoded;\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp1xpbd5rl.rs:15:26\n\
    \   |\n15 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n15 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n15 -             vowel_counter++;\n\
    15 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp1xpbd5rl.rs:18:27\n   |\n18 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n18 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    18 -             letter_counter++;\n18 +             letter_counter += 1;\n  \
    \ | \n\nerror[E0425]: cannot find value `letters` in this scope\n  --> /tmp/tmp1xpbd5rl.rs:17:31\n\
    \   |\n17 |             encoded.push_str(&letters[letter_counter]);\n   |    \
    \                           ^^^^^^^ help: a local variable with a similar name\
    \ exists: `letter`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp1xpbd5rl.rs:13:22\n   |\n13 |         if letter == vowels[vowel_counter]\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp1xpbd5rl.rs:14:31\n   |\n14 |             encoded.push_str(&vowels[vowel_counter]);\n\
    \   |                              "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mu\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph2srw6fj.rs:43:11\n   |\n\
    43 |     let mu\n   |           ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmph2srw6fj.rs:7:31\n  |\n\
    7 | fn encode(message: String) -> String {\n  |    ------                    \
    \ ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut i = 0;\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ result.push_str(\" \");\n        } else {\n            result.push_str(&letters[letters_index[letter]]);\n\
    \        }\n    }\n    for vowel in vowels {\n        result.push_str(&vowels[vowels_index[vowel]]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `char`\n  -->\
    \ /tmp/tmpy8_xdbpt.rs:18:38\n   |\n18 |             result.push_str(&letters[letters_index[letter]]);\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `&str`\n  --> /tmp/tmpy8_xdbpt.rs:22:33\n\
    \   |\n22 |         result.push_str(&vowels[vowels_index[vowel]]);\n   |     \
    \                            ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `Index<&str>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_2 = \"AEIOU\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut letters_2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for letter in\
    \ message.chars() {\n        if letter in vowels {\n            encoded.push_str(&vowels_2[vowels.find(letter).unwrap()\
    \ + 2]);\n        } else {\n            encoded.push_str(&letters_2[letters.find(letter).unwrap()\
    \ + 2]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpiwwssd6v.rs:14:19\n\
    \   |\n14 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index_2 = String::new();\n\
    \    let mut vowels_index_3 = String::new();\n    let mut vowels_index_4 = String::new();\n\
    \    let mut vowels_index_5 = String::new();\n    let mut vowels_index_6 = String::new();\n\
    \    let mut vowels_index_7 = String::new();\n    let mut vowels_index_8 = String::new();\n\
    \    let mut vowels_index_9 = String::new();\n    let mut vowels_index_10 = String::new();\n\
    \    let mut vowels_index_11 = String::new();\n    let mut vowels_index_12 = String::new();\n\
    \    let mut vowels_index_13 = String::new();\n    let mut vowels_index_14 = String::new();\n\
    \    let mut vowels_index_15 = String::new();\n    let mut vowels_index_16 = String::new();\n\
    \    let mut vowels_index_17 = String::new();\n    let mut vowels_index_18 = String::new();\n\
    \    let mut vowels_index_19 = String::new();\n    let mut vowels_index_20 = String::new();\n\
    \    let mut vowels_index_21 = String::new();\n    let mut vowels_index_22 = String::new();\n\
    \    let mut vowels_index_23 = String::new();\n    let mut vowels_index_24 = String::new();\n\
    \    let mut vowels_index_25 = String::new();\n    let mut vowels_index_26 = String::new();\n\
    \    let mut vowels_index_27 = String::new();\n    let mut vowels_index_28 = String::new();\n\
    \    let mut vowels_index_29 = String::new();\n    let mut vowels_index_30 = String::new();\n\
    \    let mut vowels_index_31 = String::new();\n    let mut vowels_index_32 = String::new();\n\
    \    let mut vowels_index_33 = String::new();\n    let mut vowels_index_34 = String::new();\n\
    \    let mut vowels_index_35 = String::new();\n    let mut vowels_index_36 = String::new();\n\
    \    let mut vowels_index_37 = String::new();\n    let mut vowels_index_38 = String::new();\n\
    \    let mut vowels_index_39 = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6z24kthq.rs:7:31\n  |\n7 |\
    \ fn encode(message: String) -> String {\n  |    ------                     ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.find(letter) {\n            encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpqrc8dfpo.rs:13:31\n\
    \   |\n13 |             encoded.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpqrc8dfpo.rs:15:31\n   |\n15 |             encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \            result.push_str(&letters[index % letters.len()]);\n        } else\
    \ {\n            result.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ % letters.len()]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp7eepfgcf.rs:12:60\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmp7eepfgcf.rs:15:69\n   |\n15 |            \
    \ result.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ % letters.len()]);\n   |                                                   \
    \                  ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            encoded.push('_');\n        } else\
    \ {\n            let mut new_letter = letter;\n            for vowel in vowels\
    \ {\n                if letter == vowel {\n                    new_letter = letters[vowels.iter().position(|x|\
    \ x == vowel)! + 1];\n                    break;\n                }\n        \
    \    }\n            encoded.push(new_letter);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `!`\n  -->\
    \ /tmp/tmpygkd_t2h.rs:18:80\n   |\n18 |                     new_letter = letters[vowels.iter().position(|x|\
    \ x == vowel)! + 1];\n   |                                                   \
    \                             ^ expected one of `.`, `?`, `]`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpygkd_t2h.rs:17:30\n   |\n17 |\
    \                 if letter == vowel {\n   |                              ^^^^^\
    \ expected `char`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter == letters[index] {\n        \
    \    encoded.push_str(&vowels[index]);\n            index += 1;\n        } else\
    \ {\n            encoded.push_str(&letters[index]);\n            index += 1;\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmphgzbxhv6.rs:12:19\n\
    \   |\n12 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message\
    \ {\n        if letter in vowels {\n            result.push_str(&letters[vowels.index(&letter)].to_string());\n\
    \        } else {\n            result.push_str(&letters[letters.iter().position(|x|\
    \ *x == letter).unwrap() + 1].to_string());\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp2mx6ae64.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp2mx6ae64.rs:11:19\n\
    \   |\n11 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut letter_encoded = vec![\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"];\n    let mut letter_encoded1 = vec![\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \    let mut letter_encoded2 = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\",\
    \ \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut\
    \ letter_encoded3 = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_encoded1\
    \ = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_encoded2 = vec![\"a\"\
    , \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"];\n    let mut letter_encoded3 = vec![\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"];\n    let mut letter_encoded1 = vec![\"a\", \"b\", \"c\", \"d\", \"e\"\
    , \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n   \
    \ let mut letter_encoded2 = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp66f4hyj0.rs:28:109\n\
    \   |\n28 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    29 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[index % letters.len()]);\n        } else\
    \ {\n            encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ % letters.len()]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp5guptvha.rs:12:60\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmp5guptvha.rs:15:70\n   |\n15 |            \
    \ encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ % letters.len()]);\n   |                                                   \
    \                   ^^ no implementation for `&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.find(letter) {\n            encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpqrc8dfpo.rs:13:31\n\
    \   |\n13 |             encoded.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpqrc8dfpo.rs:15:31\n   |\n15 |             encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"?\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_lowercase() {\n            encoded.push_str(&c.to_uppercase());\n\
    \        } else {\n            encoded.push_str(&c.to_lowercase());\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:19:30\n   |\n19 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:21:30\n   |\n21 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    for letter\
    \ in message.chars() {\n        if let Some(index) = vowels.find(letter) {\n \
    \           encoded.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ } else {\n            encoded.push_str(&letters[letters.find(letter)!]);\n \
    \       }\n    }\n    \n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `]`, or an operator, found `!`\n  -->\
    \ /tmp/tmpj3w0piez.rs:16:59\n   |\n16 |             encoded.push_str(&letters[letters.find(letter)!]);\n\
    \   |                                                           ^ expected one\
    \ of `.`, `?`, `]`, or an operator\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpj3w0piez.rs:14:31\n   |\n14 |             encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message {\n        if letter in vowels\
    \ {\n            encoded.push_str(&letters[vowels.position(|x| x == letter)! +\
    \ 1]);\n        } else {\n            encoded.push_str(&letters[letters.position(|x|\
    \ x == letter)! + 1]);\n        }\n    }\n    return encoded;\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpdzoto4fy.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpdzoto4fy.rs:11:19\n\
    \   |\n11 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_map = HashMap::new();\n\
    \    for letter in vowels.iter() {\n        vowels_map.insert(letter, letter);\n\
    \    }\n    for letter in message.chars() {\n        let mut new_letter = letter;\n\
    \        if vowels_map.contains_key(&new_letter) {\n            new_letter = vowels_map.get(&new_letter).unwrap();\n\
    \        }\n        encoded.push(new_letter);\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp1g8mnp8e.rs:10:26\n   |\n10 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    \n    for letter in message.chars() {\n        if\
    \ letter == ' ' {\n            encoded.push_str(\"_\");\n        } else {\n  \
    \          let index = letters.iter().position(|x| x == letter).unwrap();\n  \
    \          encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpsbrqv3fr.rs:16:55\n\
    \   |\n16 |             let index = letters.iter().position(|x| x == letter).unwrap();\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpsbrqv3fr.rs:17:30\n   |\n17 |  \
    \           encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n   |     \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            encoded.push('_');\n        } else\
    \ {\n            let mut encode = String::new();\n            for vowel in vowels\
    \ {\n                encode.push_str(&letters[vowels.index(&letter)].to_string());\n\
    \            }\n            encoded.push_str(&encode);\n        }\n    }\n   \
    \ encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmps58zgoq6.rs:17:49\n   |\n17 |                 encode.push_str(&letters[vowels.index(&letter)].to_string());\n\
    \   |                                                 ^^^^^ method not found in\
    \ `Vec<&str>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&letter) {\n          \
    \  encoded.push_str(&vowels[(vowel - index) as usize]);\n            index = vowel\
    \ + 1;\n        } else {\n            encoded.push_str(&letter);\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcrieh8s4.rs:12:51\n   |\n\
    12 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \                                             ^^^^^^^ expected `&str`, found `char`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcrieh8s4.rs:12:16\n   |\n12 |\
    \         if let Some(vowel) = vowels.binary_search(&letter) {\n   |         \
    \       ^^^^^^^^^^^   ----------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcrieh8s4.rs:16:30\n   |\n16 |             encoded.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut new_c = c;\n        if c.is_uppercase() {\n            new_c\
    \ = c.to_lowercase();\n        }\n        if c.is_lowercase() {\n            new_c\
    \ = c.to_uppercase();\n        }\n        if c.is_digit() {\n            new_c\
    \ = c.to_digit();\n        }\n        if c.is_punctuation() {\n            new_c\
    \ = c.to_ascii_lowercase();\n        }\n        if c.is_whitespace() {\n     \
    \       new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_lowercase()\
    \ {\n            new_c = c.to_ascii_uppercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_lowercase()\
    \ {\n            new_c = c.to_ascii_uppercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_lowercase()\
    \ {\n            new_c = c.to_ascii_uppercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_lowercase()\
    \ {\n            new_c = c.to_ascii_uppercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_lowercase()\
    \ {\n            new_c = c.to_ascii_uppercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_lowercase()\
    \ {\n            new_c = c.to_ascii_uppercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            new_c = c.to_ascii_lowercase();\n        }\n        if c.is_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4dng8oy3.rs:108:3\n\
    \    |\n7   | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n8   |     let mut encoded = String::new();\n\
    9   |     for c in message.chars() {\n    |                              - this\
    \ delimiter might not be properly closed...\n...\n99  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n108 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmp4dng8oy3.rs:99:1\n   |\n98 |         if c.is_\n\
    \   |         -- this `if` expression has a condition, but no block\n99 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4dng8oy3.rs:12:21\n\
    \   |\n10 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n11 |         if c.is_uppercase() {\n12 |             new_c\
    \ = c.to_lowercase();\n   |                     ^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4dng8oy3.rs:15:21\n\
    \   |\n10 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n...\n15 |             new_c = c.to_uppercase();\n   |   \
    \                  ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp4dng8oy3.rs:17:14\n    |\n17  |         if c.is_digit() {\n  \
    \  |              ^^^^^^^^- supplied 0 arguments\n    |              |\n    |\
    \              expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp4dng8oy3.rs:18:23\n    |\n18  |             new_c = c.to_digit();\n\
    \    |                       ^^^^^^^^- supplied 0 arguments\n    |           \
    \            |\n    |                       expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4dng8oy3.rs:18:21\n\
    \   |\n10 |         let mut new_c = c;\n   |                         - expected\
    \ due to this "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n\
    \    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            encoded.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n        } else {\n            encoded.push_str(&letter);\n\
    \        }\n        if letter_counter_index == 2 {\n            letter_counter_index\
    \ = 0;\n            letter_counter = letter_counter + 1;\n        }\n        letter_counter_index\
    \ += 1;\n    }\n    return encoded;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ide4ovk.rs:14:28\n   |\n\
    14 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0277]: can't compare `&&str`\
    \ with `char`\n  --> /tmp/tmp2ide4ovk.rs:15:80\n   |\n15 |             encoded.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n   |                                \
    \                                                ^^ no implementation for `&&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ide4ovk.rs:17:30\n   |\n17 |             encoded.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[index % letters.len()]);\n        } else\
    \ {\n            encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpz8ok294m.rs:12:60\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpz8ok294m.rs:15:70\n   |\n15 |            \
    \ encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n   |                                                               \
    \       ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqi010joz.rs:101:3\n\
    \    |\n7   | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n89  |     for c in encoded.chars()\
    \ {\n    |                              - unclosed delimiter\n90  |         if\
    \ c.is_uppercase() {\n    |                             - this delimiter might\
    \ not be properly closed...\n91  |             encoded.push_str(&c.to_lowercase());\n\
    92  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    101 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:11:30\n\
    \   |\n11 |             encoded.push_str(&c.to_lowercase());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:19:30\n   |\n19 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:21:30\n   |\n21 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:27:30\n   |\n27 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n        "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut vowels_index2 = vowels.len();\n\
    \    let mut vowels_index3 = vowels.len();\n    let mut vowels_index4 = vowels.len();\n\
    \    let mut vowels_index5 = vowels.len();\n    let mut vowels_index6 = vowels.len();\n\
    \    let mut vowels_index7 = vowels.len();\n    let mut vowels_index8 = vowels.len();\n\
    \    let mut vowels_index9 = vowels.len();\n    let mut vowels_index10 = vowels.len();\n\
    \    let mut vowels_index11 = vowels.len();\n    let mut vowels_index12 = vowels.len();\n\
    \    let mut vowels_index13 = vowels.len();\n    let mut vowels_index14 = vowels.len();\n\
    \    let mut vowels_index15 = vowels.len();\n    let mut vowels_index16 = vowels.len();\n\
    \    let mut vowels_index17 = vowels.len();\n    let mut vowels_index18 = vowels.len();\n\
    \    let mut vowels_index19 = vowels.len();\n    let mut vowels_index20 = vowels.len();\n\
    \    let mut vowels_index21 = vowels.len();\n    let mut vowels_index22 = vowels.len();\n\
    \    let mut vowels_index23 = vowels.len();\n    let mut vowels_index24 = vowels.len();\n\
    \    let mut vowels_index25 = vowels.len();\n    let mut vowels_index26 = vowels.len();\n\
    \    let mut vowels_index27 = vowels.len();\n    let mut vowels_index28 = vowels.len();\n\
    \    let mut vowels_index29 = vowels.len();\n    let mut vowels_index30 = vowels.len();\n\
    \    let mut vowels_index31 = vowels.len();\n    let mut vowels_index32 = vowels.len();\n\
    \    let mut vowels_index33 = vowels.len();\n    let mut vowels_index34 = vowels.len();\n\
    \    let mut vowels_index35 = vowels.len();\n    let mut vowels_index36 = vowels.len();\n\
    \    let mut vowels_index37 = vowels.len();\n    let mut vowels_index38 = vowels.len();\n\
    \    let mut vowels_index39 = vowels.len();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6h3t0gqj.rs:7:31\n  |\n7 |\
    \ fn encode(message: String) -> String {\n  |    ------                     ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|x| x == letter) {\n\
    \            let index = vowel + 2;\n            encoded.push_str(&letters[index\
    \ % letters.len()]);\n        } else {\n            encoded.push_str(&letters[letter]);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp25mdtkdc.rs:12:59\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp25mdtkdc.rs:16:31\n   |\n\
    16 |             encoded.push_str(&letters[letter]);\n   |                   \
    \            ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut i = 0;\n\
    \    \n    for letter in message {\n        if letter in vowels {\n          \
    \  result.push_str(&letters[letters.position(letter).unwrap() + 2]);\n       \
    \ } else {\n            result.push_str(&letters[letters.position(letter).unwrap()]);\n\
    \        }\n    }\n    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp_8zco1pu.rs:14:19\n\
    \   |\n14 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp_8zco1pu.rs:13:19\n\
    \   |\n13 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded1 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded2 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded3 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded4 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded5 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded6 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded7 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded8\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded9 = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded10 = vec![\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded11 = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded12 = vec![\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"];\n    let mut vowels_encoded13 = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_encoded14 = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"];\n    let mut vowels_encoded15 = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let mut vowels_encoded16 = vec![\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    let mut vowels_encoded17 = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut vowels_encoded18 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_encoded19 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n   \
    \ let mut vowels_encoded20 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut vowels_encoded21 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut\
    \ vowels_encoded22 = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_encoded23\
    \ = vec![\"a\", \"e\", \"\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpb8tmzx38.rs:42:109\n\
    \   |\n42 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    43 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747236
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels_index[vowels.iter().position(|&x| x ==\
    \ letter).unwrap()] {\n            encoded.push_str(&vowels[vowels_index[index\
    \ + 1]]);\n            letter_count.push(letter_count.iter().position(|&x| x ==\
    \ letter).unwrap() + 1);\n        } else {\n            encoded.push_str(&letter);\n\
    \            letter_count.push(0);\n        }\n    }\n    encoded.push_str(&vowels[vowels_index[vowels.iter().position(|&x|\
    \ x == &message[letter_count.iter().position(|&x| x == 0).unwrap()]).unwrap()]);\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `)`\n  --> /tmp/tmp4kji0ncq.rs:21:29\n\
    \   |\n21 | ...str(&vowels[vowels_index[vowels.iter().position(|&x| x == &message[letter_count.iter().position(|&x|\
    \ x == 0).unwrap()]).unwrap()]);\n   |       -       ^ unclosed delimiter    \
    \                                                                            \
    \                  ^ mismatched closing delimiter\n   |       |\n   |       closing\
    \ delimiter possibly meant for this\n\nerror[E0277]: can't compare `&str` with\
    \ `char`\n  --> /tmp/tmp4kji0ncq.rs:13:73\n   |\n13 |         if let Some(index)\
    \ = vowels_index[vowels.iter().position(|&x| x == letter).unwrap()] {\n   |  \
    \                                                                       ^^ no\
    \ implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4kji0ncq.rs:13:16\n\
    \   |\n13 |         if let Some(index) = vowels_index[vowels.iter().position(|&x|\
    \ x == letter).unwrap()] {\n   |                ^^^^^^^^^^^   ---------------------------------------------------------------\
    \ this expression has type `{integer}`\n   |                |\n   |          \
    \      expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4kji0ncq.rs:15:70\n   |\n15 |             letter_count.push(letter_count.iter().position(|&x|\
    \ x == letter).unwrap() + 1);\n   |                                          \
    \                            ^^^^^^ expected integer, found `char`\n\nerror[E0277]:\
    \ can't compare `"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message {\n        if letter in vowels\
    \ {\n            encoded.push_str(&letters[vowels.position(|x| x == letter)].to_string());\n\
    \        } else {\n            encoded.push_str(&letters[letters.position(|x|\
    \ x == letter)].to_string());\n        }\n    }\n    return encoded;\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpnjidhgfa.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpnjidhgfa.rs:11:19\n\
    \   |\n11 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"\
    ~\");\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n    for c in encoded.chars() {\n       \
    \ encoded.push_str(c.to_ascii_lowercase());\n    }\n    encoded.push_str(\"~\"\
    );\n    for c in encoded.chars() {\n        encoded.push_str(c.to_ascii_lowercase());\n\
    \    }\n    encoded.push_str(\"~\");\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvwjsso1p.rs:10:26\n   |\n\
    10 |         encoded.push_str(c.to_ascii_lowercase());\n   |                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvwjsso1p.rs:14:26\n   |\n14 |         encoded.push_str(c.to_ascii_lowercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvwjsso1p.rs:18:26\n   |\n18 |\
    \         encoded.push_str(c.to_ascii_lowercase());\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvwjsso1p.rs:22:26\n   |\n22 |         encoded.push_str(c.to_ascii_lowercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvwjsso1p.rs:26:26\n   |\n26 |\
    \         encoded.push_str(c.to_ascii_lowercase());\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvwjsso1p.rs:30:26\n   |\n30 |         encoded.push_str(c.to_ascii_lowercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvwjsso1p.rs:34:26\n   |\n34 |\
    \         encoded.push_str(c.to_ascii_lowercase());\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvwjsso1p.rs:38:26\n   |\n38 |         encoded.push_str(c.to_ascii_lowercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvwjsso1p.rs:42:26\n   |\n42 |\
    \         encoded.push_str(c.to_ascii_lowercase());\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvwjsso1p.rs:46:26\n   |\n46 |         encoded.push_str(c.to_ascii_lowercase());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    for letter\
    \ in message.chars() {\n        if vowels.contains(&letter) {\n            result.push_str(&alphabet[alphabet.index(&letter)\
    \ + 1]);\n        } else {\n            result.push_str(&alphabet[alphabet.index(&letter)\
    \ - 1]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpadgaerct.rs:13:28\n\
    \     |\n13   |         if vowels.contains(&letter) {\n     |                \
    \   -------- ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n     | \
    \                  |\n     |                   required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n13   |         if\
    \ vowels.contains(*&letter) {\n     |                            +\n\nerror[E0599]:\
    \ no method named `index` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpadgaerct.rs:14:48\n   |\n14 |             result.push_str(&alphabet[alphabet.index(&letter)\
    \ + 1]);\n   |                                                ^^^^^ method not\
    \ found in `&str`\n   |\n   = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]:\
    \ no method named `index` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpadgaerct.rs:16:48\n   |\n16 |             result.push_str(&alphabet[alphabet.index(&letter)\
    \ - 1]);\n   |                                                ^^^^^ method not\
    \ found in `&str`\n   |\n   = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ result.push_str(\" \");\n        } else {\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n        }\n    }\n    for vowel\
    \ in vowels {\n        result.push_str(&vowels[(vowels.iter().position(|x| x ==\
    \ vowel).unwrap() + 1) % vowels.len()]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpn98ctjlw.rs:21:63\n\
    \   |\n21 |         result.push_str(&vowels[(vowels.iter().position(|x| x == vowel).unwrap()\
    \ + 1) % vowels.len()]);\n   |                                               \
    \                ^^ no implementation for `&str == str`\n   |\n   = help: the\
    \ trait `PartialEq<str>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(\" \");\n        } else {\n          \
    \  result.push_str(&letters[letter - 'A']);\n        }\n    }\n    for vowel in\
    \ vowels {\n        result.push_str(&letters[vowel - 'A']);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpd7o6bvl6.rs:15:45\n\
    \   |\n15 |             result.push_str(&letters[letter - 'A']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpd7o6bvl6.rs:19:40\n   |\n\
    19 |         result.push_str(&letters[vowel - 'A']);\n   |                   \
    \               ----- ^ --- char\n   |                                  |\n  \
    \ |                                  char\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            encoded.push_str(&letters[vowel + index]);\n        } else {\n\
    \            encoded.push_str(&letter);\n        }\n        index += 1;\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpvwvkiqon.rs:12:19\n\
    \   |\n12 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvwvkiqon.rs:13:16\n   |\n13 |         if let\
    \ Some(vowel) = vowels.binary_search(&letter) {\n   |                ^^^^^^^^^^^\
    \   ----------------------------- this expression has type `Result<usize, usize>`\n\
    \   |                |\n   |                expected enum `Result`, found enum\
    \ `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n          \
    \    found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ encoded.push_str(\" \");\n        } else {\n            if let Some(vowel) =\
    \ vowels.iter().position(|&x| x == letter) {\n                encoded.push_str(&letters[vowel\
    \ + 2]);\n            } else {\n                encoded.push_str(&letters[index]);\n\
    \            }\n        }\n        index += 1;\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpeyo_pil_.rs:16:64\n\
    \   |\n16 |             if let Some(vowel) = vowels.iter().position(|&x| x ==\
    \ letter) {\n   |                                                            \
    \    ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter in vowels {\n            encoded.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n        } else {\n            encoded.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            index += 1;\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpxp494ukb.rs:13:19\n\
    \   |\n13 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpxp494ukb.rs:12:19\n\
    \   |\n12 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[(index + 1) % 6]);\n        } else {\n\
    \            encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpuvh_x5dg.rs:12:60\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpuvh_x5dg.rs:15:70\n   |\n15 |            \
    \ encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n   |                                                               \
    \       ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_position = vec![0, 1, 2, 3, 4];\n    let mut letter_position\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_position = vec![0, 1, 2, 3, 4];\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpe73g8sci.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    \n    for letter in\
    \ message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            encoded.push_str(&letters[vowel + 2]);\n       \
    \ } else {\n            encoded.push_str(&letters[letter]);\n        }\n    }\n\
    \    \n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpzco49f7c.rs:13:60\n\
    \   |\n13 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `char`\n  --> /tmp/tmpzco49f7c.rs:16:31\n   |\n\
    16 |             encoded.push_str(&letters[letter]);\n   |                   \
    \            ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n        } else {\n            encoded.push_str(&letter);\n        }\n\
    \    }\n    return encoded;\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpkf4hgwah.rs:11:28\n\
    \     |\n11   |         if vowels.contains(&letter) {\n     |                \
    \   -------- ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n     | \
    \                  |\n     |                   required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ vowels.contains(*&letter) {\n     |                            +\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpkf4hgwah.rs:12:50\n\
    \     |\n12   |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n     |                                             ---- ^^^^^^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                             \
    \                |\n     |                                             required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\nhelp: consider dereferencing here\n\
    \     |\n12   |             encoded.push_str(&vowels[vowels.find(*&letter)..vowels.find(&letter)\
    \ + 2]);\n     |                                                  +\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpkf4hgwah.rs:12:72\n\
    \     |\n12   |             encoded.push_str(&vowels[vowels.find(&letter)..vowels.find(&letter)\
    \ + 2]);\n     |                                                             \
    \      ---- ^^^^^^^ expected an `Fn<"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message.chars()\
    \ {\n        encoded.push_str(&encode(letter));\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph0n0muis.rs:10:34\n   |\n\
    10 |         encoded.push_str(&encode(letter));\n   |                        \
    \          ^^^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                                 |\n   |                                  expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|x|\
    \ x == letter) {\n            encoded.push_str(&letters[vowel + 2]);\n       \
    \ } else {\n            encoded.push_str(&letters[index]);\n        }\n      \
    \  index += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmpjfq939cj.rs:13:59\n\
    \   |\n13 |         if let Some(vowel) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let mut new_c = c;\n        if c.is_uppercase() {\n            new_c\
    \ = c.to_lowercase();\n        }\n        let mut new_c_2 = c;\n        if c.is_lowercase()\
    \ {\n            new_c_2 = c.to_uppercase();\n        }\n        let mut new_c_3\
    \ = c;\n        if c.is_digit() {\n            new_c_3 = c.to_digit();\n     \
    \   }\n        let mut new_c_4 = c;\n        if c.is_punct() {\n            new_c_4\
    \ = c.to_ascii();\n        }\n        let mut new_c_5 = c;\n        if c.is_space()\
    \ {\n            new_c_5 = c.to_ascii();\n        }\n        let mut new_c_6 =\
    \ c;\n        if c.is_punct() {\n            new_c_6 = c.to_ascii();\n       \
    \ }\n        let mut new_c_7 = c;\n        if c.is_digit() {\n            new_c_7\
    \ = c.to_digit();\n        }\n        let mut new_c_8 = c;\n        if c.is_space()\
    \ {\n            new_c_8 = c.to_ascii();\n        }\n        let mut new_c_9 =\
    \ c;\n        if c.is_punct() {\n            new_c_9 = c.to_ascii();\n       \
    \ }\n        let mut new_c_10 = c;\n        if c.is_digit() {\n            new_c_10\
    \ = c.to_digit();\n        }\n        let mut new_c_11 = c;\n        if c.is_space()\
    \ {\n            new_c_11 = c.to_ascii();\n        }\n        let mut new_c_12\
    \ = c;\n        if c.is_punct() {\n            new_c_12 = c.to_ascii();\n    \
    \    }\n        let mut new_c_13 = c;\n        if c.is_digit() {\n           \
    \ new_c_13 = c.to_digit();\n        }\n        let mut new_c_14 = c;\n       \
    \ if c.is_space() {\n            new_c_14 = c.to_ascii();\n        }\n       \
    \ let mut new_c_15 = c;\n        if c.is_punct() {\n            new_c_15 = c.to_ascii();\n\
    \        }\n        let mut new_c_16 = c;\n        if c.is_digit() {\n       \
    \     new_c_16 = c.to_digit();\n        }\n        let mut new_c_17 = c;\n   \
    \     if c.is_space() {\n            new_c_17 = c.to_ascii();\n        }\n   \
    \     let mut new_c_18 = c;\n        if c.is_punct() {\n            new_c_18 =\
    \ c.to_ascii();\n        }\n        let mut new_c_19 = c;\n        if c.is_digit()\
    \ {\n            new_c_19 = c.to_digit();\n        }\n        let mut new_c_20\
    \ = c;\n        if c.is_space() {\n            new_c_20 = c.to_ascii();\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpiu_hgocs.rs:98:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n8  |     let mut result = String::new();\n\
    9  |     for c in message.chars() {\n   |                              - unclosed\
    \ delimiter\n...\n87 |         if c.is_space() {\n   |                       \
    \  - this delimiter might not be properly closed...\n88 |             new_c_20\
    \ = c.to_ascii();\n89 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n98 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiu_hgocs.rs:12:21\n\
    \   |\n10 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n11 |         if c.is_uppercase() {\n12 |             new_c\
    \ = c.to_lowercase();\n   |                     ^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiu_hgocs.rs:16:23\n\
    \   |\n14 |         let mut new_c_2 = c;\n   |                           - expected\
    \ due to this value\n15 |         if c.is_lowercase() {\n16 |             new_c_2\
    \ = c.to_uppercase();\n   |                       ^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `ToUppercase`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmpiu_hgocs.rs:19:14\n    |\n19  |  \
    \       if c.is_digit() {\n    |              ^^^^^^^^- supplied 0 arguments\n\
    \    |              |\n    |              expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmpiu_hgocs.rs:20:25\n    |\n20  |    \
    \         new_c_3 = c.to_digit();\n    |                         ^^^^^^^^- supplied\
    \ 0 arguments\n    |                         |\n    |                        \
    \ expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiu_hgocs.rs:20:23\n   |\n18 |         let mut\
    \ new_c_3 = c;\n   |                           - expected due to this value\n\
    19 |         if c"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            encoded.push_str(\"_\");\n      \
    \  } else {\n            encoded.push_str(letters[letter - 'a']);\n        }\n\
    \    }\n    for vowel in vowels {\n        encoded.push_str(vowels[vowel - 'a']);\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpuatn5fbz.rs:15:45\n\
    \   |\n15 |             encoded.push_str(letters[letter - 'a']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0369]:\
    \ cannot subtract `char` from `&str`\n  --> /tmp/tmpuatn5fbz.rs:19:39\n   |\n\
    19 |         encoded.push_str(vowels[vowel - 'a']);\n   |                    \
    \             ----- ^ --- char\n   |                                 |\n   | \
    \                                &str\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_count = message.len();\n\
    \    let mut letter_count_index = letter_count.len();\n    let mut letter_count_index2\
    \ = letter_count.len();\n    let mut letter_count_index3 = letter_count.len();\n\
    \    let mut letter_count_index4 = letter_count.len();\n    let mut letter_count_index5\
    \ = letter_count.len();\n    let mut letter_count_index6 = letter_count.len();\n\
    \    let mut letter_count_index7 = letter_count.len();\n    let mut letter_count_index8\
    \ = letter_count.len();\n    let mut letter_count_index9 = letter_count.len();\n\
    \    let mut letter_count_index10 = letter_count.len();\n    let mut letter_count_index11\
    \ = letter_count.len();\n    let mut letter_count_index12 = letter_count.len();\n\
    \    let mut letter_count_index13 = letter_count.len();\n    let mut letter_count_index14\
    \ = letter_count.len();\n    let mut letter_count_index15 = letter_count.len();\n\
    \    let mut letter_count_index16 = letter_count.len();\n    let mut letter_count_index17\
    \ = letter_count.len();\n    let mut letter_count_index18 = letter_count.len();\n\
    \    let mut letter_count_index19 = letter_count.len();\n    let mut letter_count_index20\
    \ = letter_count.len();\n    let mut letter_count_index21 = letter_count.len();\n\
    \    let mut letter_count_index22 = letter_count.len();\n    let mut letter_count_index23\
    \ = letter_count.len();\n    let mut letter_count_index24 = letter_count.len();\n\
    \    let mut letter_count_index25 = letter_count.len();\n    let mut letter_count_index26\
    \ = letter_count.len();\n    let mut letter_count_index27 = letter_count.len();\n\
    \    let mut letter_count_index28 = letter_count.len();\n    let mut letter_count_index29\
    \ = letter_count.len();\n    let mut letter_count_index30 = letter_count.len();\n\
    \    let mut letter_count_index31 = letter_count.len();\n    let mut letter_count_index32\
    \ = letter_count.len();\n    let mut letter_count_index33 = letter_count.len();\n\
    \    let mut letter_count_index34 = letter_count.len();\n    let mut letter_count_index35\
    \ = letter_count.len();\n    let mut letter_count_index36 = letter_count.len();\n\
    \    let mut letter_count_index37 = letter_count.len();\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1yvnygx1.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp1yvnygx1.rs:12:47\n   |\n12 |     let mut letter_count_index\
    \ = letter_count.len();\n   |                                               ^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp1yvnygx1.rs:13:48\n   |\n13\
    \ |     let mut letter_count_index2 = letter_count.len();\n   |              \
    \                                  ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmp1yvnygx1.rs:14:48\n\
    \   |\n14 |     let mut letter_count_index3 = letter_count.len();\n   |      \
    \                                          ^^^ method not found in `usize`\n\n\
    error[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmp1yvnygx1.rs:15:48\n   |\n15 |     let mut letter_count_index4 =\
    \ letter_count.len();\n   |                                                ^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp1yvnygx1.rs:16:48\n   |\n16\
    \ |     let mut letter_count_index5 = letter_count.len();\n   |              \
    \                                  ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmp1yvnygx1.rs:17:48\n\
    \   |\n17 |     let mut letter_count_index6 = letter_count.len();\n   |      \
    \                                          ^^^ method not found in `usize`\n\n\
    error[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmp1yvnygx1.rs:18:48\n   |\n18 |     let mut letter_count_index7 =\
    \ letter_count.len();\n   |                                                ^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the curre"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message {\n        if letter in vowels {\n            encoded.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n        } else {\n            encoded.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            index += 1;\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpxp494ukb.rs:13:19\n\
    \   |\n13 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpxp494ukb.rs:12:19\n\
    \   |\n12 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if let Some(vowel)\
    \ = vowels.iter().position(|x| x == letter) {\n            encoded.push_str(&letters[vowel\
    \ + 2]);\n        } else {\n            encoded.push_str(&letters[letter]);\n\
    \        }\n    }\n    return encoded;\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp245gzygv.rs:12:59\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp245gzygv.rs:13:30\n   |\n13 |  \
    \           encoded.push_str(&letters[vowel + 2]);\n   |                     \
    \         ^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0277]: the\
    \ type `[char]` cannot be indexed by `char`\n  --> /tmp/tmp245gzygv.rs:15:31\n\
    \   |\n15 |             encoded.push_str(&letters[letter]);\n   |            \
    \                   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            encoded.push_str(&letters[vowel + index]);\n        } else {\n\
    \            encoded.push_str(&letters[letter]);\n        }\n        index +=\
    \ 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnjslf36s.rs:13:51\n   |\n\
    13 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \                                             ^^^^^^^ expected `&str`, found `char`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnjslf36s.rs:13:16\n   |\n13 |\
    \         if let Some(vowel) = vowels.binary_search(&letter) {\n   |         \
    \       ^^^^^^^^^^^   ----------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0277]: the type `[&str]` cannot\
    \ be indexed by `char`\n  --> /tmp/tmpnjslf36s.rs:16:31\n   |\n16 |          \
    \   encoded.push_str(&letters[letter]);\n   |                               ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<&str>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut encoded = encoded.clone();\n        if c.is_uppercase() {\n\
    \            encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_lowercase());\n\
    \        } else {\n            encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_uppercase());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2nzov9pk.rs:12:53\n   |\n\
    12 |             encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_lowercase());\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2nzov9pk.rs:14:53\n\
    \   |\n14 |             encoded.replace(c.to_ascii_lowercase(), c.to_ascii_lowercase().to_ascii_uppercase());\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"?\");\n    return encoded;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjuxk3aje.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(1).unwrap()).to_string());\n        } else {\n\
    \            result.push((c.to_lowercase() + c.to_lowercase().chars().nth(2).unwrap()).to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmp6qdje8hz.rs:11:62\n   |\n11 |             result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(1).unwrap()).to_string());\n   |            \
    \                                                  ^^^^^ method not found in `ToLowercase`\n\
    \nerror[E0599]: no method named `chars` found for struct `ToLowercase` in the\
    \ current scope\n  --> /tmp/tmp6qdje8hz.rs:13:62\n   |\n13 |             result.push((c.to_lowercase()\
    \ + c.to_lowercase().chars().nth(2).unwrap()).to_string());\n   |            \
    \                                                  ^^^^^ method not found in `ToLowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            encoded.push_str(\"_\");\n      \
    \  } else {\n            let index = letters.iter().position(|&x| x == letter).unwrap();\n\
    \            encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp7qzrdov4.rs:15:56\n\
    \   |\n15 |             let index = letters.iter().position(|&x| x == letter).unwrap();\n\
    \   |                                                        ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message.chars()\
    \ {\n        encoded.push_str(&encode(letter));\n    }\n    return encoded;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp529vdvkz.rs:10:34\n   |\n\
    10 |         encoded.push_str(&encode(letter));\n   |                        \
    \          ^^^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                                 |\n   |                                  expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqi010joz.rs:101:3\n\
    \    |\n7   | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n89  |     for c in encoded.chars()\
    \ {\n    |                              - unclosed delimiter\n90  |         if\
    \ c.is_uppercase() {\n    |                             - this delimiter might\
    \ not be properly closed...\n91  |             encoded.push_str(&c.to_lowercase());\n\
    92  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    101 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:11:30\n\
    \   |\n11 |             encoded.push_str(&c.to_lowercase());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:19:30\n   |\n19 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:21:30\n   |\n21 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:27:30\n   |\n27 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n        "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowels_2 = \"AEIOUaeiou\".to_string();\n    for letter\
    \ in message.chars() {\n        if letter == vowels.chars().nth(0) {\n       \
    \     encoded.push(vowels_2.chars().nth(1).unwrap());\n        } else {\n    \
    \        encoded.push(vowels.chars().nth(1).unwrap());\n        }\n    }\n   \
    \ encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuyvbnisw.rs:12:22\n   |\n\
    12 |         if letter == vowels.chars().nth(0) {\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'E', 'I', 'O', 'U'];\n\
    \    let mut index = 0;\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            encoded.push_str(\" \");\n        } else {\n         \
    \   encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n            encoded.push_str(&vowels[index]);\n            encoded.push_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuq2fnzj4.rs:61:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n12 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n15 |  \
    \       } else {\n   |                - this delimiter might not be properly closed...\n\
    ...\n52 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    61 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuq2fnzj4.rs:16:30\n\
    \   |\n16 |             encoded.push_str(&vowels[index]);\n   |              \
    \                ^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuq2fnzj4.rs:17:30\n   |\n17 |             encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuq2fnzj4.rs:18:30\n\
    \   |\n18 |             encoded.push_str(&vowels[index]);\n   |              \
    \                ^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuq2fnzj4.rs:19:30\n   |\n19 |             encoded.push_str(&letters[(index\
    \ + 1) % 6]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuq2fnzj4.rs:20:30\n\
    \   |\n20 |             encoded.push_str(&vowels[index]);\n   |              \
    \                ^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuq2fnzj4.rs:21:30\n   |\n21 |             encoded.push_str(&letters[(index\
    \ + 1) % 6]);"
  stdout: ''
  timestamp: 1660009213
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[index % letters.len()]);\n        } else\
    \ {\n            encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpz8ok294m.rs:12:60\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpz8ok294m.rs:15:70\n   |\n15 |            \
    \ encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n   |                                                               \
    \       ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            vowel_counter += 1;\n            result.push_str(&alphabet[vowel]);\n\
    \        } else {\n            result.push_str(&alphabet[vowel_counter]);\n  \
    \          result.push_str(&alphabet[vowel_counter + 1]);\n            vowel_counter\
    \ += 2;\n        }\n        letter_counter += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78vrgi44.rs:14:16\n   |\n\
    14 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp78vrgi44.rs:18:29\n   |\n18 |             result.push_str(&alphabet[vowel_counter]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp78vrgi44.rs:19:29\n\
    \   |\n19 |             result.push_str(&alphabet[vowel_counter + 1]);\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowel\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwwr7d2y_.rs:43:18\n   |\n\
    43 |     let mut vowel\n   |                  ^ help: add `;` here\n44 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwwr7d2y_.rs:7:31\n\
    \  |\n7 | fn encode(message: String) -> String {\n  |    ------              \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == c) {\n    \
    \        let mut new_index = index;\n            for _ in 0..2 {\n           \
    \     new_index += 1;\n                if new_index >= vowels.len() {\n      \
    \              new_index = 0;\n                }\n            }\n            encoded.push_str(&vowels[new_index]);\n\
    \        } else {\n            encoded.push_str(&c);\n        }\n        index\
    \ += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpd4i53fn0.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == c) {\n\
    \   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd4i53fn0.rs:22:30\n   |\n22 |             encoded.push_str(&c);\n\
    \   |                              ^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let mut new_c = c;\n        if c.is_uppercase() {\n            new_c\
    \ = c.to_lowercase();\n        }\n        if c.is_lowercase() {\n            new_c\
    \ = c.to_uppercase();\n        }\n        if c.is_digit() {\n            new_c\
    \ = c.to_digit();\n        }\n        if c.is_punct() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_whitespace() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_symbol() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_control() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_ascii() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_punctuation() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_symbol() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_control() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_ascii() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_punctuation() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_symbol() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_control() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_ascii() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_punctuation() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_symbol() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_control() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_ascii() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_punctuation() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_symbol() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_control() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_ascii() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_punctuation() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_symbol() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_control() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_ascii() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_punctuation() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_symbol() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if c.is_control() {\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqprmku_r.rs:112:3\n\
    \    |\n7   | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n8   |     let mut result = String::new();\n\
    9   |     for c in message.chars() {\n    |                              - unclosed\
    \ delimiter\n...\n101 |         if c.is_control() {\n    |                   \
    \        - this delimiter might not be properly closed...\n102 | \n103 | }\n \
    \   | - ...as it matches this but it has different indentation\n...\n112 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqprmku_r.rs:12:21\n\
    \   |\n10 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n11 |         if c.is_uppercase() {\n12 |             new_c\
    \ = c.to_lowercase();\n   |                     ^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqprmku_r.rs:15:21\n\
    \   |\n10 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n...\n15 |             new_c = c.to_uppercase();\n   |   \
    \                  ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpqprmku_r.rs:17:14\n    |\n17  |         if c.is_digit() {\n  \
    \  |              ^^^^^^^^- supplied 0 arguments\n    |              |\n    |\
    \              expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpqprmku_r.rs:18:23\n    |\n18  |             new_c = c.to_digit();\n\
    \    |                       ^^^^^^^^- supplied 0 arguments\n    |           \
    \            |\n    |                       expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqprmku_r.rs:18:21\n\
    \   |\n10 |         let mut new_c = c;\n   |                         - expected\
    \ due to this value\n...\n18 |             new_c = c.to_digit();\n   |       \
    \              ^^^^^^^^^^^^ expe"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_map = HashMap::new();\n\
    \    vowels.iter().for_each(|vowel| {\n        vowels_map.insert(vowel.to_string(),\
    \ vowel);\n    });\n    message.chars().for_each(|c| {\n        if let Some(vowel)\
    \ = vowels_map.get(&c.to_string()) {\n            result.push_str(&vowel);\n \
    \       } else {\n            result.push_str(&c.to_string());\n        }\n  \
    \  });\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpu7jjnxyh.rs:10:26\n   |\n10 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpu7jjnxyh.rs:15:21\n   |\n15 |         if let Some(vowel) = vowels_map.get(&c.to_string())\
    \ {\n   |                     ^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpu7jjnxyh.rs:15:16\n\
    \    |\n15  |         if let Some(vowel) = vowels_map.get(&c.to_string()) {\n\
    \    |                ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Some`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqi010joz.rs:101:3\n\
    \    |\n7   | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n89  |     for c in encoded.chars()\
    \ {\n    |                              - unclosed delimiter\n90  |         if\
    \ c.is_uppercase() {\n    |                             - this delimiter might\
    \ not be properly closed...\n91  |             encoded.push_str(&c.to_lowercase());\n\
    92  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    101 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:11:30\n\
    \   |\n11 |             encoded.push_str(&c.to_lowercase());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:19:30\n   |\n19 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:21:30\n   |\n21 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqi010joz.rs:27:30\n   |\n27 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n        "
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    \n    for letter in message {\n        if letter == letters[index] {\n  \
    \          encoded.push_str(&vowels[index]);\n        } else {\n            encoded.push_str(&letters[index]);\n\
    \        }\n        index += 1;\n    }\n    \n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpfmql4ttg.rs:13:19\n\
    \   |\n13 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    for c in encoded.chars() {\n        if c.is_lowercase() {\n      \
    \      encoded.push_str(&c.to_uppercase());\n        } else {\n            encoded.push_str(&c.to_lowercase());\n\
    \        }\n    }\n    for c in encoded.chars() {\n        if c.is_lowercase()\
    \ {\n            encoded.push_str(&c.to_lowercase());\n        } else {\n    \
    \        encoded.push_str(&c.to_uppercase());\n        }\n    }\n    for c in\
    \ encoded.chars() {\n        if c.is_lowercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    for c in encoded.chars() {\n        if c.is_lowercase() {\n      \
    \      encoded.push_str(&c.to_lowercase());\n        } else {\n            encoded.push_str(&c.to_uppercase());\n\
    \        }\n    }\n    for c in encoded.chars() {\n        if c.is_lowercase()\
    \ {\n            encoded.push_str(&c.to_lowercase());\n        } else {\n    \
    \        encoded.push_str(&c.to_uppercase());\n        }\n    }\n    for c in\
    \ encoded.chars() {\n        if c.is_lowercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    for c in encoded.chars() {\n        if c.is_lowercase() {\n      \
    \      encoded.push_str(&c.to_lowercase());\n        } else {\n            encoded.push_str(&c.to_uppercase());\n\
    \        }\n    }\n    for c in encoded.chars() {\n        if c.is_lowercase()\
    \ {\n            encoded.push_str(&c.to_lowercase());\n        } else {\n    \
    \        encoded.push_str(&c.to_uppercase());\n        }\n    }\n    for c in\
    \ encoded.chars() {\n        if c.is_lowercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    for c in encoded.chars() {\n        if c.is_lowercase() {\n      \
    \      encoded.push_str(&c.to_lowercase());\n        } else {\n            encoded.push_str(&c.to_uppercase());\n\
    \        }\n    }\n    for c in encoded.chars() {\n        if c.is_lowercase()\
    \ {\n            encoded.push_str(&c.to_lowercase());\n        } else {\n    \
    \        encoded.push_str(&c.to_uppercase());\n        }\n    }\n    for c in\
    \ encoded.chars() {\n        if c.is_lowercase\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsmaaemq8.rs:104:3\n\
    \    |\n7   | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n93  |     for c in encoded.chars()\
    \ {\n    |                              - this delimiter might not be properly\
    \ closed...\n94  |         if c.is_lowercase\n95  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n104 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpsmaaemq8.rs:95:1\n   |\n94 |         if c.is_lowercase\n\
    \   |         -- this `if` expression has a condition, but no block\n95 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsmaaemq8.rs:11:30\n\
    \   |\n11 |             encoded.push_str(&c.to_lowercase());\n   |           \
    \                   ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsmaaemq8.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsmaaemq8.rs:18:30\n   |\n18 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsmaaemq8.rs:20:30\n   |\n20 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsmaaemq8.rs:25:30\n   |\n25 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`"
  stdout: ''
  timestamp: 1660009213
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message.chars()\
    \ {\n        let mut new_letter = letter;\n        let mut vowels = vec!['o',\
    \ 'a', 'e', 'i', 'u', 'y'];\n        for vowel in vowels.iter() {\n          \
    \  if letter == vowel {\n                new_letter += vowels[vowels.iter().position(|x|\
    \ x == vowel)+1];\n            }\n        }\n        encoded.push(new_letter);\n\
    \    }\n    return encoded;\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp50ld6us7.rs:13:26\n   |\n\
    13 |             if letter == vowel {\n   |                          ^^^^^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    13 |             if letter == *vowel {\n   |                          +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp50ld6us7.rs:14:76\n\
    \   |\n14 |                 new_letter += vowels[vowels.iter().position(|x| x\
    \ == vowel)+1];\n   |                                      --------------------------------------^-\
    \ {integer}\n   |                                      |\n   |               \
    \                       Option<usize>\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letter_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index2\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index3 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index4 = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index5 = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut letter_count_index6 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut letter_count_index7 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut letter_count_index8 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letter_count_index9 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letter_count_index10 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut\
    \ letter_count_index11 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index12\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index13 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index14 = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index15 = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut letter_count_index16 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut letter_count_index17 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut letter_count_index18 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letter_count_index19 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letter_count_index20 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut\
    \ letter_count_index21 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index22\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index23 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index24 = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letter_count_index25 = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut letter_count_index26 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1lt_9enh.rs:39:1\n  \
    \ |\n39 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|x| x == letter) {\n\
    \            encoded.push_str(&letters[vowel + 2]);\n        } else {\n      \
    \      encoded.push_str(&letters[letter]);\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmpb5cj55ko.rs:12:59\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `char`\n  --> /tmp/tmpb5cj55ko.rs:15:31\n   |\n\
    15 |             encoded.push_str(&letters[letter]);\n   |                   \
    \            ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx = vec![0, 1, 2, 3, 4];\n\
    \    for letter in message.chars() {\n        if let Some(idx) = vowels_idx.iter().position(|&idx|\
    \ letter == vowels[idx]) {\n            encoded.push_str(&vowels[idx % 5]);\n\
    \        } else {\n            encoded.push_str(&letter);\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppfzr0vm7.rs:12:72\n   |\n\
    12 |         if let Some(idx) = vowels_idx.iter().position(|&idx| letter == vowels[idx])\
    \ {\n   |                                                                    \
    \    ^^^^^^^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppfzr0vm7.rs:15:30\n   |\n15 |             encoded.push_str(&letter);\n\
    \   |                              ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut encoded = String::new();\n        if c.is_uppercase() {\n\
    \            encoded.push_str(&c.to_lowercase());\n        } else {\n        \
    \    encoded.push_str(&c.to_uppercase());\n        }\n        for vowel in \"\
    AEIOU\".chars() {\n            let index = c - vowel;\n            if index >=\
    \ 0 {\n                encoded.push_str(&vowel.to_lowercase());\n            \
    \    encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.push_str(&vowel.to_lowercase());\n                encoded.push_str(&vowel.to_lowercase());\n\
    \                encoded.\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp14l9v7p_.rs:68:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n8  |     let mut encoded = String::new();\n\
    9  |     for c in message.chars() {\n   |                              - unclosed\
    \ delimiter\n...\n16 |         for vowel in \"AEIOU\".chars() {\n   |        \
    \                              - unclosed delimiter\n17 |             let index\
    \ = c - vowel;\n18 |             if index >= 0 {\n   |                       \
    \    - this delimiter might not be properly closed...\n...\n59 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n68 | }\n   |   ^\n\n\
    error: unexpected token: `}`\n  --> /tmp/tmp14l9v7p_.rs:59:1\n   |\n59 | }\n \
    \  | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14l9v7p_.rs:12:30\n  \
    \ |\n12 |             encoded.push_str(&c.to_lowercase());\n   |             \
    \                 ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp14l9v7p_.rs:14:30\n   |\n14 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp14l9v7p_.rs:17:27\n\
    \   |\n17 |             let index = c - vowel;\n   |                         -\
    \ ^ ----- char\n   |                         |\n   |                         char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp14l9v7p_.rs:19:34\n   |\n19 |\
    \                 encoded.push_str(&vowel.to_lowercase());\n   |             \
    \                     ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp14l9v7p_.rs:20:34\n   |\n20 |\
    \                 encoded.push_str(&vowel.to_low"
  stdout: ''
  timestamp: 1660009213
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'E', 'I', 'O', 'U'];\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|x|\
    \ x == letter) {\n            encoded.push_str(&letters[vowel + 2]);\n       \
    \ } else {\n            encoded.push_str(&letters[vowel]);\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowel` in this scope\n  --> /tmp/tmpjmen6eiw.rs:15:39\n\
    \   |\n15 |             encoded.push_str(&letters[vowel]);\n   |             \
    \                          ^^^^^ help: a local variable with a similar name exists:\
    \ `vowels`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjmen6eiw.rs:12:59\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjmen6eiw.rs:13:30\n   |\n13 |  \
    \           encoded.push_str(&letters[vowel + 2]);\n   |                     \
    \         ^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"?\");\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwxe8r53k.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxe8r53k.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    for letter in message.chars() {\n        if let Some(index) = vowels_index[letter\
    \ - 'a'] {\n            encoded.push_str(&vowels[vowels_index[index + 1] - vowels_index[index]]);\n\
    \        } else {\n            encoded.push_str(&letter);\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpjujshe3l.rs:12:50\n\
    \   |\n12 |         if let Some(index) = vowels_index[letter - 'a'] {\n   |  \
    \                                         ------ ^ --- char\n   |            \
    \                               |\n   |                                      \
    \     char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjujshe3l.rs:15:30\n\
    \   |\n15 |             encoded.push_str(&letter);\n   |                     \
    \         ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9y1uuwrv.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[(index + 1) % 6]);\n        } else {\n\
    \            encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpuvh_x5dg.rs:12:60\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpuvh_x5dg.rs:15:70\n   |\n15 |            \
    \ encoded.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n   |                                                               \
    \       ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_encoded\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters_encoded = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for\
    \ letter in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            encoded.push_str(&vowels_encoded[vowel]);\n    \
    \    } else {\n            encoded.push_str(&letters_encoded[letter]);\n     \
    \   }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp5vyykluk.rs:14:60\n\
    \   |\n14 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp5vyykluk.rs:17:31\n   |\n\
    17 |             encoded.push_str(&letters_encoded[letter]);\n   |           \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>` is not\
    \ implemented for `char`\n   = note: required because of the requirements on the\
    \ impl of `Index<char>` for `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpub5kyx71.rs:11:29\n   |\n\
    11 |             result.push_str(&c.to_lowercase());\n   |                   \
    \          ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpub5kyx71.rs:13:29\n   |\n13 |\
    \             result.push_str(&c.to_uppercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut vowels_index_2 = vowels.len();\n\
    \    let mut vowels_index_3 = vowels.len();\n    let mut vowels_index_4 = vowels.len();\n\
    \    let mut vowels_index_5 = vowels.len();\n    let mut vowels_index_6 = vowels.len();\n\
    \    let mut vowels_index_7 = vowels.len();\n    let mut vowels_index_8 = vowels.len();\n\
    \    let mut vowels_index_9 = vowels.len();\n    let mut vowels_index_10 = vowels.len();\n\
    \    let mut vowels_index_11 = vowels.len();\n    let mut vowels_index_12 = vowels.len();\n\
    \    let mut vowels_index_13 = vowels.len();\n    let mut vowels_index_14 = vowels.len();\n\
    \    let mut vowels_index_15 = vowels.len();\n    let mut vowels_index_16 = vowels.len();\n\
    \    let mut vowels_index_17 = vowels.len();\n    let mut vowels_index_18 = vowels.len();\n\
    \    let mut vowels_index_19 = vowels.len();\n    let mut vowels_index_20 = vowels.len();\n\
    \    let mut vowels_index_21 = vowels.len();\n    let mut vowels_index_22 = vowels.len();\n\
    \    let mut vowels_index_23 = vowels.len();\n    let mut vowels_index_24 = vowels.len();\n\
    \    let mut vowels_index_25 = vowels.len();\n    let mut vowels_index_26 = vowels.len();\n\
    \    let mut vowels_index_27 = vowels.len();\n    let mut vowels_index_28 = vowels.len();\n\
    \    let mut vowels_index_29 = vowels.len();\n    let mut vowels_index_30 = vowels.len();\n\
    \    let mut vowels_index_31 = vowels.len();\n    let mut vowels_index_32 = vowels.len();\n\
    \    let mut vowels_index_33 = vowels.len();\n    let mut vowels_index_34 = vowels.len();\n\
    \    let mut vowels_index_35 = vowels.len();\n    let mut vowels_index_36 = vowels.len();\n\
    \    let mut vowels_index_37 = vowels.len();\n    let mut vowels_index_38 = vowels.len();\n\
    \    let mut vowels_index_39 = vowels.len();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp88007ur6.rs:7:31\n  |\n7 |\
    \ fn encode(message: String) -> String {\n  |    ------                     ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            encoded.push_str(&c.to_lowercase());\n\
    \        } else {\n            encoded.push_str(&c.to_uppercase());\n        }\n\
    \    }\n    encoded.push_str(\"\\n\");\n    for c in encoded.chars() {\n     \
    \   if c.is_lowercase() {\n            encoded.push_str(&c.to_uppercase());\n\
    \        } else {\n            encoded.push_str(&c.to_lowercase());\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:11:30\n   |\n\
    11 |             encoded.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:13:30\n   |\n13 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:19:30\n   |\n19 |\
    \             encoded.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7q38ss76.rs:21:30\n   |\n21 |\
    \             encoded.push_str(&c.to_lowercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    for letter in message.chars() {\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::new();\n\
    \        let mut encoded = String::new();\n        let mut encoded = String::\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwdplivvb.rs:69:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for letter in message.chars()\
    \ {\n   |                                   - this delimiter might not be properly\
    \ closed...\n...\n60 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n69 | }\n   |   ^\n\nerror: expected identifier, found `}`\n  --> /tmp/tmpwdplivvb.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpwdplivvb.rs:10:26\n   |\n10\
    \ |     let mut vowels_map = HashMap::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpwdplivvb.rs:7:31\n  |\n7 | fn encode(message: String) -> String\
    \ {\n  |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_count = 1;\n \
    \   for letter in message.chars() {\n        if letter == vowels[vowels_index]\
    \ {\n            vowels_index += 2;\n        } else {\n            vowels_index\
    \ += 1;\n        }\n        if vowels_index >= vowels.len() {\n            vowels_index\
    \ = 0;\n        }\n        result.push_str(&vowels[vowels_index]);\n        result.push_str(&letter);\n\
    \        letter_count += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmphkb3fi8g.rs:13:22\n\
    \   |\n13 |         if letter == vowels[vowels_index] {\n   |                \
    \      ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmphkb3fi8g.rs:21:26\n \
    \  |\n21 |         result.push_str(&vowels[vowels_index]);\n   |             \
    \             ^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphkb3fi8g.rs:22:25\n   |\n22 |         result.push_str(&letter);\n\
    \   |                         ^^^^^^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut vowels_index2 = vowels.len();\n\
    \    let mut vowels_index3 = vowels.len();\n    let mut vowels_index4 = vowels.len();\n\
    \    let mut vowels_index5 = vowels.len();\n    let mut vowels_index6 = vowels.len();\n\
    \    let mut vowels_index7 = vowels.len();\n    let mut vowels_index8 = vowels.len();\n\
    \    let mut vowels_index9 = vowels.len();\n    let mut vowels_index10 = vowels.len();\n\
    \    let mut vowels_index11 = vowels.len();\n    let mut vowels_index12 = vowels.len();\n\
    \    let mut vowels_index13 = vowels.len();\n    let mut vowels_index14 = vowels.len();\n\
    \    let mut vowels_index15 = vowels.len();\n    let mut vowels_index16 = vowels.len();\n\
    \    let mut vowels_index17 = vowels.len();\n    let mut vowels_index18 = vowels.len();\n\
    \    let mut vowels_index19 = vowels.len();\n    let mut vowels_index20 = vowels.len();\n\
    \    let mut vowels_index21 = vowels.len();\n    let mut vowels_index22 = vowels.len();\n\
    \    let mut vowels_index23 = vowels.len();\n    let mut vowels_index24 = vowels.len();\n\
    \    let mut vowels_index25 = vowels.len();\n    let mut vowels_index26 = vowels.len();\n\
    \    let mut vowels_index27 = vowels.len();\n    let mut vowels_index28 = vowels.len();\n\
    \    let mut vowels_index29 = vowels.len();\n    let mut vowels_index30 = vowels.len();\n\
    \    let mut vowels_index31 = vowels.len();\n    let mut vowels_index32 = vowels.len();\n\
    \    let mut vowels_index33 = vowels.len();\n    let mut vowels_index34 = vowels.len();\n\
    \    let mut vowels_index35 = vowels.len();\n    let mut vowels_index36 = vowels.len();\n\
    \    let mut vowels_index37 = vowels.len();\n    let mut vowels_index38 = vowels.len();\n\
    \    let mut vowels_index39 = vowel\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe98f6226.rs:48:35\n   |\n\
    48 |     let mut vowels_index39 = vowel\n   |                                \
    \   ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `vowel` in this scope\n  --> /tmp/tmpe98f6226.rs:48:30\n   |\n48\
    \ |     let mut vowels_index39 = vowel\n   |                              ^^^^^\
    \ help: a local variable with a similar name exists: `vowels`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpe98f6226.rs:7:31\n  |\n7 | fn encode(message:\
    \ String) -> String {\n  |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    for letter in message.chars() {\n        let mut new_letter = letter;\n \
    \       if let Some(vowel) = vowels_map.get(&new_letter) {\n            new_letter\
    \ = vowel;\n        }\n        encoded.push(new_letter);\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxcihasny.rs:10:26\n   |\n10 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \            result.push_str(&letters[vowel + 2]);\n        } else {\n       \
    \     result.push_str(&letters[letter]);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp2zgwbzgk.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp2zgwbzgk.rs:15:30\n   |\n\
    15 |             result.push_str(&letters[letter]);\n   |                    \
    \          ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ in vowels {\n            result.push_str(&letters[vowels.index(letter)].to_string());\n\
    \        } else {\n            result.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() + 1].to_string());\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp3geafn5j.rs:12:19\n\
    \   |\n12 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.iter().position(|x| x == letter) {\n\
    \            encoded.push_str(&letters[index % letters.len()]);\n        } else\
    \ {\n            encoded.push_str(&letters[letters.iter().position(|x| x == letter).unwrap()\
    \ % letters.len()]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp5p597d0j.rs:12:59\n\
    \   |\n12 |         if let Some(index) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&&str` with `char`\n  --> /tmp/tmp5p597d0j.rs:15:69\n   |\n15 |           \
    \  encoded.push_str(&letters[letters.iter().position(|x| x == letter).unwrap()\
    \ % letters.len()]);\n   |                                                   \
    \                  ^^ no implementation for `&&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_counter = 0;\n    for letter in message.chars()\
    \ {\n        if vowels.contains(&letter) {\n            encoded.push_str(&vowels[vowels_counter]);\n\
    \            vowels_counter += 1;\n        } else {\n            encoded.push_str(&letter);\n\
    \        }\n    }\n    return encoded;\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx8cugqjy.rs:13:30\n   |\n\
    13 |             encoded.push_str(&vowels[vowels_counter]);\n   |            \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx8cugqjy.rs:16:30\n   |\n16 |\
    \             encoded.push_str(&letter);\n   |                              ^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    let mut index2 = 0;\n    for c in message {\n \
    \       if c.is_uppercase() {\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            index += 1;\n        } else {\n            encoded.push_str(&vowels[(index2\
    \ + 1) % vowels.len()]);\n            index2 += 1;\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp_nympbtn.rs:12:14\n\
    \   |\n12 |     for c in message {\n   |              ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmp_nympbtn.rs:14:31\n \
    \  |\n14 |             encoded.push_str(&vowels[index % vowels.len()]);\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmp_nympbtn.rs:17:31\n   |\n17 |             encoded.push_str(&vowels[(index2\
    \ + 1) % vowels.len()]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \            encoded.push_str(&letters[vowel + 2]);\n        } else {\n      \
    \      encoded.push_str(&letters[letter]);\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpnq0bxhy1.rs:12:60\n\
    \   |\n12 |         if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n   |                                                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n\nerror[E0277]: the type `[&str]` cannot be indexed by `char`\n\
    \  --> /tmp/tmpnq0bxhy1.rs:15:31\n   |\n15 |             encoded.push_str(&letters[letter]);\n\
    \   |                               ^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<&str>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747237
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter == vowels[vowel_counter] {\n            vowel_counter++;\n       \
    \     if vowel_counter == 2 {\n                result += letters[letter_counter];\n\
    \                letter_counter = 0;\n                vowel_counter = 0;\n   \
    \         }\n        } else {\n            result += letter;\n            letter_counter++;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp44jytzwc.rs:15:26\n\
    \   |\n15 |             vowel_counter++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n15 |       \
    \      { let tmp = vowel_counter; vowel_counter += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n15 -             vowel_counter++;\n\
    15 +             vowel_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp44jytzwc.rs:23:27\n   |\n23 |             letter_counter++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n23 |             { let tmp = letter_counter; letter_counter\
    \ += 1; tmp };\n   |             +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    23 -             letter_counter++;\n23 +             letter_counter += 1;\n  \
    \ | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp44jytzwc.rs:13:19\n\
    \   |\n13 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            encoded.push_str(\"_\");\n        } else {\n         \
    \   let mut index = letters.iter().position(|&x| x == letter).unwrap();\n    \
    \        encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n        }\n \
    \   }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3trkri3x.rs:16:30\n   |\n\
    16 |             encoded.push_str(&vowels[(index + 1) % vowels.len()]);\n   |\
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_pos\
    \ = 0;\n    let mut letter_pos = 0;\n    for letter in message {\n        if letter\
    \ == vowels[vowel_pos] {\n            encoded.push_str(&letters[letter_pos]);\n\
    \            letter_pos += 2;\n        } else {\n            encoded.push_str(&letters[letter_pos]);\n\
    \            letter_pos += 1;\n        }\n        vowel_pos += 1;\n    }\n   \
    \ encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp9spr6r1f.rs:13:19\n\
    \   |\n13 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    \n    for letter in message.chars() {\n        if\
    \ let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n            let\
    \ vowel_index = vowels.iter().position(|&x| x == letter).unwrap();\n         \
    \   encoded.push_str(&letters[vowel_index + 2]);\n        } else {\n         \
    \   encoded.push_str(&letters[letter]);\n        }\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3bl4_hhg.rs:15:30\n   |\n\
    15 |             encoded.push_str(&letters[vowel_index + 2]);\n   |          \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0277]: the type `[char]` cannot be indexed by `char`\n  --> /tmp/tmp3bl4_hhg.rs:17:31\n\
    \   |\n17 |             encoded.push_str(&letters[letter]);\n   |            \
    \                   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut vowels_index2 = vowels.len();\n\
    \    let mut vowels_index3 = vowels.len();\n    let mut vowels_index4 = vowels.len();\n\
    \    let mut vowels_index5 = vowels.len();\n    let mut vowels_index6 = vowels.len();\n\
    \    let mut vowels_index7 = vowels.len();\n    let mut vowels_index8 = vowels.len();\n\
    \    let mut vowels_index9 = vowels.len();\n    let mut vowels_index10 = vowels.len();\n\
    \    let mut vowels_index11 = vowels.len();\n    let mut vowels_index12 = vowels.len();\n\
    \    let mut vowels_index13 = vowels.len();\n    let mut vowels_index14 = vowels.len();\n\
    \    let mut vowels_index15 = vowels.len();\n    let mut vowels_index16 = vowels.len();\n\
    \    let mut vowels_index17 = vowels.len();\n    let mut vowels_index18 = vowels.len();\n\
    \    let mut vowels_index19 = vowels.len();\n    let mut vowels_index20 = vowels.len();\n\
    \    let mut vowels_index21 = vowels.len();\n    let mut vowels_index22 = vowels.len();\n\
    \    let mut vowels_index23 = vowels.len();\n    let mut vowels_index24 = vowels.len();\n\
    \    let mut vowels_index25 = vowels.len();\n    let mut vowels_index26 = vowels.len();\n\
    \    let mut vowels_index27 = vowels.len();\n    let mut vowels_index28 = vowels.len();\n\
    \    let mut vowels_index29 = vowels.len();\n    let mut vowels_index30 = vowels.len();\n\
    \    let mut vowels_index31 = vowels.len();\n    let mut vowels_index32 = vowels.len();\n\
    \    let mut vowels_index33 = vowels.len();\n    let mut vowels_index34 = vowels.len();\n\
    \    let mut vowels_index35 = vowels.len();\n    let mut vowels_index36 = vowels.len();\n\
    \    let mut vowels_index37 = vowels.len();\n    let mut vowels_index38 = vowels.len();\n\
    \    let mut vowels_index39 = vowels.\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp5hb56i0v.rs:49:1\n   |\n49\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp5hb56i0v.rs:48:37\n\
    \   |\n48 |     let mut vowels_index39 = vowels.\n   |                       \
    \              ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp5hb56i0v.rs:7:31\n  |\n7 | fn encode(message:\
    \ String) -> String {\n  |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_2 = \"AEIOU\";\n    let mut vowels_3 = \"AEIOUaeiou\";\n\
    \    let mut vowels_4 = \"AEIOUaeiouAEIOU\";\n    let mut vowels_5 = \"AEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_6 = \"AEIOUaeiouAEIOUaeiouAEIOU\";\n    let mut vowels_7\
    \ = \"AEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    let mut vowels_8 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_9 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    let\
    \ mut vowels_10 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    let\
    \ mut vowels_11 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n  \
    \  let mut vowels_12 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_13 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_14 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_15 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_16 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    let mut vowels_17 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk1vgjj5h.rs:26:20\n   |\n\
    26 |     let mut vowels_\n   |                    ^ help: add `;` here\n27 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpk1vgjj5h.rs:7:31\n\
    \  |\n7 | fn encode(message: String) -> String {\n  |    ------              \
    \       ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009212
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\
    \ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,\
    \ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\
    \ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\
    \ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\
    \ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\
    \ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\
    \ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\
    \ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\
    \ 240, 241, 242, 243, 244, 245, 246, 24\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp2dnbn05b.rs:13:1\n   |\n13 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp2dnbn05b.rs:12:33\n   |\n7  | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n12 |     let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28...\n   |                                 ^ unclosed delimiter\n13 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009212
