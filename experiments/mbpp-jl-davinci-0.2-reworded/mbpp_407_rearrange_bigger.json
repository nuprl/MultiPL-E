{
  "name": "mbpp_407_rearrange_bigger",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\nfunction rearrange_bigger(n::Int64)::Any \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "reworded",
  "tests": "using Test\n\n@testset begin\n\ncandidate = rearrange_bigger;\n\t@test(candidate(12) == 21)\n\t@test(candidate(10) == false)\n\t@test(candidate(102) == 120)\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the one to its right\n\ti = 1\n\twhile i < length(digits) && digits[i] >= digits[i+1]\n\t\ti += 1\n\tend\n\t\n\t# if no such digit exists, then the number is already the largest possible\n\tif i == length(digits)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tj = i+1\n\twhile j < length(digits) && digits[j] > digits[i]\n\t\tj += 1\n\tend\n\tj -= 1\n\t\n\t# swap the pivot with the smallest digit to its right\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# reverse the digits to the right of the pivot\n\tdigits[i+1:end] = reverse(digits[i+1:end])\n\t\n\t# convert the digits back to an integer\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\tGiven a number, rearrange the digits to create the next bigger number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tstr_n = string(n)\n\t# convert to array\n\tarr_n = [parse(Int64, str_n[i]) for i in 1:length(str_n)]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(arr_n)-1\n\t\tif arr_n[i] < arr_n[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\tif i == length(arr_n)\n\t\treturn -1\n\tend\n\t# find the smallest digit to the right of the digit found above that is greater than the digit found above\n\tfor j in i+1:length(arr_n)\n\t\tif arr_n[j] > arr_n[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap the two digits\n\tarr_n[i], arr_n[j] = arr_n[j], arr_n[i]\n\t# sort the digits to the right of the digit found above in ascending order\n\tarr_n[i+1:end] = sort(arr_n[i+1:end])\n\t# convert the array to a string\n\tstr_n = \"\"\n\tfor k in 1:length(arr_n)\n\t\tstr_n = str_n * string(arr_n[k])\n\tend\n\t# convert the string to an integer\n\treturn parse(Int64, str_n)\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first decreasing digit\n\tfor i in 1:length(n_str)-1\n\t\tif n_arr[i] > n_arr[i+1]\n\t\t\t# find the smallest digit larger than n_arr[i]\n\t\t\tfor j in i+1:length(n_str)\n\t\t\t\tif n_arr[j] > n_arr[i]\n\t\t\t\t\t# swap\n\t\t\t\t\tn_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n\t\t\t\t\t# sort the rest of the digits\n\t\t\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t\t\t# return the result\n\t\t\t\t\treturn parse(Int64, join(n_arr))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if no rearrangement is possible, return -1\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# get the length of the string\n\tn_len = length(n_str)\n\t# get the last digit of the number\n\tlast_digit = parse(Int64, n_str[end])\n\t# get the second last digit of the number\n\tsecond_last_digit = parse(Int64, n_str[end-1])\n\t# get the third last digit of the number\n\tthird_last_digit = parse(Int64, n_str[end-2])\n\t# get the fourth last digit of the number\n\tfourth_last_digit = parse(Int64, n_str[end-3])\n\t# get the fifth last digit of the number\n\tfifth_last_digit = parse(Int64, n_str[end-4])\n\t# get the sixth last digit of the number\n\tsixth_last_digit = parse(Int64, n_str[end-5])\n\t# get the seventh last digit of the number\n\tseventh_last_digit = parse(Int64, n_str[end-6])\n\t# get the eighth last digit of the number\n\teighth_last_digit = parse(Int64, n_str[end-7])\n\t# get the ninth last digit of the number\n\tninth_last_digit = parse(Int64, n_str[end-8])\n\t# get the tenth last digit of the number\n\ttenth_last_digit = parse(Int64, n_str[end-9])\n\t# get the eleventh last digit of the number\n\televenth_last_digit = parse(Int64, n_str[end-10])\n\t# get the twelfth last digit of the number\n\ttwelfth_last_digit = parse(Int64, n_str[end-11])\n\t# get the thirteenth last digit of the number\n\tthirteenth_last_digit = parse(Int64, n_str[end-12])\n\t# get the fourteenth last digit of the number\n\tfourteenth_last_digit = parse(Int64, n_str[end-13])\n\t# get the fifteenth last digit of the number\n\tfifteenth_",
    "\tdigits = digits(n)\n\tfor i in length(digits):-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the digits\n\tn_digits = length(digits)\n\t# create an array to store the new number\n\tnew_number = zeros(Int64, n_digits)\n\t# create a variable to store the index of the number to be swapped\n\tswap_index = 0\n\t# create a variable to store the index of the number to be swapped with\n\tswap_with_index = 0\n\t# create a variable to store the number to be swapped\n\tswap_number = 0\n\t# create a variable to store the number to be swapped with\n\tswap_with_number = 0\n\t# create a variable to store the new number\n\tnew_number_int = 0\n\t# loop through the digits\n\tfor i in 1:n_digits\n\t\t# loop through the digits from the current digit to the end\n\t\tfor j in i:n_digits\n\t\t\t# if the current digit is less than the digit to be compared with\n\t\t\tif digits[i] < digits[j]\n\t\t\t\t# if the swap number is 0 or the current digit is greater than the swap number\n\t\t\t\tif swap_number == 0 || digits[i] > swap_number\n\t\t\t\t\t# set the swap number to the current digit\n\t\t\t\t\tswap_number = digits[i]\n\t\t\t\t\t# set the swap index to the current index\n\t\t\t\t\tswap_index = i\n\t\t\t\t\t# set the swap with number to the digit to be compared with\n\t\t\t\t\tswap_with_number = digits[j]\n\t\t\t\t\t# set the swap with index to the index of the digit to be compared with\n\t\t\t\t\tswap_with_index = j\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if the swap number is 0\n\tif swap_number == 0\n\t\t# return -1\n\t\treturn -1\n\tend\n\t# loop through the digits\n\tfor i in 1:n_digits\n\t\t# if the current index is the swap index",
    "\t#convert to string\n\ts = string(n)\n\t#convert to array\n\ta = collect(s)\n\t#sort array\n\tsort!(a)\n\t#convert to string\n\ts = join(a)\n\t#convert to int\n\tn = parse(Int64, s)\n\t#return\n\treturn n\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\t\n\tfor i in n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tn_str[i], n_str[i-1] = n_str[i-1], n_str[i]\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tn_str_arr = collect(n_str)\n\tn_str_arr_rev = reverse(n_str_arr)\n\tn_str_arr_rev_sort = sort(n_str_arr_rev)\n\tn_str_arr_rev_sort_rev = reverse(n_str_arr_rev_sort)\n\tn_str_arr_rev_sort_rev_str = join(n_str_arr_rev_sort_rev)\n\tn_str_arr_rev_sort_rev_str_int = parse(Int64, n_str_arr_rev_sort_rev_str)\n\tif n_str_arr_rev_sort_rev_str_int == n\n\t\treturn -1\n\telse\n\t\treturn n_str_arr_rev_sort_rev_str_int\n\tend\nend",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\tfor j in length(digits):i+1\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\tdigits[i], digits[j] = digits[j], digits[i]\n\tdigits[i+1:end] = reverse(digits[i+1:end])\n\treturn parse(Int64, join(digits))\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the digits\n\tlen_digits = length(digits)\n\t# get the last digit\n\tlast_digit = digits[len_digits]\n\t# get the second last digit\n\tsecond_last_digit = digits[len_digits-1]\n\t# get the third last digit\n\tthird_last_digit = digits[len_digits-2]\n\t# get the fourth last digit\n\tfourth_last_digit = digits[len_digits-3]\n\t# get the fifth last digit\n\tfifth_last_digit = digits[len_digits-4]\n\t# get the sixth last digit\n\tsixth_last_digit = digits[len_digits-5]\n\t# get the seventh last digit\n\tseventh_last_digit = digits[len_digits-6]\n\t# get the eighth last digit\n\teighth_last_digit = digits[len_digits-7]\n\t# get the ninth last digit\n\tninth_last_digit = digits[len_digits-8]\n\t# get the tenth last digit\n\ttenth_last_digit = digits[len_digits-9]\n\t# get the eleventh last digit\n\televenth_last_digit = digits[len_digits-10]\n\t# get the twelfth last digit\n\ttwelfth_last_digit = digits[len_digits-11]\n\t# get the thirteenth last digit\n\tthirteenth_last_digit = digits[len_digits-12]\n\t# get the fourteenth last digit\n\tfourteenth_last_digit = digits[len_digits-13]\n\t# get the fifteenth last digit\n\tfifteenth_last_digit = digits[len_digits-14]\n\t# get the sixteenth last digit\n\tsixteenth_last_digit = digits[len_digits-15]\n\t# get the seventeenth last digit\n\tseventeenth_last_digit = digits[len_digits-16]\n\t# get the eighteenth last digit\n\teighteenth_last_digit = digits[len_digits-17]\n\t# get the",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# create a list of digits\n\tdigits = [int(d) for d in string(n)]\n\t# find the first digit that is smaller than the one to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is greater than the pivot\n\t\t\tmin_index = i+1\n\t\t\tfor j in i+2:length(digits)\n\t\t\t\tif digits[j] < digits[min_index] && digits[j] > digits[i]\n\t\t\t\t\tmin_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the pivot with the smallest digit to its right\n\t\t\tdigits[i], digits[min_index] = digits[min_index], digits[i]\n\t\t\t# sort the digits to the right of the pivot\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\t# return the number\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t# return -1 if no bigger number can be found\n\treturn -1\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the number\n\tlen = length(digits)\n\t# get the first digit of the number\n\tfirst_digit = digits[1]\n\t# get the last digit of the number\n\tlast_digit = digits[len]\n\t# get the second last digit of the number\n\tsecond_last_digit = digits[len-1]\n\t# get the third last digit of the number\n\tthird_last_digit = digits[len-2]\n\t# get the fourth last digit of the number\n\tfourth_last_digit = digits[len-3]\n\t# get the fifth last digit of the number\n\tfifth_last_digit = digits[len-4]\n\t# get the sixth last digit of the number\n\tsixth_last_digit = digits[len-5]\n\t# get the seventh last digit of the number\n\tseventh_last_digit = digits[len-6]\n\t# get the eighth last digit of the number\n\teighth_last_digit = digits[len-7]\n\t# get the ninth last digit of the number\n\tninth_last_digit = digits[len-8]\n\t# get the tenth last digit of the number\n\ttenth_last_digit = digits[len-9]\n\t# get the eleventh last digit of the number\n\televenth_last_digit = digits[len-10]\n\t# get the twelfth last digit of the number\n\ttwelfth_last_digit = digits[len-11]\n\t# get the thirteenth last digit of the number\n\tthirteenth_last_digit = digits[len-12]\n\t# get the fourteenth last digit of the number\n\tfourteenth_last_digit = digits[len-13]\n\t# get the fifteenth last digit of the number\n\tfifteenth_last_digit = digits[len-14]\n\t# get the sixteenth last digit of the number\n\tsixteenth_last_digit = digits[len-15]\n\t# get the seventeenth last digit of the number\n\tseventeenth_last_digit = digits[len-16]\n\t# get the eighteenth last digit of the number\n\teight",
    "\t#convert to string\n\tn_str = string(n)\n\t#convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t#find the first digit that is smaller than the previous one\n\tfor i in 2:length(n_arr)\n\t\tif n_arr[i] > n_arr[i-1]\n\t\t\t#find the smallest digit that is bigger than the previous one\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i-1]\n\t\t\t\t\t#swap the two digits\n\t\t\t\t\tn_arr[i-1], n_arr[j] = n_arr[j], n_arr[i-1]\n\t\t\t\t\t#sort the rest of the digits\n\t\t\t\t\tn_arr[i:end] = sort(n_arr[i:end])\n\t\t\t\t\t#convert to string\n\t\t\t\t\tn_str = join(n_arr)\n\t\t\t\t\t#convert to integer\n\t\t\t\t\tn_int = parse(Int64, n_str)\n\t\t\t\t\treturn n_int\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end], rev=true)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\n\t# Example\n\t```jldoctest\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t"
  ]
}