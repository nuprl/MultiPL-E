{
  "name": "mbpp_407_rearrange_bigger",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\nfunction rearrange_bigger(n::Int64)::Any \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "reworded",
  "tests": "using Test\n\n@testset begin\n\ncandidate = rearrange_bigger;\n\t@test(candidate(12) == 21)\n\t@test(candidate(10) == false)\n\t@test(candidate(102) == 120)\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the one to its right\n\ti = 1\n\twhile i < length(digits) && digits[i] >= digits[i+1]\n\t\ti += 1\n\tend\n\t\n\t# if no such digit exists, then the number is already the largest possible\n\tif i == length(digits)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tj = i+1\n\twhile j < length(digits) && digits[j] > digits[i]\n\t\tj += 1\n\tend\n\tj -= 1\n\t\n\t# swap the pivot with the smallest digit to its right\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# reverse the digits to the right of the pivot\n\tdigits[i+1:end] = reverse(digits[i+1:end])\n\t\n\t# convert the digits back to an integer\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\tGiven a number, rearrange the digits to create the next bigger number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tstr_n = string(n)\n\t# convert to array\n\tarr_n = [parse(Int64, str_n[i]) for i in 1:length(str_n)]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(arr_n)-1\n\t\tif arr_n[i] < arr_n[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\tif i == length(arr_n)\n\t\treturn -1\n\tend\n\t# find the smallest digit to the right of the digit found above that is greater than the digit found above\n\tfor j in i+1:length(arr_n)\n\t\tif arr_n[j] > arr_n[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap the two digits\n\tarr_n[i], arr_n[j] = arr_n[j], arr_n[i]\n\t# sort the digits to the right of the digit found above in ascending order\n\tarr_n[i+1:end] = sort(arr_n[i+1:end])\n\t# convert the array to a string\n\tstr_n = \"\"\n\tfor k in 1:length(arr_n)\n\t\tstr_n = str_n * string(arr_n[k])\n\tend\n\t# convert the string to an integer\n\treturn parse(Int64, str_n)\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array of chars\n\tn_arr = collect(n_str)\n\t# find the first decreasing digit\n\tfor i in 1:length(n_str)-1\n\t\tif n_arr[i] > n_arr[i+1]\n\t\t\t# find the smallest digit larger than n_arr[i]\n\t\t\tfor j in i+1:length(n_str)\n\t\t\t\tif n_arr[j] > n_arr[i]\n\t\t\t\t\t# swap\n\t\t\t\t\tn_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n\t\t\t\t\t# sort the rest of the digits\n\t\t\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t\t\t# return the result\n\t\t\t\t\treturn parse(Int64, join(n_arr))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if no rearrangement is possible, return -1\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# get the length of the string\n\tn_len = length(n_str)\n\t# get the last digit of the number\n\tlast_digit = parse(Int64, n_str[end])\n\t# get the second last digit of the number\n\tsecond_last_digit = parse(Int64, n_str[end-1])\n\t# get the third last digit of the number\n\tthird_last_digit = parse(Int64, n_str[end-2])\n\t# get the fourth last digit of the number\n\tfourth_last_digit = parse(Int64, n_str[end-3])\n\t# get the fifth last digit of the number\n\tfifth_last_digit = parse(Int64, n_str[end-4])\n\t# get the sixth last digit of the number\n\tsixth_last_digit = parse(Int64, n_str[end-5])\n\t# get the seventh last digit of the number\n\tseventh_last_digit = parse(Int64, n_str[end-6])\n\t# get the eighth last digit of the number\n\teighth_last_digit = parse(Int64, n_str[end-7])\n\t# get the ninth last digit of the number\n\tninth_last_digit = parse(Int64, n_str[end-8])\n\t# get the tenth last digit of the number\n\ttenth_last_digit = parse(Int64, n_str[end-9])\n\t# get the eleventh last digit of the number\n\televenth_last_digit = parse(Int64, n_str[end-10])\n\t# get the twelfth last digit of the number\n\ttwelfth_last_digit = parse(Int64, n_str[end-11])\n\t# get the thirteenth last digit of the number\n\tthirteenth_last_digit = parse(Int64, n_str[end-12])\n\t# get the fourteenth last digit of the number\n\tfourteenth_last_digit = parse(Int64, n_str[end-13])\n\t# get the fifteenth last digit of the number\n\tfifteenth_",
    "\tdigits = digits(n)\n\tfor i in length(digits):-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the digits\n\tn_digits = length(digits)\n\t# create an array to store the new number\n\tnew_number = zeros(Int64, n_digits)\n\t# create a variable to store the index of the number to be swapped\n\tswap_index = 0\n\t# create a variable to store the index of the number to be swapped with\n\tswap_with_index = 0\n\t# create a variable to store the number to be swapped\n\tswap_number = 0\n\t# create a variable to store the number to be swapped with\n\tswap_with_number = 0\n\t# create a variable to store the new number\n\tnew_number_int = 0\n\t# loop through the digits\n\tfor i in 1:n_digits\n\t\t# loop through the digits from the current digit to the end\n\t\tfor j in i:n_digits\n\t\t\t# if the current digit is less than the digit to be compared with\n\t\t\tif digits[i] < digits[j]\n\t\t\t\t# if the swap number is 0 or the current digit is greater than the swap number\n\t\t\t\tif swap_number == 0 || digits[i] > swap_number\n\t\t\t\t\t# set the swap number to the current digit\n\t\t\t\t\tswap_number = digits[i]\n\t\t\t\t\t# set the swap index to the current index\n\t\t\t\t\tswap_index = i\n\t\t\t\t\t# set the swap with number to the digit to be compared with\n\t\t\t\t\tswap_with_number = digits[j]\n\t\t\t\t\t# set the swap with index to the index of the digit to be compared with\n\t\t\t\t\tswap_with_index = j\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if the swap number is 0\n\tif swap_number == 0\n\t\t# return -1\n\t\treturn -1\n\tend\n\t# loop through the digits\n\tfor i in 1:n_digits\n\t\t# if the current index is the swap index",
    "\t#convert to string\n\ts = string(n)\n\t#convert to array\n\ta = collect(s)\n\t#sort array\n\tsort!(a)\n\t#convert to string\n\ts = join(a)\n\t#convert to int\n\tn = parse(Int64, s)\n\t#return\n\treturn n\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\t\n\tfor i in n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tn_str[i], n_str[i-1] = n_str[i-1], n_str[i]\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tn_str_arr = collect(n_str)\n\tn_str_arr_rev = reverse(n_str_arr)\n\tn_str_arr_rev_sort = sort(n_str_arr_rev)\n\tn_str_arr_rev_sort_rev = reverse(n_str_arr_rev_sort)\n\tn_str_arr_rev_sort_rev_str = join(n_str_arr_rev_sort_rev)\n\tn_str_arr_rev_sort_rev_str_int = parse(Int64, n_str_arr_rev_sort_rev_str)\n\tif n_str_arr_rev_sort_rev_str_int == n\n\t\treturn -1\n\telse\n\t\treturn n_str_arr_rev_sort_rev_str_int\n\tend\nend",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\tfor j in length(digits):i+1\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\tdigits[i], digits[j] = digits[j], digits[i]\n\tdigits[i+1:end] = reverse(digits[i+1:end])\n\treturn parse(Int64, join(digits))\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the digits\n\tlen_digits = length(digits)\n\t# get the last digit\n\tlast_digit = digits[len_digits]\n\t# get the second last digit\n\tsecond_last_digit = digits[len_digits-1]\n\t# get the third last digit\n\tthird_last_digit = digits[len_digits-2]\n\t# get the fourth last digit\n\tfourth_last_digit = digits[len_digits-3]\n\t# get the fifth last digit\n\tfifth_last_digit = digits[len_digits-4]\n\t# get the sixth last digit\n\tsixth_last_digit = digits[len_digits-5]\n\t# get the seventh last digit\n\tseventh_last_digit = digits[len_digits-6]\n\t# get the eighth last digit\n\teighth_last_digit = digits[len_digits-7]\n\t# get the ninth last digit\n\tninth_last_digit = digits[len_digits-8]\n\t# get the tenth last digit\n\ttenth_last_digit = digits[len_digits-9]\n\t# get the eleventh last digit\n\televenth_last_digit = digits[len_digits-10]\n\t# get the twelfth last digit\n\ttwelfth_last_digit = digits[len_digits-11]\n\t# get the thirteenth last digit\n\tthirteenth_last_digit = digits[len_digits-12]\n\t# get the fourteenth last digit\n\tfourteenth_last_digit = digits[len_digits-13]\n\t# get the fifteenth last digit\n\tfifteenth_last_digit = digits[len_digits-14]\n\t# get the sixteenth last digit\n\tsixteenth_last_digit = digits[len_digits-15]\n\t# get the seventeenth last digit\n\tseventeenth_last_digit = digits[len_digits-16]\n\t# get the eighteenth last digit\n\teighteenth_last_digit = digits[len_digits-17]\n\t# get the",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# create a list of digits\n\tdigits = [int(d) for d in string(n)]\n\t# find the first digit that is smaller than the one to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is greater than the pivot\n\t\t\tmin_index = i+1\n\t\t\tfor j in i+2:length(digits)\n\t\t\t\tif digits[j] < digits[min_index] && digits[j] > digits[i]\n\t\t\t\t\tmin_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the pivot with the smallest digit to its right\n\t\t\tdigits[i], digits[min_index] = digits[min_index], digits[i]\n\t\t\t# sort the digits to the right of the pivot\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\t# return the number\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t# return -1 if no bigger number can be found\n\treturn -1\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the number\n\tlen = length(digits)\n\t# get the first digit of the number\n\tfirst_digit = digits[1]\n\t# get the last digit of the number\n\tlast_digit = digits[len]\n\t# get the second last digit of the number\n\tsecond_last_digit = digits[len-1]\n\t# get the third last digit of the number\n\tthird_last_digit = digits[len-2]\n\t# get the fourth last digit of the number\n\tfourth_last_digit = digits[len-3]\n\t# get the fifth last digit of the number\n\tfifth_last_digit = digits[len-4]\n\t# get the sixth last digit of the number\n\tsixth_last_digit = digits[len-5]\n\t# get the seventh last digit of the number\n\tseventh_last_digit = digits[len-6]\n\t# get the eighth last digit of the number\n\teighth_last_digit = digits[len-7]\n\t# get the ninth last digit of the number\n\tninth_last_digit = digits[len-8]\n\t# get the tenth last digit of the number\n\ttenth_last_digit = digits[len-9]\n\t# get the eleventh last digit of the number\n\televenth_last_digit = digits[len-10]\n\t# get the twelfth last digit of the number\n\ttwelfth_last_digit = digits[len-11]\n\t# get the thirteenth last digit of the number\n\tthirteenth_last_digit = digits[len-12]\n\t# get the fourteenth last digit of the number\n\tfourteenth_last_digit = digits[len-13]\n\t# get the fifteenth last digit of the number\n\tfifteenth_last_digit = digits[len-14]\n\t# get the sixteenth last digit of the number\n\tsixteenth_last_digit = digits[len-15]\n\t# get the seventeenth last digit of the number\n\tseventeenth_last_digit = digits[len-16]\n\t# get the eighteenth last digit of the number\n\teight",
    "\t#convert to string\n\tn_str = string(n)\n\t#convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t#find the first digit that is smaller than the previous one\n\tfor i in 2:length(n_arr)\n\t\tif n_arr[i] > n_arr[i-1]\n\t\t\t#find the smallest digit that is bigger than the previous one\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i-1]\n\t\t\t\t\t#swap the two digits\n\t\t\t\t\tn_arr[i-1], n_arr[j] = n_arr[j], n_arr[i-1]\n\t\t\t\t\t#sort the rest of the digits\n\t\t\t\t\tn_arr[i:end] = sort(n_arr[i:end])\n\t\t\t\t\t#convert to string\n\t\t\t\t\tn_str = join(n_arr)\n\t\t\t\t\t#convert to integer\n\t\t\t\t\tn_int = parse(Int64, n_str)\n\t\t\t\t\treturn n_int\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end], rev=true)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\n\t# Example\n\t```jldoctest\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the smallest digit to the right of i that is larger than digits[i]\n\t\t\tsmallest_larger = digits[i+1]\n\t\t\tsmallest_larger_index = i+1\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i] && digits[j] <= smallest_larger\n\t\t\t\t\tsmallest_larger = digits[j]\n\t\t\t\t\tsmallest_larger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap digits[i] and smallest_larger\n\t\t\tdigits[i], digits[smallest_larger_index] = digits[smallest_larger_index], digits[i]\n\t\t\t# sort the rest of the digits\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\t# return the new number\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any \n\t\n\trearrange_bigger(n) takes a number n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, return -1.\n\t\"\"\"\n\t\n\t# convert n to string\n\tn_str = string(n)\n\t\n\t# convert string to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t\n\t# find the first digit from the right that is smaller than its right neighbor\n\tfor i in length(n_arr):-1:2\n\t\tif n_arr[i] > n_arr[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, return -1\n\tif i == 1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the digit found above that is greater than it\n\tfor j in i:length(n_arr)\n\t\tif n_arr[j] > n_arr[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the digits\n\tn_arr[i-1], n_arr[j] = n_arr[j], n_arr[i-1]\n\t\n\t# sort the digits to the right of the digit found above in ascending order\n\tn_arr[i:end] = sort(n_arr[i:end])\n\t\n\t# convert array to string\n\tn_str = join(n_arr)\n\t\n\t# convert string to integer\n\tn = parse(Int64, n_str)\n\t\n\treturn n\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tReturn the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t=======\n\tjulia> rearrange_bigger(123)\n\t132\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1243)\n\t1324\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_big",
    "\t\"\"\"\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn = string(n)\n\tif length(n) == 1\n\t\treturn -1\n\tend\n\tif length(n) == 2\n\t\tif n[1] < n[2]\n\t\t\treturn parse(Int64, n[2]*n[1])\n\t\telse\n\t\t\treturn -1\n\t\tend\n\tend\n\tif length(n) == 3\n\t\tif n[1] < n[2]\n\t\t\tif n[2] < n[3]\n\t\t\t\treturn parse(Int64, n[3]*n[1]*n[2])\n\t\t\telse\n\t\t\t\treturn parse(Int64, n[2]*n[3]*n[1])\n\t\t\tend\n\t\telse\n\t\t\tif n[1] < n[3]\n\t\t\t\treturn parse(Int64, n[3]*n[1]*n[2])\n\t\t\telse\n\t\t\t\treturn -1\n\t\t\tend\n\t\tend\n\tend\n\tif length(n) > 3\n\t\tif n[1] < n[2]\n\t\t\tif n[2] < n[3]\n\t\t\t\treturn parse(Int64, n[3]*n[1]*n[2]*n[4:end])\n\t\t\telse\n\t\t\t\treturn parse(Int64, n[2]*n[3]*n[1]*n[4:end])\n\t\t\tend\n\t\telse\n\t\t\tif n[1] < n[3]\n\t\t\t\treturn parse(Int64, n[3]*n[1]*n[2]*n[4:end])\n\t\t\telse\n\t\t\t\treturn -1\n\t\t\tend\n\t\tend\n\tend\nend",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 12345678901234567890\n\t# n = 1234567890123456789012345678901234567890\n\t# n = 12345678901234567890123456789012345678901234567890123456789012345678901234567890\n\t# n = 123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789",
    "\tn_str = string(n)\n\tn_len = length(n_str)\n\tfor i in n_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tj = i\n\t\t\twhile j < n_len && n_str[j] > n_str[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tn_str[i-1], n_str[j-1] = n_str[j-1], n_str[i-1]\n\t\t\tn_str[i:n_len] = sort(n_str[i:n_len])\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i = n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tn_str[i-1], n_str[i] = n_str[i], n_str[i-1]\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12453\n\t\n\tjulia> rearrange_bigger(12453)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t12543\n\t\n\tjulia> rearrange_bigger(12543)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t154",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i in n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tn_str[i], n_str[i-1] = n_str[i-1], n_str[i]\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t\n\t# get the length of the string\n\tn_len = length(n_str)\n\t\n\t# create a vector of the digits\n\tdigits = zeros(Int64, n_len)\n\tfor i = 1:n_len\n\t\tdigits[i] = parse(Int64, n_str[i])\n\tend\n\t\n\t# find the first digit that is smaller than the digit to its right\n\tfor i = 1:n_len-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, return -1\n\tif i == n_len\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the digit found above that is larger than it\n\tsmallest = i+1\n\tfor j = i+2:n_len\n\t\tif digits[j] > digits[i] && digits[j] < digits[smallest]\n\t\t\tsmallest = j\n\t\tend\n\tend\n\t\n\t# swap the two digits\n\tdigits[i], digits[smallest] = digits[smallest], digits[i]\n\t\n\t# sort the digits to the right of the digit found above in ascending order\n\tdigits[i+1:n_len] = sort(digits[i+1:n_len])\n\t\n\t# convert the digits back to an integer\n\tnew_n = 0\n\tfor i = 1:n_len\n\t\tnew_n = new_n*10 + digits[i]\n\tend\n\t\n\treturn new_n\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] > digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# create a vector of digits\n\tdigits = digits(n)\n\t# find the first digit that is smaller than the next digit\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the smallest digit that is bigger than the current digit\n\t\t\tsmallest = digits[i+1]\n\t\t\tsmallest_index = i+1\n\t\t\tfor j in i+2:length(digits)\n\t\t\t\tif digits[j] > digits[i] && digits[j] < smallest\n\t\t\t\t\tsmallest = digits[j]\n\t\t\t\t\tsmallest_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the digits\n\t\t\tdigits[i], digits[smallest_index] = digits[smallest_index], digits[i]\n\t\t\t# sort the digits after the current digit\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\t# return the number\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t# if no digit is smaller than the next digit, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tn_arr = zeros(Int64, n_str_len)\n\tfor i in 1:n_str_len\n\t\tn_arr[i] = parse(Int64, n_str[i])\n\tend\n\tn_arr_sorted = sort(n_arr, rev=true)\n\tif n_arr == n_arr_sorted\n\t\treturn -1\n\tend\n\tn_arr_sorted_str = \"\"\n\tfor i in 1:n_str_len\n\t\tn_arr_sorted_str *= string(n_arr_sorted[i])\n\tend\n\tn_arr_sorted_int = parse(Int64, n_arr_sorted_str)\n\tn_arr_sorted_int_str = string(n_arr_sorted_int)\n\tn_arr_sorted_int_str_len = length(n_arr_sorted_int_str)\n\tn_arr_sorted_int_str_len_half = div(n_arr_sorted_int_str_len, 2)\n\tn_arr_sorted_int_str_len_half_floor = floor(n_arr_sorted_int_str_len_half)\n\tn_arr_sorted_int_str_len_half_ceil = ceil(n_arr_sorted_int_str_len_half)\n\tn_arr_sorted_int_str_len_half_diff = n_arr_sorted_int_str_len_half_ceil - n_arr_sorted_int_str_len_half_floor\n\tn_arr_sorted_int_str_len_half_diff_half = div(n_arr_sorted_int_str_len_half_diff, 2)\n\tn_arr_sorted_int_str_len_half_diff_half_floor = floor(n_arr_sorted_int_str_len_half_diff_half)\n\tn_arr_sorted_int_str_len_half_diff",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tfor j in i+1:length(digits)\n\t\t\tif digits[i] < digits[j]\n\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\treturn parse(Int64, join(digits))\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(123)\n\t132\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(1243)\n\t1324\n\t\n\tjulia> rearrange_bigger(1324)\n\t1342\n\t\n\tjulia> rearrange_bigger(1342)\n\t1423\n\t\n\tjulia> rearrange_bigger(1423)\n\t1432\n\t\n\tjulia> rearrange_bigger(1432)\n\t2134\n\t\n\tjulia> rearrange_bigger(2134)\n\t2314\n\t\n\tjulia> rearrange_bigger(2314)\n\t2341\n\t\n\tjulia> rearrange_bigger(2341)\n\t2413\n\t\n\tjulia> rearrange_bigger(2413)\n\t2431\n\t\n\tjulia> rearrange_bigger(2431)\n\t3124\n\t\n\tjulia> rearrange_bigger(3124)\n\t3142\n\t\n\tjulia> rearrange_bigger(3142)\n\t3214\n\t\n\tjulia> rearrange_bigger(3214)\n\t3241\n\t\n\tjulia> rearrange_bigger(3241)\n\t3412\n\t\n\tjulia> rearrange_bigger(3412)\n\t3421\n\t\n\tjulia> rearrange_bigger(3421)\n\t4123\n\t\n\tjulia> rearrange_bigger(4123)\n\t4132\n\t\n\tjulia> rearrange_bigger(4132)\n\t4213\n\t\n\tjulia> rearrange_bigger(4213)\n\t4231\n\t\n\tjulia> rearrange_bigger(4231)\n\t4312\n\t\n\tjulia> rearrange_bigger(4312)\n\t4321\n",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[i] < digits[j]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\ti = length(digits) - 1\n\twhile i > 1\n\t\tif digits[i] > digits[i-1]\n\t\t\tbreak\n\t\tend\n\t\ti -= 1\n\tend\n\t\n\tif i == 1\n\t\treturn -1\n\tend\n\t\n\tj = length(digits)\n\twhile j > i\n\t\tif digits[j] > digits[i-1]\n\t\t\tbreak\n\t\tend\n\t\tj -= 1\n\tend\n\t\n\tdigits[i-1], digits[j] = digits[j], digits[i-1]\n\tdigits[i:end] = reverse(digits[i:end])\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t# Get the digits of the number\n\tdigits = digits(n)\n\t# Get the length of the number\n\tn_digits = length(digits)\n\t# Get the index of the first digit that is smaller than the next digit\n\tfor i in 1:n_digits-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# If the number is already the biggest possible, return -1\n\tif i == n_digits-1\n\t\treturn -1\n\tend\n\t# Get the index of the smallest digit that is bigger than the digit at index i\n\tfor j in i+1:n_digits\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# Swap the digits at index i and j\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t# Sort the digits after index i\n\tdigits[i+1:n_digits] = sort(digits[i+1:n_digits])\n\t# Return the number\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) takes a number n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, it returns -1.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the one to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is bigger than the pivot\n\t\t\tmin_index = i+1\n\t\t\tfor j in i+2:length(n_str)\n\t\t\t\tif n_str[j] < n_str[min_index] && n_str[j] > n_str[i]\n\t\t\t\t\tmin_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the pivot with the smallest digit to its right\n\t\t\tn_str[i], n_str[min_index] = n_str[min_index], n_str[i]\n\t\t\t# sort the digits to the right of the pivot in ascending order\n\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\t# convert to int and return\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t# if no such digit is found, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the smallest digit larger than digits[i]\n\t\t\tsmallest = digits[i+1]\n\t\t\tsmallest_index = i+1\n\t\t\tfor j in i+2:length(digits)\n\t\t\t\tif digits[j] < smallest && digits[j] > digits[i]\n\t\t\t\t\tsmallest = digits[j]\n\t\t\t\t\tsmallest_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap digits[i] and smallest\n\t\t\tdigits[i], digits[smallest_index] = digits[smallest_index], digits[i]\n\t\t\t# sort the rest of the digits\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\t# return the new number\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t# if no such number exists, return -1\n\treturn -1\nend",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in length(digits):-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i-1]\n\t\t\tdigits[i-1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the number\n\tn_digits = length(digits)\n\t# get the number of permutations\n\tn_permutations = factorial(n_digits)\n\t# get the permutations of the digits\n\tpermutations = permutations(digits)\n\t# get the permutations of the digits as numbers\n\tpermutations_as_numbers = [parse(Int64, join(permutation)) for permutation in permutations]\n\t# get the permutations of the digits as numbers that are bigger than the original number\n\tpermutations_as_numbers_bigger = [permutation for permutation in permutations_as_numbers if permutation > n]\n\t# get the smallest permutation as a number\n\tsmallest_permutation_as_number = minimum(permutations_as_numbers_bigger)\n\t# return the smallest permutation as a number\n\treturn smallest_permutation_as_number\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[1:i+1]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, i) for i in n_str]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\tif i == length(n_arr)\n\t\treturn -1\n\tend\n\t# find the smallest digit to the right of the pivot that is greater than the pivot\n\tfor j in i+1:length(n_arr)\n\t\tif n_arr[j] > n_arr[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap the pivot with the smallest digit to the right of the pivot\n\tn_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n\t# reverse the digits to the right of the pivot\n\tn_arr[i+1:end] = reverse(n_arr[i+1:end])\n\t# convert to string\n\tn_str = \"\"\n\tfor i in 1:length(n_arr)\n\t\tn_str *= string(n_arr[i])\n\tend\n\t# convert to int\n\tn_int = parse(Int64, n_str)\n\treturn n_int\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[i] < digits[j]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) takes an integer n and returns the next bigger number by rearranging the digits of n.\n\tIf no bigger number can be formed, returns -1.\n\t\"\"\"\n\t\n\t# Convert n to a string\n\tn_string = string(n)\n\t\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i = 1:length(n_string)-1\n\t\tif n_string[i] < n_string[i+1]\n\t\t\tfirst_smaller_index = i\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, return -1\n\tif !defined(first_smaller_index)\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the first digit that is smaller than the digit to its right\n\tsmallest_index = first_smaller_index + 1\n\tfor i = first_smaller_index + 1:length(n_string)\n\t\tif n_string[i] < n_string[smallest_index] && n_string[i] > n_string[first_smaller_index]\n\t\t\tsmallest_index = i\n\t\tend\n\tend\n\t\n\t# Swap the first digit that is smaller than the digit to its right with the smallest digit to the right of the first digit that is smaller than the digit to its right\n\tn_string[first_smaller_index], n_string[smallest_index] = n_string[smallest_index], n_string[first_smaller_index]\n\t\n\t# Sort the digits to the right of the first digit that is smaller than the digit to its right\n\tn_string[first_smaller_index+1:end] = sort(n_string[first_smaller_index+1:end])\n\t\n\t# Convert the string back to an integer\n\treturn parse(Int64, n_string)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i = n_str_len-1:-1:1\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\tif i == 1\n\t\treturn -1\n\tend\n\tfor j = n_str_len:-1:i\n\t\tif n_str[j] > n_str[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\tn_str[i-1], n_str[j] = n_str[j], n_str[i-1]\n\tn_str[i:n_str_len] = sort(n_str[i:n_str_len])\n\treturn parse(Int64, n_str)\nend",
    "\t\"\"\"\n\tThis function rearranges the digits of a given number to create the next bigger number.\n\t\"\"\"\n\t# Convert the number to a string\n\tn_string = string(n)\n\t# Convert the string to a vector of characters\n\tn_vector = collect(n_string)\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i = 1:length(n_vector)-1\n\t\tif n_vector[i] < n_vector[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# If no such digit exists, then the number is already the largest possible\n\tif i == length(n_vector)\n\t\treturn -1\n\tend\n\t# Find the smallest digit to the right of the digit found above that is larger than the digit found above\n\tfor j = i+1:length(n_vector)\n\t\tif n_vector[j] > n_vector[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# Swap the digits found above\n\tn_vector[i], n_vector[j] = n_vector[j], n_vector[i]\n\t# Reverse the digits to the right of the digit found above\n\tn_vector[i+1:end] = reverse(n_vector[i+1:end])\n\t# Convert the vector of characters to a string\n\tn_string = join(n_vector)\n\t# Convert the string to an integer\n\tn_bigger = parse(Int64, n_string)\n\t# Return the next bigger number\n\treturn n_bigger\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tReturn the next bigger number by rearranging the digits of a given number.\n\t\n\tExample:\n\tjulia> rearrange_bigger(123)\n\t132\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(12345)\n\t12435\n\t\n\tjulia> rearrange_bigger(123456)\n\t123465\n\t\n\tjulia> rearrange_bigger(1234567)\n\t1234657\n\t\n\tjulia> rearrange_bigger(12345678)\n\t12345687\n\t\n\tjulia> rearrange_bigger(123456789)\n\t123456798\n\t\n\tjulia> rearrange_bigger(1234567890)\n\t1234567908\n\t\n\tjulia> rearrange_bigger(12345678901)\n\t12345678910\n\t\n\tjulia> rearrange_bigger(123456789012)\n\t123456789102\n\t\n\tjulia> rearrange_bigger(1234567890123)\n\t1234567890132\n\t\n\tjulia> rearrange_bigger(12345678901234)\n\t12345678901243\n\t\n\tjulia> rearrange_bigger(123456789012345)\n\t123456789012354\n\t\n\tjulia> rearrange_bigger(1234567890123456)\n\t1234567890123465\n\t\n\tjulia> rearrange_bigger(12345678901234567)\n\t12345678901234576\n\t\n\tjulia> rearrange_bigger(123456789012345678)\n\t123456789012345687\n\t\n\tjulia> rearrange_bigger(1234567890123456789)\n\t1234567890123456798\n\t\n\tjulia> rearrange_bigger(12345678901234567890)\n\t12345678901234567908\n",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert the number to a string\n\tn_str = string(n)\n\t# convert the string to a vector of characters\n\tn_vec = collect(n_str)\n\t# convert the vector of characters to a vector of integers\n\tn_vec = parse.(Int64, n_vec)\n\t# sort the vector of integers in descending order\n\tn_vec = sort(n_vec, rev=true)\n\t# convert the vector of integers to a string\n\tn_str = join(n_vec)\n\t# convert the string to an integer\n\tn_int = parse(Int64, n_str)\n\t# return the integer\n\treturn n_int\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the digits\n\tlen_digits = length(digits)\n\t# get the last digit\n\tlast_digit = digits[len_digits]\n\t# get the second last digit\n\tsecond_last_digit = digits[len_digits-1]\n\t# if the last digit is greater than the second last digit\n\tif last_digit > second_last_digit\n\t\t# swap the last and second last digit\n\t\tdigits[len_digits] = second_last_digit\n\t\tdigits[len_digits-1] = last_digit\n\t\t# return the digits\n\t\treturn digits\n\t# if the last digit is not greater than the second last digit\n\telse\n\t\t# return -1\n\t\treturn -1\n\tend\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tCreate the next bigger number by rearranging the digits of a given number.\n\t\n\tExample:\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t12543\n\t\n\tjulia> rearrange_bigger(12543)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tswap!(digits, i, i+1)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the first digit that is smaller than the next digit\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit that is bigger than n_str[i]\n\t\t\tsmallest_bigger_index = i+1\n\t\t\tfor j in i+2:length(n_str)\n\t\t\t\tif n_str[j] > n_str[i] && n_str[j] < n_str[smallest_bigger_index]\n\t\t\t\t\tsmallest_bigger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap n_str[i] and n_str[smallest_bigger_index]\n\t\t\tn_str[i], n_str[smallest_bigger_index] = n_str[smallest_bigger_index], n_str[i]\n\t\t\t# sort the rest of the digits\n\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\t# convert back to integer\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t# if no bigger number exists\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\t# convert to string\n\tn_str = string(n)\n\t\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t\n\t# find the first digit that is smaller than the digit after it\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit is found, return -1\n\tif i == length(n_arr)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit that is larger than n_arr[i]\n\tsmallest_larger = n_arr[i+1]\n\tsmallest_larger_index = i+1\n\tfor j in i+2:length(n_arr)\n\t\tif n_arr[j] > n_arr[i] && n_arr[j] < smallest_larger\n\t\t\tsmallest_larger = n_arr[j]\n\t\t\tsmallest_larger_index = j\n\t\tend\n\tend\n\t\n\t# swap the digits\n\tn_arr[i], n_arr[smallest_larger_index] = n_arr[smallest_larger_index], n_arr[i]\n\t\n\t# sort the digits after the swapped digit\n\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\n\t# convert to string\n\tn_str = \"\"\n\tfor i in 1:length(n_arr)\n\t\tn_str *= string(n_arr[i])\n\tend\n\t\n\t# convert to int\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert the number to a string\n\tn_str = string(n)\n\t# convert the string to an array of characters\n\tn_arr = collect(n_str)\n\t# find the first index where the next number is smaller than the current number\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if the index is the last index, then there is no bigger number\n\tif i == length(n_arr)\n\t\treturn -1\n\tend\n\t# find the smallest number that is bigger than the current number\n\tsmallest_bigger = n_arr[i+1]\n\tsmallest_bigger_index = i+1\n\tfor j in i+1:length(n_arr)\n\t\tif n_arr[j] > n_arr[i] && n_arr[j] < smallest_bigger\n\t\t\tsmallest_bigger = n_arr[j]\n\t\t\tsmallest_bigger_index = j\n\t\tend\n\tend\n\t# swap the smallest bigger number with the current number\n\tn_arr[i], n_arr[smallest_bigger_index] = n_arr[smallest_bigger_index], n_arr[i]\n\t# sort the remaining numbers\n\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t# convert the array to a string\n\tn_str = join(n_arr)\n\t# convert the string to an integer\n\tn_int = parse(Int64, n_str)\n\treturn n_int\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn join(digits)\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\ts = string(n)\n\t# convert to array of chars\n\ta = collect(s)\n\t# find the first index that is smaller than the next index\n\tfor i in 1:length(a)-1\n\t\tif a[i] < a[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no such index exists, return -1\n\tif i == length(a)-1\n\t\treturn -1\n\tend\n\t# find the smallest number that is bigger than a[i] and is on the right of a[i]\n\tmin_index = i+1\n\tfor j in i+2:length(a)\n\t\tif a[j] > a[i] && a[j] < a[min_index]\n\t\t\tmin_index = j\n\t\tend\n\tend\n\t# swap a[i] and a[min_index]\n\ttemp = a[i]\n\ta[i] = a[min_index]\n\ta[min_index] = temp\n\t# sort the array from a[i+1] to the end\n\ta[i+1:end] = sort(a[i+1:end])\n\t# convert the array back to string and return\n\treturn parse(Int64, join(a))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExamples\n\t\n\tjulia> rearrange_bigger(12)\n\t21\n\t\n\tjulia> rearrange_bigger(513)\n\t531\n\t\n\tjulia> rearrange_bigger(2017)\n\t2071\n\t\n\tjulia> rearrange_bigger(414)\n\t441\n\t\n\tjulia> rearrange_bigger(144)\n\t414\n\t\"\"\"\n\t\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)\n\t\tif digits[i] > digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tdigits = digits[1:i] * sort(digits[i+1:end])\n\t\t\t\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t\"\"\"\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tif n_len == 1\n\t\treturn -1\n\tend\n\tfor i = n_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\ttemp = n_str[i]\n\t\t\tn_str[i] = n_str[i-1]\n\t\t\tn_str[i-1] = temp\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tThis function takes an integer and returns the next bigger number by rearranging the digits of a given number.\n\tIf no bigger number can be composed using those digits, return -1.\n\t\"\"\"\n\t\n\t# get the digits of the number\n\tdigits = digits(n)\n\t\n\t# get the length of the number\n\tn_len = length(digits)\n\t\n\t# get the permutations of the digits\n\tperms = permutations(digits)\n\t\n\t# get the length of the permutations\n\tperms_len = length(perms)\n\t\n\t# create a vector to store the permutations\n\tperms_vec = zeros(Int64, perms_len)\n\t\n\t# convert the permutations to integers\n\tfor i in 1:perms_len\n\t\tperms_vec[i] = parse(Int64, join(perms[i]))\n\tend\n\t\n\t# sort the permutations\n\tperms_vec = sort(perms_vec)\n\t\n\t# find the index of the number in the permutations\n\tindex = findfirst(perms_vec, n)\n\t\n\t# if the number is the last permutation, return -1\n\tif index == perms_len\n\t\treturn -1\n\telse\n\t\treturn perms_vec[index+1]\n\tend\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tlen = length(digits)\n\tfor i in 1:len-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:len\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# get digits of n\n\tdigits = digits(n)\n\t# get the index of the first digit that is smaller than the digit to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tindex = i\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\tif index == nothing\n\t\treturn -1\n\tend\n\t# get the smallest digit to the right of the digit at index that is larger than the digit at index\n\tfor i in index+1:length(digits)\n\t\tif digits[i] > digits[index]\n\t\t\tsmallest_index = i\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap the digits at index and smallest_index\n\tdigits[index], digits[smallest_index] = digits[smallest_index], digits[index]\n\t# sort the digits to the right of index\n\tdigits[index+1:end] = sort(digits[index+1:end])\n\t# convert the digits back to an integer\n\treturn parse(Int64, join(digits))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n::Int64) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t213",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 0\n\t\treturn \"Error: n must be a positive integer\"\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tif length(digits) == 1\n\t\treturn \"No bigger number possible\"\n\tend\n\t\n\tif length(digits) == 2\n\t\tif digits[1] > digits[2]\n\t\t\treturn n\n\t\telse\n\t\t\treturn digits[2]*10 + digits[1]\n\t\tend\n\tend\n\t\n\tfor i in length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tfor j in i:length(digits)\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\ttemp = digits[j]\n\t\t\t\t\tdigits[j] = digits[i-1]\n\t\t\t\t\tdigits[i-1] = temp\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\treturn parse(Int64, join(digits[1:i]))*10^(length(digits)-i) + parse(Int64, join(digits[i:length(digits)]))\n\t\tend\n\tend\n\t\n\treturn \"No bigger number possible\"\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[i] < digits[j]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\treturn parse(Int64, join(reverse(digits[i+1:end]), digits[1:i]))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits, \"\"))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = findfirst(x -> x > digits[i-1], digits[i:end])\n\t\t\tdigits[i-1], digits[i+j-1] = digits[i+j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the number\n\tn_digits = length(digits)\n\t# get the first digit\n\tfirst_digit = digits[1]\n\t# get the last digit\n\tlast_digit = digits[end]\n\t# get the second last digit\n\tsecond_last_digit = digits[end-1]\n\t# get the third last digit\n\tthird_last_digit = digits[end-2]\n\t# get the fourth last digit\n\tfourth_last_digit = digits[end-3]\n\t# get the fifth last digit\n\tfifth_last_digit = digits[end-4]\n\t# get the sixth last digit\n\tsixth_last_digit = digits[end-5]\n\t# get the seventh last digit\n\tseventh_last_digit = digits[end-6]\n\t# get the eighth last digit\n\teighth_last_digit = digits[end-7]\n\t# get the ninth last digit\n\tninth_last_digit = digits[end-8]\n\t# get the tenth last digit\n\ttenth_last_digit = digits[end-9]\n\t# get the eleventh last digit\n\televenth_last_digit = digits[end-10]\n\t# get the twelfth last digit\n\ttwelfth_last_digit = digits[end-11]\n\t# get the thirteenth last digit\n\tthirteenth_last_digit = digits[end-12]\n\t# get the fourteenth last digit\n\tfourteenth_last_digit = digits[end-13]\n\t# get the fifteenth last digit\n\tfifteenth_last_digit = digits[end-14]\n\t# get the sixteenth last digit\n\tsixteenth_last_digit = digits[end-15]\n\t# get the seventeenth last digit\n\tseventeenth_last_digit = digits[end-16]\n\t# get the eighteenth last digit\n\teighteenth_last_digit = digits[end-17]\n\t# get the nineteenth last digit\n\tnineteenth_last_digit = digits[end-18]\n\t# get the twentieth last digit\n\ttwentieth_last_digit = digits",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# if n is a single digit, then there is no bigger number\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\t# convert n to a string\n\tn_str = string(n)\n\t\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if there is no such digit, then n is the largest possible number\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of i that is larger than n_str[i]\n\tsmallest_larger = i+1\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i] && n_str[j] < n_str[smallest_larger]\n\t\t\tsmallest_larger = j\n\t\tend\n\tend\n\t\n\t# swap n_str[i] and n_str[smallest_larger]\n\tn_str[i], n_str[smallest_larger] = n_str[smallest_larger], n_str[i]\n\t\n\t# sort the digits to the right of i\n\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\n\t# convert n_str to an integer and return it\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the digit after it\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if all digits are in descending order, there is no bigger number\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit that is larger than digits[i]\n\tsmallest_larger = i+1\n\tfor j in i+2:length(digits)\n\t\tif digits[j] > digits[i] && digits[j] < digits[smallest_larger]\n\t\t\tsmallest_larger = j\n\t\tend\n\tend\n\t\n\t# swap the two digits\n\tdigits[i], digits[smallest_larger] = digits[smallest_larger], digits[i]\n\t\n\t# sort the digits after the swapped digit\n\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\n\t# convert the array of digits to a number\n\treturn parse(Int64, join(digits))\nend",
    "\t# find the first digit that is smaller than the digit to its right\n\t# and swap it with the smallest digit to its right that is larger than it\n\t# then sort the digits to the right of the swapped digit\n\t# if no such digit exists, return -1\n\tn_str = string(n)\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find smallest digit to the right\n\t\t\tmin_idx = i+1\n\t\t\tfor j in i+2:length(n_str)\n\t\t\t\tif n_str[j] < n_str[min_idx]\n\t\t\t\t\tmin_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap\n\t\t\tn_str[i], n_str[min_idx] = n_str[min_idx], n_str[i]\n\t\t\t# sort\n\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i = n_str_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tfor j = n_str_len:-1:i\n\t\t\t\tif n_str[j] > n_str[i-1]\n\t\t\t\t\tn_str[i-1], n_str[j] = n_str[j], n_str[i-1]\n\t\t\t\t\tn_str[i:end] = sort(n_str[i:end])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] > digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first digit that is smaller than the next digit\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit that is bigger than n_arr[i]\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i]\n\t\t\t\t\t# swap the digits\n\t\t\t\t\tn_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n\t\t\t\t\t# sort the digits after the swapped digit\n\t\t\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t\t\t# convert to string\n\t\t\t\t\tn_str = join(n_arr)\n\t\t\t\t\t# convert to int\n\t\t\t\t\tn_int = parse(Int64, n_str)\n\t\t\t\t\t# return the number\n\t\t\t\t\treturn n_int\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# if no bigger number exists\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# swap\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tCreate the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the next one\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, then the number is already the largest possible\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(digits)\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to the right of the pivot\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# reverse the digits to the right of the pivot\n\tdigits[i+1:end] = reverse(digits[i+1:end])\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t-------\n\tjulia> rearrange_bigger(12)\n\t21\n\t\n\tjulia> rearrange_bigger(513)\n\t531\n\t\n\tjulia> rearrange_bigger(2017)\n\t2071\n\t\n\tjulia> rearrange_bigger(414)\n\t441\n\t\n\tjulia> rearrange_bigger(144)\n\t414\n\t\n\t\"\"\"\n\t\n\tdigits = digits(n)\n\t\n\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, then the number is already the largest possible\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(digits)\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the pivot with the smallest digit to the right of the pivot\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# Sort the digits to the right of the pivot\n\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\n\t# Convert the digits to a number\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\n\tExample:\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t21354\n\t\n\tjulia> rearr",
    "\t# Find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n)-1\n\t\tif n[i] < n[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# If no such digit exists, the number is already the largest possible\n\tif i == length(n)-1\n\t\treturn -1\n\tend\n\t# Find the smallest digit to the right of the digit found above that is larger than it\n\tfor j in i+1:length(n)\n\t\tif n[j] > n[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# Swap the two digits\n\tn[i], n[j] = n[j], n[i]\n\t# Sort the digits to the right of the digit found above in ascending order\n\tsort!(n[i+1:end])\n\treturn n\nend",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 1234567890\n\t# n = 12345678901\n\t# n = 123456789012\n\t# n = 1234567890123\n\t# n = 12345678901234\n\t# n = 123456789012345\n\t# n = 1234567890123456\n\t# n = 12345678901234567\n\t# n = 123456789012345678\n\t# n = 1234567890123456789\n\t# n = 12345678901234567890\n\t# n = 123456789012345678901\n\t# n = 1234567890123456789012\n\t# n = 12345678901234567890123\n\t# n = 123456789012345678901234\n\t# n = 1234567890123456789012345\n\t# n = 12345678901234567890123456\n\t# n = 123456789012345678901234567\n\t# n = 1234567890123456789012345678\n\t# n = 12345678901234567890123456789\n\t# n = 123456789012345678901234567890\n\t# n = 1234567890123456789012345678901\n\t# n = 12345678901234567890123456789012\n\t# n = 123456789012345678901234567890123\n\t# n = 1234567890123456789012345678901234\n\t# n = 12345678901234567890123456789012345\n\t# n = 123456789012345678901234567890123456\n\t# n = 1234567890123456789012345678901234567\n\t# n = 12345678901234567890123456789012345678\n\t# n = 123456789012345678901234567890123456789\n",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12)\n\t21\n\t\n\tjulia> rearrange_bigger(513)\n\t531\n\t\n\tjulia> rearrange_bigger(2017)\n\t2071\n\t\n\tjulia> rearrange_bigger(414)\n\t441\n\t\n\tjulia> rearrange_bigger(144)\n\t414\n\t\"\"\"\n\t\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tdigits[i], digits[i-1] = digits[i-1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t# convert integer to array of digits\n\tdigits = [Int(i) for i in string(n)]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 2:length(digits)\n\t\tif digits[i-1] < digits[i]\n\t\t\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\t# and swap them\n\t\t\tfor j in i:length(digits)\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\tdigits[i-1], digits[j] = digits[j], digits[i-1]\n\t\t\t\t\tbreak\n\t\t\tend\n\t\t\t# sort the digits to the right of the pivot\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\t# convert array of digits to integer\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExamples\n\t\n\tjulia> rearrange_bigger(1234)\n\t1243\n\t\n\tjulia> rearrange_bigger(4321)\n\t4321\n\t\n\tjulia> rearrange_bigger(531)\n\t531\n\t\n\tjulia> rearrange_bigger(123456789)\n\t123456798\n\t\n\tjulia> rearrange_bigger(123456798)\n\t123456879\n\t\n\tjulia> rearrange_bigger(123456879)\n\t123456897\n\t\n\tjulia> rearrange_bigger(123456897)\n\t123456978\n\t\n\tjulia> rearrange_bigger(123456978)\n\t123457689\n\t\n\tjulia> rearrange_bigger(123457689)\n\t123457869\n\t\n\tjulia> rearrange_bigger(123457869)\n\t123457896\n\t\n\tjulia> rearrange_bigger(123457896)\n\t123457968\n\t\n\tjulia> rearrange_bigger(123457968)\n\t123458769\n\t\n\tjulia> rearrange_bigger(123458769)\n\t123458967\n\t\n\tjulia> rearrange_bigger(123458967)\n\t123458976\n\t\n\tjulia> rearrange_bigger(123458976)\n\t123459678\n\t\n\tjulia> rearrange_bigger(123459678)\n\t123459768\n\t\n\tjulia> rearrange_bigger(123459768)\n\t123459786\n\t\n\tjulia> rearrange_bigger(123459786)\n\t123459867\n\t\n\tjulia> rearrange_bigger(123459867)\n\t123459876\n\t\n\tjulia> rearrange_bigger(123459876)\n\t",
    "\tdigits = digits(n)\n\tif length(digits) == 1\n\t\treturn -1\n\tend\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tdigits = digits(n)\n\tfor i = length(digits)-1:-1:1\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_len = length(n_str)\n\tfor i in n_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tfor j in i:n_len\n\t\t\t\tif n_str[j] > n_str[i-1]\n\t\t\t\t\tn_str[i-1], n_str[j] = n_str[j], n_str[i-1]\n\t\t\t\t\tn_str = n_str[1:i] * sort(n_str[i:n_len])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[i:end]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tif n < 10\n\t\treturn -1\n\tend\n\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tstr = string(n)\n\t#convert to array\n\tarr = [parse(Int64,i) for i in str]\n\t#find the first number that is smaller than the number to its right\n\tfor i in 1:length(arr)-1\n\t\tif arr[i] < arr[i+1]\n\t\t\t#find the smallest number to the right of the number that is greater than it\n\t\t\tfor j in i+1:length(arr)\n\t\t\t\tif arr[j] > arr[i]\n\t\t\t\t\t#swap the two numbers\n\t\t\t\t\ttemp = arr[i]\n\t\t\t\t\tarr[i] = arr[j]\n\t\t\t\t\tarr[j] = temp\n\t\t\t\t\t#sort the numbers to the right of the swapped number\n\t\t\t\t\tarr[i+1:length(arr)] = sort(arr[i+1:length(arr)])\n\t\t\t\t\t#convert to string\n\t\t\t\t\tstr = \"\"\n\t\t\t\t\tfor k in arr\n\t\t\t\t\t\tstr = str * string(k)\n\t\t\t\t\t#convert to integer\n\t\t\t\t\treturn parse(Int64,str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end], rev=true)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t21354\n\t",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# find the next biggest digit\n\t\t\tnext_biggest = digits[i+1]\n\t\t\tnext_biggest_index = i+1\n\t\t\tfor j in i+2:length(digits)\n\t\t\t\tif digits[j] > digits[i] && digits[j] < next_biggest\n\t\t\t\t\tnext_biggest = digits[j]\n\t\t\t\t\tnext_biggest_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the digits\n\t\t\tdigits[i], digits[next_biggest_index] = digits[next_biggest_index], digits[i]\n\t\t\t# sort the rest of the digits\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, x) for x in n_str]\n\t# find the first digit that is smaller than the next digit\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit that is bigger than the current digit\n\t\t\tsmallest_bigger = n_arr[i+1]\n\t\t\tsmallest_bigger_index = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < smallest_bigger\n\t\t\t\t\tsmallest_bigger = n_arr[j]\n\t\t\t\t\tsmallest_bigger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the smallest bigger digit with the current digit\n\t\t\ttemp = n_arr[i]\n\t\t\tn_arr[i] = n_arr[smallest_bigger_index]\n\t\t\tn_arr[smallest_bigger_index] = temp\n\t\t\t# sort the digits after the current digit\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = join(n_arr, \"\")\n\t\t\t# convert to int\n\t\t\tn = parse(Int64, n_str)\n\t\t\treturn n\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first digit that is smaller than the next digit\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit that is bigger than n_arr[i]\n\t\t\tmin_idx = i+1\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < n_arr[min_idx]\n\t\t\t\t\tmin_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the two digits\n\t\t\tn_arr[i], n_arr[min_idx] = n_arr[min_idx], n_arr[i]\n\t\t\t# sort the rest of the digits\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# return the result\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\t# if no such digit is found, return -1\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int,i) for i in n_str]\n\t# find the first digit that is smaller than the next digit\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit that is bigger than the digit at i\n\t\t\tsmallest_bigger = n_arr[i+1]\n\t\t\tsmallest_bigger_index = i+1\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < smallest_bigger\n\t\t\t\t\tsmallest_bigger = n_arr[j]\n\t\t\t\t\tsmallest_bigger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the digits\n\t\t\tn_arr[i], n_arr[smallest_bigger_index] = n_arr[smallest_bigger_index], n_arr[i]\n\t\t\t# sort the digits after i\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = \"\"\n\t\t\tfor i in n_arr\n\t\t\t\tn_str *= string(i)\n\t\t\tend\n\t\t\t# convert to int\n\t\t\tn = parse(Int,n_str)\n\t\t\treturn n\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_string = string(n)\n\tn_array = [parse(Int64, n_string[i]) for i in 1:length(n_string)]\n\tn_array_sorted = sort(n_array, rev=true)\n\tif n_array == n_array_sorted\n\t\treturn -1\n\telse\n\t\tfor i in 1:length(n_array)\n\t\t\tif n_array[i] != n_array_sorted[i]\n\t\t\t\tn_array[i] = n_array_sorted[i]\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn parse(Int64, join(n_array))\n\tend\nend",
    "\t\"\"\"\n\trearrange_bigger(n)\n\t\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\n\tParameters\n\t----------\n\tn : Int64\n\t\tThe number to rearrange.\n\t\n\tReturns\n\t-------\n\tAny\n\t\tThe next bigger number, or -1 if no bigger number can be found.\n\t\"\"\"\n\t\n\t# Convert the number to a string\n\tn_str = string(n)\n\t\n\t# Find the first digit from the right that is smaller than the one to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[end-i] < n_str[end-i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# If no such digit exists, return -1\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t\n\t# Find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i:length(n_str)-1\n\t\tif n_str[end-j] > n_str[end-i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Swap the pivot with the smallest digit to its right\n\tn_str[end-i], n_str[end-j] = n_str[end-j], n_str[end-i]\n\t\n\t# Sort the digits to the right of the pivot\n\tn_str[end-i+1:end] = sort(n_str[end-i+1:end])\n\t\n\t# Return the next bigger number\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\t# swap\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tn_str = string(n)\n\tn_len = length(n_str)\n\tn_arr = collect(n_str)\n\tfor i in 1:n_len-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tfor j in i+1:n_len\n\t\t\t\tif n_arr[i] < n_arr[j]\n\t\t\t\t\ttemp = n_arr[i]\n\t\t\t\t\tn_arr[i] = n_arr[j]\n\t\t\t\t\tn_arr[j] = temp\n\t\t\t\t\tn_arr[i+1:n_len] = sort(n_arr[i+1:n_len])\n\t\t\t\t\treturn parse(Int64, join(n_arr))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#rearrange the digits of a given number to create the next bigger number\n\t#if no bigger number exists, return -1\n\t#if n is negative, return -1\n\t#if n is 0, return -1\n\tif n < 0\n\t\treturn -1\n\tend\n\tif n == 0\n\t\treturn -1\n\tend\n\t#convert n to a string\n\tn_string = string(n)\n\t#convert n_string to an array of characters\n\tn_array = collect(n_string)\n\t#find the first index where the value is less than the value to the right\n\ti = 1\n\twhile n_array[i] >= n_array[i+1]\n\t\ti += 1\n\t\tif i == length(n_array)\n\t\t\treturn -1\n\t\tend\n\tend\n\t#find the first index where the value is greater than the value to the left\n\tj = i + 1\n\twhile n_array[j] <= n_array[i]\n\t\tj += 1\n\tend\n\t#swap the values at i and j\n\ttemp = n_array[i]\n\tn_array[i] = n_array[j]\n\tn_array[j] = temp\n\t#reverse the array from i+1 to the end\n\tn_array[i+1:end] = reverse(n_array[i+1:end])\n\t#convert the array back to a string\n\tn_string = join(n_array)\n\t#convert the string back to an integer\n\tn_int = parse(Int64, n_string)\n\t#return the integer\n\treturn n_int\nend",
    "\t#rearrange the digits of a given number to create the next bigger number\n\t#if no bigger number exists, return -1\n\t#if n is negative, return -1\n\t#if n is 0, return -1\n\t#if n is a single digit, return -1\n\t#if n is a palindrome, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -1\n\t#if n is a palindrome with a single digit, return -",
    "\t\"\"\"\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tfor i in 1:n_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_len\n\t\t\t\tif n_str[i] < n_str[j]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is greater than the pivot\n\t\t\tmin_idx = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] < n_arr[min_idx] && n_arr[j] > n_arr[i]\n\t\t\t\t\tmin_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the pivot with the smallest digit to its right\n\t\t\tn_arr[i], n_arr[min_idx] = n_arr[min_idx], n_arr[i]\n\t\t\t# sort the digits to the right of the pivot in ascending order\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = join(n_arr)\n\t\t\t# convert to integer\n\t\t\tn_int = parse(Int64, n_str)\n\t\t\treturn n_int\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\tInput:\n\t\tn: Int64\n\tOutput:\n\t\tAny\n\t\"\"\"\n\tn_string = string(n)\n\tn_length = length(n_string)\n\tn_array = zeros(Int64, n_length)\n\tfor i in 1:n_length\n\t\tn_array[i] = parse(Int64, n_string[i])\n\tend\n\tfor i in n_length:-1:2\n\t\tif n_array[i] > n_array[i-1]\n\t\t\tfor j in i:n_length\n\t\t\t\tif n_array[j] > n_array[i-1]\n\t\t\t\t\ttemp = n_array[j]\n\t\t\t\t\tn_array[j] = n_array[i-1]\n\t\t\t\t\tn_array[i-1] = temp\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tn_array[i:n_length] = sort(n_array[i:n_length])\n\t\t\tbreak\n\t\tend\n\tend\n\tif n_array == zeros(Int64, n_length)\n\t\treturn -1\n\telse\n\t\treturn parse(Int64, join(n_array, \"\"))\n\tend\nend",
    "\t# if n is a single digit, return -1\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\t# convert n to a string\n\tn_str = string(n)\n\t\n\t# find the first digit from the right that is smaller than the digit to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[end-i] > n_str[end-i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, return -1\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is greater than the pivot\n\tmin_index = end-i+1\n\tfor j in end-i+1:length(n_str)\n\t\tif n_str[j] > n_str[end-i] && n_str[j] < n_str[min_index]\n\t\t\tmin_index = j\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to its right\n\tn_str[end-i], n_str[min_index] = n_str[min_index], n_str[end-i]\n\t\n\t# sort the digits to the right of the pivot in ascending order\n\tn_str[end-i+1:end] = sort(n_str[end-i+1:end])\n\t\n\t# return the new number\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tfor j = length(digits):-1:i\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\ttemp = digits[j]\n\t\t\t\t\tdigits[j] = digits[i-1]\n\t\t\t\t\tdigits[i-1] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[i:end]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the number of digits\n\tn_digits = length(digits)\n\t# get the index of the first digit that is smaller than the digit to its right\n\tfor i = 1:n_digits-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no such digit exists, return -1\n\tif i == n_digits\n\t\treturn -1\n\tend\n\t# get the index of the smallest digit to the right of the digit at index i that is larger than the digit at index i\n\tfor j = i+1:n_digits\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap the digits at indices i and j\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t# sort the digits to the right of index i\n\tdigits[i+1:n_digits] = sort(digits[i+1:n_digits])\n\t# return the number\n\treturn parse(Int64, join(digits))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first decreasing element\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest element greater than n_arr[i]\n\t\t\tmin_greater = n_arr[i+1]\n\t\t\tmin_greater_index = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] > n_arr[i] && n_arr[j] < min_greater\n\t\t\t\t\tmin_greater = n_arr[j]\n\t\t\t\t\tmin_greater_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the elements\n\t\t\tn_arr[i], n_arr[min_greater_index] = n_arr[min_greater_index], n_arr[i]\n\t\t\t# sort the rest of the array\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = join(n_arr)\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any \n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t213",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits[i:end]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [Int(i) for i in n_str]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# swap the two digits\n\t\t\tn_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n\t\t\t# sort the digits to the right of the swapped digits\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert to string\n\t\t\tn_str = join(n_arr)\n\t\t\t# convert to int\n\t\t\tn_int = parse(Int64, n_str)\n\t\t\treturn n_int\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[1:i]..., join(sort(digits[i+1:end]...))))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\ti = length(digits) - 1\n\twhile i > 1 && digits[i] <= digits[i-1]\n\t\ti -= 1\n\tend\n\tif i == 1\n\t\treturn -1\n\tend\n\tj = length(digits)\n\twhile digits[j] <= digits[i-1]\n\t\tj -= 1\n\tend\n\tdigits[i-1], digits[j] = digits[j], digits[i-1]\n\tdigits[i:end] = reverse(digits[i:end])\n\treturn parse(Int64, join(digits))\nend",
    "\t\"\"\"\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tn_arr = collect(n_str)\n\tfor i in n_len:-1:2\n\t\tif n_arr[i] > n_arr[i-1]\n\t\t\tn_arr[i-1], n_arr[i] = n_arr[i], n_arr[i-1]\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tfor j = length(digits):-1:i\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\tdigits[i-1], digits[j] = digits[j], digits[i-1]\n\t\t\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end], rev=true)\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n)\n\t\n\trearrange_bigger(n) returns the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:n_len]\n\tn_arr_sorted = sort(n_arr, rev=true)\n\tif n_arr == n_arr_sorted\n\t\treturn -1\n\tend\n\tfor i in 1:n_len\n\t\tif n_arr[i] != n_arr_sorted[i]\n\t\t\tn_arr[i] = n_arr_sorted[i]\n\t\t\tbreak\n\t\tend\n\tend\n\tn_arr_sorted = sort(n_arr[i+1:n_len], rev=true)\n\tn_arr[i+1:n_len] = n_arr_sorted\n\treturn parse(Int64, join(n_arr, \"\"))\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# find the last digit that is smaller than the digit to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\tsmallest_larger = n_str[i+1]\n\t\t\tsmallest_larger_index = i+1\n\t\t\tfor j in i+2:length(n_str)\n\t\t\t\tif n_str[j] > n_str[i] && n_str[j] < smallest_larger\n\t\t\t\t\tsmallest_larger = n_str[j]\n\t\t\t\t\tsmallest_larger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the pivot and the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\tn_str[i], n_str[smallest_larger_index] = n_str[smallest_larger_index], n_str[i]\n\t\t\t# sort the digits to the right of the pivot in ascending order\n\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\t# convert to int and return\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t# if no such digit is found, return -1\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first element from the right that is smaller than the next element\n\tfor i in length(n_arr):-1:2\n\t\tif n_arr[i] > n_arr[i-1]\n\t\t\t# find the smallest element from the right that is bigger than the element found\n\t\t\tfor j in length(n_arr):i\n\t\t\t\tif n_arr[j] > n_arr[i-1]\n\t\t\t\t\t# swap the two elements\n\t\t\t\t\tn_arr[i-1], n_arr[j] = n_arr[j], n_arr[i-1]\n\t\t\t\t\t# sort the rest of the array\n\t\t\t\t\tn_arr[i:end] = sort(n_arr[i:end])\n\t\t\t\t\t# convert to string\n\t\t\t\t\tn_str = join(n_arr)\n\t\t\t\t\t# convert to int\n\t\t\t\t\tn_int = parse(Int64, n_str)\n\t\t\t\t\t# return the result\n\t\t\t\t\treturn n_int\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# return -1 if no bigger number can be found\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tThis function takes an integer n and returns the next bigger integer by rearranging its digits.\n\tIf no bigger integer can be formed, it returns -1.\n\t\"\"\"\n\t\n\t# convert n to a string\n\tn_str = string(n)\n\t\n\t# convert n_str to an array of characters\n\tn_array = collect(n_str)\n\t\n\t# find the first index from the right where the digit is smaller than the digit to its right\n\t# if no such index exists, return -1\n\tfor i in length(n_array):-1:1\n\t\tif n_array[i] < n_array[i+1]\n\t\t\tbreak\n\t\telseif i == 1\n\t\t\treturn -1\n\t\tend\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\t# swap the pivot with this digit\n\tpivot = n_array[i]\n\tfor j in i+1:length(n_array)\n\t\tif n_array[j] > pivot\n\t\t\tn_array[i] = n_array[j]\n\t\t\tn_array[j] = pivot\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# reverse the digits to the right of the pivot\n\tn_array[i+1:length(n_array)] = reverse(n_array[i+1:length(n_array)])\n\t\n\t# convert the array of characters back to a string\n\tn_str = join(n_array)\n\t\n\t# convert the string back to an integer\n\tn_int = parse(Int64, n_str)\n\t\n\treturn n_int\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\tReturns the next bigger number by rearranging the digits of a given number.\n\t\n\t>>> rearrange_bigger(12)\n\t21\n\t>>> rearrange_bigger(513)\n\t531\n\t>>> rearrange_bigger(2017)\n\t2071\n\t>>> rearrange_bigger(414)\n\t441\n\t>>> rearrange_bigger(144)\n\t414\n\t\"\"\"\n\t\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, the number is already the largest possible\n\tif i == length(digits)-1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i+1:length(digits)\n\t\tif digits[j] > digits[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to the right of the pivot\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t\n\t# reverse the digits to the right of the pivot\n\tdigits[i+1:end] = reverse(digits[i+1:end])\n\t\n\treturn parse(Int64, join(digits))\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#convert to array\n\tn_arr = [parse(Int64, x) for x in n_str]\n\t#find the first digit that is smaller than the one to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t#find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\tmin_idx = i+1\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] < n_arr[min_idx] && n_arr[j] > n_arr[i]\n\t\t\t\t\tmin_idx = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t#swap the pivot with the smallest digit to its right\n\t\t\ttemp = n_arr[i]\n\t\t\tn_arr[i] = n_arr[min_idx]\n\t\t\tn_arr[min_idx] = temp\n\t\t\t#sort the digits to the right of the pivot in ascending order\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\tbreak\n\t\tend\n\tend\n\t#convert to string\n\tn_str = \"\"\n\tfor i in 1:length(n_arr)\n\t\tn_str = n_str * string(n_arr[i])\n\tend\n\t#convert to int\n\tn_int = parse(Int64, n_str)\n\t#return the result\n\treturn n_int\nend",
    "\t#rearrange the digits of a given number to create the next bigger number\n\t#if no bigger number exists, return -1\n\t#if the number is a palindrome, return -1\n\t#if the number is a single digit, return -1\n\t#if the number is a two digit number, return -1\n\t#if the number is a three digit number, return -1\n\t#if the number is a four digit number, return -1\n\t#if the number is a five digit number, return -1\n\t#if the number is a six digit number, return -1\n\t#if the number is a seven digit number, return -1\n\t#if the number is an eight digit number, return -1\n\t#if the number is a nine digit number, return -1\n\t#if the number is a ten digit number, return -1\n\t#if the number is an eleven digit number, return -1\n\t#if the number is a twelve digit number, return -1\n\t#if the number is a thirteen digit number, return -1\n\t#if the number is a fourteen digit number, return -1\n\t#if the number is a fifteen digit number, return -1\n\t#if the number is a sixteen digit number, return -1\n\t#if the number is a seventeen digit number, return -1\n\t#if the number is an eighteen digit number, return -1\n\t#if the number is a nineteen digit number, return -1\n\t#if the number is a twenty digit number, return -1\n\t#if the number is a twenty one digit number, return -1\n\t#if the number is a twenty two digit number, return -1\n\t#if the number is a twenty three digit number, return -1\n\t#if the number is a twenty four digit number, return -1\n\t#if the number is a twenty five digit number, return -1\n\t#if the number is a twenty six digit number, return -1\n\t#if the number is a twenty seven digit number, return -1\n\t#if the number is a twenty eight digit number, return -1\n\t#if the number is a twenty nine digit number, return -1\n\t#if the number is a thirty digit number, return -1\n\t#if the number is a thirty",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits[i:length(digits)]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Nothing\n\t\n\trearrange_bigger(n::Int64) -> String\n\t\n\trearrange_bigger(n::Int64) -> Bool\n\t\n\trearrange_bigger(n::Int64) -> Float64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> Int64",
    "\t# convert to string\n\ts = string(n)\n\t# convert to array\n\ta = [parse(Int64,s[i]) for i in 1:length(s)]\n\t# find the first number that is smaller than the next number\n\tfor i in 1:length(a)-1\n\t\tif a[i] < a[i+1]\n\t\t\t# find the smallest number that is bigger than the number\n\t\t\t# and swap them\n\t\t\tfor j in i+1:length(a)\n\t\t\t\tif a[j] > a[i]\n\t\t\t\t\ttemp = a[j]\n\t\t\t\t\ta[j] = a[i]\n\t\t\t\t\ta[i] = temp\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t# sort the rest of the array\n\t\t\ta[i+1:end] = sort(a[i+1:end])\n\t\t\t# convert to string\n\t\t\ts = \"\"\n\t\t\tfor i in 1:length(a)\n\t\t\t\ts = s * string(a[i])\n\t\t\tend\n\t\t\t# convert to int\n\t\t\treturn parse(Int64,s)\n\t\tend\n\tend\n\t# if no number is found, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in length(digits):i+1\n\t\t\t\tif digits[j] > digits[i]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(reverse(digits[i+1:end]), digits[1:i]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t#if no such digit exists, return -1\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t#find the smallest digit to the right of the pivot that is larger than the pivot\n\tmin_index = i+1\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i] && n_str[j] < n_str[min_index]\n\t\t\tmin_index = j\n\t\tend\n\tend\n\t#swap the pivot and the smallest digit to the right of the pivot\n\tn_str[i], n_str[min_index] = n_str[min_index], n_str[i]\n\t#reverse the digits to the right of the pivot\n\tn_str = n_str[1:i] * reverse(n_str[i+1:end])\n\t#convert back to integer\n\treturn parse(Int64, n_str)\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\n\tExample:\n\tjulia> rearrange_bigger(12345)\n\t12354\n\t\n\tjulia> rearrange_bigger(12354)\n\t12435\n\t\n\tjulia> rearrange_bigger(12435)\n\t12534\n\t\n\tjulia> rearrange_bigger(12534)\n\t13245\n\t\n\tjulia> rearrange_bigger(13245)\n\t13254\n\t\n\tjulia> rearrange_bigger(13254)\n\t13425\n\t\n\tjulia> rearrange_bigger(13425)\n\t13452\n\t\n\tjulia> rearrange_bigger(13452)\n\t13524\n\t\n\tjulia> rearrange_bigger(13524)\n\t13542\n\t\n\tjulia> rearrange_bigger(13542)\n\t14235\n\t\n\tjulia> rearrange_bigger(14235)\n\t14253\n\t\n\tjulia> rearrange_bigger(14253)\n\t14325\n\t\n\tjulia> rearrange_bigger(14325)\n\t14352\n\t\n\tjulia> rearrange_bigger(14352)\n\t14523\n\t\n\tjulia> rearrange_bigger(14523)\n\t14532\n\t\n\tjulia> rearrange_bigger(14532)\n\t15234\n\t\n\tjulia> rearrange_bigger(15234)\n\t15243\n\t\n\tjulia> rearrange_bigger(15243)\n\t15324\n\t\n\tjulia> rearrange_bigger(15324)\n\t15342\n\t\n\tjulia> rearrange_bigger(15342)\n\t15423\n\t\n\tjulia> rearrange_bigger(15423)\n\t15432\n\t\n\tjulia> rearrange_bigger(15432)\n\t21345\n\t\n\tjulia> rearrange_bigger(21345)\n\t21354\n\t\n\tjulia> rearr",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tfor j = length(digits):-1:i\n\t\t\t\tif digits[j] > digits[i-1]\n\t\t\t\t\ttemp = digits[i-1]\n\t\t\t\t\tdigits[i-1] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t#find the first digit that is smaller than the digit to its right\n\tfor i in 2:length(n_str)\n\t\tif n_arr[i-1] < n_arr[i]\n\t\t\t#find the smallest digit to the right of the pivot that is larger than the pivot\n\t\t\tsmallest_larger = n_arr[i]\n\t\t\tsmallest_larger_ind = i\n\t\t\tfor j in i+1:length(n_str)\n\t\t\t\tif n_arr[j] > n_arr[i-1] && n_arr[j] < smallest_larger\n\t\t\t\t\tsmallest_larger = n_arr[j]\n\t\t\t\t\tsmallest_larger_ind = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t#swap the pivot with the smallest larger digit\n\t\t\tn_arr[i-1], n_arr[smallest_larger_ind] = n_arr[smallest_larger_ind], n_arr[i-1]\n\t\t\t#sort the digits to the right of the pivot\n\t\t\tn_arr[i:end] = sort(n_arr[i:end])\n\t\t\t#convert to string\n\t\t\tn_str = \"\"\n\t\t\tfor i in 1:length(n_arr)\n\t\t\t\tn_str = n_str * string(n_arr[i])\n\t\t\tend\n\t\t\t#convert to int\n\t\t\tn = parse(Int64, n_str)\n\t\t\treturn n\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\trearrange the digits of a given number to create the next bigger number.\n\t\n\tParameters\n\t----------\n\tn : Int64\n\t\tthe given number\n\t\n\tReturns\n\t-------\n\tAny\n\t\tthe next bigger number or -1 if there is no bigger number\n\t\"\"\"\n\t\n\t# convert the number to a string\n\ts = string(n)\n\t\n\t# find the first digit from the right that is smaller than the digit to its right\n\tfor i = length(s):-1:2\n\t\tif s[i] > s[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if there is no such digit, there is no bigger number\n\tif i == 1\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the digit found above that is larger than it\n\tfor j = length(s):-1:i\n\t\tif s[j] > s[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the two digits\n\ts[i-1], s[j] = s[j], s[i-1]\n\t\n\t# reverse the digits to the right of the digit found above\n\ts[i:end] = reverse(s[i:end])\n\t\n\t# convert the string to an integer and return it\n\treturn parse(Int64, s)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[i] < digits[j]\n\t\t\t\t\ttemp = digits[i]\n\t\t\t\t\tdigits[i] = digits[j]\n\t\t\t\t\tdigits[j] = temp\n\t\t\t\t\treturn parse(Int64, join(digits[1:i], digits[i+1:end]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i = length(digits):-1:2\n\t\tif digits[i] > digits[i-1]\n\t\t\tj = i\n\t\t\twhile j < length(digits) && digits[j] > digits[i-1]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i-1], digits[j-1] = digits[j-1], digits[i-1]\n\t\t\tdigits[i:end] = sort(digits[i:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[i] < digits[j]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)::Any\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i = n_str_len-1:-1:1\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tfor j = n_str_len:-1:i\n\t\t\t\tif n_str[j] > n_str[i-1]\n\t\t\t\t\tn_str[i-1], n_str[j] = n_str[j], n_str[i-1]\n\t\t\t\t\tn_str[i:n_str_len] = sort(n_str[i:n_str_len])\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#find the first digit that is smaller than the next digit\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\t#find the smallest digit that is larger than the digit at i\n\t\t\tsmallest_larger = n_str[i+1]\n\t\t\tsmallest_larger_index = i+1\n\t\t\tfor j in i+1:length(n_str)\n\t\t\t\tif n_str[j] > n_str[i] && n_str[j] < smallest_larger\n\t\t\t\t\tsmallest_larger = n_str[j]\n\t\t\t\t\tsmallest_larger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t#swap the digits\n\t\t\tn_str[i], n_str[smallest_larger_index] = n_str[smallest_larger_index], n_str[i]\n\t\t\t#sort the rest of the digits\n\t\t\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\t\t#convert to int\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# get the length of the string\n\tn_len = length(n_str)\n\t# get the last digit\n\tlast_digit = parse(Int64, n_str[n_len])\n\t# get the second last digit\n\tsecond_last_digit = parse(Int64, n_str[n_len-1])\n\t# if the last digit is greater than the second last digit\n\tif last_digit > second_last_digit\n\t\t# swap the last two digits\n\t\tn_str[n_len] = second_last_digit\n\t\tn_str[n_len-1] = last_digit\n\t\t# return the new number\n\t\treturn parse(Int64, n_str)\n\telse\n\t\t# return nothing\n\t\treturn nothing\n\tend\nend",
    "\t# get the digits of the number\n\tdigits = digits(n)\n\t# get the length of the digits\n\tlen_digits = length(digits)\n\t# get the index of the last digit\n\tlast_index = len_digits - 1\n\t# get the index of the second last digit\n\tsecond_last_index = last_index - 1\n\t# get the last digit\n\tlast_digit = digits[last_index]\n\t# get the second last digit\n\tsecond_last_digit = digits[second_last_index]\n\t# get the index of the last digit\n\tlast_index = len_digits - 1\n\t# get the index of the second last digit\n\tsecond_last_index = last_index - 1\n\t# get the last digit\n\tlast_digit = digits[last_index]\n\t# get the second last digit\n\tsecond_last_digit = digits[second_last_index]\n\t# if the last digit is greater than the second last digit\n\tif last_digit > second_last_digit\n\t\t# swap the last and second last digit\n\t\tdigits[last_index] = second_last_digit\n\t\tdigits[second_last_index] = last_digit\n\t\t# return the number\n\t\treturn parse(Int64, join(digits))\n\tend\n\t# get the index of the last digit\n\tlast_index = len_digits - 1\n\t# get the index of the second last digit\n\tsecond_last_index = last_index - 1\n\t# get the last digit\n\tlast_digit = digits[last_index]\n\t# get the second last digit\n\tsecond_last_digit = digits[second_last_index]\n\t# if the last digit is greater than the second last digit\n\tif last_digit > second_last_digit\n\t\t# swap the last and second last digit\n\t\tdigits[last_index] = second_last_digit\n\t\tdigits[second_last_index] = last_digit\n\t\t# return the number\n\t\treturn parse(Int64, join(digits))\n\tend\n\t# get the index of the last digit\n\tlast_index = len_digits",
    "\t\"\"\"\n\tFind the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\tn_str = string(n)\n\tn_len = length(n_str)\n\tif n_len == 1\n\t\treturn -1\n\tend\n\tfor i = n_len-1:-1:1\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\tif i == 1\n\t\treturn -1\n\tend\n\tfor j = n_len:-1:i\n\t\tif n_str[j] > n_str[i-1]\n\t\t\tbreak\n\t\tend\n\tend\n\tn_str[i-1], n_str[j] = n_str[j], n_str[i-1]\n\tn_str[i:n_len] = reverse(n_str[i:n_len])\n\treturn parse(Int64, n_str)\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64) -> Int64\n\t\n\trearrange_bigger(n::Int64) -> String\n\t\n\trearrange_bigger(n::Int64) -> Nothing\n\t\n\trearrange_bigger(n::Int64) -> Any\n\t\n\trearrange_bigger(n::Int64) -> Union{Int64, String, Nothing}\n\t\n\trearrange_bigger(n::Int64) -> Union{Int64, String, Nothing, Any}\n\t\n\trearrange_bigger(n::Int64) -> Union{Int64, String, Nothing, Any, Union{Int64, String, Nothing}}\n\t\n\trearrange_bigger(n::Int64) -> Union{Int64, String, Nothing, Any, Union{Int64, String, Nothing, Union{Int64, String, Nothing}}}\n\t\n\trearrange_bigger(n::Int64) -> Union{Int64, String, Nothing, Any, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing}}}}}\n\t\n\trearrange_bigger(n::Int64) -> Union{Int64, String, Nothing, Any, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union{Int64, String, Nothing, Union",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# if n is a single digit, there is no bigger number\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\t# convert n to a string\n\tn_str = string(n)\n\t\n\t# find the first digit that is less than the digit to its right\n\tfor i in 1:length(n_str)\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# if no such digit exists, there is no bigger number\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t\n\t# find the smallest digit to the right of the pivot that is greater than the pivot\n\tfor j in i+1:length(n_str)\n\t\tif n_str[j] > n_str[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# swap the pivot with the smallest digit to its right\n\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\n\t# sort the digits to the right of the pivot\n\tn_str[i+1:end] = sort(n_str[i+1:end])\n\t\n\t# convert the string back to an integer\n\treturn parse(Int64, n_str)\nend",
    "\tn_str = string(n)\n\tn_str_len = length(n_str)\n\tfor i in 1:n_str_len-1\n\t\tif n_str[i] < n_str[i+1]\n\t\t\tfor j in i+1:n_str_len\n\t\t\t\tif n_str[j] > n_str[i]\n\t\t\t\t\tn_str[i], n_str[j] = n_str[j], n_str[i]\n\t\t\t\t\treturn parse(Int64, n_str)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# convert to string\n\tn = string(n)\n\t# convert to array of chars\n\tn = collect(n)\n\t# find the first decreasing digit\n\tfor i in 1:length(n)-1\n\t\tif n[i] < n[i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t# if no decreasing digit found, return -1\n\tif i == length(n)\n\t\treturn -1\n\tend\n\t# find the smallest digit greater than n[i]\n\tfor j in i+1:length(n)\n\t\tif n[j] > n[i]\n\t\t\tbreak\n\t\tend\n\tend\n\t# swap the digits\n\tn[i], n[j] = n[j], n[i]\n\t# sort the digits after the swapped digit\n\tn[i+1:end] = sort(n[i+1:end])\n\t# convert to string and return\n\treturn parse(Int64, join(n))\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j <= length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tj -= 1\n\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\tdigits[i+1:end] = reverse(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tFunction to create the next bigger number by rearranging the digits of a given number.\n\t\n\tExample\n\t\n\tjulia> rearrange_bigger(12)\n\t21\n\t\n\tjulia> rearrange_bigger(513)\n\t531\n\t\n\tjulia> rearrange_bigger(2017)\n\t2071\n\t\n\tjulia> rearrange_bigger(414)\n\t441\n\t\n\tjulia> rearrange_bigger(144)\n\t414\n\t\"\"\"\n\t\n\tif n < 10\n\t\treturn -1\n\tend\n\t\n\tdigits = digits(n)\n\t\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tdigits[i], digits[i+1] = digits[i+1], digits[i]\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\t\n\treturn -1\nend",
    "\t#find the first digit that is smaller than the digit to its right\n\t#find the smallest digit to the right of the digit that is greater than it\n\t#swap the two digits\n\t#sort the digits to the right of the digit that was swapped\n\t#return the new number\n\tn_str = string(n)\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\tmin_index = i+1\n\t\t\tmin_val = n_arr[i+1]\n\t\t\tfor j in i+1:length(n_arr)\n\t\t\t\tif n_arr[j] < min_val && n_arr[j] > n_arr[i]\n\t\t\t\t\tmin_index = j\n\t\t\t\t\tmin_val = n_arr[j]\n\t\t\t\tend\n\t\t\tend\n\t\t\tn_arr[i], n_arr[min_index] = n_arr[min_index], n_arr[i]\n\t\t\tsort!(n_arr[i+1:end])\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tj = i+1\n\t\t\twhile j < length(digits) && digits[j] > digits[i]\n\t\t\t\tj += 1\n\t\t\tend\n\t\t\tdigits[i], digits[j-1] = digits[j-1], digits[i]\n\t\t\tdigits[i+1:end] = sort(digits[i+1:end])\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\t#convert to string\n\tn_str = string(n)\n\t#find the first digit from the right that is smaller than the digit to its left\n\tfor i in 1:length(n_str)-1\n\t\tif n_str[end-i] > n_str[end-i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t#if no such digit exists, the number is the largest possible\n\tif i == length(n_str)\n\t\treturn -1\n\tend\n\t#find the smallest digit to the right of the pivot that is larger than the pivot\n\tfor j in i:length(n_str)-1\n\t\tif n_str[end-j] > n_str[end-i+1]\n\t\t\tbreak\n\t\tend\n\tend\n\t#swap the pivot and the smallest digit\n\tn_str[end-i+1], n_str[end-j] = n_str[end-j], n_str[end-i+1]\n\t#reverse the digits to the right of the pivot\n\tn_str[end-i+2:end] = reverse(n_str[end-i+2:end])\n\t#convert back to integer\n\treturn parse(Int64, n_str)\nend",
    "\t# convert to string\n\tn_str = string(n)\n\t# convert to array\n\tn_arr = [parse(Int64, n_str[i]) for i in 1:length(n_str)]\n\t# find the first digit that is smaller than the digit to its right\n\tfor i in 1:length(n_arr)-1\n\t\tif n_arr[i] < n_arr[i+1]\n\t\t\t# find the smallest digit to the right of this digit that is larger than it\n\t\t\tsmallest_larger_index = i+1\n\t\t\tfor j in i+2:length(n_arr)\n\t\t\t\tif n_arr[j] < n_arr[smallest_larger_index] && n_arr[j] > n_arr[i]\n\t\t\t\t\tsmallest_larger_index = j\n\t\t\t\tend\n\t\t\tend\n\t\t\t# swap the two digits\n\t\t\ttemp = n_arr[i]\n\t\t\tn_arr[i] = n_arr[smallest_larger_index]\n\t\t\tn_arr[smallest_larger_index] = temp\n\t\t\t# sort the digits to the right of the swapped digit\n\t\t\tn_arr[i+1:end] = sort(n_arr[i+1:end])\n\t\t\t# convert back to int\n\t\t\treturn parse(Int64, join(n_arr))\n\t\tend\n\tend\n\t# if no digit is smaller than the digit to its right, return -1\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\ttemp = digits[i]\n\t\t\tdigits[i] = digits[i+1]\n\t\t\tdigits[i+1] = temp\n\t\t\treturn parse(Int64, join(digits))\n\t\tend\n\tend\n\treturn -1\nend",
    "\tdigits = digits(n)\n\tfor i in 1:length(digits)-1\n\t\tif digits[i] < digits[i+1]\n\t\t\tfor j in i+1:length(digits)\n\t\t\t\tif digits[i] < digits[j]\n\t\t\t\t\tdigits[i], digits[j] = digits[j], digits[i]\n\t\t\t\t\treturn parse(Int64, join(digits))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn -1\nend",
    "\t# Get the digits of the number\n\tdigits = digits(n)\n\t# Get the length of the number\n\tn_digits = length(digits)\n\t# Get the index of the first digit that is smaller than the digit to its right\n\ti = findfirst(digits[1:end-1] .< digits[2:end])\n\t# If no such digit exists, return -1\n\tif isempty(i)\n\t\treturn -1\n\tend\n\t# Get the index of the smallest digit that is larger than the digit at index i\n\tj = findfirst(digits[i+1:end] .> digits[i]) + i\n\t# Swap the digits at indices i and j\n\tdigits[i], digits[j] = digits[j], digits[i]\n\t# Sort the digits from index i+1 to the end\n\tdigits[i+1:end] = sort(digits[i+1:end])\n\t# Return the number\n\treturn parse(Int64, join(digits))\nend",
    "\t# convert number to string\n\tn_str = string(n)\n\t# convert string to array of characters\n\tn_arr = collect(n_str)\n\t# get the length of the array\n\tn_len = length(n_arr)\n\t# initialize the index of the first digit to be swapped\n\ti = n_len - 1\n\t# initialize the index of the second digit to be swapped\n\tj = n_len\n\t# loop through the array from the end to the beginning\n\twhile i > 0\n\t\t# if the current digit is smaller than the previous digit\n\t\tif n_arr[i] < n_arr[i - 1]\n\t\t\t# decrement the index of the first digit to be swapped\n\t\t\ti -= 1\n\t\t\t# break the loop\n\t\t\tbreak\n\t\tend\n\t\t# decrement the index of the first digit to be swapped\n\t\ti -= 1\n\tend\n\t# if the index of the first digit to be swapped is not zero\n\tif i > 0\n\t\t# loop through the array from the end to the beginning\n\t\twhile j > i\n\t\t\t# if the current digit is greater than the digit at the index of the first digit to be swapped\n\t\t\tif n_arr[j] > n_arr[i]\n\t\t\t\t# break the loop\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t# decrement the index of the second digit to be swapped\n\t\t\tj -= 1\n\t\tend\n\t\t# swap the digits at the indexes of the first and second digits to be swapped\n\t\tn_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n\t\t# reverse the array from the index of the second digit to be swapped to the end\n\t\treverse!(n_arr, i + 1:n_len)\n\t\t# convert the array to a string\n\t\tn_str = join(n_arr)\n\t\t# convert the string to an integer\n\t\tn = parse(Int64, n_str)\n\t\t# return the integer\n\t\treturn n\n\t# if the index of the first digit to be swapped is zero\n\telse\n",
    "\t# n = 12345\n\t# n = 123456789\n\t# n = 1234567890\n\t# n = 12345678901\n\t# n = 123456789012\n\t# n = 1234567890123\n\t# n = 12345678901234\n\t# n = 123456789012345\n\t# n = 1234567890123456\n\t# n = 12345678901234567\n\t# n = 123456789012345678\n\t# n = 1234567890123456789\n\t# n = 12345678901234567890\n\t# n = 123456789012345678901\n\t# n = 1234567890123456789012\n\t# n = 12345678901234567890123\n\t# n = 123456789012345678901234\n\t# n = 1234567890123456789012345\n\t# n = 12345678901234567890123456\n\t# n = 123456789012345678901234567\n\t# n = 1234567890123456789012345678\n\t# n = 12345678901234567890123456789\n\t# n = 123456789012345678901234567890\n\t# n = 1234567890123456789012345678901\n\t# n = 12345678901234567890123456789012\n\t# n = 123456789012345678901234567890123\n\t# n = 1234567890123456789012345678901234\n\t# n = 12345678901234567890123456789012345\n\t# n = 123456789012345678901234567890123456\n\t# n = 1234567890123456789012345678901234567\n\t# n = 12345678901234567890123456789012345678\n\t# n = 123456789012345678901234567890123456789\n",
    "\t\"\"\"\n\trearrange_bigger(n::Int64)\n\t\n\tWrite a function to create the next bigger number by rearranging the digits of a given number.\n\t\"\"\"\n\t\n\tn_str = string(n)\n\tn_len = length(n_str)\n\t\n\tif n_len == 1\n\t\treturn -1\n\tend\n\t\n\tif n_len == 2\n\t\tif n_str[1] < n_str[2]\n\t\t\treturn parse(Int64, n_str[2] * n_str[1])\n\t\telse\n\t\t\treturn -1\n\t\tend\n\tend\n\t\n\tfor i in n_len:-1:2\n\t\tif n_str[i] > n_str[i-1]\n\t\t\tfor j in i:n_len\n\t\t\t\tif n_str[j] > n_str[i-1]\n\t\t\t\t\ttemp = n_str[j]\n\t\t\t\t\tn_str[j] = n_str[i-1]\n\t\t\t\t\tn_str[i-1] = temp\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tn_str = n_str[1:i-1] * sort(n_str[i:n_len])\n\t\t\treturn parse(Int64, n_str)\n\t\tend\n\tend\n\t\n\treturn -1\nend"
  ]
}