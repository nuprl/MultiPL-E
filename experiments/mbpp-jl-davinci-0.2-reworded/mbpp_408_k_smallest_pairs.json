{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\n\t\"\"\"\nfunction k_smallest_pairs(nums1::Vector{Int64}, nums2::Vector{Int64}, k::Int64)::Vector{Vector{Int64}} \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "using Test\n\n@testset begin\n\ncandidate = k_smallest_pairs;\n\t@test(candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]])\n\t@test(candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]])\n\t@test(candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\t# nums1 and nums2 are sorted in ascending order\n\t# k is the number of smallest pairs\n\t# return a vector of k smallest pairs\n\t\n\t# initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}()\n\t\n\t# initialize the first pair\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\t# loop through the heap\n\twhile length(result) < k && length(heap) > 0\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t\n\t\t# add the pair to the result vector\n\t\tpush!(result, pair)\n\t\t\n\t\t# update the heap\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2)\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\telseif pair[2] < length(nums1)\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\telseif pair[3] < length(nums2)\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\tend\n\tend\n\t\n\t# return the result vector\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# create a heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# push the first k pairs into the heap\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tpush!(heap, [nums1[n1] + nums2[i - n1], n1, i - n1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\theapify(heap, i)\n\tend\n\t\n\t# push the rest pairs into the heap\n\tfor i in k+1:n1+n2\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tpush!(heap, [nums1[n1] + nums2[i - n1], n1, i - n1])\n\t\tend\n\t\t\n\t\t# pop the largest pair\n\t\tpop!(heap)\n\t\t\n\t\t# heapify\n\t\tfor i in 1:k\n\t\t\theapify(heap, i)\n\t\tend\n\tend\n\t\n\t# pop the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = pop!(heap)\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# iterate through the heap\n\tfor i in 1:k\n\t\t# get the top element\n\t\ttop = heap[1]\n\t\t\n\t\t# add the top element to the result\n\t\tresult[i] = [nums1[top[2]], nums2[top[3]]]\n\t\t\n\t\t# if the top element is the last element in the heap, then we are done\n\t\tif i == k\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# if the top element is the last element in the first row, then we need to add the first element in the second row\n\t\tif top[2] == n1\n\t\t\theap[1] = [nums1[1] + nums2[top[3] + 1], 1, top[3] + 1]\n\t\telseif top[3] == n2\n\t\t\theap[1] = [nums1[top[2] + 1] + nums2[1], top[2] + 1, 1]\n\t\telse\n\t\t\theap[1] = [nums1[top[2] + 1] + nums2[top[3]], top[2] + 1, top[3]]\n\t\tend\n\t\t\n\t\t# heapify\n\t\theapify(heap, 1)\n\tend\n\t\n\treturn result\nend",
    "\t# TODO: Implement me!\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\twhile k > 0 && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j == length(nums2)\n\t\t\ti += 1\n\t\t\tj = 1\n\t\telse\n\t\t\tj += 1\n\t\tend\n\t\tif i <= length(nums1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, x, y) = pop!(pq)\n\t\tres[i] = [nums1[x], nums2[y]]\n\t\tif x < n\n\t\t\tvisited_add(visited, x+1, y)\n\t\t\tpush!(pq, (nums1[x+1] + nums2[y], x+1, y))\n\t\tend\n\t\tif y < m\n\t\t\tvisited_add(visited, x, y+1)\n\t\t\tpush!(pq, (nums1[x] + nums2[y+1], x, y+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= length(nums1) && i <= length(nums2)\n\t\t\theap[i] = [nums1[i] + nums2[i], i, 1]\n\t\telse\n\t\t\theap[i] = [typemax(Int64), 0, 0]\n\t\tend\n\tend\n\t# Heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1 && heap[j][1] < heap[j \u00f7 2][1]\n\t\t\theap[j], heap[j \u00f7 2] = heap[j \u00f7 2], heap[j]\n\t\t\tj = j \u00f7 2\n\t\tend\n\tend\n\t# Extract the minimum element\n\tfor i in k+1:length(nums1) * length(nums2)\n\t\tif i <= length(nums1) && i <= length(nums2)\n\t\t\theap[1] = [nums1[i] + nums2[i], i, 1]\n\t\telse\n\t\t\theap[1] = [typemax(Int64), 0, 0]\n\t\tend\n\t\tj = 1\n\t\twhile 2j <= k\n\t\t\tif 2j + 1 <= k && heap[2j + 1][1] < heap[2j][1]\n\t\t\t\tif heap[2j + 1][1] < heap[j][1]\n\t\t\t\t\theap[j], heap[2j + 1] = heap[2j + 1], heap[j]\n\t\t\t\t\tj = 2j + 1\n\t\t\t\telse\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif heap[2j][1] < heap[j][1]\n\t\t\t\t\theap[j], heap[2j] = heap[2j], heap[j]\n\t\t\t\t\tj = 2j\n\t\t\t\telse\n\t\t\t\t\tbreak",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in (k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the top k elements\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = heap[1][1:2]\n\t\tif heap[1][3] < n2\n\t\t\theap[1][1] = nums1[heap[1][3] + 1]\n\t\t\theap[1][3] += 1\n\t\telse\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\tend\n\t\theapify(heap, 1, length(heap))\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i], nums2[1], 1]\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tif heap[j][1] + heap[j][2] < heap[j \u00f7 2][1] + heap[j \u00f7 2][2]\n\t\t\t\theap[j], heap[j \u00f7 2] = heap[j \u00f7 2], heap[j]\n\t\t\t\tj = j \u00f7 2\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# pop the smallest element and push the next element\n\tfor i in k + 1:n1 * n2\n\t\theap[1] = [nums1[i \u00f7 n2 + 1], nums2[i \u00f7 n1 + 1], i \u00f7 n1 + 1]\n\t\tj = 1\n\t\twhile j < k\n\t\t\tif j * 2 + 1 <= k\n\t\t\t\tif heap[j * 2][1] + heap[j * 2][2] < heap[j * 2 + 1][1] + heap[j * 2 + 1][2]\n\t\t\t\t\tif heap[j][1] + heap[j][2] > heap[j * 2][1] + heap[j * 2][2]\n\t\t\t\t\t\theap[j], heap[j * 2] = heap[j * 2], heap[j]\n\t\t\t\t\t\tj = j * 2\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tif heap[j][1]",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i = 2:k\n\t\tif i <= n1\n\t\t\theappush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# pop the smallest pair and push the next pair\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i > length(heap)\n\t\t\tbreak\n\t\tend\n\t\tpair = heappop!(heap)\n\t\tres[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\tif pair[3] < n2\n\t\t\theappush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = Vector{Int64}(undef, 2)\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = Vector{Int64}(undef, 3)\n\tend\n\tfor i in 1:k\n\t\theap[i][1] = nums1[i]\n\t\theap[i][2] = nums2[i]\n\t\theap[i][3] = nums1[i] + nums2[i]\n\tend\n\tbuild_min_heap(heap)\n\t\n\t# start to find the k smallest pairs\n\tfor i in k+1:n1\n\t\tfor j in k+1:n2\n\t\t\tif nums1[i] + nums2[j] < heap[1][3]\n\t\t\t\theap[1][1] = nums1[i]\n\t\t\t\theap[1][2] = nums2[j]\n\t\t\t\theap[1][3] = nums1[i] + nums2[j]\n\t\t\t\tmin_heapify(heap, 1)\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# sort the k smallest pairs\n\tfor i in 1:k\n\t\tpairs[i][1] = heap[i][1]\n\t\tpairs[i][2] = heap[i][2]\n\tend\n\tsort!(pairs, by = x -> x[1] + x[2])\n\treturn pairs\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\t\n\twhile k > 0 && !isempty(pq)\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif j == 1 && i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t# Initialize the heap\n\theap = BinaryHeap{Tuple{Int64, Int64, Int64}}()\n\t# Push the first element into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# Iterate k times\n\tfor i in 1:k\n\t\t# If the heap is empty, return the result\n\t\tif isempty(heap)\n\t\t\treturn result\n\t\tend\n\t\t# Pop the smallest element from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\t# Push the element into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# If the index i is not the last one, push the next element into the heap\n\t\tif i < length(nums1)\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t# If the index j is not the last one, push the next element into the heap\n\t\tif j < length(nums2) && i == 1\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t# Return the result\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = []\n\twhile !isempty(pq) && k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\telseif i < n1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\telseif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# Build the heap\n\tfor i in 2:k\n\t\theapify(heap, i)\n\tend\n\t\n\t# Pop the heap\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\t\n\t\tif heap[1][2] == n1\n\t\t\theap[1] = [heap[1][1] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = [heap[1][1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\t\n\t\theapify(heap, 1)\n\tend\n\t\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# Initialize the heap with the first element of nums1\n\theap = [nums1[1] + nums2[i] for i in 1:m]\n\t\n\t# Initialize the result vector\n\tresult = []\n\t\n\t# Initialize the index vector\n\tindex = [1 for i in 1:m]\n\t\n\t# Initialize the counter\n\tcounter = 0\n\t\n\t# Loop until the heap is empty\n\twhile counter < k && length(heap) > 0\n\t\t# Get the minimum element from the heap\n\t\tmin_element = pop!(heap)\n\t\t\n\t\t# Get the index of the minimum element\n\t\tmin_index = findfirst(heap -> heap == min_element, heap)\n\t\t\n\t\t# Push the minimum element to the result vector\n\t\tpush!(result, [nums1[index[min_index]], nums2[min_index]])\n\t\t\n\t\t# Increment the counter\n\t\tcounter += 1\n\t\t\n\t\t# Increment the index of the minimum element\n\t\tindex[min_index] += 1\n\t\t\n\t\t# Check if the index is valid\n\t\tif index[min_index] <= n\n\t\t\t# Push the new element to the heap\n\t\t\tpush!(heap, nums1[index[min_index]] + nums2[min_index])\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# find the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = heap[1][1:2]\n\t\tif heap[1][3] < n2\n\t\t\theap[1] = [heap[1][1], nums2[heap[1][3] + 1], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = heap[k]\n\t\t\tk -= 1\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tres[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < res[k][1] + res[k][2]\n\t\t\t\tres[k] = [nums1[i], nums2[j]]\n\t\t\t\tk = k - 1\n\t\t\t\tfor l in 1:k\n\t\t\t\t\tif res[l][1] + res[l][2] > res[l + 1][1] + res[l + 1][2]\n\t\t\t\t\t\tres[l], res[l + 1] = res[l + 1], res[l]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tk = k + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}(k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}(k)\n\t\n\t# Initialize the visited vector\n\tvisited = Vector{Vector{Int64}}(length(nums1), length(nums2))\n\tvisited[1, 1] = 1\n\t\n\t# Initialize the heap size\n\theap_size = 1\n\t\n\t# Initialize the result size\n\tresult_size = 0\n\t\n\t# Iterate until the heap is empty or the result size is equal to k\n\twhile heap_size != 0 && result_size != k\n\t\t# Pop the top element from the heap\n\t\ttop = heap[1]\n\t\theap[1] = heap[heap_size]\n\t\theap_size -= 1\n\t\t\n\t\t# Add the top element to the result\n\t\tresult[result_size + 1] = [nums1[top[2]], nums2[top[3]]]\n\t\tresult_size += 1\n\t\t\n\t\t# Push the next element from nums1 to the heap\n\t\tif top[2] + 1 <= length(nums1) && visited[top[2] + 1, top[3]] != 1\n\t\t\theap_size += 1\n\t\t\theap[heap_size] = [nums1[top[2] + 1] + nums2[top[3]], top[2] + 1, top[3]]\n\t\t\tvisited[top[2] + 1, top[3]] = 1\n\t\tend\n\t\t\n\t\t# Push the next element from nums2 to the heap\n\t\tif top[3] + 1 <= length(nums2) && visited[top[2], top[3] + 1] !=",
    "\t# create a priority queue\n\tpq = PriorityQueue()\n\t# push the first pair into the queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# create a set to store the visited pairs\n\tvisited = Set()\n\t# create a vector to store the result\n\tres = Vector{Vector{Int64}}()\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the pair with the smallest sum\n\t\t(sum, i, j) = pop!(pq)\n\t\t# push the pair into the result vector\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t# if the first element of the pair is not the last element of the first vector\n\t\tif i < length(nums1)\n\t\t\t# push the pair with the first element of the pair being the next element of the first vector and the second element of the pair being the same as the previous pair\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t# if the second element of the pair is not the last element of the second vector\n\t\tif j < length(nums2)\n\t\t\t# push the pair with the second element of the pair being the next element of the second vector and the first element of the pair being the same as the previous pair\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t# return the result vector\n\treturn res\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tif n == 0 || m == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tif k > n*m\n\t\tk = n*m\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n && j == 1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif j < m\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\ti = 1\n\tj = 1\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tk = k - 1\n\t\t\t\tif k == 0\n\t\t\t\t\treturn pairs\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1], nums2[1], 1, 1]\n\t\n\t# Initialize the heap size\n\theap_size = 1\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the result size\n\tresult_size = 0\n\t\n\twhile heap_size > 0 && result_size < k\n\t\t# Pop the top element from the heap\n\t\ttop = heap[1]\n\t\t\n\t\t# Push the top element to the result\n\t\tresult[result_size + 1] = [top[1], top[2]]\n\t\tresult_size += 1\n\t\t\n\t\t# If the second element of the top element is not the last element of nums2, push the next element of nums2 to the heap\n\t\tif top[4] < n2\n\t\t\theap[1] = [top[1], nums2[top[4] + 1], top[3], top[4] + 1]\n\t\t\theap_size = 1\n\t\telse\n\t\t\theap[1] = heap[heap_size]\n\t\t\theap_size -= 1\n\t\tend\n\t\t\n\t\t# If the first element of the top element is not the last element of nums1, push the next element of nums1 to the heap\n\t\tif top[3] < n1\n\t\t\theap[heap_size + 1] = [nums1[top[3] + 1], top[2], top[3] + 1, top[4]]\n\t\t\theap_size += 1\n\t\tend\n\t\t\n\t\t# Sift down the top element\n\t\ti = 1\n\t\twhile 2 * i <= heap_size\n\t\t\tj =",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Heap(nums1[1] + nums2[1])\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif i == 1 && j == 1\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\tpush!(heap, nums1[i] + nums2[j])\n\t\tend\n\tend\n\t\n\t# pop k elements from the heap\n\tresult = []\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\tpush!(result, pop!(heap))\n\tend\n\t\n\treturn result\nend",
    "\t\n\t# Initialize a priority queue with the first element of nums1 and nums2\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Initialize a set to store the indices of the elements that have been added to the priority queue\n\tseen = Set()\n\tpush!(seen, (1, 1))\n\t\n\t# Initialize a vector to store the k smallest pairs\n\tk_smallest_pairs = Vector{Vector{Int64}}()\n\t\n\t# Loop through the priority queue until it is empty or the number of pairs added to the vector is k\n\twhile !isempty(pq) && length(k_smallest_pairs) < k\n\t\t\n\t\t# Pop the smallest pair from the priority queue\n\t\t(sum, i, j) = pop!(pq)\n\t\t\n\t\t# Add the pair to the vector\n\t\tpush!(k_smallest_pairs, [nums1[i], nums2[j]])\n\t\t\n\t\t# If the first element of the pair is not the last element of nums1, add the pair with the next element of nums1 to the priority queue\n\t\tif i < length(nums1)\n\t\t\tif !(i + 1, j) in seen\n\t\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\t\tpush!(seen, (i + 1, j))\n\t\t\tend\n\t\tend\n\t\t\n\t\t# If the second element of the pair is not the last element of nums2, add the pair with the next element of nums2 to the priority queue\n\t\tif j < length(nums2)\n\t\t\tif !(i, j + 1) in seen\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\t\tpush!(seen, (i, j + 1))\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# Return the",
    "\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1], nums2[1]]\n\t\n\t# Initialize the indices of the first element of nums1 and nums2\n\tindices = Vector{Vector{Int64}}(undef, k)\n\tindices[1] = [1, 1]\n\t\n\t# Initialize the size of the heap\n\tsize = 1\n\t\n\t# Iterate through the rest of the elements in nums1 and nums2\n\tfor i in 2:min(k, length(nums1), length(nums2))\n\t\t# Push the next element of nums1 and nums2 into the heap\n\t\theap[i] = [nums1[i], nums2[i]]\n\t\tindices[i] = [i, i]\n\t\t\n\t\t# Sift up the new element\n\t\tsift_up(heap, indices, i)\n\t\t\n\t\t# Increment the size of the heap\n\t\tsize += 1\n\tend\n\t\n\t# Iterate through the rest of the elements in nums1 and nums2\n\tfor i in min(k, length(nums1), length(nums2)) + 1:length(nums1)\n\t\tfor j in min(k, length(nums1), length(nums2)) + 1:length(nums2)\n\t\t\t# If the new element is smaller than the root of the heap\n\t\t\tif nums1[i] + nums2[j] < heap[1][1] + heap[1][2]\n\t\t\t\t# Replace the root of the heap with the new element\n\t\t\t\theap[1] = [nums1[i], nums2[j]]\n\t\t\t\tindices[1] = [i, j]\n\t\t\t\t\n\t\t\t\t# Sift down the new element\n\t\t\t\tsift_down(heap, indices, 1, size)\n\t\t\tend\n\t\tend\n\tend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\tif k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n && !visited_contains(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add(visited, i + 1, j)\n\t\tend\n\t\tif j + 1 <= m && !visited_contains(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add(visited, i, j + 1)\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\tif k < 1\n\t\treturn []\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set()\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# start to find the k smallest pairs\n\twhile length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# if i < n, we can push the pair (i+1, j) into the priority queue\n\t\tif i < n && !(i+1, j) in visited\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\t\tpush!(visited, (i+1, j))\n\t\tend\n\t\t\n\t\t# if j < m, we can push the pair (i, j+1) into the priority queue\n\t\tif j < m && !(i, j+1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\t\tpush!(visited, (i, j+1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\theap = Heap(k)\n\t\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\theap.push([nums1[i], nums2[j]])\n\t\tend\n\tend\n\t\n\tresult = []\n\tfor i in 1:k\n\t\tresult = [heap.pop()] + result\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the smallest pair\n\tfor i in k+1:n1*n2\n\t\tif heap[1][1] > nums1[i/n2 + 1] + nums2[i%n2 + 1]\n\t\t\theap[1] = [nums1[i/n2 + 1] + nums2[i%n2 + 1], i/n2 + 1, i%n2 + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\treturn heap\nend",
    "\t# Initialize a priority queue\n\tpq = PriorityQueue()\n\t# Initialize a set to store the visited pairs\n\tvisited = Set()\n\t# Initialize a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# Initialize a tuple to store the first pair\n\tpush!(pq, (nums1[1] + nums2[1], (1, 1)))\n\t# Initialize a variable to store the number of pairs\n\tcount = 0\n\t# Loop until the queue is empty or the number of pairs is equal to k\n\twhile !isempty(pq) && count < k\n\t\t# Pop the pair with the smallest sum\n\t\t(sum, (i, j)) = pop!(pq)\n\t\t# Add the pair to the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# Increment the number of pairs\n\t\tcount += 1\n\t\t# If the first element of the pair is not the last element of the first vector\n\t\tif i < length(nums1)\n\t\t\t# If the pair with the first element of the first vector and the second element of the second vector is not visited\n\t\t\tif !(i + 1, j) in visited\n\t\t\t\t# Push the pair to the queue\n\t\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], (i + 1, j)))\n\t\t\t\t# Add the pair to the set\n\t\t\t\tpush!(visited, (i + 1, j))\n\t\t\tend\n\t\tend\n\t\t# If the second element of the pair is not the last element of the second vector\n\t\tif j < length(nums2)\n\t\t\t# If the pair with the first element of the first vector and the second element of the second vector is not visited\n\t\t\tif !(i, j + 1) in visited\n\t\t\t\t# Push the pair to the queue\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], (i, j + 1)))\n\t\t\t\t# Add the pair",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\theapify(heap, i)\n\tend\n\t\n\t# pop the smallest pair and push the next pair\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = pop!(heap)\n\t\tif res[i][3] < n2\n\t\t\tpush!(heap, [res[i][1], nums2[res[i][3] + 1], res[i][3] + 1])\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the heap\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tres[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\tif heap[1][2] == n1\n\t\t\theap[1] = heap[k]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2]+1] + nums2[heap[1][3]], heap[1][2]+1, heap[1][3]]\n\t\tend\n\t\theapify(heap, 1, k-i)\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t# create a priority queue\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\tresult = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\tif i + 1 <= n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j + 1 <= n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tsum, x, y = pop!(pq)\n\t\tres[i] = [nums1[x], nums2[y]]\n\t\tif x + 1 <= n && !visited_has(visited, x + 1, y)\n\t\t\tvisited_add!(visited, x + 1, y)\n\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\tend\n\t\tif y + 1 <= m && !visited_has(visited, x, y + 1)\n\t\t\tvisited_add!(visited, x, y + 1)\n\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Array{Tuple{Int64, Int64, Int64}, 1}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = (nums1[i] + nums2[1], i, 1)\n\tend\n\t\n\t# heapify\n\tfor i in (k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the top k elements\n\tres = Array{Vector{Int64}, 1}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [nums1[heap[1][2]], nums2[heap[1][3]]]\n\t\t\n\t\t# pop the top element\n\t\theap[1] = heap[k-i+1]\n\t\t\n\t\t# heapify\n\t\theapify(heap, 1, k-i)\n\tend\n\t\n\treturn res\nend",
    "\t# sort the two vectors\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# initialize the result vector\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t# initialize the index vector\n\tindex = Vector{Int64}(undef, length(nums1))\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\t# initialize the heap size\n\theap_size = 0\n\t# loop through the first vector\n\tfor i in 1:length(nums1)\n\t\t# push the first element of the second vector into the heap\n\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\t# increase the heap size\n\t\theap_size += 1\n\t\t# push the index into the index vector\n\t\tpush!(index, 1)\n\tend\n\t# loop through the heap\n\tfor i in 1:k\n\t\t# pop the smallest element from the heap\n\t\ttemp = pop!(heap)\n\t\t# push the smallest element into the result vector\n\t\tpush!(result, temp[1:2])\n\t\t# get the index of the second element\n\t\tindex_2 = temp[3]\n\t\t# if the index is not the last element of the second vector\n\t\tif index_2 < length(nums2)\n\t\t\t# push the next pair into the heap\n\t\t\tpush!(heap, [temp[1], nums2[index_2+1], index_2+1])\n\t\t\t# increase the heap size\n\t\t\theap_size += 1\n\t\tend\n\tend\n\t# return the result vector\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tres[i] = [nums1[1], nums2[1]]\n\tend\n\t\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < res[k][1] + res[k][2]\n\t\t\t\tres[k] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif res[l][1] + res[l][2] > res[l+1][1] + res[l+1][2]\n\t\t\t\t\t\tres[l], res[l+1] = res[l+1], res[l]\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= length(nums1) && i <= length(nums2)\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i in (k/2):-1:1\n\t\theap = min_heapify(heap, i, k)\n\tend\n\t\n\t# extract the smallest k pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= length(heap)\n\t\t\tresult[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\t\t\n\t\t\t# update the heap\n\t\t\tif heap[1][3] < length(nums2)\n\t\t\t\theap[1] = [nums1[heap[1][2]] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\t\telse\n\t\t\t\theap[1] = heap[end]\n\t\t\t\theap = heap[1:end-1]\n\t\t\tend\n\t\t\t\n\t\t\theap = min_heapify(heap, 1, length(heap))\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\twhile !isempty(pq) && length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\treturn result\nend",
    "\t# Create a priority queue\n\tpq = PriorityQueue()\n\t# Add the first pair to the queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# Create a set to keep track of the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\t# Add the first pair to the set\n\tpush!(visited, (1, 1))\n\t# Create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# Loop until the queue is empty or the result has k elements\n\twhile !isempty(pq) && length(result) < k\n\t\t# Pop the pair with the smallest sum\n\t\t(sum, i, j) = pop!(pq)\n\t\t# Add the pair to the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# Add the pair to the right to the queue if it is not visited\n\t\tif i < length(nums1) && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\t# Add the pair below to the queue if it is not visited\n\t\tif j < length(nums2) && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t# Return the result\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tsum, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1] + nums2[i2], i1+1, i2))\n\t\tend\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Heap()\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# Pop the top k elements\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the top element\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# Push the next element\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile length(res) < k && !isempty(pq)\n\t\tcur = pop!(pq)\n\t\tpush!(res, [nums1[cur[2]], nums2[cur[3]]])\n\t\tif cur[2] < n1 && cur[3] < n2\n\t\t\tif !(cur[2] + 1, cur[3]) in visited\n\t\t\t\tpush!(pq, (nums1[cur[2] + 1] + nums2[cur[3]], cur[2] + 1, cur[3]))\n\t\t\t\tpush!(visited, (cur[2] + 1, cur[3]))\n\t\t\tend\n\t\t\tif !(cur[2], cur[3] + 1) in visited\n\t\t\t\tpush!(pq, (nums1[cur[2]] + nums2[cur[3] + 1], cur[2], cur[3] + 1))\n\t\t\t\tpush!(visited, (cur[2], cur[3] + 1))\n\t\t\tend\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = PriorityQueue()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Iterate k times\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the smallest pair from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# Add the next pair to the heap\n\t\tif j == 1 && i < length(nums1)\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# sort nums1 and nums2\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the result vector\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the heap\n\theap = BinaryHeap{Int64}()\n\t\n\t# initialize the visited vector\n\tvisited = Vector{Bool}(undef, length(nums1))\n\t\n\t# initialize the first pair\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\tvisited[1] = true\n\t\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the smallest pair\n\t\tpair = pop!(heap)\n\t\t\n\t\t# if the heap is empty, break\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# push the pair to the result vector\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# if the first element of the pair is the last element of nums1, push the next pair\n\t\tif pair[2] == length(nums1)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t# if the second element of the pair is the last element of nums2, push the next pair\n\t\telseif pair[3] == length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t# if the pair is not visited, push the next pair\n",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# While the heap is not empty and the result vector has not reached k elements\n\twhile length(heap) > 0 && length(result) < k\n\t\t# Pop the top element from the heap\n\t\ttop = pop!(heap)\n\t\t\n\t\t# Add the top element to the result vector\n\t\tpush!(result, [nums1[top[2]], nums2[top[3]]])\n\t\t\n\t\t# If the first element of the top element is not the last element of nums1\n\t\tif top[2] < length(nums1)\n\t\t\t# Push the sum of the next element of nums1 and the current element of nums2 to the heap\n\t\t\tpush!(heap, [nums1[top[2] + 1] + nums2[top[3]], top[2] + 1, top[3]])\n\t\tend\n\t\t\n\t\t# If the second element of the top element is not the last element of nums2\n\t\tif top[3] < length(nums2)\n\t\t\t# Push the sum of the current element of nums1 and the next element of nums2 to the heap\n\t\t\tpush!(heap, [nums1[top[2]] + nums2[top[3] + 1], top[2], top[3] + 1])\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n && !visited_has(visited, i + 1, j)\n\t\t\tvisited_add!(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif j + 1 <= m && !visited_has(visited, i, j + 1)\n\t\t\tvisited_add!(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\tfor i in 2:k\n\t\tif i <= length(nums1)\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[end] + nums2[i - length(nums1)], length(nums1), i - length(nums1)]\n\t\tend\n\tend\n\t\n\t# Heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1 && heap[j][1] < heap[j \u00f7 2][1]\n\t\t\theap[j], heap[j \u00f7 2] = heap[j \u00f7 2], heap[j]\n\t\t\tj = j \u00f7 2\n\t\tend\n\tend\n\t\n\t# Pop the smallest element\n\tfor i in k + 1:length(nums1) * length(nums2)\n\t\tif i <= length(nums1)\n\t\t\theap[1] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[1] = [nums1[end] + nums2[i - length(nums1)], length(nums1), i - length(nums1)]\n\t\tend\n\t\t\n\t\tj = 1\n\t\twhile 2j <= k\n\t\t\tif 2j + 1 <= k\n\t\t\t\tif heap[2j][1] < heap[2j + 1][1]\n\t\t\t\t\tif heap[j][1] > heap[2j][1]\n\t\t\t\t\t\theap[j],",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# create a heap of size k\n\theap = Vector{Vector{Int64}}(undef, k)\n\t# push the first pair into the heap\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t# create a set to store the indices of the pairs that have been pushed into the heap\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\t# iterate k times to get the k smallest pairs\n\tfor i in 1:k\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t# push the pair into the result vector\n\t\tpush!(res, pair)\n\t\t# get the indices of the pair\n\t\ti1, i2 = pair[2], pair[3]\n\t\t# if the first index is not the last index of the first vector\n\t\tif i1 < n1\n\t\t\t# create a new pair\n\t\t\tnew_pair = [nums1[i1 + 1] + nums2[i2], i1 + 1, i2]\n\t\t\t# if the new pair has not been pushed into the heap\n\t\t\tif !(i1 + 1, i2) in visited\n\t\t\t\t# push the new pair into the heap\n\t\t\t\tpush!(heap, new_pair)\n\t\t\t\t# add the indices of the new pair into the set\n\t\t\t\tpush!(visited, (i1 + 1, i2))\n\t\t\tend\n\t\tend\n\t\t# if the second index is not the last index of the second vector\n\t\tif i2 < n2\n\t\t\t# create a new pair\n\t\t\tnew_pair = [nums1[i1] + nums2[i2 + 1",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# create a heap\n\theap = Vector{Vector{Int64}}()\n\t\n\t# push the first element of nums1 and nums2\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set{Vector{Int64}}()\n\tpush!(visited, [1, 1])\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the top element\n\t\ttop = pop!(heap)\n\t\t\n\t\t# if the heap is empty, break\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# push the top element to the result\n\t\tpush!(result, [nums1[top[2]], nums2[top[3]]])\n\t\t\n\t\t# if the top element's first index is not the last element of nums1\n\t\tif top[2] < n\n\t\t\t# create a new pair\n\t\t\tnew_pair = [nums1[top[2] + 1] + nums2[top[3]], top[2] + 1, top[3]]\n\t\t\t\n\t\t\t# if the new pair is not visited\n\t\t\tif !(new_pair[2:3] in visited)\n\t\t\t\t# push the new pair to the heap\n\t\t\t\tpush!(heap, new_pair)\n\t\t\t\t\n\t\t\t\t# add the new pair to the visited set\n\t\t\t\tpush!(visited, new_pair[2:3])\n\t\t\tend\n\t\tend\n\t\t\n\t\t# if the top element's second index is not the last element of nums2\n\t\tif",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i = 1:n1\n\t\tfor j = 1:n2\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tk = k - 1\n\t\t\t\tif k == 0\n\t\t\t\t\treturn pairs\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\tfor i in 2:k\n\t\tif i <= n\n\t\t\theappush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= length(heap)\n\t\t\tresult[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\t\t\n\t\t\t# pop the top element\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\t\t\n\t\t\t# push the next element\n\t\t\tif result[i][3] + 1 <= m\n\t\t\t\theappush!(heap, [nums1[result[i][2]] + nums2[result[i][3] + 1], result[i][2], result[i][3] + 1])\n\t\t\tend\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([1, 1])\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tsum, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 + 1 <= n1 && !(i1 + 1, i2) in visited\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\t\tpush!(visited, (i1 + 1, i2))\n\t\tend\n\t\tif i2 + 1 <= n2 && !(i1, i2 + 1) in visited\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\t\tpush!(visited, (i1, i2 + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in (k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the heap\n\tfor i in k+1:n1 * n2\n\t\tif nums1[(i-1) \u00f7 n2 + 1] + nums2[(i-1) % n2 + 1] < heap[1][1]\n\t\t\theap[1] = [nums1[(i-1) \u00f7 n2 + 1] + nums2[(i-1) % n2 + 1], (i-1) \u00f7 n2 + 1, (i-1) % n2 + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\t# return the result\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [nums1[heap[i][2]], nums2[heap[i][3]]]\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theappush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\tend\n\t\tif i <= n2\n\t\t\theappush!(heap, [nums1[1] + nums2[i], 1, i])\n\t\tend\n\tend\n\t\n\t# Pop the smallest pair and push the next pair\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpair = heappop!(heap)\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\tif pair[2] < n1 && pair[3] < n2\n\t\t\theappush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\tend\n\t\tif pair[3] < n2 - 1\n\t\t\theappush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = []\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# start to pop the smallest pairs\n\tfor i = 1:k\n\t\t# pop the smallest pair\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# push the next pair\n\t\tif i + 1 <= n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j + 1 <= n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif k == 0\n\t\treturn []\n\tend\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# create a min heap\n\theap = MinHeap()\n\t\n\t# add the first element of nums1 and nums2 to the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the indices of the elements already added to the heap\n\tindices = Set([(1, 1)])\n\t\n\t# create a vector to store the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# iterate k times\n\tfor i in 1:k\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t\n\t\t# add the pair to the result vector\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# if the first element of the pair is the last element of nums1\n\t\tif pair[2] == length(nums1)\n\t\t\t# add the next element of nums2 to the heap\n\t\t\tif pair[3] < length(nums2) && !(pair[2], pair[3] + 1) in indices\n\t\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t\t\tpush!(indices, (pair[2], pair[3] + 1))\n\t\t\tend\n\t\t# if the second element of the pair is the last element of nums2\n\t\telseif pair[3] == length(nums2)\n\t\t\t# add the next element of nums1 to the heap\n\t\t\tif pair[2] < length(nums1) && !(pair[2] + 1, pair[3",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tbuild_heap!(heap)\n\t\n\t# pop the heap\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tresult[i] = heap[1][1:2]\n\t\tif heap[1][3] < n2\n\t\t\theap[1] = [heap[1][1], nums2[heap[1][3] + 1], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\tend\n\t\theapify!(heap, 1)\n\tend\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\t\n\tif k > n * m\n\t\tk = n * m\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tresult[i] = [nums1[i], nums2[j]]\n\t\tif i == n\n\t\t\tcontinue\n\t\tend\n\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tif j == 1\n\t\t\tcontinue\n\t\tend\n\t\tpush!(pq, (nums1[i + 1] + nums2[j - 1], i + 1, j - 1))\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add!(visited, 1, 1)\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tresult[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1\n\t\t\ti1 += 1\n\t\t\tif !visited_has(visited, i1, i2)\n\t\t\t\tvisited_add!(visited, i1, i2)\n\t\t\t\tpush!(pq, (nums1[i1] + nums2[i2], i1, i2))\n\t\t\tend\n\t\tend\n\t\tif i2 < n2\n\t\t\ti2 += 1\n\t\t\tif !visited_has(visited, i1, i2)\n\t\t\t\tvisited_add!(visited, i1, i2)\n\t\t\t\tpush!(pq, (nums1[i1] + nums2[i2], i1, i2))\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\t# Output: [[1,2],[1,4],[1,6]]\n\t# Explanation: The first 3 pairs are returned from the sequence:\n\t#              [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\t\n\tnums1_len = length(nums1)\n\tnums2_len = length(nums2)\n\t\n\tif nums1_len == 0 || nums2_len == 0\n\t\treturn []\n\tend\n\t\n\tif k > nums1_len * nums2_len\n\t\tk = nums1_len * nums2_len\n\tend\n\t\n\t# sort nums1 and nums2\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the first k pairs\n\tfor i in 1:k\n\t\theap[i] = [nums1[i], nums2[1], 1]\n\tend\n\t\n\t# build the heap\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1 && heap[j][1] + heap[j][2] < heap[j \u00f7 2][1] + heap[j \u00f7 2][2]\n\t\t\theap[j], heap[j \u00f7 2] = heap[j \u00f7 2], heap[j]\n\t\t\tj = j \u00f7 2\n\t\tend\n\tend\n\t\n\t# pop the heap\n\tfor i in 1:k\n\t\tresult[i] = [heap[1][1], heap[1][2]]\n\t\t\n\t\tif heap[1][3] < nums2_len\n\t\t\theap[1] =",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile length(res) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif j == 1 && i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tif i < n1 - 1 && j == 1\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t# push the first element of nums1 and nums2 into the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# create a set to store the visited pairs\n\tvisited = Set()\n\t# create a vector to store the result\n\tres = Vector{Vector{Int64}}()\n\t# loop k times\n\tfor i in 1:k\n\t\t# if the priority queue is empty, break the loop\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t# pop the smallest pair from the priority queue\n\t\t(sum, i, j) = pop!(pq)\n\t\t# push the pair into the result vector\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t# if the first element of the pair is not the last element of nums1\n\t\tif i < length(nums1)\n\t\t\t# create a new pair\n\t\t\tnew_pair = (nums1[i+1] + nums2[j], i+1, j)\n\t\t\t# if the new pair is not visited\n\t\t\tif !(new_pair in visited)\n\t\t\t\t# push the new pair into the priority queue\n\t\t\t\tpush!(pq, new_pair)\n\t\t\t\t# add the new pair into the visited set\n\t\t\t\tpush!(visited, new_pair)\n\t\t\tend\n\t\tend\n\t\t# if the second element of the pair is not the last element of nums2\n\t\tif j < length(nums2)\n\t\t\t# create a new pair\n\t\t\tnew_pair = (nums1[i] + nums2[j+1], i, j+1)\n\t\t\t# if the new pair is not visited\n\t\t\tif !(new_pair in visited)\n\t\t\t\t# push the new pair",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tif heap[j][1] < heap[j \u00f7 2][1]\n\t\t\t\theap[j], heap[j \u00f7 2] = heap[j \u00f7 2], heap[j]\n\t\t\t\tj = j \u00f7 2\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# extract the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap[1][2], heap[1][3]]\n\t\t\n\t\t# update the heap\n\t\tif heap[1][2] == n1\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\t\n\t\t# heapify\n\t\tj = 1\n\t\twhile 2 * j <= length(heap)\n\t\t\tif 2 * j + 1 <= length(heap)\n\t\t\t\tif heap[2 * j][1] < heap[2 * j + 1][1]\n\t\t\t\t\tif heap[j][1] > heap[2 * j][1]\n\t\t\t\t\t\theap[j], heap[",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([1])\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\tif i + 1 <= n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j + 1 <= n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1]+nums2[i2], i1+1, i2))\n\t\t\tpush!(pq, (nums1[i1]+nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(k)\n\t\n\tfor i in 1:k\n\t\tsum, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\t\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1] + nums2[i2], i1+1, i2))\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\telseif i1 < n1\n\t\t\tpush!(pq, (nums1[i1+1] + nums2[i2], i1+1, i2))\n\t\telseif i2 < n2\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1], nums2[1], 1, 1]\n\t\n\t# initialize the heap size\n\theap_size = 1\n\t\n\t# initialize the result vector\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# loop until the heap is empty\n\twhile heap_size > 0\n\t\t# pop the smallest element from the heap\n\t\tsmallest = heap[1]\n\t\theap[1] = heap[heap_size]\n\t\theap_size -= 1\n\t\t\n\t\t# push the smallest element to the result vector\n\t\tresult[k - heap_size] = smallest[1:2]\n\t\t\n\t\t# push the next element of nums1 to the heap\n\t\tif smallest[3] < n1\n\t\t\theap[heap_size + 1] = [nums1[smallest[3] + 1], smallest[2], smallest[3] + 1, smallest[4]]\n\t\t\theap_size += 1\n\t\tend\n\t\t\n\t\t# push the next element of nums2 to the heap\n\t\tif smallest[4] < n2 && smallest[3] == 1\n\t\t\theap[heap_size + 1] = [smallest[1], nums2[smallest[4] + 1], smallest[3], smallest[4] + 1]\n\t\t\theap_size += 1\n\t\tend\n\t\t\n\t\t# heapify the heap\n\t\ti = 1\n\t\twhile i <= heap_size\n\t\t\t# find the smallest child\n\t\t\tsmallest_child = i\n\t\t\tif 2i <= heap_size && heap[2i][1] + heap[2i][2] < heap[smallest_child][1] + heap[smallest_",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}(k)\n\t\n\t# iterate k times\n\tfor i in 1:k\n\t\t# pop the smallest pair\n\t\t(sum, i, j) = pop!(heap)\n\t\tresult[i] = [nums1[i], nums2[j]]\n\t\t\n\t\t# push the next pair\n\t\tif i == n1\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# Initialize a priority queue\n\tpq = PriorityQueue()\n\t\n\t# Initialize a set to store the visited pairs\n\tvisited = Set()\n\t\n\t# Initialize a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Push the first pair into the queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Push the first pair into the set\n\tpush!(visited, (1, 1))\n\t\n\t# Loop k times\n\tfor i in 1:k\n\t\t# If the queue is empty, break\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the first pair from the queue\n\t\t(sum, i, j) = pop!(pq)\n\t\t\n\t\t# Push the pair into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# If the i index is not the last one, push the pair with the next i index into the queue\n\t\tif i < length(nums1)\n\t\t\tif !(visited[(i + 1, j)])\n\t\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\t\tpush!(visited, (i + 1, j))\n\t\t\tend\n\t\tend\n\t\t\n\t\t# If the j index is not the last one, push the pair with the next j index into the queue\n\t\tif j < length(nums2)\n\t\t\tif !(visited[(i, j + 1)])\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\t\tpush!(visited, (i, j + 1))\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# Return the result\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# initialize the result\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the visited matrix\n\tvisited = zeros(Int64, n1, n2)\n\tvisited[1, 1] = 1\n\t\n\t# initialize the heap size\n\tsize = 1\n\t\n\tfor i in 1:k\n\t\t# pop the smallest pair from the heap\n\t\tcur = heap[1]\n\t\t\n\t\t# push the next smallest pair into the heap\n\t\tif cur[2] < n1 && visited[cur[2] + 1, cur[3]] == 0\n\t\t\theap[1] = [nums1[cur[2] + 1] + nums2[cur[3]], cur[2] + 1, cur[3]]\n\t\t\tvisited[cur[2] + 1, cur[3]] = 1\n\t\t\tsize += 1\n\t\t\theapify(heap, 1, size)\n\t\telseif cur[3] < n2 && visited[cur[2], cur[3] + 1] == 0\n\t\t\theap[1] = [nums1[cur[2]] + nums2[cur[3] + 1], cur[2], cur[3] + 1]\n\t\t\tvisited[cur[2], cur[3] + 1] = 1\n\t\t\tsize += 1\n\t\t\theapify(heap, 1, size)\n\t\telse\n\t\t\tsize -= 1\n\t\tend\n\t\t\n\t\t# push the current pair into the result\n\t\tres[i] = [nums1[cur[2]], nums1[cur[3]]]\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}()\n\twhile length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n1 && !visited_contains(visited, i + 1, j)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited_add!(visited, i + 1, j)\n\t\tend\n\t\tif j + 1 <= n2 && !visited_contains(visited, i, j + 1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited_add!(visited, i, j + 1)\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(k)\n\ti = 1\n\twhile i <= k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\tend\n\t\tif i1 == 1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\tend\n\t\ti += 1\n\tend\n\t\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\t\n\t# if k is greater than the total number of pairs, return all pairs\n\tif k > length(nums1)*length(nums2)\n\t\treturn [(nums1[i], nums2[j]) for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\t# initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# initialize the heap\n\theap = BinaryHeap()\n\t\n\t# push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# loop through the heap\n\tfor i in 1:k\n\t\t# pop the smallest pair\n\t\tpair = pop!(heap)\n\t\t\n\t\t# push the pair into the result vector\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# if the first element of the pair is the last element of nums1, push the next pair with the first element of nums1\n\t\tif pair[2] == length(nums1)\n\t\t\tpush!(heap, (nums1[1] + nums2[pair[3] + 1], 1, pair[3] + 1))\n\t\telse\n\t\t\tpush!(heap, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tsum, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1]+nums2[i2], i1+1, i2))\n\t\t\tpush!(pq, (nums1[i1]+nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\tif i < n1 && visited_add!(visited, i+1, j)\n\t\t\tpush!(pq, (nums1[i+1]+nums2[j], i+1, j))\n\t\tend\n\t\tif j < n2 && visited_add!(visited, i, j+1)\n\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\t# create a heap\n\theap = PriorityQueue()\n\t# push the first element of nums1 and nums2 into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# create a set to store the indices of nums1 and nums2\n\tindices = Set([(1,1)])\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the smallest element from the heap\n\t\t(sum, i1, i2) = pop!(heap)\n\t\t# push the element into the result\n\t\tpush!(result, [nums1[i1], nums2[i2]])\n\t\t# if the index of nums1 is not the last one\n\t\tif i1 < length(nums1)\n\t\t\t# if the index of nums2 is not the last one\n\t\t\tif i2 < length(nums2)\n\t\t\t\t# if the index of nums1 and nums2 is not in the set\n\t\t\t\tif !(indices[(i1+1, i2)])\n\t\t\t\t\t# push the element into the heap\n\t\t\t\t\tpush!(heap, (nums1[i1+1] + nums2[i2], i1+1, i2))\n\t\t\t\t\t# add the index into the set\n\t\t\t\t\tpush!(indices, (i1+1, i2))\n\t\t\t\tend\n\t\t\tend\n\t\t\t# if the index of nums2 is not in the set\n\t\t\tif !(indices[(i1, i2+1)])\n\t\t\t\t# push the element into the heap\n\t\t\t\tpush!(heap, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\t\t\t# add the index into the set\n\t\t\t\tpush!(indices, (i1, i2+1))\n\t\t\tend\n",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# Initialize the heap with the first k elements\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i], nums2[1], 1]\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# Build the heap\n\tfor i in floor(Int64, k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Extract the top k elements\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tres[i] = heap[1][1:2]\n\t\tif heap[1][3] < n2\n\t\t\theap[1] = [heap[1][1], nums2[heap[1][3] + 1], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = heap[k - i + 1]\n\t\tend\n\t\theapify(heap, 1, k - i)\n\tend\n\t\n\treturn res\nend",
    "\t# sort the two vectors\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# initialize a heap\n\theap = Heap()\n\t# initialize a set to store the pairs\n\tpairs = Set()\n\t# initialize a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# push the first pair into the set\n\tpush!(pairs, (1, 1))\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t# push the pair into the result\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t# if the first element of the pair is not the last element of the first vector\n\t\tif pair[2] < length(nums1)\n\t\t\t# push the pair with the first element of the first vector plus the next element of the second vector into the heap\n\t\t\tpush!(heap, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\t# push the pair with the first element of the first vector plus the next element of the second vector into the set\n\t\t\tpush!(pairs, (pair[2] + 1, pair[3]))\n\t\tend\n\t\t# if the second element of the pair is not the last element of the second vector\n\t\tif pair[3] < length(nums2)\n\t\t\t# push the pair with the first element of the first vector plus the next element of the second vector into the heap\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t\t# push the pair with the first element of the first vector plus the next element of the second vector into the set\n\t\t\tpush",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 0, 0]\n\t\n\t# Build the heap\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\t# Heapify\n\tfor i in floor(Int64, k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Find the k smallest pairs\n\tfor i in k+1:n1*n2\n\t\tif heap[1][1] > nums1[heap[1][2] + 1] + nums2[heap[1][3]]\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\telseif heap[1][3] < n2 && heap[1][1] > nums1[heap[1][2]] + nums2[heap[1][3] + 1]\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\t# Return the result\n\treturn heap\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\ttop = pop!(pq)\n\t\tpush!(res, [nums1[top[2]], nums2[top[3]]])\n\t\tif top[3] < m\n\t\t\tif !visited_contains(visited, top[2], top[3] + 1)\n\t\t\t\tpush!(pq, (nums1[top[2]] + nums2[top[3] + 1], top[2], top[3] + 1))\n\t\t\t\tvisited_add(visited, top[2], top[3] + 1)\n\t\t\tend\n\t\tend\n\t\tif top[2] < n\n\t\t\tif !visited_contains(visited, top[2] + 1, top[3])\n\t\t\t\tpush!(pq, (nums1[top[2] + 1] + nums2[top[3]], top[2] + 1, top[3]))\n\t\t\t\tvisited_add(visited, top[2] + 1, top[3])\n\t\t\tend\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tbuild_heap!(heap)\n\t\n\t# pop the smallest pair\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\tres[i] = pop!(heap)\n\t\tif res[i][3] < n2\n\t\t\tpush!(heap, [res[i][1], nums2[res[i][3] + 1], res[i][3] + 1])\n\t\tend\n\t\tbuild_heap!(heap)\n\tend\n\t\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector of integers\n\tnums2: Vector of integers\n\tk: Number of smallest pairs to return\n\t\"\"\"\n\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Initialize the first pair\n\tpairs[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# Initialize the rest of the pairs\n\tfor i in 2:k\n\t\tif pairs[i - 1][2] == n1\n\t\t\tpairs[i] = [nums1[n1] + nums2[pairs[i - 1][3] + 1], n1, pairs[i - 1][3] + 1]\n\t\telseif pairs[i - 1][3] == n2\n\t\t\tpairs[i] = [nums1[pairs[i - 1][2] + 1] + nums2[n2], pairs[i - 1][2] + 1, n2]\n\t\telse\n\t\t\tpairs[i] = [nums1[pairs[i - 1][2] + 1] + nums2[pairs[i - 1][3]], pairs[i - 1][2] + 1, pairs[i - 1][3]]\n\t\tend\n\tend\n\t\n\t# Sort the pairs\n\tsort!(pairs, by = x -> x[1])\n\t\n\t# Return the first k pairs\n\treturn pairs[1:k]\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue(k)\n\t\n\tfor i in 1:n1\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\tres = []\n\t\n\twhile length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t# create a priority queue\n\tpq = PriorityQueue()\n\t# push the first element of each vector into the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# create a set to store the indices of the elements that have been pushed into the priority queue\n\tset = Set([(1, 1)])\n\t# create a vector to store the result\n\tres = Vector{Vector{Int64}}()\n\t# loop k times\n\tfor i in 1:k\n\t\t# if the priority queue is empty, break\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t# pop the top element from the priority queue\n\t\tsum, i, j = pop!(pq)\n\t\t# push the popped element into the result vector\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t# if the popped element is the last element of the first vector, continue\n\t\tif i == length(nums1)\n\t\t\tcontinue\n\t\tend\n\t\t# if the popped element is the last element of the second vector, continue\n\t\tif j == length(nums2)\n\t\t\tcontinue\n\t\tend\n\t\t# if the popped element is not the last element of the first vector, push the next element of the first vector into the priority queue\n\t\tif !(i + 1, j) in set\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(set, (i + 1, j))\n\t\tend\n\t\t# if the popped element is not the last element of the second vector, push the next element of the second vector into the priority queue\n\t\tif !(i, j + 1) in set\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(set, (i, j + 1))\n\t\tend\n\tend\n\t# return the result vector\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# create a heap of size k\n\theap = PriorityQueue(k)\n\t\n\t# push the first k pairs into the heap\n\tfor i in 1:min(k, length(nums1))\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# pop the smallest pairs from the heap and push the next pairs\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the smallest pair\n\t\tpair = pop!(heap)\n\t\t\n\t\t# store the pair\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# push the next pair\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first element of each array\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1], nums2[1], 1, 1])\n\t\n\t# Initialize the result array\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Loop until the heap is empty or we have k elements in the result array\n\twhile !isempty(heap) && length(result) < k\n\t\t# Get the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\tpush!(result, pair[1:2])\n\t\t\n\t\t# If the first array has more elements, add the next element of the first array to the heap\n\t\tif pair[3] < n1\n\t\t\tpush!(heap, [nums1[pair[3] + 1], pair[2], pair[3] + 1, pair[4]])\n\t\tend\n\t\t\n\t\t# If the second array has more elements, add the next element of the second array to the heap\n\t\tif pair[4] < n2 && pair[3] == 1\n\t\t\tpush!(heap, [pair[1], nums2[pair[4] + 1], pair[3], pair[4] + 1])\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile !isempty(pq) && length(res) < k\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n && j == 1\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t\n\t\tif j < m\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize a priority queue\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Initialize a set to store the pairs\n\tpairs = Set{Vector{Int64}}()\n\t\n\twhile length(pairs) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(pairs, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn collect(pairs)\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\theapify!(heap)\n\t\n\t# pop the top k pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\tresult[i] = pop!(heap)\n\t\tif result[i][3] < n2\n\t\t\tpush!(heap, [result[i][1], nums2[result[i][3] + 1], result[i][3] + 1])\n\t\t\theapify!(heap)\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# create a heap\n\theap = Heap()\n\t# push the first pair into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# create a set to store the indices of the pairs that have been pushed into the heap\n\tindices = Set()\n\t# create a vector to store the k smallest pairs\n\tk_smallest_pairs = Vector{Vector{Int64}}()\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the smallest pair from the heap\n\t\t(sum, index1, index2) = pop!(heap)\n\t\t# push the pair into the k_smallest_pairs vector\n\t\tpush!(k_smallest_pairs, [nums1[index1], nums2[index2]])\n\t\t# if the index1 is not the last index of the nums1 vector\n\t\tif index1 < length(nums1)\n\t\t\t# if the pair (index1 + 1, index2) has not been pushed into the heap\n\t\t\tif !(index1 + 1, index2) in indices\n\t\t\t\t# push the pair into the heap\n\t\t\t\tpush!(heap, (nums1[index1 + 1] + nums2[index2], index1 + 1, index2))\n\t\t\t\t# add the pair into the indices set\n\t\t\t\tpush!(indices, (index1 + 1, index2))\n\t\t\tend\n\t\tend\n\t\t# if the index2 is not the last index of the nums2 vector\n\t\tif index2 < length(nums2)\n\t\t\t# if the pair (index1, index2 + 1) has not been pushed into the heap\n\t\t\tif !(index1, index2 + 1) in indices\n\t\t\t\t# push the pair into the heap\n\t\t\t\tpush!(heap, (nums1[index1] + nums2[index2 + 1], index1, index2 + 1))\n\t\t\t\t# add the pair into the indices set\n\t\t\t\tpush!(indices, (index1,",
    "\t\"\"\"\n\tInput:\n\t\tnums1: Vector{Int64}\n\t\tnums2: Vector{Int64}\n\t\tk: Int64\n\tOutput:\n\t\tVector{Vector{Int64}}\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k >= length(nums1) * length(nums2)\n\t\treturn [nums1[i] + nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [nums1[1] + nums2[1], 1, 1]\n\tend\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tif nums1[i] + nums2[j] < result[k][1]\n\t\t\t\tresult[k] = [nums1[i] + nums2[j], i, j]\n\t\t\t\tresult = sort(result, by = x -> x[1])\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t\n\t# push the first element of each vector into the priority queue\n\tfor i in 1:n\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop the first k elements from the priority queue\n\tres = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the first element from the priority queue\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\t# push the next element from the second vector into the priority queue\n\t\tif j < m\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\theap = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile k > 0 && !isempty(heap)\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif j == length(nums2)\n\t\t\tpush!(heap, (nums1[i+1] + nums2[j], i+1, j))\n\t\telse\n\t\t\tpush!(heap, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\t\n\twhile k > 0 && !isempty(pq)\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\t\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif pairs[l][1] + pairs[l][2] > pairs[l+1][1] + pairs[l+1][2]\n\t\t\t\t\t\tpairs[l], pairs[l+1] = pairs[l+1], pairs[l]\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\t# Initialize the heap\n\theap = BinaryHeap()\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t\n\t# Pop k elements from the heap\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\tpush!(result, [nums1[heap.data[1][2]], nums2[heap.data[1][3]]])\n\t\tpop!(heap)\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] * nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\tpq = PriorityQueue()\n\tfor i in 1:length(nums1)\n\t\tpush!(pq, (nums1[i] * nums2[1], i, 1))\n\tend\n\t\n\tresult = Vector{Vector{Int64}}()\n\twhile length(result) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] * nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t\n\t# Initialize a heap and a result vector\n\theap = BinaryHeap()\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Initialize a vector of indices\n\tindices = Vector{Int64}(1:length(nums2))\n\t\n\t# Push the first k pairs into the heap\n\tfor i in 1:k\n\t\tpush!(heap, (nums1[i] + nums2[indices[i]], i, indices[i]))\n\tend\n\t\n\t# Pop the smallest pair from the heap and push the next pair from the same vector\n\tfor i in 1:k\n\t\tpair = pop!(heap)\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# sort the two vectors\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t# create a heap\n\theap = Heap{Tuple{Int64, Int64}}()\n\t# push the first k pairs into the heap\n\tfor i in 1:k\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t# create a list to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# pop the heap\n\twhile !isempty(heap)\n\t\t# pop the first element\n\t\t(sum, i, j) = pop!(heap)\n\t\t# push the sum into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# if j is not the last element of nums2\n\t\tif j < length(nums2)\n\t\t\t# push the next pair into the heap\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t# return the result\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1] + nums2[i2], i1+1, i2))\n\t\tend\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\tfor i = 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1], n1, i - n1]\n\t\tend\n\tend\n\t\n\t# Heapify\n\tfor i = k \u00f7 2:1:-1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the smallest element\n\tfor i = k + 1:n1 * n2\n\t\tif i <= n1\n\t\t\theap[1] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[1] = [nums1[n1] + nums2[i - n1], n1, i - n1]\n\t\tend\n\t\t\n\t\theapify(heap, 1, k)\n\tend\n\t\n\t# Get the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tresult[i] = [nums1[heap[i][2]], nums2[heap[i][3]]]\n\tend\n\t\n\treturn result\nend",
    "\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t# Initialize the priority queue\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\t# Initialize the first element\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# Initialize the counter\n\tcount = 0\n\t# Loop until the queue is empty\n\twhile !isempty(pq) && count < k\n\t\t# Pop the top element\n\t\t(sum, i, j) = pop!(pq)\n\t\t# Push the element into the result vector\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# Increment the counter\n\t\tcount += 1\n\t\t# Push the next element into the queue\n\t\tif i < length(nums1) && j == 1\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t# Push the next element into the queue\n\t\tif j < length(nums2) && i == 1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t# Return the result vector\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k == 0\n\t\treturn []\n\tend\n\t\n\tif n1*n2 <= k\n\t\treturn [nums1[i] + nums2[j] for i in 1:n1, j in 1:n2]\n\tend\n\t\n\t# heap\n\th = BinaryHeap()\n\t\n\t# push the first element\n\tpush!(h, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# push the rest of the elements\n\tfor i in 2:n1\n\t\tpush!(h, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop the k smallest elements\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(h)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\t\n\t\tif j < n2\n\t\t\tpush!(h, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tk = min(k, n1*n2)\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}(undef, k)\n\t\n\tfor i in 1:k\n\t\tval, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\t\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1]+nums2[i2], i1+1, i2))\n\t\tend\n\t\t\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1]+nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\t# Initialize the heap\n\theap = Heap(Tuple{Int64, Int64, Int64})\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# Pop k elements from the heap\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the smallest element\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# Push the next element\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([(1, 1)])\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && !(i1 + 1, i2) in visited\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\t\tpush!(visited, (i1 + 1, i2))\n\t\tend\n\t\tif i2 < n2 && !(i1, i2 + 1) in visited\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\t\tpush!(visited, (i1, i2 + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([1])\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tres[i] = [nums1[i], nums2[j]]\n\t\tif i + 1 <= n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j + 1 <= n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# Heapify\n\tfor i in 1:k\n\t\theapify(heap, i)\n\tend\n\t\n\t# Pop the top k pairs\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = pop!(heap)\n\tend\n\t\n\treturn res\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([1])\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tval, i1, i2 = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1 && !(i1 + 1 in visited)\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\t\tpush!(visited, i1 + 1)\n\t\tend\n\t\tif i2 < n2 && !(i2 + 1 in visited)\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\t\tpush!(visited, i2 + 1)\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# create a heap\n\theap = Heap(Tuple{Int64, Int64, Int64})\n\t\n\t# push the first element of each array into the heap\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop the k smallest pairs\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# push the next pair from the same array\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([(1, 1)])\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\tt = pop!(pq)\n\t\tpush!(res, [nums1[t[2]], nums2[t[3]]])\n\t\tif t[2] < n1 && !(t[2] + 1, t[3]) in visited\n\t\t\tpush!(pq, (nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3]))\n\t\t\tpush!(visited, (t[2] + 1, t[3]))\n\t\tend\n\t\tif t[3] < n2 && !(t[2], t[3] + 1) in visited\n\t\t\tpush!(pq, (nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1))\n\t\t\tpush!(visited, (t[2], t[3] + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# Heapify\n\tfor i = k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Extract the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tresult[i] = heap[1][1:2]\n\t\tif heap[1][3] < n2\n\t\t\theap[1][1] = nums1[heap[1][3] + 1]\n\t\t\theap[1][3] += 1\n\t\telse\n\t\t\theap[1] = heap[k]\n\t\t\tk -= 1\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the first k pairs\n\tfor i in 1:k\n\t\tif i <= n\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# build the heap\n\tbuild_max_heap!(heap)\n\t\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = heap[1]\n\t\t\n\t\t# get the next pair\n\t\tif heap[1][3] < m\n\t\t\theap[1] = [heap[1][1], nums2[heap[1][3] + 1], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\tend\n\t\t\n\t\t# heapify\n\t\tmax_heapify!(heap, 1)\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\twhile length(result) < k && !isempty(pq)\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# create a heap\n\theap = BinaryHeap()\n\t# push the first element of each vector into the heap\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# create a set to store the visited pairs\n\tvisited = Set()\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# loop k times\n\tfor i in 1:k\n\t\t# pop the smallest pair from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\t# push the pair into the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# if the first element of the pair is the last element of nums1, then we don't need to push the next pair into the heap\n\t\tif i == length(nums1)\n\t\t\tcontinue\n\t\tend\n\t\t# if the pair (i+1, j) is not visited, then push it into the heap\n\t\tif !(i+1, j) in visited\n\t\t\tpush!(heap, (nums1[i+1] + nums2[j], i+1, j))\n\t\t\tpush!(visited, (i+1, j))\n\t\tend\n\t\t# if the pair (i, j+1) is not visited, then push it into the heap\n\t\tif j < length(nums2) && !(i, j+1) in visited\n\t\t\tpush!(heap, (nums1[i] + nums2[j+1], i, j+1))\n\t\t\tpush!(visited, (i, j+1))\n\t\tend\n\tend\n\t# return the result\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\twhile length(result) < k && !isempty(pq)\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\theapify!(heap)\n\t\n\t# pop the smallest pair and push the next pair\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = pop!(heap)\n\t\tif result[i][3] < n2\n\t\t\tpush!(heap, [result[i][1], nums2[result[i][3] + 1], result[i][3] + 1])\n\t\tend\n\t\theapify!(heap)\n\tend\n\t\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([(1, 1)])\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tsum, x, y = pop!(pq)\n\t\tres[i] = [nums1[x], nums2[y]]\n\t\tif x < n && !(x + 1, y) in visited\n\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\t\tpush!(visited, (x + 1, y))\n\t\tend\n\t\tif y < m && !(x, y + 1) in visited\n\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\t\tpush!(visited, (x, y + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set()\n\t\n\t# push the first pair into the queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tres = Vector{Vector{Int64}}()\n\t\n\t# loop k times\n\tfor i in 1:k\n\t\t# if the queue is empty, break the loop\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the smallest pair from the queue\n\t\tpair = pop!(pq)\n\t\t\n\t\t# add the pair to the result\n\t\tpush!(res, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# if the first element of the pair is not the last element of the first vector\n\t\tif pair[2] < length(nums1)\n\t\t\t# push the pair with the first element of the pair being the next element of the first vector\n\t\t\tpush!(pq, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\tpush!(visited, (pair[2] + 1, pair[3]))\n\t\tend\n\t\t\n\t\t# if the second element of the pair is not the last element of the second vector\n\t\tif pair[3] < length(nums2)\n\t\t\t# push the pair with the second element of the pair being the next element of the second vector\n\t\t\tpush!(pq, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t\tpush!(visited, (pair[2], pair[3] + 1))\n\t",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i = div(k, 2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the top of the heap and push the next element of the popped element\n\tfor i = k+1:n1*n2\n\t\tif i <= k\n\t\t\tif heap[1][3] < n2\n\t\t\t\theap[1][3] += 1\n\t\t\t\theap[1][2] = nums2[heap[1][3]]\n\t\t\tend\n\t\telse\n\t\t\tif heap[1][3] < n2\n\t\t\t\theap[1][3] += 1\n\t\t\t\theap[1][2] = nums2[heap[1][3]]\n\t\t\telse\n\t\t\t\theap[1] = [nums1[div(i-1, n2)+1], nums2[mod(i-1, n2)+1], mod(i-1, n2)+1]\n\t\t\tend\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tn = min(n1, n2)\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif i == 1 && j == 1\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tfor l in k-1:-1:1\n\t\t\t\t\tif pairs[l][1] + pairs[l][2] > pairs[l+1][1] + pairs[l+1][2]\n\t\t\t\t\t\tpairs[l], pairs[l+1] = pairs[l+1], pairs[l]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i = 2:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i = k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the top k pairs\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tres[i] = [heap[1][2], heap[1][3]]\n\t\t\n\t\t# update the heap\n\t\tif heap[1][3] < n2\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\tend\n\t\theapify(heap, 1, length(heap))\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) * length(nums2) == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\t# create a heap\n\theap = Heap(k)\n\t\n\t# push the first k pairs into the heap\n\tfor i in 1:min(k, length(nums1))\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop the smallest pair and push the next pair from the same vector\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(heap)\n\t\tresult[i] = [nums1[i1], nums2[i2]]\n\t\tif i2 < length(nums2)\n\t\t\tpush!(heap, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\tif k > n*m\n\t\tk = n*m\n\tend\n\t\n\t# create a heap of size k\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tif heap[j][1] < heap[j\u00f72][1]\n\t\t\t\theap[j], heap[j\u00f72] = heap[j\u00f72], heap[j]\n\t\t\t\tj = j\u00f72\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# pop the smallest element\n\tfor i in k+1:n*m\n\t\tif nums1[(i-1)\u00f7m+1] + nums2[(i-1)%m+1] < heap[1][1]\n\t\t\theap[1] = [nums1[(i-1)\u00f7m+1] + nums2[(i-1)%m+1], (i-1)\u00f7m+1, (i-1)%m+1]\n\t\tend\n\t\tj = 1\n\t\twhile 2j <= k\n\t\t\tif 2j+1 <= k\n\t\t\t\tif heap[2j][1] < heap[2j+1][1]\n\t\t\t\t\tif heap[j][1] > heap[2j][1]\n\t\t\t\t\t\theap[j], heap[2j] = heap[2j], heap[j]\n\t\t\t\t\t\tj = 2j\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\t",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# Initialize the heap with the first element of nums1\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t\n\t# Iterate over the heap\n\tfor i in 2:k\n\t\t# Get the top element of the heap\n\t\ttop = heap[1]\n\t\t\n\t\t# Add the top element to the result\n\t\tresult[i - 1] = [nums1[top[2]], nums2[top[3]]]\n\t\t\n\t\t# If the second element of the top element is not the last element of nums1\n\t\tif top[2] < n\n\t\t\t# Add the next element of nums1 to the heap\n\t\t\theap[1] = [nums1[top[2] + 1] + nums2[top[3]], top[2] + 1, top[3]]\n\t\t# If the third element of the top element is not the last element of nums2\n\t\telseif top[3] < m\n\t\t\t# Add the next element of nums2 to the heap\n\t\t\theap[1] = [nums1[top[2]] + nums2[top[3] + 1], top[2], top[3] + 1]\n\t\t# If the second element of the top element is the last element of nums1 and the third element of the top element is the last element of nums2\n\t\telse\n\t\t\t# Remove the top element from the heap\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\t\t\n\t\t\t# If the heap is empty\n\t\t\tif isempty(heap)\n\t\t\t\t#",
    "\t# nums1 = [1,7,11]\n\t# nums2 = [2,4,6]\n\t# k = 3\n\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t# initialize the heap\n\theap = Heap(k)\n\tfor i in 1:length(nums1)\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t# pop the first k elements\n\tresult = []\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn result\nend",
    "\t# Initialize a priority queue\n\tpq = PriorityQueue()\n\t# Initialize a set to store the visited pairs\n\tvisited = Set()\n\t# Initialize a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# Initialize a tuple to store the current pair\n\tcurr = (nums1[1], nums2[1])\n\t# Push the first pair into the priority queue\n\tpush!(pq, curr)\n\t# Push the first pair into the set\n\tpush!(visited, curr)\n\t# Loop until the priority queue is empty or the result vector has k elements\n\twhile !isempty(pq) && length(result) < k\n\t\t# Pop the current pair from the priority queue\n\t\tcurr = pop!(pq)\n\t\t# Push the current pair into the result vector\n\t\tpush!(result, curr)\n\t\t# If the first element of the current pair is not the last element of the first vector\n\t\tif curr[1] < nums1[end]\n\t\t\t# Create a new pair by adding 1 to the first element of the current pair\n\t\t\tnew_pair = (curr[1] + 1, curr[2])\n\t\t\t# If the new pair is not in the set\n\t\t\tif !(new_pair in visited)\n\t\t\t\t# Push the new pair into the priority queue\n\t\t\t\tpush!(pq, new_pair)\n\t\t\t\t# Push the new pair into the set\n\t\t\t\tpush!(visited, new_pair)\n\t\t\tend\n\t\tend\n\t\t# If the second element of the current pair is not the last element of the second vector\n\t\tif curr[2] < nums2[end]\n\t\t\t# Create a new pair by adding 1 to the second element of the current pair\n\t\t\tnew_pair = (curr[1], curr[2] + 1)\n\t\t\t# If the new pair is not in the set\n\t\t\tif !(new_pair in visited)\n\t\t\t\t# Push the new pair into the priority queue\n\t\t\t\tpush!(",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize a heap\n\theap = Heap(k)\n\t\n\t# Add the first k pairs to the heap\n\tfor i in 1:min(k, length(nums1))\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}(k)\n\t\n\t# Pop the smallest pair from the heap and add the next pair from the same row\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t\n\t\t# Add the pair to the result\n\t\tresult[i] = [nums1[pair[2]], nums2[pair[3]]]\n\t\t\n\t\t# Add the next pair from the same row\n\t\tif pair[3] < length(nums2)\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile !isempty(pq) && length(res) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpairs = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpairs[i] = [nums1[1], nums2[1]]\n\tend\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif nums1[i] + nums2[j] < pairs[k][1] + pairs[k][2]\n\t\t\t\tpairs[k] = [nums1[i], nums2[j]]\n\t\t\t\tpairs = sort(pairs, by=x->x[1]+x[2])\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue()\n\tfor i in 1:length(nums1)\n\t\tpush!(pq, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop k elements from the queue\n\tres = []\n\tfor i in 1:k\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\theap[i] = [nums1[i], nums2[i], 1]\n\tend\n\t# build the heap\n\tfor i = floor(Int64, k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t# update the heap\n\tfor i = k+1:n1\n\t\tif nums1[i] + nums2[1] < heap[1][1] + heap[1][2]\n\t\t\theap[1] = [nums1[i], nums2[1], 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\tfor i = k+1:n2\n\t\tif nums1[1] + nums2[i] < heap[1][1] + heap[1][2]\n\t\t\theap[1] = [nums1[1], nums2[i], 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t# update the heap\n\tfor i = 1:k\n\t\tif heap[i][3] < n2\n\t\t\theap[i][1] = nums1[heap[i][3]]\n\t\t\theap[i][2] = nums2[heap[i][3]+1]\n\t\t\theap[i][3] += 1\n\t\t\theapify(heap, i, k)\n\t\tend\n\tend\n\treturn heap\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\ti, j = 1, 1\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor l in 1:k\n\t\tif nums1[i] + nums2[j] < nums1[i] + nums2[j+1]\n\t\t\tres[l] = [nums1[i], nums2[j]]\n\t\t\tif j == n2\n\t\t\t\ti += 1\n\t\t\telse\n\t\t\t\tj += 1\n\t\t\tend\n\t\telse\n\t\t\tres[l] = [nums1[i], nums2[j+1]]\n\t\t\tif i == n1\n\t\t\t\tj += 1\n\t\t\telse\n\t\t\t\ti += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tm = length(nums1)\n\tn = length(nums2)\n\t\n\t# create a heap of size k\n\theap = Vector{Vector{Int64}}(undef, k)\n\t\n\t# initialize the heap with the first k elements\n\tfor i = 1:k\n\t\tif i <= m\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify the heap\n\theapify!(heap)\n\t\n\t# create a vector to store the k smallest pairs\n\tk_smallest_pairs = Vector{Vector{Int64}}(undef, k)\n\t\n\t# extract the k smallest pairs\n\tfor i = 1:k\n\t\t# extract the top element from the heap\n\t\ttop = pop!(heap)\n\t\t\n\t\t# add the top element to the k smallest pairs vector\n\t\tpush!(k_smallest_pairs, top[1:2])\n\t\t\n\t\t# if the top element is not the last element of the second vector, add the next element to the heap\n\t\tif top[3] < n\n\t\t\tpush!(heap, [top[1], nums2[top[3] + 1], top[3] + 1])\n\t\tend\n\t\t\n\t\t# heapify the heap\n\t\theapify!(heap)\n\tend\n\t\n\treturn k_smallest_pairs\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] * nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\theap = BinaryHeap()\n\tpush!(heap, (nums1[1] * nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile length(result) < k\n\t\t(val, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\tif i < length(nums1)\n\t\t\tpush!(heap, (nums1[i+1] * nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(heap, (nums1[i] * nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# create a heap\n\theap = Heap(Tuple{Int64, Int64, Int64})\n\t\n\t# push the first element of the first vector\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# iterate k times\n\tfor i in 1:k\n\t\t# if the heap is empty, break\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# pop the top element from the heap\n\t\t(sum, i, j) = pop!(heap)\n\t\t\n\t\t# push the pair to the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# if the first element is not the last element of the first vector\n\t\tif i < length(nums1)\n\t\t\t# if the pair is not visited\n\t\t\tif !(i + 1, j) in visited\n\t\t\t\t# push the pair to the heap and mark it as visited\n\t\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\t\tpush!(visited, (i + 1, j))\n\t\t\tend\n\t\tend\n\t\t\n\t\t# if the second element is not the last element of the second vector\n\t\tif j < length(nums2)\n\t\t\t# if the pair is not visited\n\t\t\tif !(i, j + 1) in visited\n\t\t\t\t# push the pair to the heap and mark it as visited\n\t\t\t\tpush!(heap, (nums",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\t# push the first k elements into the heap\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1], n1, i - n1]\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the first k elements\n\tfor i in k:-1:1\n\t\theap[1], heap[i] = heap[i], heap[1]\n\t\theapify(heap, 1, i-1)\n\tend\n\t\n\t# push the next elements into the heap\n\tfor i in k+1:n1 * n2\n\t\tif i <= n1 * n2\n\t\t\theap[1] = [nums1[heap[1][2]] + nums2[heap[1][3] + 1], heap[1][2], heap[1][3] + 1]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\t# pop the next k elements\n\tfor i in k:-1:1\n\t\theap[1], heap[i] = heap[i], heap[1]\n\t\theapify(heap,",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# create a heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tif heap[j][1] < heap[j \u00f7 2][1]\n\t\t\t\theap[j], heap[j \u00f7 2] = heap[j \u00f7 2], heap[j]\n\t\t\t\tj = j \u00f7 2\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# pop the smallest element and push the next element\n\tfor i in k+1:n1*n2\n\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tj = 1\n\t\twhile j < k\n\t\t\tif j * 2 + 1 > k\n\t\t\t\tif heap[j][1] > heap[j * 2][1]\n\t\t\t\t\theap[j], heap[j * 2] = heap[j * 2], heap[j]\n\t\t\t\t\tj = j * 2\n\t\t\t\telse\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif heap[j][1] > heap[j * 2][1] || heap[j][1] > heap[j * 2 + 1][1]\n\t\t\t\t\tif heap[j * 2][1] < heap[j * 2 + 1][1]\n\t\t\t\t\t\theap[j], heap[j * 2] = heap",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i], nums2[1], 1]\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the heap\n\tfor i in k+1:n1\n\t\tif nums1[i] + nums2[1] < heap[1][1] + heap[1][2]\n\t\t\theap[1] = [nums1[i], nums2[1], 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\tfor i in k+1:n1 * n2\n\t\tif nums1[heap[1][3]] + nums2[heap[1][3] + 1] < heap[1][1] + heap[1][2]\n\t\t\theap[1] = [nums1[heap[1][3]], nums2[heap[1][3] + 1], heap[1][3] + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in 2:k\n\t\theapify(heap, i)\n\tend\n\t\n\t# extract the top k elements\n\tfor i in k+1:n1*n2\n\t\tif heap[1][1] > nums1[(i-1) div n2 + 1] + nums2[(i-1) mod n2 + 1]\n\t\t\theap[1] = [nums1[(i-1) div n2 + 1] + nums2[(i-1) mod n2 + 1], (i-1) div n2 + 1, (i-1) mod n2 + 1]\n\t\t\theapify(heap, 1)\n\t\tend\n\tend\n\t\n\t# extract the top k elements\n\tfor i in 1:k\n\t\theap[i] = [heap[i][2], heap[i][3]]\n\tend\n\t\n\treturn heap\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Dict()\n\tvisited[(1, 1)] = true\n\tresult = Vector{Vector{Int64}}()\n\twhile length(result) < k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif i + 1 <= n && !haskey(visited, (i + 1, j))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tvisited[(i + 1, j)] = true\n\t\tend\n\t\tif j + 1 <= m && !haskey(visited, (i, j + 1))\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tvisited[(i, j + 1)] = true\n\t\tend\n\tend\n\treturn result\nend",
    "\t# create a priority queue\n\tpq = PriorityQueue()\n\t# push the first element of each vector\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\t# create a set to store the visited pairs\n\tvisited = Set()\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# loop through the priority queue\n\twhile length(result) < k && !isempty(pq)\n\t\t# pop the first element\n\t\t(sum, i, j) = pop!(pq)\n\t\t# add the pair to the result\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# check if the next element of the first vector is valid\n\t\tif i < length(nums1)\n\t\t\t# check if the pair is visited\n\t\t\tif !(i+1, j) in visited\n\t\t\t\t# push the pair to the priority queue\n\t\t\t\tpush!(pq, (nums1[i+1]+nums2[j], i+1, j))\n\t\t\t\t# add the pair to the visited set\n\t\t\t\tpush!(visited, (i+1, j))\n\t\t\tend\n\t\tend\n\t\t# check if the next element of the second vector is valid\n\t\tif j < length(nums2)\n\t\t\t# check if the pair is visited\n\t\t\tif !(i, j+1) in visited\n\t\t\t\t# push the pair to the priority queue\n\t\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\t\t\t# add the pair to the visited set\n\t\t\t\tpush!(visited, (i, j+1))\n\t\t\tend\n\t\tend\n\tend\n\t# return the result\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# initialize heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in 1:k\n\t\tj = i\n\t\twhile j > 1\n\t\t\tif heap[j][1] + heap[j][2] < heap[j\u00f72][1] + heap[j\u00f72][2]\n\t\t\t\theap[j], heap[j\u00f72] = heap[j\u00f72], heap[j]\n\t\t\t\tj = j\u00f72\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# pop and push\n\tfor i in k+1:n1*n2\n\t\tif i <= n1*n2\n\t\t\tpush!(heap, [nums1[heap[1][3]], nums2[heap[1][2]+1], heap[1][3]])\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\t\tj = 1\n\t\t\twhile 2j <= length(heap)\n\t\t\t\tif 2j+1 <= length(heap)\n\t\t\t\t\tif heap[j][1] + heap[j][2] > heap[2j][1] + heap[2j][2] || heap[j][1] + heap[j][2] > heap[2j+1][1] + heap[2j+1][2]\n\t\t\t\t\t\tif heap[2j][1] + heap[2j][2] < heap[2j+1][1] + heap[2j+1][2]\n\t\t\t\t\t\t\theap[j",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, x, y) = pop!(pq)\n\t\tres[i] = [nums1[x], nums2[y]]\n\t\tif x + 1 <= n && !visited_contains(visited, x + 1, y)\n\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\t\tvisited_add(visited, x + 1, y)\n\t\tend\n\t\tif y + 1 <= m && !visited_contains(visited, x, y + 1)\n\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\t\tvisited_add(visited, x, y + 1)\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in (k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the smallest pair and push the next pair\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = heap[1][1:2]\n\t\tif heap[1][3] == n2\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\telse\n\t\t\theap[1][1] = nums1[heap[1][3] + 1]\n\t\t\theap[1][3] += 1\n\t\tend\n\t\theapify(heap, 1, length(heap))\n\tend\n\t\n\treturn result\nend",
    "\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1], nums2[1], 1, 1])\n\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t# Initialize the visited vector\n\tvisited = Vector{Vector{Int64}}()\n\tpush!(visited, [1, 1])\n\t# Loop until the heap is empty or the result vector has k elements\n\twhile !isempty(heap) && length(result) < k\n\t\t# Get the smallest pair from the heap\n\t\tpair = pop!(heap)\n\t\t# Add the pair to the result vector\n\t\tpush!(result, pair)\n\t\t# Get the next pair from the first vector\n\t\tnext_pair = [nums1[pair[3]], nums2[pair[4] + 1], pair[3], pair[4] + 1]\n\t\t# Check if the next pair is not visited\n\t\tif !(next_pair[3] in [visited[i][1] for i in 1:length(visited)] && next_pair[4] in [visited[i][2] for i in 1:length(visited)])\n\t\t\t# Add the next pair to the heap\n\t\t\tpush!(heap, next_pair)\n\t\t\t# Add the next pair to the visited vector\n\t\t\tpush!(visited, next_pair)\n\t\tend\n\t\t# Get the next pair from the second vector\n\t\tnext_pair = [nums1[pair[3] + 1], nums2[pair[4]], pair[3] + 1, pair[4]]\n\t\t# Check if the next pair is not visited\n\t\tif !(next_pair[3] in [visited[i][1] for i in 1:length(visited)] && next_pair[4] in [visited[i][2] for i in 1:length(visited)])\n\t\t\t# Add the next pair to the heap\n\t\t\tpush!(heap, next_pair)",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = []\n\twhile !isempty(pq) && length(res) < k\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile !isempty(pq) && k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\t\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\t\n\t\tif i == 1 && j < length(nums2)\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 0, 0]\n\t\n\t# push the first k pairs into the heap\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the first k pairs\n\tfor i in k+1:n1*n2\n\t\tif i <= n1\n\t\t\tif heap[1][1] > nums1[i] + nums2[1]\n\t\t\t\theap[1] = [nums1[i] + nums2[1], i, 1]\n\t\t\t\theapify(heap, 1, k)\n\t\t\tend\n\t\telse\n\t\t\tif heap[1][1] > nums1[n1] + nums2[i - n1 + 1]\n\t\t\t\theap[1] = [nums1[n1] + nums2[i - n1 + 1], n1, i - n1 + 1]\n\t\t\t\theapify(heap, 1, k)\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn heap\nend",
    "\tif length(nums1) * length(nums2) <= k\n\t\treturn [nums1[i] nums2[j] for i in 1:length(nums1), j in 1:length(nums2)]\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[i] nums2[1]]\n\tend\n\t\n\t# Heapify\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the top element and push the next element from the same vector\n\tfor i in k+1:length(nums1)\n\t\theap[1] = [nums1[i] nums2[1]]\n\t\theapify(heap, 1, k)\n\tend\n\t\n\t# Pop the top element and push the next element from the same vector\n\tfor j in 2:length(nums2)\n\t\theap[1] = [heap[1][1] nums2[j]]\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn heap\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap[1][2], heap[1][3]]\n\t\t\n\t\t# update the heap\n\t\tif heap[1][2] == length(nums1)\n\t\t\theap[1] = [heap[k][1], heap[k][2], heap[k][3]]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\twhile k > 0 && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif i == length(nums1)\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == length(nums2)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i in (k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the smallest element\n\tfor i in k+1:n1*n2\n\t\tif i <= n1*n2\n\t\t\theap[1] = [nums1[heap[1][2]], nums2[heap[1][3]], heap[1][3]+1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\treturn heap\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\t\n\tif k > n*m\n\t\tk = n*m\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\tfor i in 1:k\n\t\t(sum, x, y) = pop!(pq)\n\t\tpush!(result, [nums1[x], nums2[y]])\n\t\t\n\t\tif y == m\n\t\t\tpush!(pq, (nums1[x+1] + nums2[y], x+1, y))\n\t\telseif y < m\n\t\t\tpush!(pq, (nums1[x] + nums2[y+1], x, y+1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t# Initialize the heap with the first element of nums1 and nums2\n\theap = PriorityQueue()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Loop until the heap is empty or the result has k elements\n\twhile !isempty(heap) && length(result) < k\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t\n\t\t# Push the next element of nums1 if it exists\n\t\tif i < length(nums1)\n\t\t\tpush!(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t\n\t\t# Push the next element of nums2 if it exists and it is not the same as the previous element\n\t\tif j < length(nums2) && j != i\n\t\t\tpush!(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\t\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\t\n\twhile k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif i < n1 && j < n2 - 1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\t\n\treturn res\nend",
    "\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t# Initialize the priority queue\n\tpq = PriorityQueue()\n\t# Add the first pair to the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# Iterate over the priority queue\n\tfor i in 1:k\n\t\t# Pop the top element from the priority queue\n\t\t(sum, index1, index2) = pop!(pq)\n\t\t# Add the pair to the result vector\n\t\tresult[i] = [nums1[index1], nums2[index2]]\n\t\t# Check if the first index is less than the length of the first vector\n\t\tif index1 < length(nums1)\n\t\t\t# Add the next pair to the priority queue\n\t\t\tpush!(pq, (nums1[index1 + 1] + nums2[index2], index1 + 1, index2))\n\t\tend\n\t\t# Check if the first index is less than the length of the first vector and the second index is less than the length of the second vector\n\t\tif index1 < length(nums1) && index2 < length(nums2)\n\t\t\t# Add the next pair to the priority queue\n\t\t\tpush!(pq, (nums1[index1] + nums2[index2 + 1], index1, index2 + 1))\n\t\tend\n\tend\n\t# Return the result vector\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set([1])\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && !(i + 1, j) in visited\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\t\tpush!(visited, (i + 1, j))\n\t\tend\n\t\tif j < n2 && !(i, j + 1) in visited\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(visited, (i, j + 1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i = 2:k\n\t\tif i <= n1\n\t\t\theappush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t# pop and push\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= length(heap)\n\t\t\tresult[i] = [heap[1][2], heap[1][3]]\n\t\t\tif heap[1][3] < n2\n\t\t\t\theap[1][3] += 1\n\t\t\t\theap[1][1] = nums1[heap[1][2]] + nums2[heap[1][3]]\n\t\t\t\tsiftdown!(heap, 1)\n\t\t\telse\n\t\t\t\tpop!(heap)\n\t\t\tend\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# create a priority queue\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\t# create a set to store the visited pairs\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tpush!(visited, (1, 1))\n\t\n\t# create a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\twhile length(result) < k && !isempty(pq)\n\t\t# pop the smallest pair from the priority queue\n\t\tpair = pop!(pq)\n\t\t\n\t\t# add the pair to the result\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# add the next pair to the priority queue\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2)\n\t\t\tif !(pair[2] + 1, pair[3]) in visited\n\t\t\t\tpush!(pq, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\t\tpush!(visited, (pair[2] + 1, pair[3]))\n\t\t\tend\n\t\t\tif !(pair[2], pair[3] + 1) in visited\n\t\t\t\tpush!(pq, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t\t\tpush!(visited, (pair[2], pair[3] + 1))\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile length(res) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1], nums2[1], 1, 1]\n\t# Initialize the heap size\n\theap_size = 1\n\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}(undef, k)\n\t# Loop through the heap\n\tfor i in 1:k\n\t\t# Get the current smallest pair\n\t\tcurrent_pair = heap[1]\n\t\t# Add the current pair to the result vector\n\t\tresult[i] = [current_pair[1], current_pair[2]]\n\t\t# If the current pair is the last pair, break the loop\n\t\tif current_pair[3] == length(nums1) && current_pair[4] == length(nums2)\n\t\t\tbreak\n\t\tend\n\t\t# If the current pair is the last pair in the first vector, add the next element in the second vector\n\t\tif current_pair[3] == length(nums1)\n\t\t\theap[1] = [nums1[current_pair[3]], nums2[current_pair[4] + 1], current_pair[3], current_pair[4] + 1]\n\t\t# If the current pair is the last pair in the second vector, add the next element in the first vector\n\t\telseif current_pair[4] == length(nums2)\n\t\t\theap[1] = [nums1[current_pair[3] + 1], nums2[current_pair[4]], current_pair[3] + 1, current_pair[4]]\n\t\t# If the current pair is not the last pair in either vector, add the next pair in the first vector or the second vector\n\t\telse\n\t\t\tif nums1[current_pair[3] + 1] + nums2[current_pair[4]] < nums1[current_pair[3]] + nums2[current_pair[4] + 1]\n\t\t\t\theap[1] = [n",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = Vector{Vector{Int64}}()\n\twhile k > 0\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == m\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\t# Initialize the result vector\n\tresult = Vector{Vector{Int64}}()\n\t# Initialize the priority queue\n\tpq = PriorityQueue()\n\t# Push the first pair into the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# Loop k times to get the k smallest pairs\n\tfor i in 1:k\n\t\t# If the priority queue is empty, break the loop\n\t\tif isempty(pq)\n\t\t\tbreak\n\t\tend\n\t\t# Pop the smallest pair from the priority queue\n\t\t(sum, i, j) = pop!(pq)\n\t\t# Push the smallest pair into the result vector\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\t# If the first element of the pair is not the last element of the first vector, push the next pair into the priority queue\n\t\tif i < length(nums1)\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\t# If the second element of the pair is not the last element of the second vector, push the next pair into the priority queue\n\t\tif j < length(nums2) && i == 1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\t# Return the result vector\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\tpq = PriorityQueue()\n\tfor i in 1:n1\n\t\tpush!(pq, (nums1[i]+nums2[1], i, 1))\n\tend\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\t(sum, i1, i2) = pop!(pq)\n\t\tres[i] = [nums1[i1], nums2[i2]]\n\t\tif i2 < n2\n\t\t\tpush!(pq, (nums1[i1]+nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\t# initialize the heap\n\theap = Heap{Tuple{Int64, Int64, Int64}}()\n\tpush!(heap, (nums1[1] + nums2[1], 1, 1))\n\t# initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t# initialize the visited pairs\n\tvisited = Dict{Tuple{Int64, Int64}, Int64}()\n\tvisited[(1, 1)] = 1\n\t# loop until the heap is empty\n\twhile length(heap) > 0 && length(result) < k\n\t\t# pop the smallest pair\n\t\tpair = pop!(heap)\n\t\t# add the pair to the result\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t# add the next pair to the heap\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2) && !haskey(visited, (pair[2] + 1, pair[3]))\n\t\t\tpush!(heap, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\tvisited[(pair[2] + 1, pair[3])] = 1\n\t\tend\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2) && !haskey(visited, (pair[2], pair[3] + 1))\n\t\t\tpush!(heap, (nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1))\n\t\t\tvisited[(pair[2], pair[3] + 1)] = 1\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\twhile k > 0 && !isempty(pq)\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tk -= 1\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tif i == 1 && j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\tend\n\tend\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile !isempty(pq) && length(res) < k\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap\n\theap = PriorityQueue(k)\n\tfor i in 1:k\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# Pop the smallest pair and push the next pair\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\t(sum, index1, index2) = pop!(heap)\n\t\tresult[i] = [nums1[index1], nums2[index2]]\n\t\tif index2 < length(nums2)\n\t\t\tpush!(heap, (nums1[index1] + nums2[index2 + 1], index1, index2 + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tInput:\n\t\tnums1: Vector of integers\n\t\tnums2: Vector of integers\n\t\tk: Integer\n\tOutput:\n\t\tk_smallest_pairs: Vector of vectors of integers\n\t\"\"\"\n\tnums1_len = length(nums1)\n\tnums2_len = length(nums2)\n\tk_smallest_pairs = Vector{Vector{Int64}}()\n\tif nums1_len == 0 || nums2_len == 0\n\t\treturn k_smallest_pairs\n\tend\n\tif k > nums1_len * nums2_len\n\t\tk = nums1_len * nums2_len\n\tend\n\tfor i = 1:nums1_len\n\t\tfor j = 1:nums2_len\n\t\t\tif length(k_smallest_pairs) < k\n\t\t\t\tpush!(k_smallest_pairs, [nums1[i], nums2[j]])\n\t\t\telse\n\t\t\t\tif nums1[i] + nums2[j] < k_smallest_pairs[k][1] + k_smallest_pairs[k][2]\n\t\t\t\t\tk_smallest_pairs[k] = [nums1[i], nums2[j]]\n\t\t\t\t\tk_smallest_pairs = sort(k_smallest_pairs, by = x -> x[1] + x[2])\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn k_smallest_pairs\nend",
    "\tif nums1 == [] || nums2 == [] || k == 0\n\t\treturn []\n\tend\n\t\n\tn = length(nums1)\n\tm = length(nums2)\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\tfor i in 2:k\n\t\tif i <= n\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tbuild_min_heap!(heap)\n\t\n\tfor i in k+1:n*m\n\t\tif heap[1][2] == n\n\t\t\tbreak\n\t\tend\n\t\t\n\t\theap[1] = [nums1[heap[1][2]+1] + nums2[heap[1][3]], heap[1][2]+1, heap[1][3]]\n\t\tmin_heapify!(heap, 1)\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\twhile k > 0\n\t\tsum, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif j < n2\n\t\t\tpush!(pq, (nums1[i] + nums2[j+1], i, j+1))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tres = []\n\twhile k > 0\n\t\tval, i, j = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i == n1\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\telseif j == n2\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\telse\n\t\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\t\t\tpush!(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n\t\tend\n\t\tk -= 1\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1]+nums2[1], 1, 1))\n\tvisited = zeros(Int64, n1, n2)\n\tvisited[1, 1] = 1\n\t\n\tres = []\n\tfor i = 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\t\n\t\tif i+1 <= n1 && visited[i+1, j] == 0\n\t\t\tpush!(pq, (nums1[i+1]+nums2[j], i+1, j))\n\t\t\tvisited[i+1, j] = 1\n\t\tend\n\t\t\n\t\tif j+1 <= n2 && visited[i, j+1] == 0\n\t\t\tpush!(pq, (nums1[i]+nums2[j+1], i, j+1))\n\t\t\tvisited[i, j+1] = 1\n\t\tend\n\tend\n\t\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\t# Initialize the heap with the first element of nums1 and nums2\n\theap = Vector{Vector{Int64}}()\n\tpush!(heap, [nums1[1] + nums2[1], 1, 1])\n\t\n\t# Initialize the result\n\tresult = Vector{Vector{Int64}}()\n\t\n\t# Pop the first k elements from the heap\n\tfor i in 1:k\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Pop the first element from the heap\n\t\tpair = pop!(heap)\n\t\t\n\t\t# Add the popped element to the result\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t\n\t\t# Add the next possible pair to the heap\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2)\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]])\n\t\tend\n\t\t\n\t\t# Add the next possible pair to the heap\n\t\tif pair[2] < length(nums1) && pair[3] < length(nums2) - 1\n\t\t\tpush!(heap, [nums1[pair[2] + 1] + nums2[pair[3] + 1], pair[2] + 1, pair[3] + 1])\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set{Tuple{Int64, Int64}}()\n\tvisited_add(visited, 1, 1)\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tsum, i1, i2 = pop!(pq)\n\t\tresult[i] = [nums1[i1], nums2[i2]]\n\t\tif i1 < n1\n\t\t\tvisited_add(visited, i1 + 1, i2)\n\t\t\tpush!(pq, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))\n\t\tend\n\t\tif i2 < n2\n\t\t\tvisited_add(visited, i1, i2 + 1)\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))\n\t\tend\n\tend\n\treturn result\nend",
    "\t# Initialize the heap\n\theap = PriorityQueue()\n\tfor i in 1:length(nums1)\n\t\tfor j in 1:length(nums2)\n\t\t\tpush!(heap, (nums1[i] + nums2[j], i, j))\n\t\tend\n\tend\n\t# Pop k elements from the heap\n\tresult = Vector{Vector{Int64}}()\n\tfor i in 1:k\n\t\tif isempty(heap)\n\t\t\tbreak\n\t\tend\n\t\t(sum, i, j) = pop!(heap)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\tend\n\treturn result\nend",
    "\t# Initialize a priority queue\n\tpq = PriorityQueue()\n\t# Initialize a set to store the visited pairs\n\tvisited = Set()\n\t# Initialize a vector to store the result\n\tresult = Vector{Vector{Int64}}()\n\t# Push the first pair into the priority queue\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t# Push the first pair into the set\n\tpush!(visited, (1, 1))\n\t# Loop k times\n\tfor i in 1:k\n\t\t# If the priority queue is empty, return the result\n\t\tif isempty(pq)\n\t\t\treturn result\n\t\tend\n\t\t# Pop the smallest pair from the priority queue\n\t\tpair = pop!(pq)\n\t\t# Push the pair into the result\n\t\tpush!(result, [nums1[pair[2]], nums2[pair[3]]])\n\t\t# If the first element of the pair is not the last element of nums1\n\t\tif pair[2] < length(nums1)\n\t\t\t# If the pair (pair[2] + 1, pair[3]) is not visited\n\t\t\tif !(pair[2] + 1, pair[3]) in visited\n\t\t\t\t# Push the pair (pair[2] + 1, pair[3]) into the priority queue\n\t\t\t\tpush!(pq, (nums1[pair[2] + 1] + nums2[pair[3]], pair[2] + 1, pair[3]))\n\t\t\t\t# Push the pair (pair[2] + 1, pair[3]) into the set\n\t\t\t\tpush!(visited, (pair[2] + 1, pair[3]))\n\t\t\tend\n\t\tend\n\t\t# If the second element of the pair is not the last element of nums2\n\t\tif pair[3] < length(nums2)\n\t\t\t# If the pair (pair[2], pair[3] + 1) is not visited\n\t\t\tif !(pair[2], pair[3] + 1) in visited\n\t\t",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\tfor i in 2:k\n\t\tif i <= n1\n\t\t\theap[i] = [nums1[i] + nums2[1], i, 1]\n\t\telse\n\t\t\theap[i] = [nums1[n1] + nums2[i - n1], n1, i - n1]\n\t\tend\n\tend\n\t\n\t# build the heap\n\tfor i in k/2:-1:1\n\t\theap = heap_down(heap, i, k)\n\tend\n\t\n\t# get the k smallest pairs\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [heap[1][1], heap[1][2], heap[1][3]]\n\t\tif heap[1][2] == n1\n\t\t\theap[1] = [nums1[n1] + nums2[heap[1][3] + 1], n1, heap[1][3] + 1]\n\t\telseif heap[1][3] == n2\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[n2], heap[1][2] + 1, n2]\n\t\telse\n\t\t\theap[1] = [nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]]\n\t\tend\n\t\theap = heap_down(heap, 1, k)\n\tend\n\t\n\treturn result\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0\n\t\treturn []\n\tend\n\t\n\tif k > length(nums1) * length(nums2)\n\t\tk = length(nums1) * length(nums2)\n\tend\n\t\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = []\n\t\n\tfor i in 1:k\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(result, [nums1[i], nums2[j]])\n\t\tif j == length(nums2)\n\t\t\tcontinue\n\t\tend\n\t\tpush!(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\t# create a min heap\n\theap = MinHeap()\n\t\n\t# push the first element of each vector into the heap\n\tfor i = 1:n1\n\t\tpush!(heap, (nums1[i] + nums2[1], i, 1))\n\tend\n\t\n\t# pop k elements from the heap\n\tresult = Vector{Vector{Int64}}(k)\n\tfor i = 1:k\n\t\t(sum, i1, i2) = pop!(heap)\n\t\tresult[i] = [nums1[i1], nums2[i2]]\n\t\tif i2 < n2\n\t\t\tpush!(heap, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tpq = PriorityQueue(k)\n\tfor i in 1:n1\n\t\tfor j in 1:n2\n\t\t\tif pq.size() < k\n\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\telse\n\t\t\t\tif pq.top()[1] > nums1[i] + nums2[j]\n\t\t\t\t\tpop!(pq)\n\t\t\t\t\tpush!(pq, (nums1[i] + nums2[j], i, j))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tres = Vector{Vector{Int64}}(k)\n\tfor i in 1:k\n\t\tres[i] = [nums1[pq.top()[2]], nums2[pq.top()[3]]]\n\t\tpop!(pq)\n\tend\n\treturn res\nend",
    "\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn Vector{Vector{Int64}}()\n\tend\n\t\n\tm, n = length(nums1), length(nums2)\n\t\n\t# Initialize the heap with the first k pairs\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= m\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# Build the heap\n\tbuild_heap!(heap)\n\t\n\t# Extract the smallest pair from the heap\n\tfor i in k+1:k*n\n\t\tif length(heap) == 0\n\t\t\tbreak\n\t\tend\n\t\t\n\t\t# Extract the smallest pair\n\t\tpair = pop!(heap)\n\t\t\n\t\t# Add the next pair\n\t\tif pair[3] < n\n\t\t\tpush!(heap, [pair[1], nums2[pair[3]+1], pair[3]+1])\n\t\tend\n\t\t\n\t\t# Rebuild the heap\n\t\tbuild_heap!(heap)\n\tend\n\t\n\treturn heap\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\t\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\t\n\tif k > n * m\n\t\tk = n * m\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tresult = Vector{Vector{Int64}}()\n\t\n\tfor i in 1:k\n\t\t(sum, x, y) = pop!(pq)\n\t\tpush!(result, [nums1[x], nums2[y]])\n\t\t\n\t\tif x < n && y == 1\n\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\tend\n\t\t\n\t\tif y < m\n\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\tend\n\tend\n\t\n\treturn result\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\tif k > n * m\n\t\tk = n * m\n\tend\n\tpq = PriorityQueue()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\tvisited = Set()\n\tvisited_add!(visited, 1, 1)\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tsum, x, y = pop!(pq)\n\t\tres[i] = [nums1[x], nums2[y]]\n\t\tif x < n\n\t\t\tif !visited_has(visited, x + 1, y)\n\t\t\t\tpush!(pq, (nums1[x + 1] + nums2[y], x + 1, y))\n\t\t\t\tvisited_add!(visited, x + 1, y)\n\t\t\tend\n\t\tend\n\t\tif y < m\n\t\t\tif !visited_has(visited, x, y + 1)\n\t\t\t\tpush!(pq, (nums1[x] + nums2[y + 1], x, y + 1))\n\t\t\t\tvisited_add!(visited, x, y + 1)\n\t\t\tend\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tres[i] = [0, 0]\n\tend\n\ti = 1\n\tj = 1\n\tfor l in 1:k\n\t\tif nums1[i] + nums2[j] < nums1[i] + nums2[j + 1]\n\t\t\tres[l] = [nums1[i], nums2[j]]\n\t\t\tj += 1\n\t\telse\n\t\t\tres[l] = [nums1[i], nums2[j + 1]]\n\t\t\ti += 1\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t# create a heap of size k\n\theap = Vector{Vector{Int64}}(k)\n\t# initialize the heap with the first k pairs\n\tfor i in 1:k\n\t\theap[i] = [nums1[i % n1 + 1], nums2[i % n2 + 1]]\n\tend\n\t# heapify the heap\n\theapify(heap)\n\t# for each pair in the rest of the pairs\n\tfor i in k+1:n1*n2\n\t\t# if the current pair is smaller than the root of the heap\n\t\tif heap[1][1] + heap[1][2] > nums1[i % n1 + 1] + nums2[i % n2 + 1]\n\t\t\t# replace the root with the current pair\n\t\t\theap[1] = [nums1[i % n1 + 1], nums2[i % n2 + 1]]\n\t\t\t# heapify the heap\n\t\t\theapify(heap)\n\t\tend\n\tend\n\t# return the heap\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1 * n2\n\t\tk = n1 * n2\n\tend\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\theap[i] = [nums1[1] + nums2[i], 1, i]\n\tend\n\t\n\t# Build the heap\n\tfor i in k/2:-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# Pop the top k elements\n\tfor i in k+1:n1*n2\n\t\tif nums1[(i-1) \u00f7 n2 + 1] + nums2[(i-1) % n2 + 1] < heap[1][1]\n\t\t\theap[1] = [nums1[(i-1) \u00f7 n2 + 1] + nums2[(i-1) % n2 + 1], (i-1) \u00f7 n2 + 1, (i-1) % n2 + 1]\n\t\t\theapify(heap, 1, k)\n\t\tend\n\tend\n\t\n\t# Sort the heap\n\tfor i in k:-1:2\n\t\theap[1], heap[i] = heap[i], heap[1]\n\t\theapify(heap, 1, i-1)\n\tend\n\t\n\t# Return the result\n\treturn heap\nend",
    "\tn = length(nums1)\n\tm = length(nums2)\n\tif n == 0 || m == 0\n\t\treturn []\n\tend\n\t\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tif i <= n\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\tbuild_max_heap!(heap)\n\t\n\tfor i in k+1:n*m\n\t\tif heap[1][1] + heap[1][2] > nums1[heap[1][3]] + nums2[i-heap[1][3]]\n\t\t\theap[1] = [nums1[heap[1][3]], nums2[i-heap[1][3]], heap[1][3]]\n\t\t\tmax_heapify!(heap, 1)\n\t\tend\n\tend\n\t\n\treturn heap\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\tif k > n1*n2\n\t\tk = n1*n2\n\tend\n\t\n\tpq = PriorityQueue(max)\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = []\n\tfor i in 1:k\n\t\tsum, i1, i2 = pop!(pq)\n\t\tpush!(res, [nums1[i1], nums2[i2]])\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1+1] + nums2[i2], i1+1, i2))\n\t\tend\n\t\tif i1 < n1 && i2 < n2\n\t\t\tpush!(pq, (nums1[i1] + nums2[i2+1], i1, i2+1))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# Initialize the heap with the first k elements\n\theap = Vector{Tuple{Int64, Int64, Int64}}(undef, k)\n\tfor i in 1:k\n\t\tpush!(heap, (nums1[1] + nums2[i], 1, i))\n\tend\n\t\n\t# Pop the smallest element and push the next element\n\tresult = Vector{Vector{Int64}}(undef, k)\n\tfor i in 1:k\n\t\tresult[i] = [nums1[heap[1][2]], nums2[heap[1][3]]]\n\t\tif heap[1][2] == n1\n\t\t\tbreak\n\t\tend\n\t\tpop!(heap)\n\t\tpush!(heap, (nums1[heap[1][2] + 1] + nums2[heap[1][3]], heap[1][2] + 1, heap[1][3]))\n\tend\n\t\n\treturn result\nend",
    "\t\"\"\"\n\tnums1: Vector{Int64}\n\tnums2: Vector{Int64}\n\tk: Int64\n\t\"\"\"\n\tif length(nums1) == 0 || length(nums2) == 0 || k == 0\n\t\treturn []\n\tend\n\t\n\tnums1 = sort(nums1)\n\tnums2 = sort(nums2)\n\t\n\t# Initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\theap[1] = [nums1[1] + nums2[1], 1, 1]\n\t\n\tfor i in 2:k\n\t\tif i <= length(nums1)\n\t\t\tpush!(heap, [nums1[i] + nums2[1], i, 1])\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\theapify!(heap)\n\t\n\t# Pop the smallest pair and push the next pair\n\tfor i in k+1:length(nums1) * length(nums2)\n\t\tpair = pop!(heap)\n\t\tif pair[2] < length(nums2)\n\t\t\tpush!(heap, [nums1[pair[2]] + nums2[pair[3] + 1], pair[2], pair[3] + 1])\n\t\t\theapify!(heap)\n\t\tend\n\tend\n\t\n\treturn heap\nend",
    "\tn1 = length(nums1)\n\tn2 = length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\tpq = PriorityQueue{Tuple{Int64, Int64, Int64}}()\n\tpush!(pq, (nums1[1] + nums2[1], 1, 1))\n\t\n\tres = Vector{Vector{Int64}}()\n\twhile length(res) < k && !isempty(pq)\n\t\t(sum, i, j) = pop!(pq)\n\t\tpush!(res, [nums1[i], nums2[j]])\n\t\tif i < n1 && j < n2\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\t\tif i < n1 && j == 1\n\t\t\tpush!(pq, (nums1[i+1] + nums2[j], i+1, j))\n\t\tend\n\tend\n\treturn res\nend",
    "\tn1, n2 = length(nums1), length(nums2)\n\tif n1 == 0 || n2 == 0\n\t\treturn []\n\tend\n\t\n\t# initialize the heap\n\theap = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tif i <= n1\n\t\t\tpush!(heap, [nums1[i], nums2[1], 1])\n\t\tend\n\tend\n\t\n\t# heapify\n\tfor i = floor(Int64, k/2):-1:1\n\t\theapify(heap, i, k)\n\tend\n\t\n\t# pop the top k pairs\n\tres = Vector{Vector{Int64}}(undef, k)\n\tfor i = 1:k\n\t\tres[i] = heap[1]\n\t\tif res[i][3] == n2\n\t\t\theap[1] = heap[end]\n\t\t\tpop!(heap)\n\t\t\tk -= 1\n\t\telse\n\t\t\theap[1] = [nums1[res[i][1]], nums2[res[i][3]+1], res[i][3]+1]\n\t\tend\n\t\theapify(heap, 1, k)\n\tend\n\t\n\treturn res\nend"
  ]
}