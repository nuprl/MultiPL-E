{
  "name": "mbpp_296_get_Inv_Count",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a jlthon function to count inversions in a vector.\n\t\"\"\"\nfunction get_Inv_Count(arr::Vector{Int64})::Int64 \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py",
  "prompt_terminology": "reworded",
  "tests": "using Test\n\n@testset begin\n\ncandidate = get_Inv_Count;\n\t@test(candidate([1, 20, 6, 4, 5]) == 5)\n\t@test(candidate([1, 2, 1]) == 1)\n\t@test(candidate([1, 2, 5, 6, 1]) == 3)\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tThis function takes a vector of integers and returns the number of inversions in the vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)-1\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tFunction to count inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\telse\n\t\tleft = arr[1:n\u00f72]\n\t\tright = arr[n\u00f72+1:n]\n\t\tleft_count = get_Inv_Count(left)\n\t\tright_count = get_Inv_Count(right)\n\t\tmerge_count = get_Merge_Count(left, right)\n\t\treturn left_count + right_count + merge_count\n\tend\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\n\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tThis function returns the number of inversions in a vector.\n\t\"\"\"\n\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n,2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\tmerge_count = get_Merge_Count(left, right)\n\treturn left_count + right_count + merge_count\nend",
    "\t\n\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Recursive call\n\tmid = div(length(arr), 2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\t\n\t# Merge\n\ti = 1\n\tj = mid + 1\n\tcount = 0\n\ttemp = Array{Int64}(length(arr))\n\tfor k = 1:length(arr)\n\t\tif i <= mid && j <= length(arr)\n\t\t\tif arr[i] <= arr[j]\n\t\t\t\ttemp[k] = arr[i]\n\t\t\t\ti += 1\n\t\t\telse\n\t\t\t\ttemp[k] = arr[j]\n\t\t\t\tj += 1\n\t\t\t\tcount += mid - i + 1\n\t\t\tend\n\t\telseif i <= mid\n\t\t\ttemp[k] = arr[i]\n\t\t\ti += 1\n\t\telse\n\t\t\ttemp[k] = arr[j]\n\t\t\tj += 1\n\t\tend\n\tend\n\t\n\t# Copy temp to arr\n\tfor k = 1:length(arr)\n\t\tarr[k] = temp[k]\n\tend\n\t\n\treturn count + left + right\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Split the array in half\n\tmid = div(length(arr),2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t# Recursively call the function on the left and right halves\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\t# Merge the two halves and count the inversions\n\tmerged_count = merge_and_count(left,right)\n\t# Return the total number of inversions\n\treturn left_count + right_count + merged_count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Recursive case\n\tmid = div(length(arr), 2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\tsplit = get_Split_Inv_Count(arr)\n\treturn left + right + split\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n,2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:n])\n\tmerge = get_Inv_Count_Merge(arr[1:mid], arr[mid+1:n])\n\treturn left + right + merge\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tif length(arr) == 1\n\t\treturn 0\n\telse\n\t\tmid = div(length(arr), 2)\n\t\tleft = get_Inv_Count(arr[1:mid])\n\t\tright = get_Inv_Count(arr[mid+1:end])\n\t\tcross = get_Cross_Inv_Count(arr)\n\t\treturn left + right + cross\n\tend\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\telse\n\t\tmid = n \u00f7 2\n\t\tleft = get_Inv_Count(arr[1:mid])\n\t\tright = get_Inv_Count(arr[mid+1:end])\n\t\tsplit = get_Split_Inv_Count(arr)\n\t\treturn left + right + split\n\tend\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tFunction to count inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tcount = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i = 1:length(arr)\n\t\tfor j = i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\n\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Recursive case\n\tmid = div(length(arr), 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t\n\tleft_inv = get_Inv_Count(left)\n\tright_inv = get_Inv_Count(right)\n\tsplit_inv = get_Split_Inv(left, right)\n\t\n\treturn left_inv + right_inv + split_inv\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tFunction to count inversions in a vector.\n\t\"\"\"\n\tcount = 0\n\tfor i in 1:length(arr)-1\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tinv_count = 0\n\tfor i = 1:length(arr)\n\t\tfor j = i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n, 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tinv_count = get_Inv_Count(left) + get_Inv_Count(right)\n\ti = 1\n\tj = 1\n\tfor k = 1:n\n\t\tif i > length(left)\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\telseif j > length(right)\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telseif left[i] <= right[j]\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telse\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\t\tinv_count += length(left) - i + 1\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\telse\n\t\tmid = n \u00f7 2\n\t\tleft = arr[1:mid]\n\t\tright = arr[mid+1:n]\n\t\tleft_inv = get_Inv_Count(left)\n\t\tright_inv = get_Inv_Count(right)\n\t\tsplit_inv = get_Split_Inv(left, right)\n\t\treturn left_inv + right_inv + split_inv\n\tend\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tThis function returns the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Split the vector in half\n\tmid = div(length(arr), 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t\n\t# Recursively call the function on the left and right halves\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\t\n\t# Merge the two halves and count the inversions\n\tcount = left_count + right_count\n\ti = 1\n\tj = 1\n\tfor k = 1:length(arr)\n\t\tif i > length(left)\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\telseif j > length(right)\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telseif left[i] <= right[j]\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telse\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\t\tcount += length(left) - i + 1\n\t\tend\n\tend\n\t\n\treturn count\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Recursive case\n\tmid = div(length(arr), 2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\t\n\t# Merge\n\ti = 1\n\tj = 1\n\tinv_count = 0\n\twhile i <= mid && j <= length(arr) - mid\n\t\tif arr[i] <= arr[mid+j]\n\t\t\ti += 1\n\t\telse\n\t\t\tinv_count += mid - i + 1\n\t\t\tj += 1\n\t\tend\n\tend\n\t\n\treturn inv_count + left + right\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "    \"\"\"\n    This function returns the number of inversions in a vector.\n    \"\"\"\n    n = length(arr)\n    inv_count = 0\n    for i in 1:n\n        for j in i+1:n\n            if arr[i] > arr[j]\n                inv_count += 1\n            end\n        end\n    end\n    return inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tFunction to count inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tcount = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tThis function takes a vector of integers and returns the number of inversions in the vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tThis function takes a vector of integers and returns the number of inversions in the vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Split the array\n\tmid = div(length(arr),2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t# Recursive calls\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\t# Merge the arrays\n\tmerge_count = merge_and_count(left,right)\n\t# Return the total count\n\treturn left_count + right_count + merge_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t# Initialize count of inversions \n\tinv_count = 0\n\tfor i = 1:length(arr) \n\t\tfor j = i+1:length(arr) \n\t\t\tif arr[i] > arr[j] \n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tReturn the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tif length(arr) == 1\n\t\treturn 0\n\telse\n\t\tmid = div(length(arr),2)\n\t\tleft = arr[1:mid]\n\t\tright = arr[mid+1:end]\n\t\tleft_count = get_Inv_Count(left)\n\t\tright_count = get_Inv_Count(right)\n\t\tsplit_count = merge_and_count(left,right)\n\t\treturn left_count + right_count + split_count\n\tend\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n, 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tleft_inv = get_Inv_Count(left)\n\tright_inv = get_Inv_Count(right)\n\tmerge_inv = merge_and_count(left, right)\n\treturn left_inv + right_inv + merge_inv\nend",
    "\tcount = 0\n\tfor i = 1:length(arr)\n\t\tfor j = i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = n \u00f7 2\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:n])\n\treturn left + right + merge(arr, 1, mid, n)\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "    n = length(arr)\n    inv_count = 0\n    for i in 1:n\n        for j in (i+1):n\n            if arr[j] < arr[i]\n                inv_count += 1\n            end\n        end\n    end\n    return inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tFunction to count inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n,2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\tsplit_count = get_Split_Inv_Count(left,right)\n\treturn left_count + right_count + split_count\nend",
    "\t\n\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Split the array\n\tmid = div(length(arr), 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t\n\t# Recursively call the function\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\tsplit_count = get_Split_Inv_Count(left, right)\n\t\n\t# Return the total count\n\treturn left_count + right_count + split_count\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\telse\n\t\tmid = div(n,2)\n\t\tleft = arr[1:mid]\n\t\tright = arr[mid+1:end]\n\t\tleft_inv = get_Inv_Count(left)\n\t\tright_inv = get_Inv_Count(right)\n\t\tsplit_inv = merge_Inv_Count(left,right)\n\t\treturn left_inv + right_inv + split_inv\n\tend\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n, 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\tinv_count = get_Inv_Count(left) + get_Inv_Count(right)\n\ti = 1\n\tj = 1\n\tk = 1\n\twhile i <= length(left) && j <= length(right)\n\t\tif left[i] <= right[j]\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telse\n\t\t\tarr[k] = right[j]\n\t\t\tinv_count += length(left) - i + 1\n\t\t\tj += 1\n\t\tend\n\t\tk += 1\n\tend\n\twhile i <= length(left)\n\t\tarr[k] = left[i]\n\t\ti += 1\n\t\tk += 1\n\tend\n\twhile j <= length(right)\n\t\tarr[k] = right[j]\n\t\tj += 1\n\t\tk += 1\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\n\tn = length(arr)\n\tinv_count = 0\n\t\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn inv_count\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\tmid = div(length(arr),2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\treturn left + right + merge_and_count_split_inv(arr, mid)\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Recursive case\n\telse\n\t\t# Split the array into two parts\n\t\tmid = div(length(arr), 2)\n\t\tleft = arr[1:mid]\n\t\tright = arr[mid+1:end]\n\t\t# Recursively call the function on the left and right halves\n\t\tleft_count = get_Inv_Count(left)\n\t\tright_count = get_Inv_Count(right)\n\t\t# Merge the two halves and count the number of inversions\n\t\tmerge_count = merge_and_count(left, right)\n\t\t# Return the total number of inversions\n\t\treturn left_count + right_count + merge_count\n\tend\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Recursive case\n\tmid = div(length(arr),2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\tsplit = get_Split_Inv_Count(arr)\n\treturn left + right + split\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\n\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Recursive case\n\tmid = div(length(arr), 2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\t\n\t# Merge\n\ti = 1\n\tj = 1\n\tinv_count = 0\n\twhile i <= mid && j <= length(arr) - mid\n\t\tif arr[i] <= arr[mid+j]\n\t\t\ti += 1\n\t\telse\n\t\t\tinv_count += mid - i + 1\n\t\t\tj += 1\n\t\tend\n\tend\n\t\n\treturn inv_count + left + right\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Split the array into two parts\n\tmid = div(length(arr),2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t# Recursively call the function\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\t# Merge the two arrays\n\tmerge_count = merge_and_count(left,right)\n\t# Return the total count\n\treturn left_count + right_count + merge_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t# Initialize count of inversions \n\tinv_count = 0\n\t# Loop through the array \n\tfor i in 1:length(arr) \n\t\t# Loop through the array again \n\t\tfor j in i+1:length(arr) \n\t\t\t# If the first element is greater than the second \n\t\t\t# element, then increment the count \n\t\t\tif arr[i] > arr[j] \n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tGiven a vector, return the number of inversions in the vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\n\t# Initialize variables\n\tn = length(arr)\n\tinv_count = 0\n\t\n\t# Loop through the array\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn inv_count\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Divide\n\tmid = Int64(length(arr)/2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t# Conquer\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\t# Combine\n\tmerge_count = 0\n\ti = 1\n\tj = 1\n\tfor k = 1:length(arr)\n\t\tif i > length(left)\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\telseif j > length(right)\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telseif left[i] <= right[j]\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telse\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\t\tmerge_count += length(left) - i + 1\n\t\tend\n\tend\n\treturn left_count + right_count + merge_count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\telse\n\t\tmid = div(n,2)\n\t\tleft = get_Inv_Count(arr[1:mid])\n\t\tright = get_Inv_Count(arr[mid+1:n])\n\t\tsplit = get_Split_Inv(arr)\n\t\treturn left + right + split\n\tend\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tFunction to count inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\telse\n\t\tleft = arr[1:n\u00f72]\n\t\tright = arr[n\u00f72+1:n]\n\t\tleft_inv = get_Inv_Count(left)\n\t\tright_inv = get_Inv_Count(right)\n\t\tsplit_inv = get_Split_Inv(left, right)\n\t\treturn left_inv + right_inv + split_inv\n\tend\nend",
    "\t\"\"\"\n\tInput: \n\t\tarr: Vector of integers.\n\tOutput:\n\t\tcount: Number of inversions in the vector.\n\t\"\"\"\n\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in (i+1):length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n,2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\tmerge_count = merge_and_count(left,right)\n\treturn left_count + right_count + merge_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\tmid = div(length(arr), 2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\treturn left + right + merge_and_count(arr, 1, mid, length(arr))\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = Int64(n/2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tcount = get_Inv_Count(left) + get_Inv_Count(right)\n\ti = 1\n\tj = 1\n\tfor k = 1:n\n\t\tif i > mid\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\telseif j > n-mid\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telseif left[i] <= right[j]\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telse\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\t\tcount += mid-i+1\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = n \u00f7 2\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\tmerge_count = merge_and_count(left, right, arr)\n\treturn left_count + right_count + merge_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tInput: A vector of integers\n\tOutput: Number of inversions in the vector\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\telse\n\t\tmid = div(n,2)\n\t\tleft = arr[1:mid]\n\t\tright = arr[mid+1:n]\n\t\treturn get_Inv_Count(left) + get_Inv_Count(right) + merge_Inv_Count(left,right)\n\tend\nend",
    "\t# Initialize count of inversions \n\tinv_count = 0\n\t# Consider all pairs (arr[i], arr[j]) such that i < j \n\tfor i = 1:length(arr)-1\n\t\tfor j = i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t# Recursive case\n\tmid = div(length(arr), 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\tsplit_count = get_Split_Count(left, right)\n\treturn left_count + right_count + split_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i = 1:length(arr)\n\t\tfor j = i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Split the array into two halves\n\thalf = Int(length(arr)/2)\n\tleft = arr[1:half]\n\tright = arr[half+1:end]\n\t\n\t# Recursively call the function on each half\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\t\n\t# Count the number of inversions in the merged array\n\tmerge_count = 0\n\ti = 1\n\tj = 1\n\tfor k = 1:length(arr)\n\t\tif i > length(left)\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\telseif j > length(right)\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telseif left[i] <= right[j]\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telse\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\t\tmerge_count += length(left) - i + 1\n\t\tend\n\tend\n\t\n\t# Return the total number of inversions\n\treturn left_count + right_count + merge_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tinv_count = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\n\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Recursive case\n\tmid = div(length(arr), 2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:end]\n\t\n\tleft_inv_count = get_Inv_Count(left)\n\tright_inv_count = get_Inv_Count(right)\n\t\n\t# Merge\n\tleft_index = 1\n\tright_index = 1\n\tmerged_index = 1\n\tmerged = zeros(Int64, length(arr))\n\tsplit_inv_count = 0\n\t\n\twhile left_index <= length(left) && right_index <= length(right)\n\t\tif left[left_index] <= right[right_index]\n\t\t\tmerged[merged_index] = left[left_index]\n\t\t\tleft_index += 1\n\t\telse\n\t\t\tmerged[merged_index] = right[right_index]\n\t\t\tright_index += 1\n\t\t\tsplit_inv_count += length(left) - left_index + 1\n\t\tend\n\t\tmerged_index += 1\n\tend\n\t\n\tif left_index <= length(left)\n\t\tmerged[merged_index:end] = left[left_index:end]\n\telse\n\t\tmerged[merged_index:end] = right[right_index:end]\n\tend\n\t\n\treturn left_inv_count + right_inv_count + split_inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\tmid = div(length(arr), 2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:end])\n\tsplit = get_Split_Inv_Count(arr)\n\treturn left + right + split\nend",
    "\t\"\"\"\n\tThis function takes a vector of integers and returns the number of inversions.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tReturns the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n,2)\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\tmerge_count = merge_and_count(left,right)\n\treturn left_count + right_count + merge_count\nend",
    "\t\"\"\"\n\tThis function returns the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n-1\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tn = length(arr)\n\tinv_count = 0\n\tfor i in 1:n\n\t\tfor j in i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = div(n,2)\n\tleft = get_Inv_Count(arr[1:mid])\n\tright = get_Inv_Count(arr[mid+1:n])\n\tsplit = get_Split_Inv_Count(arr)\n\treturn left + right + split\nend",
    "\t# Base case\n\tif length(arr) == 1\n\t\treturn 0\n\tend\n\t\n\t# Split the array in half\n\thalf = div(length(arr), 2)\n\tleft = arr[1:half]\n\tright = arr[half+1:end]\n\t\n\t# Recursively call the function on the left and right halves\n\tleft_count = get_Inv_Count(left)\n\tright_count = get_Inv_Count(right)\n\t\n\t# Merge the two halves\n\tmerge_count = merge_and_count(left, right)\n\t\n\t# Return the total number of inversions\n\treturn left_count + right_count + merge_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tif n == 1\n\t\treturn 0\n\tend\n\tmid = n \u00f7 2\n\tleft = arr[1:mid]\n\tright = arr[mid+1:n]\n\tinv_count = get_Inv_Count(left) + get_Inv_Count(right)\n\ti = 1\n\tj = 1\n\tk = 1\n\twhile i <= length(left) && j <= length(right)\n\t\tif left[i] <= right[j]\n\t\t\tarr[k] = left[i]\n\t\t\ti += 1\n\t\telse\n\t\t\tarr[k] = right[j]\n\t\t\tj += 1\n\t\t\tinv_count += length(left) - i + 1\n\t\tend\n\t\tk += 1\n\tend\n\twhile i <= length(left)\n\t\tarr[k] = left[i]\n\t\ti += 1\n\t\tk += 1\n\tend\n\twhile j <= length(right)\n\t\tarr[k] = right[j]\n\t\tj += 1\n\t\tk += 1\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n-1\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tinv_count = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[j] < arr[i]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tn = length(arr)\n\tcount = 0\n\tfor i = 1:n\n\t\tfor j = i+1:n\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\t\"\"\"\n\tGet the number of inversions in a vector.\n\t\"\"\"\n\tinv_count = 0\n\tfor i = 1:length(arr)\n\t\tfor j = i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\t# Initialize count of inversions \n\tinv_count = 0\n\t# Consider all pairs (arr[i], arr[j]) such that i < j \n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\t# If arr[i] > arr[j] then there is an inversion. \n\t\t\tif arr[i] > arr[j]\n\t\t\t\tinv_count += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn inv_count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend",
    "\tcount = 0\n\tfor i in 1:length(arr)\n\t\tfor j in i+1:length(arr)\n\t\t\tif arr[i] > arr[j]\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend"
  ]
}