{
  "name": "mbpp_297_flatten_list",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py",
  "prompt_terminology": "reworded",
  "tests": "using Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "results": [
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpg9df7xtq.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpg9df7xtq.jl:9\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpg9df7xtq.jl:9\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpg9df7xtq.jl:20 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpg9df7xtq.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n    if typeof(list1) == Int64\n        return [list1]\n    elseif typeof(list1) == Array\n        return [flatten_list(list1[i]) for i in 1:length(list1)]\n    elseif typeof(list1) == Vector\n        return [flatten_list(list1[i]) for i in 1:length(list1)]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp1_w78vpc.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp1_w78vpc.jl:10\n   [2] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1_w78vpc.jl:18 [inlined]\n   [4] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1_w78vpc.jl:17\ntest set: Error During Test at /tmp/tmp1_w78vpc.jl:19\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(li",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp1_w78vpc.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\t\tend\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpv4rxj01h.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpv4rxj01h.jl:12\n   [2] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n     @ Main ./array.jl:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpv4rxj01h.jl:9\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpv4rxj01h.jl:20 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpv4rxj01h.jl:19\ntest set: Error During Test at /tmp/tmpv4rxj01h.jl:21\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpv4rxj01h.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpthach34w.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpthach34w.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpthach34w.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpthach34w.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpthach34w.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Array)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7pcsjg1z.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmp7pcsjg1z.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7pcsjg1z.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Array)\n\t\treturn [flatten_list(i) for i in list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(i) for i in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpmvppjtfr.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpmvppjtfr.jl:8 [inlined]\n   [11] (::var\"#1#3\")(i::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#3\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#3\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpmvppjtfr.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpmvppjtfr.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Array)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpiv_uwvip.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpiv_uwvip.jl:8\n   [11] (::var\"#1#3\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#3\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpiv_uwvip.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpiv_uwvip.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpiv_uwvip.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn flatten_list(list1[1]) .* flatten_list(list1[2:end])\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510612,
      "stdout": "test set: Test Failed at /tmp/tmpv0cq62nr.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0cq62nr.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0cq62nr.jl:19\ntest set: Test Failed at /tmp/tmpv0cq62nr.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0cq62nr.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0cq62nr.jl:19\ntest set: Test Failed at /tmp/tmpv0cq62nr.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0cq62nr.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0cq62nr.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpv0cq62nr.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\t\tend\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpv4rxj01h.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpv4rxj01h.jl:12\n   [2] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n     @ Main ./array.jl:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpv4rxj01h.jl:9\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpv4rxj01h.jl:20 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpv4rxj01h.jl:19\ntest set: Error During Test at /tmp/tmpv4rxj01h.jl:21\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpv4rxj01h.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tlist1 = list1[1]\n\tend\n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Test Failed at /tmp/tmpymfgry9j.jl:19\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpymfgry9j.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpymfgry9j.jl:18\ntest set: Error During Test at /tmp/tmpymfgry9j.jl:20\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Vector{Int64}})\n      @ Main /tmp/tmpymfgry9j.jl:11\n   [11] ",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 1 failed, 2 errored, 0 broken.\nin expression starting at /tmp/tmpymfgry9j.jl:16\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = []\n\t\tfor i in 1:length(list1)\n\t\t\tif isa(list1[i], Vector)\n\t\t\t\tlist2 = vcat(list2, flatten_list(list1[i]))\n\t\t\telse\n\t\t\t\tlist2 = vcat(list2, list1[i])\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510610,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpgypwv7ar.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpgypwv7ar.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpgypwv7ar.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp5zvu896v.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp5zvu896v.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp5zvu896v.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5zvu896v.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif isa(list1[1], Vector)\n\t\t\treturn flatten_list(list1[1])\n\t\telse\n\t\t\treturn list1\n\t\tend\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpnsy05cu8.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpnsy05cu8.jl:9\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpnsy05cu8.jl:20 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpnsy05cu8.jl:19\ntest set: Test Failed at /tmp/tmpnsy05cu8.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: [10, 20] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   ",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 2 failed, 1 errored, 0 broken.\nin expression starting at /tmp/tmpnsy05cu8.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t# Base case\n\tif length(list1) == 0\n\t\treturn []\n\tend\n\t# Recursive case\n\tif isa(list1[1], Vector)\n\t\treturn flatten_list(list1[1]) .* flatten_list(list1[2:end])\n\telse\n\t\treturn [list1[1]] .* flatten_list(list1[2:end])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510612,
      "stdout": "test set: Test Failed at /tmp/tmpoi37sdk9.jl:21\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpoi37sdk9.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpoi37sdk9.jl:20\ntest set: Test Failed at /tmp/tmpoi37sdk9.jl:22\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpoi37sdk9.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpoi37sdk9.jl:20\ntest set: Test Failed at /tmp/tmpoi37sdk9.jl:23\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpoi37sdk9.jl:23 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpoi37sdk9.jl:20\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpoi37sdk9.jl:18\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmp8edc5zn_.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp8edc5zn_.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpthach34w.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpthach34w.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpthach34w.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpthach34w.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpthach34w.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Array{Int64,1}\n\t\t\tlist2 = [list2; flatten_list(i)]\n\t\telse\n\t\t\tlist2 = [list2; i]\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2, i)\n\t\telseif typeof(i) == Array\n\t\t\tlist2 = vcat(list2, flatten_list(i))\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmp81yua4e7.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10, 40, 50] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\ntest set: Test Failed at /tmp/tmp81yua4e7.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\ntest set: Test Failed at /tmp/tmp81yua4e7.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp81yua4e7.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tThis function takes a nested vector structure and returns a flattened vector.\n\t\"\"\"\n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telse\n\t\tnew_list = []\n\t\tfor i in list1\n\t\t\tnew_list = vcat(new_list, flatten_list(i))\n\t\tend\n\t\treturn new_list\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\t\tend\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpv4rxj01h.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpv4rxj01h.jl:12\n   [2] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n     @ Main ./array.jl:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpv4rxj01h.jl:9\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpv4rxj01h.jl:20 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpv4rxj01h.jl:19\ntest set: Error During Test at /tmp/tmpv4rxj01h.jl:21\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpv4rxj01h.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist1 = [flatten_list(x) for x in list1]\n\t\treturn [item for sublist in list1 for item in sublist]\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[1])..., flatten_list(list1[2:end])...]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn flatten_list(list1[1]) .* flatten_list(list1[2:end])\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510612,
      "stdout": "test set: Test Failed at /tmp/tmpv0cq62nr.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0cq62nr.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0cq62nr.jl:19\ntest set: Test Failed at /tmp/tmpv0cq62nr.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0cq62nr.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0cq62nr.jl:19\ntest set: Test Failed at /tmp/tmpv0cq62nr.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0cq62nr.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0cq62nr.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpv0cq62nr.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif isa(list1[1], Vector)\n\t\t\treturn flatten_list(list1[1])\n\t\telse\n\t\t\treturn list1\n\t\tend\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpnsy05cu8.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpnsy05cu8.jl:9\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpnsy05cu8.jl:20 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpnsy05cu8.jl:19\ntest set: Test Failed at /tmp/tmpnsy05cu8.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: [10, 20] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   ",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 2 failed, 1 errored, 0 broken.\nin expression starting at /tmp/tmpnsy05cu8.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpthach34w.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpthach34w.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpthach34w.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpthach34w.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpthach34w.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\treturn list1\n\telse\n\t\treturn flatten_list(list1[1])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpepyfogaw.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpepyfogaw.jl:6\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpepyfogaw.jl:16 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpepyfogaw.jl:15\ntest set: Error During Test at /tmp/tmpepyfogaw.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an obje",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpepyfogaw.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = []\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[1])..., flatten_list(list1[2:end])...]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2,i)\n\t\telseif typeof(i) == Array\n\t\t\tlist2 = [list2; flatten_list(i)]\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmpgkzd5jfo.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10, 40, 50] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpgkzd5jfo.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpgkzd5jfo.jl:19\ntest set: Test Failed at /tmp/tmpgkzd5jfo.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpgkzd5jfo.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpgkzd5jfo.jl:19\ntest set: Test Failed at /tmp/tmpgkzd5jfo.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpgkzd5jfo.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpgkzd5jfo.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpgkzd5jfo.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpgypwv7ar.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpgypwv7ar.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpgypwv7ar.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Array)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7pcsjg1z.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmp7pcsjg1z.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7pcsjg1z.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = []\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif isa(list1[1], Vector)\n\t\t\treturn flatten_list(list1[1])\n\t\telse\n\t\t\treturn list1\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpn4aeyds9.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpn4aeyds9.jl:9\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpn4aeyds9.jl:20 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpn4aeyds9.jl:19\ntest set: Test Failed at /tmp/tmpn4aeyds9.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: [10, 20] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   ",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn list1\n\telse\n\t\treturn flatten_list(list1[1])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpfia4n844.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpfia4n844.jl:6\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpfia4n844.jl:16 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpfia4n844.jl:15\ntest set: Error During Test at /tmp/tmpfia4n844.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an obje",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpfia4n844.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\tlist2 = []\n\t\tfor i in list1\n\t\t\tlist2 = append!(list2,flatten_list(i))\n\t\tend\n\t\treturn list2\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\ta = []\n\t\tfor i in list1\n\t\t\ta = [a;flatten_list(i)]\n\t\tend\n\t\treturn a\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\treturn [flatten_list(i) for i in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpyffhsjal.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpyffhsjal.jl:8\n   [2] (::var\"#1#2\")(i::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpyffhsjal.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpyffhsjal.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpyffhsjal.jl:15\ntest set: Error During Test at /tmp/tmpyffhsjal.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpyffhsjal.jl:13\n",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpgypwv7ar.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpgypwv7ar.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpgypwv7ar.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpa0d1leey.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa0d1leey.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa0d1leey.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa0d1leey.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[1])..., flatten_list(list1[2:end])...]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in 1:length(list1)\n\t\t\tif isa(list1[i], Vector)\n\t\t\t\tlist2 = [list2; flatten_list(list1[i])]\n\t\t\telse\n\t\t\t\tlist2 = [list2; list1[i]]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tFlatten a nested vector structure.\n\t\"\"\"\n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn vcat(flatten_list(list1[1]),flatten_list(list1[2:end]))\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn flatten_list(list1[1]) .* flatten_list(list1[2:end])\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmpcc0zidfv.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpcc0zidfv.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpcc0zidfv.jl:19\ntest set: Test Failed at /tmp/tmpcc0zidfv.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpcc0zidfv.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpcc0zidfv.jl:19\ntest set: Test Failed at /tmp/tmpcc0zidfv.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpcc0zidfv.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpcc0zidfv.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpcc0zidfv.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array{Any,1}\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpkely0m_r.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpkely0m_r.jl:8\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpkely0m_r.jl:18 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpkely0m_r.jl:17\ntest set: Test Failed at /tmp/tmpkely0m_r.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] ",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\tlist2 = []\n\t\tfor i in list1\n\t\t\tlist2 = vcat(list2,flatten_list(i))\n\t\tend\n\t\treturn list2\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpjgfjgz9d.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpjgfjgz9d.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpjgfjgz9d.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpjgfjgz9d.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpjgfjgz9d.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tFlattens a nested vector structure.\n\t\"\"\"\n\tif isa(list1, Vector)\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in 1:length(list1)\n\t\t\tif isa(list1[i], Vector)\n\t\t\t\tlist2 = vcat(list2, flatten_list(list1[i]))\n\t\t\telse\n\t\t\t\tlist2 = vcat(list2, list1[i])\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2, i)\n\t\telseif typeof(i) == Array\n\t\t\tlist2 = vcat(list2, flatten_list(i))\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmp81yua4e7.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10, 40, 50] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\ntest set: Test Failed at /tmp/tmp81yua4e7.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\ntest set: Test Failed at /tmp/tmp81yua4e7.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp81yua4e7.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpthach34w.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpthach34w.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpthach34w.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpthach34w.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpthach34w.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Array{Int64,1})\n\t\treturn list1\n\telseif isa(list1,Array{Any,1})\n\t\treturn vcat(flatten_list(list1[1]),flatten_list(list1[2]))\n\telseif isa(list1,Int64)\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Test Failed at /tmp/tmp6jdt7d88.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp6jdt7d88.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp6jdt7d88.jl:17\ntest set: Error During Test at /tmp/tmp6jdt7d88.jl:19\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Vector{Vector{Int64}})\n     @ Main /tmp/tmp6jdt7d88.jl:10\n   [2] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6jdt7d88.jl:19 [inlined]\n   [4] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6jdt7d88.jl:17\ntest set: Error During Test at /tmp/tmp6jdt7d88.jl:20\n  Test threw exception\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n  Met",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmpo44ru713.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpo44ru713.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpo44ru713.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpo44ru713.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpo44ru713.jl:15\ntest set: Error During Test at /tmp/tmpo44ru713.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpo44ru713.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmp1ckl3lvy.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp1ckl3lvy.jl:8 [inlined]\n   [11] (::var\"#1#3\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#3\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#3\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp1ckl3lvy.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp1ckl3lvy.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\tend\n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\tend\n\treturn []\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmpdyt6_dw0.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpdyt6_dw0.jl:9 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpdyt6_dw0.jl:9\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpdyt6_dw0.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpa0d1leey.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa0d1leey.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa0d1leey.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa0d1leey.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tif isa(list1[1],Vector)\n\t\t\treturn flatten_list(list1[1])\n\t\telse\n\t\t\treturn list1\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmpfvt4ignu.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpfvt4ignu.jl:9\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpfvt4ignu.jl:20 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpfvt4ignu.jl:19\ntest set: Test Failed at /tmp/tmpfvt4ignu.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: [10, 20] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   ",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array{Any,1}\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpkely0m_r.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpkely0m_r.jl:8\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpkely0m_r.jl:18 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpkely0m_r.jl:17\ntest set: Test Failed at /tmp/tmpkely0m_r.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] ",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2, i)\n\t\telseif typeof(i) == Vector\n\t\t\tlist2 = vcat(list2, flatten_list(i))\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123869,
      "stdout": "test set: Test Failed at /tmp/tmpw24dt0xy.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10, 40, 50] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpw24dt0xy.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpw24dt0xy.jl:19\ntest set: Test Failed at /tmp/tmpw24dt0xy.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpw24dt0xy.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpw24dt0xy.jl:19\ntest set: Test Failed at /tmp/tmpw24dt0xy.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpw24dt0xy.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpw24dt0xy.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpw24dt0xy.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn vcat(flatten_list(list1[1]),flatten_list(list1[2]))\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Test Failed at /tmp/tmpz3zwttgn.jl:16\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3zwttgn.jl:16 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3zwttgn.jl:15\ntest set: Error During Test at /tmp/tmpz3zwttgn.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  BoundsError: attempt to access 1-element Vector{Int64} at index [2]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n   [2] flatten_list (repeats 2 times)\n     @ /tmp/tmpz3zwttgn.jl:8 [inlined]\n   [3] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [4] macro expansion\n     @ /tmp/tmpz3zwttgn.jl:17 [inlined]\n   [5] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [6] top-level scope\n     @ /tmp/tmpz3zwttgn.jl:15\ntest set: Test Failed at /tmp/tmpz3zwttgn.jl:18\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: [1, 2, 4, 5] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3zwttgn.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3zwttgn.jl:15\nTest Summary: | Fail  Error  Total\ntest set      |    2      1      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 2 failed, 1 errored, 0 broken.\nin expression starting at /tmp/tmpz3zwttgn.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif length(list1) == 0\n\t\treturn []\n\telseif isa(list1[1], Int64)\n\t\treturn [list1[1]] .+ flatten_list(list1[2:end])\n\telse\n\t\treturn flatten_list(list1[1]) .+ flatten_list(list1[2:end])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123869,
      "stdout": "test set: Test Failed at /tmp/tmp6b8vkbx6.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b8vkbx6.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp6b8vkbx6.jl:17\ntest set: Test Failed at /tmp/tmp6b8vkbx6.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b8vkbx6.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp6b8vkbx6.jl:17\ntest set: Test Failed at /tmp/tmp6b8vkbx6.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp6b8vkbx6.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp6b8vkbx6.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp6b8vkbx6.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmp8edc5zn_.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp8edc5zn_.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn list1\n\telse\n\t\treturn flatten_list(list1[1])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmpjm6oaagz.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpjm6oaagz.jl:6\n   [2] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpjm6oaagz.jl:8\n   [3] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjm6oaagz.jl:16 [inlined]\n   [5] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjm6oaagz.jl:15\ntest set: Error During Test at /tmp/tmpjm6oaagz.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/a",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpjm6oaagz.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpa0d1leey.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa0d1leey.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa0d1leey.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa0d1leey.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[1])..., flatten_list(list1[2:end])...]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123867,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array{Any,1}\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpkely0m_r.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpkely0m_r.jl:8\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpkely0m_r.jl:18 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpkely0m_r.jl:17\ntest set: Test Failed at /tmp/tmpkely0m_r.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] ",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpthach34w.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpthach34w.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpthach34w.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpthach34w.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpthach34w.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[1])..., flatten_list(list1[2:end])...]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123867,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tFlatten a nested vector structure.\n\t\"\"\"\n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn Vector{Int64}()\n\t\telse\n\t\t\treturn vcat(flatten_list(list1[1]),flatten_list(list1[2:end]))\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123867,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2, i)\n\t\telse\n\t\t\tlist2 = [list2; flatten_list(i)]\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpjgfjgz9d.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpjgfjgz9d.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpjgfjgz9d.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpjgfjgz9d.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpjgfjgz9d.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2, i)\n\t\telseif typeof(i) == Array\n\t\t\tlist2 = [list2; flatten_list(i)]\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Test Failed at /tmp/tmpj8px14ef.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10, 40, 50] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpj8px14ef.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpj8px14ef.jl:19\ntest set: Test Failed at /tmp/tmpj8px14ef.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpj8px14ef.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpj8px14ef.jl:19\ntest set: Test Failed at /tmp/tmpj8px14ef.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpj8px14ef.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpj8px14ef.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpj8px14ef.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123869,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Array)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7pcsjg1z.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmp7pcsjg1z.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7pcsjg1z.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpa0d1leey.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa0d1leey.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa0d1leey.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa0d1leey.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tlist1 = [flatten_list(x) for x in list1]\n\t\treturn [x for y in list1 for x in y]\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123869,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif length(list1) == 0\n\t\treturn []\n\telseif isa(list1[1], Vector)\n\t\treturn flatten_list(list1[1])\n\telse\n\t\treturn [list1[1]] * flatten_list(list1[2:end])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123873,
      "stdout": "test set: Error During Test at /tmp/tmpmipmj0f8.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: no method matching *(::Vector{Int64}, ::Vector{Int64})\n  Closest candidates are:\n    *(::Any, ::Any, !Matched::Any, !Matched::Any...) at /home/a.guha/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    *(!Matched::StridedMatrix{T}, ::StridedVector{S}) where {T<:Union{Float32, Float64, ComplexF32, ComplexF64}, S<:Real} at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/matmul.jl:44\n    *(::StridedVecOrMat, !Matched::LinearAlgebra.Adjoint{<:Any, <:LinearAlgebra.LQPackedQ}) at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:266\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Vector{Int64}) (repeats 2 times)\n     @ Main /tmp/tmpmipmj0f8.jl:10\n   [2] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpmipmj0f8.jl:8\n   [3] flatten_list(list1::Vector{Any}) (repeats 2 times)\n     @ Main /tmp/tmpmipmj0f8.jl:10\n   [4] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [5] macro expansion\n     @ /tmp/tmpmipmj0f8.jl:18 [inlined]\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [7] top-level scope\n     @ /tmp/tmpmipmj0f8.jl:17\n",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmp8edc5zn_.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp8edc5zn_.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(i) for i in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123873,
      "stdout": "test set: Error During Test at /tmp/tmp7o3of3p2.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp7o3of3p2.jl:8 [inlined]\n   [11] (::var\"#1#2\")(i::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp7o3of3p2.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: ",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpg9df7xtq.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpg9df7xtq.jl:9\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpg9df7xtq.jl:9\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpg9df7xtq.jl:20 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpg9df7xtq.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Array{Int64,1})\n\t\treturn list1\n\telse\n\t\tlist2 = []\n\t\tfor i in 1:length(list1)\n\t\t\tlist2 = [list2; flatten_list(list1[i])]\n\t\tend\n\t\treturn list2\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "test set: Error During Test at /tmp/tmpu0phecqi.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpu0phecqi.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpu0phecqi.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpu0phecqi.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: ",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tFlatten a given nested vector structure.\n\t\"\"\"\n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "test set: Error During Test at /tmp/tmpkr5hirbo.jl:19\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpkr5hirbo.jl:11 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpkr5hirbo.jl:11\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expan",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpkr5hirbo.jl:16\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array{Any,1}\n\t\treturn [flatten_list(i) for i in list1]\n\telse\n\t\treturn [flatten_list(i) for i in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "test set: Error During Test at /tmp/tmpr7klc_pk.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpr7klc_pk.jl:10 [inlined]\n   [11] (::var\"#1#3\")(i::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#3\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#3\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpr7klc_pk.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expans",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpr7klc_pk.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t# list1 = [1,2,[3,4,[5,6],7],8]\n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2,i)\n\t\telse\n\t\t\tlist2 = vcat(list2,flatten_list(i))\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123875,
      "stdout": "test set: Error During Test at /tmp/tmp5949hcw2.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp5949hcw2.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp5949hcw2.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5949hcw2.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n    if isa(list1, Int64)\n        return [list1]\n    else\n        return [flatten_list(x) for x in list1]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123875,
      "stdout": "test set: Error During Test at /tmp/tmp2lt4uqj3.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp2lt4uqj3.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp2lt4uqj3.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: ",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Array)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7pcsjg1z.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp7pcsjg1z.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmp7pcsjg1z.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7pcsjg1z.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array{Any,1}\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in keys(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123875,
      "stdout": "test set: Error During Test at /tmp/tmpqgitwng5.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpqgitwng5.jl:10\n   [11] (::var\"#1#3\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#3\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpqgitwng5.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpqgitwng5.jl:18 [inlined]\n   [",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpqgitwng5.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = []\n\t\tfor i in 1:length(list1)\n\t\t\tif isa(list1[i], Vector)\n\t\t\t\tlist2 = [list2; flatten_list(list1[i])]\n\t\t\telse\n\t\t\t\tlist2 = [list2; list1[i]]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tlist2 = []\n\t\tfor i in 1:length(list1)\n\t\t\tif isa(list1[i],Vector)\n\t\t\t\tlist2 = [list2; flatten_list(list1[i])]\n\t\t\telse\n\t\t\t\tlist2 = [list2; list1[i]]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp5zvu896v.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp5zvu896v.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp5zvu896v.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5zvu896v.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp5zvu896v.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp5zvu896v.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp5zvu896v.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5zvu896v.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telseif typeof(list1) == Vector{Int64}\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "test set: Error During Test at /tmp/tmpf7u2pzet.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpf7u2pzet.jl:10\n   [2] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3] macro expansion\n     @ /tmp/tmpf7u2pzet.jl:18 [inlined]\n   [4] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5] top-level scope\n     @ /tmp/tmpf7u2pzet.jl:17\ntest set: Error During Test at /tmp/tmpf7u2pzet.jl:19\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(li",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpf7u2pzet.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif isa(list1[1], Vector)\n\t\t\treturn flatten_list(list1[1])\n\t\telse\n\t\t\treturn [list1[1]]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123873,
      "stdout": "test set: Test Failed at /tmp/tmppa5f_khe.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmppa5f_khe.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmppa5f_khe.jl:19\ntest set: Test Failed at /tmp/tmppa5f_khe.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: [10] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmppa5f_khe.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmppa5f_khe.jl:19\ntest set: Test Failed at /tmp/tmppa5f_khe.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: [1] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmppa5f_khe.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmppa5f_khe.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmppa5f_khe.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\tresult = []\n\t\tfor i in list1\n\t\t\tresult = vcat(result, flatten_list(i))\n\t\tend\n\t\treturn result\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123875,
      "stdout": "test set: Error During Test at /tmp/tmp5_m7_eh9.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp5_m7_eh9.jl:8\n   [2] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n     @ Main ./array.jl:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp5_m7_eh9.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp5_m7_eh9.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp5_m7_eh9.jl:15\ntest set: Error During Test at /tmp/tmp5_m7_eh9.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5_m7_eh9.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tlist2 = []\n\tfor i in list1\n\t\tif typeof(i) == Int64\n\t\t\tpush!(list2, i)\n\t\telseif typeof(i) == Array\n\t\t\tlist2 = vcat(list2, flatten_list(i))\n\t\tend\n\tend\n\treturn list2\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmp81yua4e7.jl:20\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: [0, 10, 40, 50] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\ntest set: Test Failed at /tmp/tmp81yua4e7.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:21 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\ntest set: Test Failed at /tmp/tmp81yua4e7.jl:22\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp81yua4e7.jl:22 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp81yua4e7.jl:19\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp81yua4e7.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = []\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = []\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123866,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmpo44ru713.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpo44ru713.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpo44ru713.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpo44ru713.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpo44ru713.jl:15\ntest set: Error During Test at /tmp/tmpo44ru713.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpo44ru713.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp5zvu896v.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp5zvu896v.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp5zvu896v.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5zvu896v.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Vector\n\t\treturn [flatten_list(i) for i in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123873,
      "stdout": "test set: Test Failed at /tmp/tmpg11s3w1x.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpg11s3w1x.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpg11s3w1x.jl:17\ntest set: Test Failed at /tmp/tmpg11s3w1x.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpg11s3w1x.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpg11s3w1x.jl:17\ntest set: Test Failed at /tmp/tmpg11s3w1x.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpg11s3w1x.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpg11s3w1x.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpg11s3w1x.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = []\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = append!(list2, flatten_list(i))\n\t\t\telse\n\t\t\t\tlist2 = append!(list2, i)\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123872,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "test set: Test Failed at /tmp/tmp7k43yp9m.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp7k43yp9m.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp7k43yp9m.jl:17\ntest set: Test Failed at /tmp/tmp7k43yp9m.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp7k43yp9m.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp7k43yp9m.jl:17\ntest set: Test Failed at /tmp/tmp7k43yp9m.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp7k43yp9m.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp7k43yp9m.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp7k43yp9m.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn vcat(flatten_list(list1[1]), flatten_list(list1[2:end]))\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123872,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\tif isa(list1,Vector)\n\t\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\t\telse\n\t\t\treturn list1\n\t\tend\n\tend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123875,
      "stdout": "test set: Error During Test at /tmp/tmpysppsd7a.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpysppsd7a.jl:8\n   [2] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n     @ Main ./array.jl:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpysppsd7a.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpysppsd7a.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpysppsd7a.jl:15\ntest set: Error During Test at /tmp/tmpysppsd7a.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpysppsd7a.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpa0d1leey.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa0d1leey.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa0d1leey.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa0d1leey.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "test set: Test Failed at /tmp/tmp7k43yp9m.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp7k43yp9m.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp7k43yp9m.jl:17\ntest set: Test Failed at /tmp/tmp7k43yp9m.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp7k43yp9m.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp7k43yp9m.jl:17\ntest set: Test Failed at /tmp/tmp7k43yp9m.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp7k43yp9m.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp7k43yp9m.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp7k43yp9m.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpgypwv7ar.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpgypwv7ar.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpgypwv7ar.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tFlatten a nested vector structure.\n\t\"\"\"\n\tif isa(list1, Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\t\tend\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123876,
      "stdout": "test set: Error During Test at /tmp/tmpbfoueyd8.jl:23\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpbfoueyd8.jl:15\n   [2] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n     @ Main ./array.jl:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpbfoueyd8.jl:12\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpbfoueyd8.jl:23 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpbfoueyd8.jl:22\ntest set: Error During Test at /tmp/tmpbfoueyd8.jl:24\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpbfoueyd8.jl:20\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123875,
      "stdout": "test set: Error During Test at /tmp/tmp02ll177q.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp02ll177q.jl:8\n   [2] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3] macro expansion\n     @ /tmp/tmp02ll177q.jl:16 [inlined]\n   [4] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5] top-level scope\n     @ /tmp/tmp02ll177q.jl:15\ntest set: Error During Test at /tmp/tmp02ll177q.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(lis",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp02ll177q.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn [flatten_list(list1[1])..., flatten_list(list1[2:end])...]\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123867,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(i) for i in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123876,
      "stdout": "test set: Error During Test at /tmp/tmpe43i0nhe.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpe43i0nhe.jl:8 [inlined]\n   [11] (::var\"#1#2\")(i::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpe43i0nhe.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpe43i0nhe.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmpo44ru713.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpo44ru713.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpo44ru713.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpo44ru713.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpo44ru713.jl:15\ntest set: Error During Test at /tmp/tmpo44ru713.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpo44ru713.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp7te6191u.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmp7te6191u.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmp7te6191u.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7te6191u.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7te6191u.jl:15\ntest set: Error During Test at /tmp/tmp7te6191u.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp7te6191u.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tFunction to flatten a given nested vector structure.\n\t\"\"\"\n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123876,
      "stdout": "test set: Error During Test at /tmp/tmphqr1uqbf.jl:21\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmphqr1uqbf.jl:11\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmphqr1uqbf.jl:11\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmphqr1uqbf.jl:21 [inlined]\n   ",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmphqr1uqbf.jl:18\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif length(list1) == 0\n\t\treturn []\n\telseif typeof(list1[1]) == Int64\n\t\treturn [list1[1]] .+ flatten_list(list1[2:end])\n\telse\n\t\treturn flatten_list(list1[1]) .+ flatten_list(list1[2:end])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123874,
      "stdout": "test set: Test Failed at /tmp/tmpvn7hot8o.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpvn7hot8o.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpvn7hot8o.jl:17\ntest set: Test Failed at /tmp/tmpvn7hot8o.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpvn7hot8o.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpvn7hot8o.jl:17\ntest set: Test Failed at /tmp/tmpvn7hot8o.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpvn7hot8o.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpvn7hot8o.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpvn7hot8o.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array{Any,1}\n\t\treturn [flatten_list(x) for x in list1]\n\telseif typeof(list1) == Vector{Int64}\n\t\treturn list1\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123876,
      "stdout": "test set: Error During Test at /tmp/tmp8g3ycxga.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp8g3ycxga.jl:8\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmp8g3ycxga.jl:20 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmp8g3ycxga.jl:19\ntest set: Test Failed at /tmp/tmp8g3ycxga.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] ",
      "stderr": "ERROR: LoadError: ",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in list1\n\t\t\tif isa(i, Vector)\n\t\t\t\tlist2 = vcat(list2, flatten_list(i))\n\t\t\telse\n\t\t\t\tlist2 = vcat(list2, i)\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123873,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpjgfjgz9d.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpjgfjgz9d.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpjgfjgz9d.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpjgfjgz9d.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpjgfjgz9d.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tFlattens a given nested vector structure.\n\t\"\"\"\n\tif isa(list1,Vector)\n\t\tlist2 = []\n\t\tfor i in 1:length(list1)\n\t\t\tif isa(list1[i],Vector)\n\t\t\t\tlist2 = append!(list2,flatten_list(list1[i]))\n\t\t\telse\n\t\t\t\tlist2 = append!(list2,list1[i])\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123873,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\t\"\"\"\n\tThis function will take a nested list and flatten it.\n\t\"\"\"\n\tif isa(list1,Vector)\n\t\tif length(list1) == 0\n\t\t\treturn []\n\t\telse\n\t\t\treturn flatten_list(list1[1]) .+ flatten_list(list1[2:end])\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123876,
      "stdout": "test set: Test Failed at /tmp/tmp5exljg4z.jl:23\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp5exljg4z.jl:23 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp5exljg4z.jl:22\ntest set: Test Failed at /tmp/tmp5exljg4z.jl:24\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp5exljg4z.jl:24 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp5exljg4z.jl:22\ntest set: Test Failed at /tmp/tmp5exljg4z.jl:25\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp5exljg4z.jl:25 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp5exljg4z.jl:22\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp5exljg4z.jl:20\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tif isa(list1[1], Vector)\n\t\t\treturn flatten_list(list1[1])\n\t\telse\n\t\t\treturn list1\n\t\tend\n\telse\n\t\treturn [list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpn4aeyds9.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpn4aeyds9.jl:9\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpn4aeyds9.jl:20 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpn4aeyds9.jl:19\ntest set: Test Failed at /tmp/tmpn4aeyds9.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: [10, 20] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   ",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Vector{Int64}\n\t\treturn list1\n\telse\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in 1:length(list1)\n\t\t\tlist2 = vcat(list2, flatten_list(list1[i]))\n\t\tend\n\t\treturn list2\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123878,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp5zvu896v.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp5zvu896v.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp5zvu896v.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5zvu896v.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Array\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123868,
      "stdout": "test set: Test Failed at /tmp/tmp8edc5zn_.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\ntest set: Test Failed at /tmp/tmp8edc5zn_.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp8edc5zn_.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp8edc5zn_.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp8edc5zn_.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Vector\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123876,
      "stdout": "test set: Test Failed at /tmp/tmpepxixj36.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpepxixj36.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpepxixj36.jl:17\ntest set: Test Failed at /tmp/tmpepxixj36.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpepxixj36.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpepxixj36.jl:17\ntest set: Test Failed at /tmp/tmpepxixj36.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmpepxixj36.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmpepxixj36.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmpepxixj36.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif length(list1) == 0\n\t\treturn []\n\telseif isa(list1[1], Vector)\n\t\treturn flatten_list(list1[1]) .* flatten_list(list1[2:end])\n\telse\n\t\treturn [list1[1]] .* flatten_list(list1[2:end])\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123876,
      "stdout": "test set: Test Failed at /tmp/tmp_eu8u57p.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp_eu8u57p.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp_eu8u57p.jl:17\ntest set: Test Failed at /tmp/tmp_eu8u57p.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp_eu8u57p.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp_eu8u57p.jl:17\ntest set: Test Failed at /tmp/tmp_eu8u57p.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp_eu8u57p.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp_eu8u57p.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp_eu8u57p.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpujo9l5__.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpujo9l5__.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpujo9l5__.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpujo9l5__.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Vector{Int64}\n\t\treturn list1\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123877,
      "stdout": "test set: Error During Test at /tmp/tmpbsgeiul4.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpbsgeiul4.jl:10\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpbsgeiul4.jl:18 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpbsgeiul4.jl:17\ntest set: Error During Test at /tmp/tmpbsgeiul4.jl:19\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Vec",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpbsgeiul4.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmp5zvu896v.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmp5zvu896v.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp5zvu896v.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmp5zvu896v.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123871,
      "stdout": "test set: Error During Test at /tmp/tmpo44ru713.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpo44ru713.jl:8\n   [2] (::var\"#1#2\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpo44ru713.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpo44ru713.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpo44ru713.jl:15\ntest set: Error During Test at /tmp/tmpo44ru713.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpo44ru713.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa3y9b60s.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa3y9b60s.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa3y9b60s.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa3y9b60s.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Vector)\n\t\tlist1 = [flatten_list(x) for x in list1]\n\t\tlist1 = [x for y in list1 for x in y]\n\tend\n\treturn list1\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123878,
      "stdout": "test set: Error During Test at /tmp/tmpcdaoowd_.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /home/a.guha/.conda/envs/polyglot/share/julia/base/array.jl:554\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1] flatten_list(list1::Int64)\n     @ Main /tmp/tmpcdaoowd_.jl:9\n   [2] (::var\"#1#3\")(x::Int64)\n     @ Main ./none:0\n   [3] iterate\n     @ ./generator.jl:47 [inlined]\n   [4] collect(itr::Base.Generator{Vector{Any}, var\"#1#3\"})\n     @ Base ./array.jl:724\n   [5] flatten_list(list1::Vector{Any})\n     @ Main /tmp/tmpcdaoowd_.jl:6\n   [6] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [7] macro expansion\n     @ /tmp/tmpcdaoowd_.jl:16 [inlined]\n   [8] macro expansion\n     @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [9] top-level scope\n     @ /tmp/tmpcdaoowd_.jl:15\ntest set: Error During Test at /tmp/tmpcdaoowd_.jl:17\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T}, !Matched::AbstractArray) where T",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpcdaoowd_.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telseif isa(list1,Vector)\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpgypwv7ar.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpgypwv7ar.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpgypwv7ar.jl:18 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpgypwv7ar.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tif isa(list1[1],Vector)\n\t\t\treturn flatten_list(list1[1])\n\t\telse\n\t\t\treturn list1\n\t\tend\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123878,
      "stdout": "test set: Error During Test at /tmp/tmp78btbpe9.jl:20\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmp78btbpe9.jl:9\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmp78btbpe9.jl:20 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmp78btbpe9.jl:19\ntest set: Test Failed at /tmp/tmp78btbpe9.jl:21\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: [10, 20] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   ",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 2 failed, 1 errored, 0 broken.\nin expression starting at /tmp/tmp78btbpe9.jl:17\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(x) for x in list1]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510614,
      "stdout": "test set: Error During Test at /tmp/tmpa56tn49i.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa56tn49i.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa56tn49i.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa56tn49i.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123870,
      "stdout": "test set: Error During Test at /tmp/tmpa0d1leey.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpa0d1leey.jl:8 [inlined]\n   [11] (::var\"#1#2\")(x::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpa0d1leey.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpa0d1leey.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Vector)\n\t\tlist2 = Vector{Int64}()\n\t\tfor i in list1\n\t\t\tif isa(i,Vector)\n\t\t\t\tlist2 = [list2; flatten_list(i)]\n\t\t\telse\n\t\t\t\tlist2 = [list2; i]\n\t\t\tend\n\t\tend\n\t\treturn list2\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123875,
      "stdout": "",
      "stderr": "Test Summary: | Pass  Total\ntest set      |    3      3\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telseif isa(list1, Vector)\n\t\treturn [flatten_list(i) for i in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123878,
      "stdout": "test set: Error During Test at /tmp/tmpxn7vw3pu.jl:18\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list\n      @ /tmp/tmpxn7vw3pu.jl:8 [inlined]\n   [11] (::var\"#1#2\")(i::Vector{Int64})\n      @ Main ./none:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!(dest::Vector{Vector{Int64}}, itr::Base.Generator{Vector{Any}, var\"#1#2\"}, offs::Int64, st::Int64)\n      @ Base ./array.jl:782\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{Vector{Any}, var\"#1#2\"})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpxn7vw3pu.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansi",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpxn7vw3pu.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1, Int64)\n\t\treturn [list1]\n\telse\n\t\treturn [flatten_list(list1[i]) for i in 1:length(list1)]\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1665510613,
      "stdout": "test set: Error During Test at /tmp/tmpthach34w.jl:16\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Vector{Int64}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Vector{Int64}})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Int64})\n      @ Main /tmp/tmpthach34w.jl:8\n   [11] (::var\"#1#2\"{Vector{Any}})(i::Int64)\n      @ Main ./array.jl:0\n   [12] iterate\n      @ ./generator.jl:47 [inlined]\n   [13] collect_to!\n      @ ./array.jl:782 [inlined]\n   [14] collect_to_with_first!\n      @ ./array.jl:760 [inlined]\n   [15] collect(itr::Base.Generator{UnitRange{Int64}, var\"#1#2\"{Vector{Any}}})\n      @ Base ./array.jl:734\n   [16] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpthach34w.jl:8\n   [17] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [18] macro expansion\n      @ /tmp/tmpthach34w.jl:16 [inlined]\n   [1",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpthach34w.jl:13\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif typeof(list1) == Int64\n\t\treturn [list1]\n\telseif typeof(list1) == Vector\n\t\treturn [flatten_list(x) for x in list1]\n\telse\n\t\treturn []\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123877,
      "stdout": "test set: Test Failed at /tmp/tmp2jg2od_c.jl:18\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n   Evaluated: Int64[] == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp2jg2od_c.jl:18 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp2jg2od_c.jl:17\ntest set: Test Failed at /tmp/tmp2jg2od_c.jl:19\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n   Evaluated: Int64[] == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp2jg2od_c.jl:19 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp2jg2od_c.jl:17\ntest set: Test Failed at /tmp/tmp2jg2od_c.jl:20\n  Expression: candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\n   Evaluated: Int64[] == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]\nStacktrace:\n [1] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n [2] macro expansion\n   @ /tmp/tmp2jg2od_c.jl:20 [inlined]\n [3] macro expansion\n   @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n [4] top-level scope\n   @ /tmp/tmp2jg2od_c.jl:17\nTest Summary: | Fail  Total\ntest set      |    3      3\n",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored, 0 broken.\nin expression starting at /tmp/tmp2jg2od_c.jl:15\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\"\"\"\n\tWrite a function to flatten a given nested vector structure.\n\t\"\"\"\nfunction flatten_list(list1::Any)::Vector{Int64} \n\tif isa(list1,Int64)\n\t\treturn list1\n\telseif isa(list1,Array)\n\t\treturn list1\n\telseif isa(list1,Vector)\n\t\treturn list1\n\telseif isa(list1,Tuple)\n\t\treturn list1\n\telseif isa(list1,Dict)\n\t\treturn list1\n\telseif isa(list1,Set)\n\t\treturn list1\n\telseif isa(list1,Any)\n\t\treturn list1\n\telse\n\t\treturn list1\n\tend\nend\nusing Test\n\n@testset begin\n\ncandidate = flatten_list;\n\t@test(candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\n\t@test(candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])\nend\n",
      "timestamp": 1666123878,
      "stdout": "test set: Error During Test at /tmp/tmpbt0xmznn.jl:28\n  Test threw exception\n  Expression: candidate([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer at /home/a.guha/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n    convert(::Type{T}, !Matched::T) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:6\n    convert(::Type{T}, !Matched::Number) where T<:Number at /home/a.guha/.conda/envs/polyglot/share/julia/base/number.jl:7\n    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::Vector{Int64}, i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{Any})\n      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n   [10] flatten_list(list1::Vector{Any})\n      @ Main /tmp/tmpbt0xmznn.jl:8\n   [11] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [12] macro expansion\n      @ /tmp/tmpbt0xmznn.jl:28 [inlined]\n   [13] macro expansion\n      @ /home/a.guha/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [14] top-level scope\n      @ /tmp/tmpbt0xmznn.jl:27\ntest set: Error During Test at /tmp/tmpbt0xmznn.jl:29\n  Test threw exception\n  Expression: candidate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40]\n  MethodError: Cannot `convert` an object of type Vector{Int64} to an obje",
      "stderr": "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored, 0 broken.\nin expression starting at /tmp/tmpbt0xmznn.jl:25\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}