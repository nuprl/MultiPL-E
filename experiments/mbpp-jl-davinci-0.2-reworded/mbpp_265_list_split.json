{
  "name": "mbpp_265_list_split",
  "language": "jl",
  "prompt": "\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\nfunction list_split(S::Any, step::Int64)::Any \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py",
  "prompt_terminology": "reworded",
  "tests": "using Test\n\n@testset begin\n\ncandidate = list_split;\n\t@test(candidate([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"], 3) == [[\"a\", \"d\", \"g\", \"j\", \"m\"], [\"b\", \"e\", \"h\", \"k\", \"n\"], [\"c\", \"f\", \"i\", \"l\"]])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]])\n\t@test(candidate([\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\"], 2) == [[\"python\", \"C\", \"DBMS\"], [\"java\", \"C++\", \"SQL\"]])\nend\n",
  "stop_tokens": [
    "\nfunction",
    "\nmacro",
    "\n\n"
  ],
  "completions": [
    "\tif step <= 0\n\t\tthrow(ArgumentError(\"step must be positive\"))\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\tthrow(ArgumentError(\"S must be a Vector or a String\"))\n\tend\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\nend",
    "\t\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\n\tif length(S) < step\n\t\treturn S\n\telse\n\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\terror(\"step must be greater than 0\")\n\tend\n\tif !isinteger(step)\n\t\terror(\"step must be an integer\")\n\tend\n\tif !isvector(S)\n\t\terror(\"S must be a vector\")\n\tend\n\tif !isinteger(step)\n\t\terror(\"step must be an integer\")\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\terror(\"step must be greater than 0\")\n\tend\n\tif !isinteger(step)\n\t\terror(\"step must be an integer\")\n\tend\n\tif !isvector(S)\n\t\terror(\"S must be a vector\")\n\tend\n\tif !isinteger(step)\n\t\terror(\"step must be an integer\")\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\terror(\"step must be greater than 0\")\n\tend\n\tif !isinteger(step)\n\t\terror(\"step must be an integer\")\n\tend\n\tif !isvector(S)\n\t\terror(\"S must be a vector\")\n\tend\n\tif !isinteger(step)\n\t\terror(\"step must be an integer\")\n\tend\n\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\terror(\"step must be greater than",
    "\t\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif isa(S, Vector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, Array)\n\t\treturn [S[i:i+step-1,:] for i in 1:step:size(S,1)]\n\telse\n\t\treturn [S[i:i+step-1,:,:] for i in 1:step:size(S,1)]\n\tend\nend",
    "\tif isa(S, Vector{Any})\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, String)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\treturn \"Error: Input must be a vector or string\"\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\tif step < 1\n\t\terror(\"step must be greater than 0\")\n\tend\n\tif isa(S, Vector)\n\t\tif isa(S[1], Vector)\n\t\t\treturn [list_split(S[i], step) for i in 1:length(S)]\n\t\telse\n\t\t\treturn [S[i:min(i+step-1, length(S))] for i in 1:step:length(S)]\n\t\tend\n\telseif isa(S, String)\n\t\treturn [S[i:min(i+step-1, length(S))] for i in 1:step:length(S)]\n\telse\n\t\terror(\"Input must be a vector or string\")\n\tend\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) <= step\n\t\treturn S\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step > length(S)\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < 1\n\t\treturn \"Error: step must be greater than 0\"\n\tend\n\tif step > length(S)\n\t\treturn \"Error: step must be less than or equal to length of S\"\n\tend\n\t\n\tresult = []\n\tfor i in 1:step:length(S)\n\t\tif i + step - 1 <= length(S)\n\t\t\tpush!(result, S[i:i+step-1])\n\t\telse\n\t\t\tpush!(result, S[i:end])\n\t\tend\n\tend\n\treturn result\nend",
    "\tif step <= 0\n\t\terror(\"step must be positive\")\n\tend\n\tif isa(S, AbstractString)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telseif isa(S, AbstractVector)\n\t\treturn [S[i:i+step-1] for i in 1:step:length(S)]\n\telse\n\t\terror(\"S must be a string or vector\")\n\tend\nend",
    "\t\"\"\"\n\tSplit a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step]] .+ list_split(S[step+1:end], step)\n\tend\nend",
    "\tif step <= 0\n\t\terror(\"Step must be positive\")\n\tend\n\tif isa(S, AbstractVector)\n\t\tif isa(S, AbstractString)\n\t\t\treturn [string(S[i]) for i in 1:step:length(S)]\n\t\telse\n\t\t\treturn [S[i] for i in 1:step:length(S)]\n\t\tend\n\telse\n\t\terror(\"Input must be a vector\")\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\n\tif step == 0\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step-1], S[step:end]]\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\telse\n\t\treturn [S[i:i+step] for i in 1:step:length(S)]\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\n\tif length(S) < step\n\t\treturn S\n\telse\n\t\treturn [S[1:step]; list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tSplits a list into sublists of length step.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif length(S) < step\n\t\treturn S\n\tend\n\tif length(S) == step\n\t\treturn [S]\n\tend\n\treturn [S[1:step]] * list_split(S[step+1:end], step)\nend",
    "\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step == length(S)\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif step < length(S)\n\t\treturn [S[1:step], list_split(S[step+1:end], step)]\n\tend\nend",
    "\t\"\"\"\n\tWrite a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\n\t\"\"\"\n\tif step == 0\n\t\treturn S\n\tend\n\tif step == 1\n\t\treturn [S]\n\tend\n\tif step > length(S)\n\t\treturn [S]\n\tend\n\tif step < 0\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractString)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractDict)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSet)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractRange)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractArray)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractFloat)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractInt)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractBool)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractComplex)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractRational)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractChar)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractUnitRange)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractBitArray)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractBitSet)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrixCSC)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrixCSR)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrixCOO)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractSparseMatrix)\n\t\treturn [S]\n\tend\n\tif isa(S, AbstractS"
  ]
}