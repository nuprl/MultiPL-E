{
  "name": "mbpp_4_heap_queue_largest",
  "language": "lua",
  "prompt": "-- Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nlocal function heap_queue_largest(nums, n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = heap_queue_largest\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), {85, 75, 65})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), {85, 75})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), {85, 75, 65, 58, 35})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  table.sort(heap, function(a, b) return a > b end)\n  return heap\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p] >= heap[i] then\n        break\n      end\n      heap[i], heap[p] = heap[p], heap[i]\n      i = p\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      if l + 1 <= #heap and heap[l + 1] > heap[l] then\n        l = l + 1\n      end\n      if heap[i] >= heap[l] then\n        break\n      end\n      heap[i], heap[l] = heap[l], heap[i]\n      i = l\n    end\n    return x\n  end\n  for i = 1, n do\n    push(nums[i])\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      pop()\n      push(nums[i])\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, 1, pop())\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "  local heap = HeapQueue.new(nums)\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local p = math.floor(i / 2)\n    while p > 0 and heap[p] < heap[i] do\n      heap[p], heap[i] = heap[i], heap[p]\n      i = p\n      p = math.floor(i / 2)\n    end\n  end\n  local function sift_down(i)\n    local c = i * 2\n    while c <= #heap do\n      if c + 1 <= #heap and heap[c + 1] > heap[c] then\n        c = c + 1\n      end\n      if heap[i] >= heap[c] then\n        break\n      end\n      heap[i], heap[c] = heap[c], heap[i]\n      i = c\n      c = i * 2\n    end\n  end\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap[#heap + 1] = num\n      sift_up(#heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      sift_down(1)\n    end\n  end\n  local res = {}\n  while #heap > 0 do\n    res[#res + 1] = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    sift_down(1)\n  end\n  return res\nend",
    "    local heap = {}\n    local function sift_up(heap, index)\n        local parent = math.floor(index / 2)\n        if parent > 0 and heap[index] > heap[parent] then\n            heap[index], heap[parent] = heap[parent], heap[index]\n            sift_up(heap, parent)\n        end\n    end\n    local function sift_down(heap, index)\n        local left = index * 2\n        local right = left + 1\n        local largest = index\n        if left <= #heap and heap[left] > heap[largest] then\n            largest = left\n        end\n        if right <= #heap and heap[right] > heap[largest] then\n            largest = right\n        end\n        if largest ~= index then\n            heap[index], heap[largest] = heap[largest], heap[index]\n            sift_down(heap, largest)\n        end\n    end\n    local function insert(heap, num)\n        heap[#heap + 1] = num\n        sift_up(heap, #heap)\n    end\n    local function remove(heap)\n        heap[1], heap[#heap] = heap[#heap], heap[1]\n        local num = table.remove(heap)\n        sift_down(heap, 1)\n        return num\n    end\n    for _, num in ipairs(nums) do\n        insert(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = remove(heap)\n    end\n    return result\nend",
    "    local heap = Heap()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for _ = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  return heap_to_list(heap)\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  return heap\nend",
    "  local heap = Heap.new(nums)\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        local i = #heap + 1\n        heap[i] = num\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = left + 1\n            if left > #heap then\n                break\n            end\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[i] < heap[max] then\n                heap[i], heap[max] = heap[max], heap[i]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heapq.heappop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local val = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return val\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local res = {}\n    for i = 1, n do\n        table.insert(res, heap_pop(heap))\n    end\n    return res\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for i, num in ipairs(nums) do\n    if i <= n then\n      heap[i] = num\n    else\n      local min = heap[1]\n      if num > min then\n        heap[1] = num\n        heap_sift_down(heap, 1, n)\n      end\n    end\n  end\n  heap_sort(heap)\n  return heap\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        local num = heap_pop(heap)\n        if num then\n            table.insert(result, num)\n        end\n    end\n    return result\nend",
    "    local heap = {}\n    local size = 0\n    local function push(x)\n        size = size + 1\n        heap[size] = x\n        local i = size\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local x = heap[1]\n        heap[1] = heap[size]\n        heap[size] = nil\n        size = size - 1\n        local i = 1\n        while i * 2 <= size do\n            local j = i * 2\n            if j < size and heap[j] < heap[j + 1] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return x\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n        if size > n then\n            pop()\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = pop()\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local count = 0\n    local function push(num)\n        count = count + 1\n        heap[count] = num\n        local i = count\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] < heap[i] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[count]\n        heap[count] = nil\n        count = count - 1\n        local i = 1\n        while i * 2 <= count do\n            local l = i * 2\n            local r = l + 1\n            local j = l\n            if r <= count and heap[r] > heap[l] then\n                j = r\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        push(num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = pop()\n    end\n    return ret\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local val = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return val\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  local function insert(num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function remove()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      local max = left\n      if right <= #heap and heap[right] > heap[left] then\n        max = right\n      end\n      if heap[max] > heap[i] then\n        heap[max], heap[i] = heap[i], heap[max]\n        i = max\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for i = 1, n do\n    insert(nums[i])\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      remove()\n      insert(nums[i])\n    end\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, 1, remove())\n  end\n  return ret\nend",
    "    local heap = Heap:new()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n            else\n                break\n            end\n            i = parent\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[max] > heap[i] then\n                heap[max], heap[i] = heap[i], heap[max]\n            else\n                break\n            end\n            i = max\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i] > heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "    local heap = Heap.new(function(a, b) return a > b end)\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = Heap.new(nums, function(a, b) return a > b end)\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for i, num in ipairs(nums) do\n        if i <= n then\n            heap[i] = num\n        else\n            heap_insert(heap, num)\n        end\n    end\n    heap_build(heap)\n    for i = n + 1, #nums do\n        heap_insert(heap, nums[i])\n    end\n    return heap_sort(heap)\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        local i = #heap + 1\n        heap[i] = val\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] >= heap[i] then\n                break\n            end\n            heap[p], heap[i] = heap[i], heap[p]\n            i = p\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        local n = #heap\n        heap[1] = heap[n]\n        heap[n] = nil\n        n = n - 1\n        local i = 1\n        while i * 2 <= n do\n            local j = i * 2\n            if j < n and heap[j] < heap[j + 1] then\n                j = j + 1\n            end\n            if heap[i] >= heap[j] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop(heap)\n    end\n    return ret\nend",
    "    local heap = Heap()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n        if heap:size() > n then\n            heap:pop()\n        end\n    end\n    local result = {}\n    while heap:size() > 0 do\n        table.insert(result, heap:pop())\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i] > heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local child = i * 2\n      if child + 1 <= #heap and heap[child + 1] > heap[child] then\n        child = child + 1\n      end\n      if heap[i] < heap[child] then\n        heap[i], heap[child] = heap[child], heap[i]\n        i = child\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[left] > heap[i] then\n          heap[left], heap[i] = heap[i], heap[left]\n        end\n        break\n      else\n        if heap[left] > heap[right] then\n          if heap[left] > heap[i] then\n            heap[left], heap[i] = heap[i], heap[left]\n            i = left\n          else\n            break\n          end\n        else\n          if heap[right] > heap[i] then\n            heap[right], heap[i] = heap[i], heap[right]\n            i = right\n          else\n            break\n          end\n        end\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    push(num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, pop())\n  end\n  return ret\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n    end\n    local ret = {}\n    for _ = 1, n do\n        table.insert(ret, pop())\n    end\n    return ret\nend",
    "  local heap = {}\n  for i, num in ipairs(nums) do\n    if #heap < n then\n      heap_push(heap, num)\n    elseif num > heap[1] then\n      heap_replace(heap, num)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local result = {}\n    for _ = 1, n do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = Heap()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    else\n      if num > heap[1] then\n        heap[1] = num\n        heap_sift_down(heap, 1, #heap)\n      end\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap[1])\n    heap[1] = heap[#heap]\n    heap_sift_down(heap, 1, #heap - 1)\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_extract_max(heap)\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local child = i * 2\n      if child + 1 <= #heap and heap[child + 1] > heap[child] then\n        child = child + 1\n      end\n      if heap[i] < heap[child] then\n        heap[i], heap[child] = heap[child], heap[i]\n        i = child\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    elseif num > heap[1] then\n      heap_pop(heap)\n      heap_insert(heap, num)\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    table.insert(ret, 1, heap_pop(heap))\n  end\n  return ret\nend",
    "    local heap = HeapQueue:new()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap:pop())\n    end\n    return result\nend",
    "    local heap = {}\n    local function sift_down(i)\n        local left = i * 2\n        local right = i * 2 + 1\n        local largest = i\n        if left <= #heap and heap[left] > heap[largest] then\n            largest = left\n        end\n        if right <= #heap and heap[right] > heap[largest] then\n            largest = right\n        end\n        if largest ~= i then\n            heap[i], heap[largest] = heap[largest], heap[i]\n            sift_down(largest)\n        end\n    end\n    local function sift_up(i)\n        local parent = math.floor(i / 2)\n        if parent > 0 and heap[parent] < heap[i] then\n            heap[parent], heap[i] = heap[i], heap[parent]\n            sift_up(parent)\n        end\n    end\n    for i = 1, n do\n        heap[i] = nums[i]\n        sift_up(i)\n    end\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            sift_down(1)\n        end\n    end\n    for i = #heap, 2, -1 do\n        heap[1], heap[i] = heap[i], heap[1]\n        sift_down(1)\n    end\n    return heap\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 and heap[i] > heap[i // 2] do\n            heap[i], heap[i // 2] = heap[i // 2], heap[i]\n            i = i // 2\n        end\n    end\n    local function pop()\n        local x = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] >= heap[j] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n        return x\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n    end\n    for i = 1, n do\n        nums[i] = pop()\n    end\n    for i = 1, n // 2 do\n        nums[i], nums[n - i + 1] = nums[n - i + 1], nums[i]\n    end\n    return nums\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    else\n      if num > heap[1] then\n        heap_replace(heap, num)\n      end\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local num = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap, #heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local child = i * 2\n      if child + 1 <= #heap and heap[child] < heap[child + 1] then\n        child = child + 1\n      end\n      if heap[i] < heap[child] then\n        heap[i], heap[child] = heap[child], heap[i]\n        i = child\n      else\n        break\n      end\n    end\n    return num\n  end\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_push(heap, num)\n    elseif num > heap[1] then\n      heap_pop(heap)\n      heap_push(heap, num)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, 1, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local res = {}\n  while #heap > 0 do\n    table.insert(res, heap_pop(heap))\n  end\n  return res\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_queue_heapify(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heap_queue_sift_down(heap, 1, n)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        table.insert(ret, 1, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                if heap[left] > heap[right] then\n                    if heap[i] < heap[left] then\n                        heap[i], heap[left] = heap[left], heap[i]\n                        i = left\n                    else\n                        break\n                    end\n                else\n                    if heap[i] < heap[right] then\n                        heap[i], heap[right] = heap[right], heap[i]\n                        i = right\n                    else\n                        break\n                    end\n                end\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        table.insert(ret, 1, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    table.insert(heap, num)\n    heap_bubble_up(heap, #heap)\n  end\n  local result = {}\n  for i = 1, n do\n    local max = heap_pop(heap)\n    table.insert(result, max)\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_push(heap, item)\n    heap[#heap + 1] = item\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local item = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local child = i * 2\n      if child + 1 <= #heap and heap[child + 1] > heap[child] then\n        child = child + 1\n      end\n      if heap[i] < heap[child] then\n        heap[i], heap[child] = heap[child], heap[i]\n        i = child\n      else\n        break\n      end\n    end\n    return item\n  end\n  for i = 1, #nums do\n    if #heap < n then\n      heap_push(heap, nums[i])\n    elseif nums[i] > heap[1] then\n      heap_pop(heap)\n      heap_push(heap, nums[i])\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, pop())\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, 1, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = Heap.new()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_insert(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[j], heap[i] = heap[i], heap[j]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    heap_insert(x)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap_pop())\n  end\n  return result\nend",
    "    local heap = {}\n    local heap_size = 0\n    local function heap_push(num)\n        heap_size = heap_size + 1\n        heap[heap_size] = num\n        local i = heap_size\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local ret = heap[1]\n        heap[1] = heap[heap_size]\n        heap[heap_size] = nil\n        heap_size = heap_size - 1\n        local i = 1\n        while i * 2 <= heap_size do\n            local j = i * 2\n            if j + 1 <= heap_size and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop()\n    end\n    return ret\nend",
    "    local heap = Heap.new()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "    local heap = {};\n    for _, num in ipairs(nums) do\n        heap_push(heap, num);\n    end\n    local result = {};\n    for i = 1, n do\n        result[i] = heap_pop(heap);\n    end\n    return result;\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local parent = math.floor(i / 2)\n    if parent > 0 and heap[parent] < heap[i] then\n      heap[parent], heap[i] = heap[i], heap[parent]\n      sift_up(parent)\n    end\n  end\n  local function sift_down(i)\n    local left = i * 2\n    local right = left + 1\n    local largest = i\n    if left <= #heap and heap[left] > heap[largest] then\n      largest = left\n    end\n    if right <= #heap and heap[right] > heap[largest] then\n      largest = right\n    end\n    if largest ~= i then\n      heap[largest], heap[i] = heap[i], heap[largest]\n      sift_down(largest)\n    end\n  end\n  for i, num in ipairs(nums) do\n    heap[i] = num\n    sift_up(i)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    sift_down(1)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  local function push(x)\n    heap[#heap+1] = x\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i/2)\n      if heap[p] < heap[i] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local l = i*2\n      local r = l+1\n      if r <= #heap then\n        if heap[l] > heap[r] then\n          if heap[i] < heap[l] then\n            heap[i], heap[l] = heap[l], heap[i]\n            i = l\n          else\n            break\n          end\n        else\n          if heap[i] < heap[r] then\n            heap[i], heap[r] = heap[r], heap[i]\n            i = r\n          else\n            break\n          end\n        end\n      elseif l <= #heap then\n        if heap[i] < heap[l] then\n          heap[i], heap[l] = heap[l], heap[i]\n          i = l\n        else\n          break\n        end\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = pop()\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local parent = math.floor(i / 2)\n    if parent > 0 and heap[i] > heap[parent] then\n      heap[i], heap[parent] = heap[parent], heap[i]\n      sift_up(parent)\n    end\n  end\n  local function sift_down(i)\n    local left = i * 2\n    local right = i * 2 + 1\n    if left <= #heap and heap[left] > heap[i] then\n      heap[left], heap[i] = heap[i], heap[left]\n      sift_down(left)\n    end\n    if right <= #heap and heap[right] > heap[i] then\n      heap[right], heap[i] = heap[i], heap[right]\n      sift_down(right)\n    end\n  end\n  for i = 1, n do\n    heap[i] = nums[i]\n    sift_up(i)\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      sift_down(1)\n    end\n  end\n  for i = #heap, 2, -1 do\n    heap[i], heap[1] = heap[1], heap[i]\n    sift_down(1)\n  end\n  return heap\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n    if heap:size() > n then\n      heap:pop()\n    end\n  end\n  local result = {}\n  while heap:size() > 0 do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, -num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, -heapq.heappop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] < heap[i] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local x = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local l = i * 2\n            local r = l + 1\n            if r <= #heap then\n                if heap[l] > heap[r] then\n                    if heap[l] > heap[i] then\n                        heap[l], heap[i] = heap[i], heap[l]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    if heap[r] > heap[i] then\n                        heap[r], heap[i] = heap[i], heap[r]\n                        i = r\n                    else\n                        break\n                    end\n                end\n            elseif l <= #heap then\n                if heap[l] > heap[i] then\n                    heap[l], heap[i] = heap[i], heap[l]\n                    i = l\n                else\n                    break\n                end\n            else\n                break\n            end\n        end\n        return x\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, pop())\n    end\n    return ret\nend",
    "    local heap = {}\n    local function heap_push(h, num)\n        table.insert(h, num)\n        local i = #h\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if h[p] < h[i] then\n                h[p], h[i] = h[i], h[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(h)\n        local r = h[1]\n        h[1] = h[#h]\n        table.remove(h)\n        local i = 1\n        while i * 2 <= #h do\n            local l = i * 2\n            local r = i * 2 + 1\n            local j = l\n            if r <= #h and h[r] > h[l] then\n                j = r\n            end\n            if h[i] < h[j] then\n                h[i], h[j] = h[j], h[i]\n                i = j\n            else\n                break\n            end\n        end\n        return r\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local r = {}\n    while #heap > 0 do\n        table.insert(r, 1, heap_pop(heap))\n    end\n    return r\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for i = 1, #nums do\n    heap_push(heap, nums[i])\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local val = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local j = i * 2\n            if j < #heap and heap[j] < heap[j + 1] then\n                j = j + 1\n            end\n            if j <= #heap and heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return val\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p] < heap[i] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      local r = i * 2 + 1\n      if r <= #heap and heap[r] > heap[l] then\n        l = r\n      end\n      if heap[i] < heap[l] then\n        heap[i], heap[l] = heap[l], heap[i]\n        i = l\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for i = 1, n do\n    push(nums[i])\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      pop()\n      push(nums[i])\n    end\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, 1, pop())\n  end\n  return ret\nend",
    "  local heap = Heap:new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = pop()\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    ret[#ret + 1] = heap_pop(heap)\n  end\n  return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_pop(heap)\n            heap_push(heap, num)\n        end\n    end\n    return heap_sort(heap)\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i] > heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for i = 1, #nums do\n    if i <= n then\n      heap_push(heap, nums[i])\n    else\n      if nums[i] > heap[1] then\n        heap_pop(heap)\n        heap_push(heap, nums[i])\n      end\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    table.insert(ret, 1, heap_pop(heap))\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  return heap\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, -num)\n    end\n    local result = {}\n    for _ = 1, n do\n        table.insert(result, -heapq.heappop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local child = i * 2\n      if child + 1 <= #heap and heap[child + 1] > heap[child] then\n        child = child + 1\n      end\n      if heap[i] < heap[child] then\n        heap[i], heap[child] = heap[child], heap[i]\n        i = child\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    push(num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, 1, pop())\n  end\n  return ret\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] < heap[i] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local x = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local l = i * 2\n            local r = i * 2 + 1\n            local j = l\n            if r <= #heap and heap[r] > heap[l] then\n                j = r\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return x\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n    end\n    local ret = {}\n    for _ = 1, n do\n        table.insert(ret, pop())\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_insert(num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop())\n    end\n    return ret\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heapify(heap, n)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heapify(heap, n, 1)\n    end\n  end\n  return heap\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_make(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heap_sift_down(heap, 1, n)\n        end\n    end\n    heap_sort(heap, n)\n    return heap\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  return heap\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_queue_heapify(heap, n)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_queue_sift_down(heap, 1, n)\n    end\n  end\n  heap_queue_sort(heap, n)\n  return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for i, v in ipairs(nums) do\n    heap_insert(heap, v)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local ret = {}\n  for _ = 1, n do\n    table.insert(ret, pop())\n  end\n  return ret\nend",
    "    local heap = {}\n    local function heap_push(heap, x)\n        heap[#heap + 1] = x\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] >= heap[i] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] >= heap[j] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n        return ret\n    end\n    for _, x in ipairs(nums) do\n        heap_push(heap, x)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop(heap)\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] <= heap[parent] then\n                break\n            end\n            heap[i], heap[parent] = heap[parent], heap[i]\n            i = parent\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = left + 1\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[i] >= heap[max] then\n                break\n            end\n            heap[i], heap[max] = heap[max], heap[i]\n            i = max\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  return heap_sort(heap)\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n        if #heap > n then\n            heapq.heappop(heap)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, -num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, -heapq.heappop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        heap[#heap + 1] = num\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] < heap[i] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local l = i * 2\n            local r = i * 2 + 1\n            local j = l\n            if r <= #heap and heap[r] > heap[l] then\n                j = r\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop(heap)\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n        if #heap > n then\n            heapq.heappop(heap)\n        end\n    end\n    return heapq.nlargest(n, heap)\nend",
    "    local heap = {}\n    local function sift_down(i)\n        local left = 2 * i\n        local right = 2 * i + 1\n        local largest = i\n        if left <= #heap and heap[left] > heap[largest] then\n            largest = left\n        end\n        if right <= #heap and heap[right] > heap[largest] then\n            largest = right\n        end\n        if largest ~= i then\n            heap[largest], heap[i] = heap[i], heap[largest]\n            sift_down(largest)\n        end\n    end\n    local function sift_up(i)\n        local parent = math.floor(i / 2)\n        if parent > 0 and heap[i] > heap[parent] then\n            heap[i], heap[parent] = heap[parent], heap[i]\n            sift_up(parent)\n        end\n    end\n    for i, num in ipairs(nums) do\n        heap[i] = num\n        sift_up(i)\n    end\n    for i = #heap, #heap - n + 1, -1 do\n        heap[1], heap[i] = heap[i], heap[1]\n        sift_down(1)\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = HeapQueue()\n    for i, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap:pop())\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, -num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = -heapq.heappop(heap)\n    end\n    return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[i] < heap[max] then\n                heap[i], heap[max] = heap[max], heap[i]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_queue_build(heap)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_queue_heapify(heap, 1)\n    end\n  end\n  return heap\nend",
    "    local heap = HeapQueue:new()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap:pop())\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            table.insert(heap, num)\n            heap_sift_up(heap, #heap)\n        elseif num > heap[1] then\n            heap[1] = num\n            heap_sift_down(heap, 1)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                if heap[left] > heap[right] then\n                    if heap[i] < heap[left] then\n                        heap[i], heap[left] = heap[left], heap[i]\n                        i = left\n                    else\n                        break\n                    end\n                else\n                    if heap[i] < heap[right] then\n                        heap[i], heap[right] = heap[right], heap[i]\n                        i = right\n                    else\n                        break\n                    end\n                end\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        else\n            if num > heap[1] then\n                heap_pop(heap)\n                heap_insert(heap, num)\n            end\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[max] > heap[i] then\n                heap[max], heap[i] = heap[i], heap[max]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        else\n            if num > heap[1] then\n                heap_pop(heap)\n                heap_push(heap, num)\n            end\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        table.insert(ret, 1, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1, #heap)\n    end\n  end\n  return heap\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    local i = #heap + 1\n    heap[i] = num\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local i = 1\n    local num = heap[i]\n    heap[i] = heap[#heap]\n    heap[#heap] = nil\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[left] > heap[i] then\n          heap[left], heap[i] = heap[i], heap[left]\n        end\n        break\n      else\n        local max = heap[left]\n        local max_i = left\n        if heap[right] > max then\n          max = heap[right]\n          max_i = right\n        end\n        if max > heap[i] then\n          heap[max_i], heap[i] = heap[i], heap[max_i]\n          i = max_i\n        else\n          break\n        end\n      end\n    end\n    return num\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heapify(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heapify(heap, n, 1)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, v in ipairs(nums) do\n        push(v)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, pop())\n    end\n    return ret\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\theap_push(heap, num)\n\t\tif #heap > n then\n\t\t\theap_pop(heap)\n\t\tend\n\tend\n\tlocal result = {}\n\twhile #heap > 0 do\n\t\tresult[#result + 1] = heap_pop(heap)\n\tend\n\treturn result\nend",
    "  local hq = HeapQueue.new(nums)\n  local result = {}\n  for i = 1, n do\n    local max = hq:pop()\n    if max == nil then break end\n    result[i] = max\n  end\n  return result\nend",
    "    local heap = {}\n    for i, v in ipairs(nums) do\n        heapq.heappush(heap, -v)\n    end\n    local res = {}\n    for i = 1, n do\n        res[i] = -heapq.heappop(heap)\n    end\n    return res\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_build_max(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heap_max_heapify(heap, 1, n)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heapify(heap)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heapify(heap, 1)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    for i, num in ipairs(nums) do\n        if i <= n then\n            heap[i] = num\n        else\n            heap_push(heap, num)\n        end\n    end\n    heap_make(heap)\n    for i = n + 1, #nums do\n        heap_push(heap, nums[i])\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                if heap[left] > heap[right] then\n                    if heap[i] < heap[left] then\n                        heap[i], heap[left] = heap[left], heap[i]\n                        i = left\n                    else\n                        break\n                    end\n                else\n                    if heap[i] < heap[right] then\n                        heap[i], heap[right] = heap[right], heap[i]\n                        i = right\n                    else\n                        break\n                    end\n                end\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        else\n            if num > heap[1] then\n                heap_pop(heap)\n                heap_insert(heap, num)\n            end\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = Heap:new(nums)\n  heap:heapify()\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "\tlocal heap = {}\n\tlocal function heap_push(heap, num)\n\t\ttable.insert(heap, num)\n\t\tlocal i = #heap\n\t\twhile i > 1 do\n\t\t\tlocal j = math.floor(i / 2)\n\t\t\tif heap[i] > heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function heap_pop(heap)\n\t\tlocal ret = heap[1]\n\t\theap[1] = heap[#heap]\n\t\ttable.remove(heap)\n\t\tlocal i = 1\n\t\twhile i < #heap do\n\t\t\tlocal j = i * 2\n\t\t\tif j < #heap and heap[j + 1] > heap[j] then\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\t\tif heap[i] < heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn ret\n\tend\n\tfor _, num in ipairs(nums) do\n\t\theap_push(heap, num)\n\tend\n\tlocal ret = {}\n\tfor i = 1, n do\n\t\ttable.insert(ret, heap_pop(heap))\n\tend\n\treturn ret\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "  local heap = Heap()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "    local heap = {}\n    local heap_size = 0\n    local function heap_push(num)\n        heap_size = heap_size + 1\n        heap[heap_size] = num\n        local i = heap_size\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local ret = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size = heap_size - 1\n        local i = 1\n        while i * 2 <= heap_size do\n            local child = i * 2\n            if child + 1 <= heap_size and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        if heap_size < n then\n            heap_push(num)\n        elseif num > heap[1] then\n            heap_pop()\n            heap_push(num)\n        end\n    end\n    local ret = {}\n    while heap_size > 0 do\n        table.insert(ret, 1, heap_pop())\n    end\n    return ret\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      local largest = i\n      if left <= #heap and heap[left] > heap[largest] then\n        largest = left\n      end\n      if right <= #heap and heap[right] > heap[largest] then\n        largest = right\n      end\n      if largest ~= i then\n        heap[i], heap[largest] = heap[largest], heap[i]\n        i = largest\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for i = 1, n do\n    heap_insert(heap, nums[i])\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap_pop(heap)\n      heap_insert(heap, nums[i])\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local num = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = i\n            if left <= #heap and heap[left] > heap[max] then\n                max = left\n            end\n            if right <= #heap and heap[right] > heap[max] then\n                max = right\n            end\n            if max ~= i then\n                heap[i], heap[max] = heap[max], heap[i]\n                i = max\n            else\n                break\n            end\n        end\n        return num\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, 1, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = HeapQueue.new()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for _ = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heapq.heappop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for i, v in ipairs(nums) do\n        heapq.heappush(heap, -v)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, -heapq.heappop(heap))\n    end\n    return result\nend",
    "  local heap = Heap.new(nums, function(a, b) return a > b end)\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "    local heap = Heap:new(nums)\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "    local hq = HeapQueue.new()\n    for _, num in ipairs(nums) do\n        hq:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, hq:pop())\n    end\n    return result\nend",
    "  local heap = Heap()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = Heap()\n    for _, num in ipairs(nums) do\n        heap:insert(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    heap[#heap + 1] = num\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local result = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[i] < heap[left] then\n          heap[i], heap[left] = heap[left], heap[i]\n        end\n        break\n      else\n        if heap[left] > heap[right] then\n          if heap[i] < heap[left] then\n            heap[i], heap[left] = heap[left], heap[i]\n            i = left\n          else\n            break\n          end\n        else\n          if heap[i] < heap[right] then\n            heap[i], heap[right] = heap[right], heap[i]\n            i = right\n          else\n            break\n          end\n        end\n      end\n    end\n    return result\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n        if #heap > n then\n            heapq.heappop(heap)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        else\n            if num > heap[1] then\n                heap_replace(heap, num)\n            end\n        end\n    end\n    local result = {}\n    for _ = 1, n do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i] > heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    elseif num > heap[1] then\n      heap_pop(heap)\n      heap_insert(heap, num)\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    table.insert(ret, 1, heap_pop(heap))\n  end\n  return ret\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] > heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local min = left\n            if right <= #heap and heap[right] < heap[left] then\n                min = right\n            end\n            if heap[i] > heap[min] then\n                heap[i], heap[min] = heap[min], heap[i]\n                i = min\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    local function push(x)\n        local i = #heap + 1\n        heap[i] = x\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[j], heap[i] = heap[i], heap[j]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local x = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return x\n    end\n    for i = 1, #nums do\n        if i <= n then\n            push(nums[i])\n        else\n            if nums[i] > heap[1] then\n                pop()\n                push(nums[i])\n            end\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = pop()\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local x = heap[1]\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[j] > heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    heap[i] = heap[#heap]\n    heap[#heap] = nil\n    return x\n  end\n  for _, x in ipairs(nums) do\n    heap_push(x)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop()\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                if heap[i] < heap[left] or heap[i] < heap[right] then\n                    if heap[left] > heap[right] then\n                        heap[i], heap[left] = heap[left], heap[i]\n                        i = left\n                    else\n                        heap[i], heap[right] = heap[right], heap[i]\n                        i = right\n                    end\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end\n    for i = 1, n do\n        heap_insert(heap, nums[i])\n    end\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap_pop(heap)\n            heap_insert(heap, nums[i])\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    elseif num > heap[1] then\n      heap_replace(heap, num)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    table.insert(heap, num)\n    heap_sift_up(heap, #heap)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n        if #heap > n then\n            heapq.heappop(heap)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] > heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i] > heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                if heap[left] < heap[right] and heap[i] > heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                    i = left\n                elseif heap[left] >= heap[right] and heap[i] > heap[right] then\n                    heap[i], heap[right] = heap[right], heap[i]\n                    i = right\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    return heap_sort(heap)\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function sift_up(i)\n        local parent = math.floor(i/2)\n        if parent > 0 and heap[i] > heap[parent] then\n            heap[i], heap[parent] = heap[parent], heap[i]\n            sift_up(parent)\n        end\n    end\n    local function sift_down(i)\n        local child = i*2\n        if child <= #heap then\n            if child < #heap and heap[child] < heap[child+1] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                sift_down(child)\n            end\n        end\n    end\n    for i, v in ipairs(nums) do\n        heap[i] = v\n        sift_up(i)\n    end\n    for i = #nums+1, n do\n        heap[i] = -math.huge\n        sift_up(i)\n    end\n    for i = n+1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            sift_down(1)\n        end\n    end\n    for i = 1, n-1 do\n        heap[1], heap[#heap] = heap[#heap], heap[1]\n        table.remove(heap)\n        sift_down(1)\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = Heap.new(nums, function(a, b) return a > b end)\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n        if #heap > n then\n            heapq.heappop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heapq.heappop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[child] > heap[i] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\theap_push(heap, num)\n\t\telseif heap[1] < num then\n\t\t\theap_replace(heap, num)\n\t\tend\n\tend\n\treturn heap_sort(heap)\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[j], heap[i] = heap[i], heap[j]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i, v in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, v)\n        elseif v > heap[1] then\n            heap_pop(heap)\n            heap_push(heap, v)\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    for i = n, 1, -1 do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    local function sift_up(heap, i)\n        local parent = math.floor(i / 2)\n        if parent > 0 and heap[parent] < heap[i] then\n            heap[parent], heap[i] = heap[i], heap[parent]\n            sift_up(heap, parent)\n        end\n    end\n    local function sift_down(heap, i)\n        local left = i * 2\n        local right = i * 2 + 1\n        local largest = i\n        if left <= #heap and heap[left] > heap[largest] then\n            largest = left\n        end\n        if right <= #heap and heap[right] > heap[largest] then\n            largest = right\n        end\n        if largest ~= i then\n            heap[largest], heap[i] = heap[i], heap[largest]\n            sift_down(heap, largest)\n        end\n    end\n    local function insert(heap, num)\n        heap[#heap + 1] = num\n        sift_up(heap, #heap)\n    end\n    local function extract_max(heap)\n        local max = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        sift_down(heap, 1)\n        return max\n    end\n    for _, num in ipairs(nums) do\n        insert(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = extract_max(heap)\n    end\n    return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(x)\n        table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local x = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return x\n    end\n    for _, x in ipairs(nums) do\n        push(x)\n    end\n    local result = {}\n    for _ = 1, n do\n        table.insert(result, pop())\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local child = i * 2\n      if child + 1 <= #heap and heap[child + 1] > heap[child] then\n        child = child + 1\n      end\n      if heap[i] < heap[child] then\n        heap[i], heap[child] = heap[child], heap[i]\n        i = child\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for _ = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = Heap.new()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local parent = math.floor(i / 2)\n    if parent > 0 and heap[parent] < heap[i] then\n      heap[parent], heap[i] = heap[i], heap[parent]\n      sift_up(parent)\n    end\n  end\n  local function sift_down(i)\n    local left = i * 2\n    local right = i * 2 + 1\n    local largest = i\n    if left <= #heap and heap[left] > heap[largest] then\n      largest = left\n    end\n    if right <= #heap and heap[right] > heap[largest] then\n      largest = right\n    end\n    if largest ~= i then\n      heap[i], heap[largest] = heap[largest], heap[i]\n      sift_down(largest)\n    end\n  end\n  local function insert(num)\n    heap[#heap + 1] = num\n    sift_up(#heap)\n  end\n  local function pop()\n    local max = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    sift_down(1)\n    return max\n  end\n  for _, num in ipairs(nums) do\n    insert(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = pop()\n  end\n  return result\nend",
    "    local heap = Heap:new()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_push(heap, item)\n        table.insert(heap, item)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local item = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return item\n    end\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_pop(heap)\n            heap_push(heap, num)\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend"
  ]
}