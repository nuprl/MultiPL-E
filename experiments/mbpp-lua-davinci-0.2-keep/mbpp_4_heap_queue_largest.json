{
  "name": "mbpp_4_heap_queue_largest",
  "language": "lua",
  "prompt": "-- Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nlocal function heap_queue_largest(nums, n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = heap_queue_largest\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), {85, 75, 65})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), {85, 75})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), {85, 75, 65, 58, 35})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  table.sort(heap, function(a, b) return a > b end)\n  return heap\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p] >= heap[i] then\n        break\n      end\n      heap[i], heap[p] = heap[p], heap[i]\n      i = p\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      if l + 1 <= #heap and heap[l + 1] > heap[l] then\n        l = l + 1\n      end\n      if heap[i] >= heap[l] then\n        break\n      end\n      heap[i], heap[l] = heap[l], heap[i]\n      i = l\n    end\n    return x\n  end\n  for i = 1, n do\n    push(nums[i])\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      pop()\n      push(nums[i])\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, 1, pop())\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "  local heap = HeapQueue.new(nums)\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local p = math.floor(i / 2)\n    while p > 0 and heap[p] < heap[i] do\n      heap[p], heap[i] = heap[i], heap[p]\n      i = p\n      p = math.floor(i / 2)\n    end\n  end\n  local function sift_down(i)\n    local c = i * 2\n    while c <= #heap do\n      if c + 1 <= #heap and heap[c + 1] > heap[c] then\n        c = c + 1\n      end\n      if heap[i] >= heap[c] then\n        break\n      end\n      heap[i], heap[c] = heap[c], heap[i]\n      i = c\n      c = i * 2\n    end\n  end\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap[#heap + 1] = num\n      sift_up(#heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      sift_down(1)\n    end\n  end\n  local res = {}\n  while #heap > 0 do\n    res[#res + 1] = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    sift_down(1)\n  end\n  return res\nend",
    "    local heap = {}\n    local function sift_up(heap, index)\n        local parent = math.floor(index / 2)\n        if parent > 0 and heap[index] > heap[parent] then\n            heap[index], heap[parent] = heap[parent], heap[index]\n            sift_up(heap, parent)\n        end\n    end\n    local function sift_down(heap, index)\n        local left = index * 2\n        local right = left + 1\n        local largest = index\n        if left <= #heap and heap[left] > heap[largest] then\n            largest = left\n        end\n        if right <= #heap and heap[right] > heap[largest] then\n            largest = right\n        end\n        if largest ~= index then\n            heap[index], heap[largest] = heap[largest], heap[index]\n            sift_down(heap, largest)\n        end\n    end\n    local function insert(heap, num)\n        heap[#heap + 1] = num\n        sift_up(heap, #heap)\n    end\n    local function remove(heap)\n        heap[1], heap[#heap] = heap[#heap], heap[1]\n        local num = table.remove(heap)\n        sift_down(heap, 1)\n        return num\n    end\n    for _, num in ipairs(nums) do\n        insert(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = remove(heap)\n    end\n    return result\nend",
    "    local heap = Heap()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(x)\n    table.insert(heap, x)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for _, x in ipairs(nums) do\n    push(x)\n  end\n  local result = {}\n  for _ = 1, n do\n    table.insert(result, pop())\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  return heap_to_list(heap)\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  return heap\nend",
    "  local heap = Heap.new(nums)\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        local i = #heap + 1\n        heap[i] = num\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = left + 1\n            if left > #heap then\n                break\n            end\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[i] < heap[max] then\n                heap[i], heap[max] = heap[max], heap[i]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heapq.heappush(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heapq.heappop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local val = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return val\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local res = {}\n    for i = 1, n do\n        table.insert(res, heap_pop(heap))\n    end\n    return res\nend"
  ]
}