{
  "name": "mbpp_308_large_product",
  "language": "lua",
  "prompt": "-- Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nlocal function large_product(nums1, nums2, N)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = large_product\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}, {3, 6, 8, 9, 10, 6}, 3), {60, 54, 50})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}, {3, 6, 8, 9, 10, 6}, 4), {60, 54, 50, 48})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}, {3, 6, 8, 9, 10, 6}, 5), {60, 54, 50, 48, 45})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local function compare(a, b)\n    return a[1] * a[2] > b[1] * b[2]\n  end\n  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local merged = {}\n    while i <= #nums1 and j <= #nums2 do\n      if compare(nums1[i], nums2[j]) then\n        merged[#merged + 1] = nums1[i]\n        i = i + 1\n      else\n        merged[#merged + 1] = nums2[j]\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      merged[#merged + 1] = nums1[i]\n      i = i + 1\n    end\n    while j <= #nums2 do\n      merged[#merged + 1] = nums2[j]\n      j = j + 1\n    end\n    return merged\n  end\n  local function merge_sort(nums)\n    if #nums <= 1 then\n      return nums\n    end\n    local mid = math.floor(#nums / 2)\n    local left = merge_sort(nums:sub(1, mid))\n    local right = merge_sort(nums:sub(mid + 1))\n    return merge(left, right)\n  end\n  local nums1 = merge_sort(nums1)\n  local nums2 = merge_sort(nums2)\n  local merged = merge(nums1, nums2)\n  local products = {}\n  for i = 1, N do\n    products[#products + 1] = merged[i][1] * merged[i][2]\n  end\n  return products\nend",
    "  local products = {}\n  for _, n1 in ipairs(nums1) do\n    for _, n2 in ipairs(nums2) do\n      table.insert(products, n1 * n2)\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "    local products = {}\n    for _, n1 in ipairs(nums1) do\n        for _, n2 in ipairs(nums2) do\n            table.insert(products, n1 * n2)\n        end\n    end\n    table.sort(products, function(a, b) return a > b end)\n    return products[N]\nend",
    "  local products = {}\n  for _, n1 in ipairs(nums1) do\n    for _, n2 in ipairs(nums2) do\n      table.insert(products, n1 * n2)\n    end\n  end\n  table.sort(products)\n  local result = {}\n  for i = #products, #products - N + 1, -1 do\n    table.insert(result, products[i])\n  end\n  return result\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(products, nums1[i] * nums2[j])\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  local result = {}\n  for i = 1, N do\n    table.insert(result, products[i])\n  end\n  return result\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products)\n  return products[#products - N + 1]\nend",
    "  local products = {}\n  for i, n1 in ipairs(nums1) do\n    for j, n2 in ipairs(nums2) do\n      products[#products + 1] = n1 * n2\n    end\n  end\n  table.sort(products)\n  return products[#products - N + 1]\nend",
    "  local products = {}\n  for _, n1 in ipairs(nums1) do\n    for _, n2 in ipairs(nums2) do\n      table.insert(products, n1 * n2)\n    end\n  end\n  table.sort(products)\n  return products[#products - N + 1]\nend",
    "  local function sort_by_product(a, b)\n    return a[1] * a[2] > b[1] * b[2]\n  end",
    "    local products = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(products, nums1[i] * nums2[j])\n        end\n    end\n    table.sort(products, function(a, b) return a > b end)\n    return products[N]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(products, nums1[i] * nums2[j])\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  local result = {}\n  for i = 1, N do\n    table.insert(result, products[i])\n  end\n  return result\nend",
    "\tlocal function compare(a, b)\n\t\treturn a > b\n\tend\n\ttable.sort(nums1, compare)\n\ttable.sort(nums2, compare)\n\tlocal products = {}\n\tfor i = 1, #nums1 do\n\t\tfor j = 1, #nums2 do\n\t\t\ttable.insert(products, nums1[i] * nums2[j])\n\t\tend\n\tend\n\ttable.sort(products, compare)\n\tlocal result = {}\n\tfor i = 1, N do\n\t\ttable.insert(result, products[i])\n\tend\n\treturn result\nend",
    "  local products = {}\n  for _, n1 in ipairs(nums1) do\n    for _, n2 in ipairs(nums2) do\n      table.insert(products, n1 * n2)\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "    local function cmp(a, b)\n        return a[1] * a[2] > b[1] * b[2]\n    end\n    local t = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            t[#t + 1] = {nums1[i], nums2[j]}\n        end\n    end\n    table.sort(t, cmp)\n    local res = {}\n    for i = 1, N do\n        res[#res + 1] = t[i][1] * t[i][2]\n    end\n    return res\nend",
    "    local function compare(a, b)\n        return a[1] * a[2] > b[1] * b[2]\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            local pair = {nums1[i], nums2[j]}\n            if #heap < N then\n                table.insert(heap, pair)\n                table.sort(heap, compare)\n            else\n                if pair[1] * pair[2] > heap[1][1] * heap[1][2] then\n                    heap[1] = pair\n                    table.sort(heap, compare)\n                end\n            end\n        end\n    end\n    return heap\nend",
    "  local products = {}\n  for _, n1 in ipairs(nums1) do\n    for _, n2 in ipairs(nums2) do\n      table.insert(products, n1 * n2)\n    end\n  end\n  table.sort(products)\n  return products[#products - N + 1]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(products, nums1[i] * nums2[j])\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  local result = {}\n  for i = 1, N do\n    table.insert(result, products[i])\n  end\n  return result\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products)\n  local result = {}\n  for i = #products, #products - N + 1, -1 do\n    result[#result + 1] = products[i]\n  end\n  return result\nend"
  ]
}