{
  "name": "mbpp_735_toggle_middle_bits",
  "language": "lua",
  "prompt": "-- Write a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\nlocal function toggle_middle_bits(n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py",
  "prompt_terminology": "verbatim",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = toggle_middle_bits\n    lu.assertEquals(candidate(9), 15)\n    lu.assertEquals(candidate(10), 12)\n    lu.assertEquals(candidate(11), 13)\n    lu.assertEquals(candidate(65), 127)\n    lu.assertEquals(candidate(77), 115)\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local mask = 0xFFFFFFFF\n  local first_bit = 0x80000000\n  local last_bit = 0x00000001\n  local first_mask = mask - first_bit\n  local last_mask = mask - last_bit\n  local middle_mask = first_mask - last_mask\n  return n ~ middle_mask\nend",
    "    local mask = 2^(bit.rshift(bit.rshift(n, 1), 1)) - 1\n    return bit.bxor(n, mask)\nend",
    "    local mask = 2^(math.floor(math.log(n, 2)) - 1) - 1\n    return n ^ mask\nend",
    "    local mask = 0xffffffff\n    local first_bit = n & 0x80000000\n    local last_bit = n & 0x1\n    mask = mask & (first_bit | last_bit)\n    return n ^ mask\nend",
    "    local mask = 0x7ffffffe\n    return bit.bxor(n, mask)\nend",
    "  local mask = 0xffffffff\n  local first_bit = n & 0x80000000\n  local last_bit = n & 0x00000001\n  local middle_bits = n & 0x7ffffffe\n  local toggled_middle_bits = middle_bits ^ mask\n  return first_bit | toggled_middle_bits | last_bit\nend",
    "    local mask = 0xffffffff\n    mask = bit32.bnot(mask)\n    mask = bit32.lshift(mask, 1)\n    mask = bit32.bor(mask, 1)\n    return bit32.bxor(n, mask)\nend",
    "    local mask = 0xFFFFFFFF\n    local first_bit = bit.lshift(1, 31)\n    local last_bit = 1\n    local first_mask = bit.bxor(first_bit, mask)\n    local last_mask = bit.bxor(last_bit, mask)\n    local mask = bit.bor(first_mask, last_mask)\n    local result = bit.bxor(n, mask)\n    return result\nend",
    "    local mask = 0x7FFFFFFF\n    local result = bit.bxor(n, mask)\n    return result\nend",
    "\tlocal mask = (1 << (n.size - 2)) - 1\n\treturn bit.bxor(n, mask)\nend",
    "  local mask = 0x7ffffffe\n  return bit32.bxor(n, mask)\nend",
    "    return bit32.bxor(n, bit32.lshift(2^(bit32.extract(n, 2, 30)-1), 1))\nend",
    "    local mask = 0xffffffffffffffff\n    local first_bit = 0x8000000000000000\n    local last_bit = 0x0000000000000001\n    local mask = bit.bxor(mask, first_bit)\n    mask = bit.bxor(mask, last_bit)\n    return bit.bxor(n, mask)\nend",
    "    local mask = 0xffffffff\n    local first_bit = 0x80000000\n    local last_bit = 0x00000001\n    mask = mask & ~first_bit\n    mask = mask & ~last_bit\n    return bit.bxor(n, mask)\nend",
    "\tlocal mask = 0xFFFFFFFF\n\tlocal first_bit = 0x80000000\n\tlocal last_bit = 0x00000001\n\tlocal first_last_mask = bit.bor(first_bit, last_bit)\n\tlocal middle_mask = bit.bxor(mask, first_last_mask)\n\treturn bit.bxor(n, middle_mask)\nend",
    "    local mask = 0x7FFFFFFE\n    return bit.bxor(n, mask)\nend",
    "    local first_bit = n & 1\n    local last_bit = n & (1 << 31)\n    local mask = 0x55555555\n    return (n ^ mask) | (first_bit << 31) | last_bit\nend",
    "    local mask = 0xffffffff\n    local first_bit = 0x80000000\n    local last_bit = 0x00000001\n    local first_mask = mask - first_bit\n    local last_mask = mask - last_bit\n    local middle_mask = first_mask - last_mask\n    return n ~ middle_mask\nend",
    "    local mask = 0xFFFFFFFF\n    local first_bit = 0x80000000\n    local last_bit = 0x00000001\n    local mask = mask - first_bit - last_bit\n    return bit.bxor(n, mask)\nend",
    "    local mask = 2^(n.size - 2) - 1\n    return n:xor(mask)\nend"
  ]
}