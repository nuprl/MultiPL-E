{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "lua",
  "prompt": "-- Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nlocal function k_smallest_pairs(nums1, nums2, k)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = k_smallest_pairs\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 2), {{1, 2}, {1, 4}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 1), {{1, 2}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 7), {{1, 2}, {1, 4}, {3, 2}, {1, 6}, {3, 4}, {3, 6}, {7, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "    local function cmp(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap + 1] = {i, j, sum}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while true do\n                local l = i * 2\n                local r = l + 1\n                if l <= #heap then\n                    if r <= #heap and heap[r][3] < heap[l][3] then\n                        l = r\n                    end\n                    if heap[l][3] < heap[i][3] then\n                        heap[l], heap[i] = heap[i], heap[l]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        res[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return res\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1][1] + heap[child + 1][2] < heap[child][1] + heap[child][2] then\n                child = child + 1\n            end\n            if heap[i][1] + heap[i][2] > heap[child][1] + heap[child][2] then\n                heap[child], heap[i] = heap[i], heap[child]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i], nums2[j]})\n        end\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  local i = 1\n  local j = 1\n  while i <= len1 and j <= len2 and #res < k do\n    local sum = nums1[i] + nums2[j]\n    if #res == 0 then\n      res[#res + 1] = {nums1[i], nums2[j]}\n    else\n      local last_sum = res[#res][1] + res[#res][2]\n      if sum < last_sum then\n        table.insert(res, 1, {nums1[i], nums2[j]})\n      else\n        res[#res + 1] = {nums1[i], nums2[j]}\n      end\n    end\n    if i == len1 then\n      j = j + 1\n    elseif j == len2 then\n      i = i + 1\n    else\n      if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] then\n        i = i + 1\n      else\n        j = j + 1\n      end\n    end\n  end\n  return res\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        else\n            if sum < heap[1][3] then\n                heap[1] = {i, j, sum}\n                local i = 1\n                while i * 2 <= #heap do\n                    local l = i * 2\n                    local r = i * 2 + 1\n                    local min_i = l\n                    if r <= #heap and heap[r][3] < heap[l][3] then\n                        min_i = r\n                    end\n                    if heap[i][3] > heap[min_i][3] then\n                        heap[i], heap[min_i] = heap[min_i], heap[i]\n                        i = min_i\n                    else\n                        break\n                    end\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local res = {}\n    while #heap > 0 do\n        local t = table.remove(heap, 1)\n        table.insert(res, {nums1[t[1]], nums2[t[2]]})\n        if t[2] < len2 then\n            push(t[1], t[2] + 1)\n        end\n    end\n    return res\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n    end\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][3] > heap[i][3] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local res = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      local r = i * 2 + 1\n      if r <= #heap and heap[r][3] < heap[l][3] then\n        l = r\n      end\n      if heap[i][3] > heap[l][3] then\n        heap[i], heap[l] = heap[l], heap[i]\n        i = l\n      else\n        break\n      end\n    end\n    return res\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local res = {}\n  while #heap > 0 do\n    local p = pop()\n    table.insert(res, {nums1[p[1]], nums2[p[2]]})\n  end\n  return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap_push(heap, {i, j, nums1[i] + nums2[j]})\n        end\n    end\n    push(1, 1)\n    local result = {}\n    while #result < k and #heap > 0 do\n        local pair = heap_pop(heap)\n        push(pair[1] + 1, pair[2])\n        push(pair[1], pair[2] + 1)\n        table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n    end\n    return result\nend",
    "  local function merge(a, b)\n    local c = {}\n    local i, j = 1, 1\n    while i <= #a and j <= #b do\n      if a[i][1] + a[i][2] < b[j][1] + b[j][2] then\n        c[#c + 1] = a[i]\n        i = i + 1\n      else\n        c[#c + 1] = b[j]\n        j = j + 1\n      end\n    end\n    while i <= #a do\n      c[#c + 1] = a[i]\n      i = i + 1\n    end\n    while j <= #b do\n      c[#c + 1] = b[j]\n      j = j + 1\n    end\n    return c\n  end",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap+1] = {i, j, sum}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i/2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while true do\n                local l = i * 2\n                local r = l + 1\n                if l > #heap then\n                    break\n                elseif r > #heap then\n                    if heap[l][3] < heap[i][3] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                    end\n                    break\n                elseif heap[l][3] < heap[r][3] then\n                    if heap[l][3] < heap[i][3] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    if heap[r][3] < heap[i][3] then\n                        heap[i], heap[r] = heap[r], heap[i]\n                        i = r\n                    else\n                        break\n                    end\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local ret = {}\n    for i = 1, #heap do\n        ret[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return ret\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    local heap_size = #heap\n    if heap_size == k then\n      if sum < heap[1][1] then\n        heap[1] = {sum, i, j}\n        heap_down(heap, 1, heap_size)\n      end\n    else\n      heap[heap_size + 1] = {sum, i, j}\n      heap_up(heap, heap_size + 1)\n    end\n  end\n  local function pop()\n    local heap_size = #heap\n    if heap_size == 0 then\n      return nil\n    end\n    local ret = heap[1]\n    heap[1] = heap[heap_size]\n    heap[heap_size] = nil\n    heap_down(heap, 1, heap_size - 1)\n    return ret\n  end\n  local function pop_all()\n    local ret = {}\n    while true do\n      local pair = pop()\n      if not pair then\n        break\n      end\n      ret[#ret + 1] = pair\n    end\n    return ret\n  end\n  local function push_all()\n    for i = 1, #nums1 do\n      for j = 1, #nums2 do\n        push(i, j)\n      end\n    end\n  end\n  push_all()\n  return pop_all()\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local function merge(a, b)\n        local c = {}\n        local i, j = 1, 1\n        while i <= #a and j <= #b do\n            if compare(a[i], b[j]) then\n                table.insert(c, a[i])\n                i = i + 1\n            else\n                table.insert(c, b[j])\n                j = j + 1\n            end\n        end\n        while i <= #a do\n            table.insert(c, a[i])\n            i = i + 1\n        end\n        while j <= #b do\n            table.insert(c, b[j])\n            j = j + 1\n        end\n        return c\n    end\n    local function merge_sort(a)\n        if #a <= 1 then\n            return a\n        end\n        local mid = #a / 2\n        local left = merge_sort(a:sub(1, mid))\n        local right = merge_sort(a:sub(mid + 1))\n        return merge(left, right)\n    end\n    local function get_pairs(nums1, nums2)\n        local pairs = {}\n        for i = 1, #nums1 do\n            for j = 1, #nums2 do\n                table.insert(pairs, {nums1[i], nums2[j]})\n            end\n        end\n        return pairs\n    end\n    local pairs = get_pairs(nums1, nums2)\n    pairs = merge_sort(pairs)\n    local result = {}\n    for i = 1, k do\n        if pairs[i] then\n            table.insert(result, pairs[i])\n        end\n    end\n    return result\nend",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local last = table.remove(heap)\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = i * 2 + 1\n            if l > #heap then break end\n            if r <= #heap and heap[r][1] < heap[l][1] then\n                l = r\n            end\n            if last[1] <= heap[l][1] then break end\n            heap[i] = heap[l]\n            i = l\n        end\n        heap[i] = last\n        return ret\n    end\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] <= heap[i][1] then break end\n            heap[i], heap[p] = heap[p], heap[i]\n            i = p\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        heap_push(heap, {nums1[i] + nums2[1], i, 1})\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then break end\n        local val = heap_pop(heap)\n        table.insert(ret, {nums1[val[2]], nums2[val[3]]})\n        if val[3] < #nums2 then\n            heap_push(heap, {nums1[val[2]] + nums2[val[3] + 1], val[2], val[3] + 1})\n        end\n    end\n    return ret\nend",
    "  if #nums1 == 0 or #nums2 == 0 then return {} end\n  local heap = {}\n  local result = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {sum, i, j}\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][1] > heap[i][1] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][1] then\n      heap[1] = {sum, i, j}\n      local i = 1\n      while i * 2 <= #heap do\n        local left = i * 2\n        local right = i * 2 + 1\n        local min = left\n        if right <= #heap and heap[right][1] < heap[left][1] then\n          min = right\n        end\n        if heap[i][1] > heap[min][1] then\n          heap[i], heap[min] = heap[min], heap[i]\n          i = min\n        else\n          break\n        end\n      end\n    end\n  end\n  push(1, 1)\n  while #result < k and #heap > 0 do\n    local item = table.remove(heap, 1)\n    result[#result + 1] = {nums1[item[2]], nums2[item[3]]}\n    if item[3] < #nums2 then\n      push(item[2], item[3] + 1)\n    end\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        if #heap == 0 then\n            return nil\n        end\n        local t = heap[1]\n        local n = #heap\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = l + 1\n            if l > n then\n                break\n            end\n            if r <= n and heap[l][1] > heap[r][1] then\n                l = r\n            end\n            if heap[i][1] > heap[l][1] then\n                heap[i], heap[l] = heap[l], heap[i]\n                i = l\n            else\n                break\n            end\n        end\n        return t[2], t[3]\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    local result = {}\n    for i = 1, k do\n        local x, y = pop()\n        if x == nil then\n            break\n        end\n        result[#result + 1] = {nums1[x], nums2[y]}\n        push(x, y + 1)\n    end\n    return result\nend",
    "  local function merge(a, b)\n    local res = {}\n    local i, j = 1, 1\n    while i <= #a and j <= #b do\n      if a[i] < b[j] then\n        table.insert(res, a[i])\n        i = i + 1\n      else\n        table.insert(res, b[j])\n        j = j + 1\n      end\n    end\n    while i <= #a do\n      table.insert(res, a[i])\n      i = i + 1\n    end\n    while j <= #b do\n      table.insert(res, b[j])\n      j = j + 1\n    end\n    return res\n  end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k or sum < heap[1][1] then\n      heapq.heappush(heap, {sum, i, j})\n      if #heap > k then\n        heapq.heappop(heap)\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  local res = {}\n  while #heap > 0 do\n    local _, i, j = table.unpack(heapq.heappop(heap))\n    table.insert(res, {nums1[i], nums2[j]})\n    if j < #nums2 then\n      push(i, j + 1)\n    end\n  end\n  return res\nend",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] < nums2[j] then\n        res[#res + 1] = {nums1[i], nums2[j]}\n        i = i + 1\n      else\n        res[#res + 1] = {nums1[i], nums2[j]}\n        j = j + 1\n      end\n    end\n    while i <= m do\n      res[#res + 1] = {nums1[i], nums2[j]}\n      i = i + 1\n    end\n    while j <= n do\n      res[#res + 1] = {nums1[i], nums2[j]}\n      j = j + 1\n    end\n    return res\n  end\n  local res = merge(nums1, nums2)\n  local function partition(arr, l, r)\n    local pivot = arr[r][1] + arr[r][2]\n    local i = l\n    for j = l, r - 1 do\n      if arr[j][1] + arr[j][2] < pivot then\n        arr[i], arr[j] = arr[j], arr[i]\n        i = i + 1\n      end\n    end\n    arr[i], arr[r] = arr[r], arr[i]\n    return i\n  end\n  local function quick_select(arr, l, r, k)\n    if l == r then return end\n    local p = partition(arr, l, r)\n    if p == k then return end\n    if p > k then\n      quick_select(arr, l, p - 1, k)\n    else\n      quick_select(arr, p + 1, r, k)\n    end\n  end\n  quick_select(res, 1, #res, k)\n  return res\nend",
    "    local function merge_sort(nums1, nums2)\n        local function merge(nums1, nums2)\n            local i, j, k = 1, 1, 1\n            local len1, len2 = #nums1, #nums2\n            local result = {}\n            while i <= len1 and j <= len2 do\n                if nums1[i] < nums2[j] then\n                    result[k] = nums1[i]\n                    i = i + 1\n                else\n                    result[k] = nums2[j]\n                    j = j + 1\n                end\n                k = k + 1\n            end\n            while i <= len1 do\n                result[k] = nums1[i]\n                i = i + 1\n                k = k + 1\n            end\n            while j <= len2 do\n                result[k] = nums2[j]\n                j = j + 1\n                k = k + 1\n            end\n            return result\n        end\n        local function merge_sort(nums)\n            local len = #nums\n            if len <= 1 then\n                return nums\n            end\n            local mid = math.floor(len / 2)\n            local left = merge_sort(nums, 1, mid)\n            local right = merge_sort(nums, mid + 1, len)\n            return merge(left, right)\n        end\n        return merge_sort(merge(nums1, nums2))\n    end\n    local function find_k_smallest(nums, k)\n        local function partition(nums, left, right)\n            local pivot = nums[left]\n            local i, j = left, right\n            while i < j do\n                while i < j and nums[j] >= pivot do\n                    j = j - 1\n                end\n                nums[i] = nums[j]\n                while i < j and nums[i] <= pivot do\n                    i = i + 1\n                end\n                nums[j] = nums[i]\n            end\n            nums[i] = pivot\n            return i\n        end\n        local function quick_sort(nums"
  ]
}