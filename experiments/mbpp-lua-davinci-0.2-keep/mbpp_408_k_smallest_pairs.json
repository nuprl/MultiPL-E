{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "lua",
  "prompt": "-- Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nlocal function k_smallest_pairs(nums1, nums2, k)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = k_smallest_pairs\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 2), {{1, 2}, {1, 4}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 1), {{1, 2}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 7), {{1, 2}, {1, 4}, {3, 2}, {1, 6}, {3, 4}, {3, 6}, {7, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "    local function cmp(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap + 1] = {i, j, sum}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while true do\n                local l = i * 2\n                local r = l + 1\n                if l <= #heap then\n                    if r <= #heap and heap[r][3] < heap[l][3] then\n                        l = r\n                    end\n                    if heap[l][3] < heap[i][3] then\n                        heap[l], heap[i] = heap[i], heap[l]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        res[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return res\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1][1] + heap[child + 1][2] < heap[child][1] + heap[child][2] then\n                child = child + 1\n            end\n            if heap[i][1] + heap[i][2] > heap[child][1] + heap[child][2] then\n                heap[child], heap[i] = heap[i], heap[child]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i], nums2[j]})\n        end\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  local i = 1\n  local j = 1\n  while i <= len1 and j <= len2 and #res < k do\n    local sum = nums1[i] + nums2[j]\n    if #res == 0 then\n      res[#res + 1] = {nums1[i], nums2[j]}\n    else\n      local last_sum = res[#res][1] + res[#res][2]\n      if sum < last_sum then\n        table.insert(res, 1, {nums1[i], nums2[j]})\n      else\n        res[#res + 1] = {nums1[i], nums2[j]}\n      end\n    end\n    if i == len1 then\n      j = j + 1\n    elseif j == len2 then\n      i = i + 1\n    else\n      if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] then\n        i = i + 1\n      else\n        j = j + 1\n      end\n    end\n  end\n  return res\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        else\n            if sum < heap[1][3] then\n                heap[1] = {i, j, sum}\n                local i = 1\n                while i * 2 <= #heap do\n                    local l = i * 2\n                    local r = i * 2 + 1\n                    local min_i = l\n                    if r <= #heap and heap[r][3] < heap[l][3] then\n                        min_i = r\n                    end\n                    if heap[i][3] > heap[min_i][3] then\n                        heap[i], heap[min_i] = heap[min_i], heap[i]\n                        i = min_i\n                    else\n                        break\n                    end\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local res = {}\n    while #heap > 0 do\n        local t = table.remove(heap, 1)\n        table.insert(res, {nums1[t[1]], nums2[t[2]]})\n        if t[2] < len2 then\n            push(t[1], t[2] + 1)\n        end\n    end\n    return res\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n    end\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][3] > heap[i][3] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local res = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      local r = i * 2 + 1\n      if r <= #heap and heap[r][3] < heap[l][3] then\n        l = r\n      end\n      if heap[i][3] > heap[l][3] then\n        heap[i], heap[l] = heap[l], heap[i]\n        i = l\n      else\n        break\n      end\n    end\n    return res\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local res = {}\n  while #heap > 0 do\n    local p = pop()\n    table.insert(res, {nums1[p[1]], nums2[p[2]]})\n  end\n  return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap_push(heap, {i, j, nums1[i] + nums2[j]})\n        end\n    end\n    push(1, 1)\n    local result = {}\n    while #result < k and #heap > 0 do\n        local pair = heap_pop(heap)\n        push(pair[1] + 1, pair[2])\n        push(pair[1], pair[2] + 1)\n        table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n    end\n    return result\nend",
    "  local function merge(a, b)\n    local c = {}\n    local i, j = 1, 1\n    while i <= #a and j <= #b do\n      if a[i][1] + a[i][2] < b[j][1] + b[j][2] then\n        c[#c + 1] = a[i]\n        i = i + 1\n      else\n        c[#c + 1] = b[j]\n        j = j + 1\n      end\n    end\n    while i <= #a do\n      c[#c + 1] = a[i]\n      i = i + 1\n    end\n    while j <= #b do\n      c[#c + 1] = b[j]\n      j = j + 1\n    end\n    return c\n  end",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap+1] = {i, j, sum}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i/2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while true do\n                local l = i * 2\n                local r = l + 1\n                if l > #heap then\n                    break\n                elseif r > #heap then\n                    if heap[l][3] < heap[i][3] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                    end\n                    break\n                elseif heap[l][3] < heap[r][3] then\n                    if heap[l][3] < heap[i][3] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    if heap[r][3] < heap[i][3] then\n                        heap[i], heap[r] = heap[r], heap[i]\n                        i = r\n                    else\n                        break\n                    end\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local ret = {}\n    for i = 1, #heap do\n        ret[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return ret\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    local heap_size = #heap\n    if heap_size == k then\n      if sum < heap[1][1] then\n        heap[1] = {sum, i, j}\n        heap_down(heap, 1, heap_size)\n      end\n    else\n      heap[heap_size + 1] = {sum, i, j}\n      heap_up(heap, heap_size + 1)\n    end\n  end\n  local function pop()\n    local heap_size = #heap\n    if heap_size == 0 then\n      return nil\n    end\n    local ret = heap[1]\n    heap[1] = heap[heap_size]\n    heap[heap_size] = nil\n    heap_down(heap, 1, heap_size - 1)\n    return ret\n  end\n  local function pop_all()\n    local ret = {}\n    while true do\n      local pair = pop()\n      if not pair then\n        break\n      end\n      ret[#ret + 1] = pair\n    end\n    return ret\n  end\n  local function push_all()\n    for i = 1, #nums1 do\n      for j = 1, #nums2 do\n        push(i, j)\n      end\n    end\n  end\n  push_all()\n  return pop_all()\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local function merge(a, b)\n        local c = {}\n        local i, j = 1, 1\n        while i <= #a and j <= #b do\n            if compare(a[i], b[j]) then\n                table.insert(c, a[i])\n                i = i + 1\n            else\n                table.insert(c, b[j])\n                j = j + 1\n            end\n        end\n        while i <= #a do\n            table.insert(c, a[i])\n            i = i + 1\n        end\n        while j <= #b do\n            table.insert(c, b[j])\n            j = j + 1\n        end\n        return c\n    end\n    local function merge_sort(a)\n        if #a <= 1 then\n            return a\n        end\n        local mid = #a / 2\n        local left = merge_sort(a:sub(1, mid))\n        local right = merge_sort(a:sub(mid + 1))\n        return merge(left, right)\n    end\n    local function get_pairs(nums1, nums2)\n        local pairs = {}\n        for i = 1, #nums1 do\n            for j = 1, #nums2 do\n                table.insert(pairs, {nums1[i], nums2[j]})\n            end\n        end\n        return pairs\n    end\n    local pairs = get_pairs(nums1, nums2)\n    pairs = merge_sort(pairs)\n    local result = {}\n    for i = 1, k do\n        if pairs[i] then\n            table.insert(result, pairs[i])\n        end\n    end\n    return result\nend",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local last = table.remove(heap)\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = i * 2 + 1\n            if l > #heap then break end\n            if r <= #heap and heap[r][1] < heap[l][1] then\n                l = r\n            end\n            if last[1] <= heap[l][1] then break end\n            heap[i] = heap[l]\n            i = l\n        end\n        heap[i] = last\n        return ret\n    end\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] <= heap[i][1] then break end\n            heap[i], heap[p] = heap[p], heap[i]\n            i = p\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        heap_push(heap, {nums1[i] + nums2[1], i, 1})\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then break end\n        local val = heap_pop(heap)\n        table.insert(ret, {nums1[val[2]], nums2[val[3]]})\n        if val[3] < #nums2 then\n            heap_push(heap, {nums1[val[2]] + nums2[val[3] + 1], val[2], val[3] + 1})\n        end\n    end\n    return ret\nend",
    "  if #nums1 == 0 or #nums2 == 0 then return {} end\n  local heap = {}\n  local result = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {sum, i, j}\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][1] > heap[i][1] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][1] then\n      heap[1] = {sum, i, j}\n      local i = 1\n      while i * 2 <= #heap do\n        local left = i * 2\n        local right = i * 2 + 1\n        local min = left\n        if right <= #heap and heap[right][1] < heap[left][1] then\n          min = right\n        end\n        if heap[i][1] > heap[min][1] then\n          heap[i], heap[min] = heap[min], heap[i]\n          i = min\n        else\n          break\n        end\n      end\n    end\n  end\n  push(1, 1)\n  while #result < k and #heap > 0 do\n    local item = table.remove(heap, 1)\n    result[#result + 1] = {nums1[item[2]], nums2[item[3]]}\n    if item[3] < #nums2 then\n      push(item[2], item[3] + 1)\n    end\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        if #heap == 0 then\n            return nil\n        end\n        local t = heap[1]\n        local n = #heap\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = l + 1\n            if l > n then\n                break\n            end\n            if r <= n and heap[l][1] > heap[r][1] then\n                l = r\n            end\n            if heap[i][1] > heap[l][1] then\n                heap[i], heap[l] = heap[l], heap[i]\n                i = l\n            else\n                break\n            end\n        end\n        return t[2], t[3]\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    local result = {}\n    for i = 1, k do\n        local x, y = pop()\n        if x == nil then\n            break\n        end\n        result[#result + 1] = {nums1[x], nums2[y]}\n        push(x, y + 1)\n    end\n    return result\nend",
    "  local function merge(a, b)\n    local res = {}\n    local i, j = 1, 1\n    while i <= #a and j <= #b do\n      if a[i] < b[j] then\n        table.insert(res, a[i])\n        i = i + 1\n      else\n        table.insert(res, b[j])\n        j = j + 1\n      end\n    end\n    while i <= #a do\n      table.insert(res, a[i])\n      i = i + 1\n    end\n    while j <= #b do\n      table.insert(res, b[j])\n      j = j + 1\n    end\n    return res\n  end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k or sum < heap[1][1] then\n      heapq.heappush(heap, {sum, i, j})\n      if #heap > k then\n        heapq.heappop(heap)\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  local res = {}\n  while #heap > 0 do\n    local _, i, j = table.unpack(heapq.heappop(heap))\n    table.insert(res, {nums1[i], nums2[j]})\n    if j < #nums2 then\n      push(i, j + 1)\n    end\n  end\n  return res\nend",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] < nums2[j] then\n        res[#res + 1] = {nums1[i], nums2[j]}\n        i = i + 1\n      else\n        res[#res + 1] = {nums1[i], nums2[j]}\n        j = j + 1\n      end\n    end\n    while i <= m do\n      res[#res + 1] = {nums1[i], nums2[j]}\n      i = i + 1\n    end\n    while j <= n do\n      res[#res + 1] = {nums1[i], nums2[j]}\n      j = j + 1\n    end\n    return res\n  end\n  local res = merge(nums1, nums2)\n  local function partition(arr, l, r)\n    local pivot = arr[r][1] + arr[r][2]\n    local i = l\n    for j = l, r - 1 do\n      if arr[j][1] + arr[j][2] < pivot then\n        arr[i], arr[j] = arr[j], arr[i]\n        i = i + 1\n      end\n    end\n    arr[i], arr[r] = arr[r], arr[i]\n    return i\n  end\n  local function quick_select(arr, l, r, k)\n    if l == r then return end\n    local p = partition(arr, l, r)\n    if p == k then return end\n    if p > k then\n      quick_select(arr, l, p - 1, k)\n    else\n      quick_select(arr, p + 1, r, k)\n    end\n  end\n  quick_select(res, 1, #res, k)\n  return res\nend",
    "    local function merge_sort(nums1, nums2)\n        local function merge(nums1, nums2)\n            local i, j, k = 1, 1, 1\n            local len1, len2 = #nums1, #nums2\n            local result = {}\n            while i <= len1 and j <= len2 do\n                if nums1[i] < nums2[j] then\n                    result[k] = nums1[i]\n                    i = i + 1\n                else\n                    result[k] = nums2[j]\n                    j = j + 1\n                end\n                k = k + 1\n            end\n            while i <= len1 do\n                result[k] = nums1[i]\n                i = i + 1\n                k = k + 1\n            end\n            while j <= len2 do\n                result[k] = nums2[j]\n                j = j + 1\n                k = k + 1\n            end\n            return result\n        end\n        local function merge_sort(nums)\n            local len = #nums\n            if len <= 1 then\n                return nums\n            end\n            local mid = math.floor(len / 2)\n            local left = merge_sort(nums, 1, mid)\n            local right = merge_sort(nums, mid + 1, len)\n            return merge(left, right)\n        end\n        return merge_sort(merge(nums1, nums2))\n    end\n    local function find_k_smallest(nums, k)\n        local function partition(nums, left, right)\n            local pivot = nums[left]\n            local i, j = left, right\n            while i < j do\n                while i < j and nums[j] >= pivot do\n                    j = j - 1\n                end\n                nums[i] = nums[j]\n                while i < j and nums[i] <= pivot do\n                    i = i + 1\n                end\n                nums[j] = nums[i]\n            end\n            nums[i] = pivot\n            return i\n        end\n        local function quick_sort(nums",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local result = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(result, nums1[i])\n                i = i + 1\n            else\n                table.insert(result, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(result, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(result, nums2[j])\n            j = j + 1\n        end\n        return result\n    end",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i][1] < heap[j][1] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end",
    "    local res = {}\n    local heap = {}\n    local heap_size = 0\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        heap_size = heap_size + 1\n        heap[heap_size] = {i, j, sum}\n        local i = heap_size\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][3] > heap[i][3] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local v = heap[1]\n        heap[1] = heap[heap_size]\n        heap[heap_size] = nil\n        heap_size = heap_size - 1\n        local i = 1\n        while i * 2 <= heap_size do\n            local l = i * 2\n            local r = i * 2 + 1\n            local j = l\n            if r <= heap_size and heap[r][3] < heap[l][3] then\n                j = r\n            end\n            if heap[i][3] > heap[j][3] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return v\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    for i = 1, k do\n        if heap_size == 0 then\n            break\n        end\n        local v = pop()\n        local i, j = v[1], v[2]\n        res[i] = res[i] or {}\n        table.insert(res[i], nums2[j])\n        if j < #nums2 then\n            push(i, j + 1)\n        end\n    end\n    return res\nend",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local res = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i][1] + nums1[i][2] < nums2[j][1] + nums2[j][2] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap_push(heap, {sum, i, j})\n        elseif sum < heap[1][1] then\n            heap_pop(heap)\n            heap_push(heap, {sum, i, j})\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        result[i] = {nums1[heap[i][2]], nums2[heap[i][3]]}\n    end\n    return result\nend",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then return res end\n  local function push(a, b)\n    local sum = nums1[a] + nums2[b]\n    if #res < k then\n      table.insert(res, {nums1[a], nums2[b]})\n    elseif sum < res[k][1] + res[k][2] then\n      table.remove(res, k)\n      table.insert(res, {nums1[a], nums2[b]})\n    end\n  end\n  local a, b = 1, 1\n  push(a, b)\n  while k > 1 and (a < len1 or b < len2) do\n    if a < len1 and b < len2 then\n      if nums1[a] < nums2[b] then\n        a = a + 1\n      else\n        b = b + 1\n      end\n    elseif a < len1 then\n      a = a + 1\n    else\n      b = b + 1\n    end\n    push(a, b)\n  end\n  return res\nend",
    "  local result = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then\n    return result\n  end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    local len = #heap\n    heap[len + 1] = {sum, i, j}\n    local i = len + 1\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] > heap[i][1] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local len = #heap\n    if len == 0 then\n      return nil\n    end\n    local result = heap[1]\n    heap[1] = heap[len]\n    heap[len] = nil\n    local i = 1\n    while i < len do\n      local left = i * 2\n      local right = left + 1\n      if left >= len then\n        break\n      end\n      local min = left\n      if right < len and heap[right][1] < heap[left][1] then\n        min = right\n      end\n      if heap[min][1] < heap[i][1] then\n        heap[min], heap[i] = heap[i], heap[min]\n        i = min\n      else\n        break\n      end\n    end\n    return result\n  end\n  push(1, 1)\n  for i = 1, k do\n    local pair = pop()\n    if not pair then\n      break\n    end\n    result[i] = {nums1[pair[2]], nums2[pair[3]]}\n    if pair[3] < len2 then\n      push(pair[2], pair[3] + 1)\n    end\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local function cmp(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(heap, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(heap, cmp)\n  local res = {}\n  for i = 1, k do\n    table.insert(res, heap[i])\n  end\n  return res\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap+1] = {nums1[i]+nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local pair = table.remove(heap, 1)\n    result[#result+1] = {nums1[pair[2]], nums2[pair[3]]}\n    push(pair[2], pair[3]+1)\n    push(pair[2]+1, pair[3])\n    k = k - 1\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            local sum = nums1[i] + nums2[j]\n            if #res < k then\n                table.insert(res, {nums1[i], nums2[j]})\n            elseif sum < res[k][1] + res[k][2] then\n                table.remove(res, k)\n                table.insert(res, {nums1[i], nums2[j]})\n            end\n        end\n    end\n    return res\nend",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] > heap[i][1] then\n        heap[j], heap[i] = heap[i], heap[j]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local res = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n        j = j + 1\n      end\n      if heap[i][1] > heap[j][1] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return res\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local res = {}\n  for i = 1, k do\n    local val = heap_pop(heap)\n    if val then\n      res[i] = val[2]\n    end\n  end\n  return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {i, j}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if nums1[heap[p][1]] + nums2[heap[p][2]] > nums1[heap[i][1]] + nums2[heap[i][2]] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local a = i * 2\n            local b = i * 2 + 1\n            if b <= #heap and nums1[heap[b][1]] + nums2[heap[b][2]] < nums1[heap[a][1]] + nums2[heap[a][2]] then\n                a = b\n            end\n            if nums1[heap[i][1]] + nums2[heap[i][2]] > nums1[heap[a][1]] + nums2[heap[a][2]] then\n                heap[i], heap[a] = heap[a], heap[i]\n                i = a\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        local p = pop()\n        if p then\n            ret[#ret + 1] = {nums1[p[1]], nums2[p[2]]}\n            push(p[1], p[2] + 1)\n        end\n    end\n    return ret\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        local v = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n                j = j + 1\n            end\n            if heap[i][1] <= heap[j][1] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n        return v\n    end\n    local function top()\n        return heap[1]\n    end\n    local function size()\n        return #heap\n    end\n    local function empty()\n        return #heap == 0\n    end\n    local function push_pop(i, j)\n        push(i, j)\n        return pop()\n    end\n    local function clear()\n        heap = {}\n    end",
    "  local function push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][1] + heap[p][2] > heap[i][1] + heap[i][2] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] > heap[i][1] then\n        heap[j], heap[i] = heap[i], heap[j]\n        i = j\n      else\n        break\n      end\n    end\n  end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > sum then\n          heap[i], heap[parent] = heap[parent], heap[i]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif heap[1][3] > sum then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local left = i * 2\n        local right = i * 2 + 1\n        local min_child = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          min_child = right\n        end\n        if heap[min_child][3] < sum then\n          heap[i], heap[min_child] = heap[min_child], heap[i]\n          i = min_child\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return result\nend",
    "    local function merge(nums1, nums2)\n        local res = {}\n        local i, j = 1, 1\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end\n    local function find_kth(nums1, nums2, k)\n        if #nums1 == 0 then\n            return nums2[k]\n        end\n        if #nums2 == 0 then\n            return nums1[k]\n        end\n        local mid1 = math.floor(#nums1 / 2)\n        local mid2 = math.floor(#nums2 / 2)\n        if mid1 + mid2 < k then\n            if nums1[mid1 + 1] > nums2[mid2 + 1] then\n                return find_kth(nums1, nums2:sub(mid2 + 1), k - mid2 - 1)\n            else\n                return find_kth(nums1:sub(mid1 + 1), nums2, k - mid1 - 1)\n            end\n        else\n            if nums1[mid1 + 1] > nums2[mid2 + 1] then\n                return find_kth(nums1:sub(1, mid1), nums2, k)\n            else\n                return find_kth(nums1, nums2:sub(1, mid2), k)\n            end\n        end\n    end\n    local function find_k_smallest(nums1, nums2, k)\n        local res = {}\n        for i = 1, k do\n",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    local top = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j < #heap and heap[j][1] > heap[j + 1][1] then\n        j = j + 1\n      end\n      if heap[i][1] > heap[j][1] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return top\n  end\n  local function heapify()\n    for i = math.floor(#heap / 2), 1, -1 do\n      local j = i\n      while j * 2 <= #heap do\n        local k = j * 2\n        if k < #heap and heap[k][1] > heap[k + 1][1] then\n          k = k + 1\n        end\n        if heap[j][1] > heap[k][1] then\n          heap[j], heap[k] = heap[k], heap[j]\n          j = k\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  heapify()\n  local result = {}\n  for i = 1, k do\n    if #heap == 0 then\n      break\n    end\n    local top = pop()\n    result[i] = {nums1[top[2]], nums2[top[3]]}\n    push(top[2], top[3] + 1)\n  end\n  return result\nend",
    "    local len1, len2 = #nums1, #nums2\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap + 1] = {i, j, sum}\n            local i = #heap\n            while i > 1 do\n                local parent = math.floor(i / 2)\n                if heap[parent][3] > sum then\n                    heap[i], heap[parent] = heap[parent], heap[i]\n                    i = parent\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= k do\n                local child = i * 2\n                if child < k and heap[child + 1][3] < heap[child][3] then\n                    child = child + 1\n                end\n                if heap[child][3] < heap[i][3] then\n                    heap[i], heap[child] = heap[child], heap[i]\n                    i = child\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local result = {}\n    for i = 1, k do\n        if heap[1] then\n            local pair = heap[1]\n            result[i] = {nums1[pair[1]], nums2[pair[2]]}\n            if pair[2] < len2 then\n                push(pair[1], pair[2] + 1)\n            end\n        else\n            break\n        end\n    end\n    return result\nend",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] < nums2[j] then\n        table.insert(res, {nums1[i], nums2[j]})\n        i = i + 1\n      else\n        table.insert(res, {nums1[i], nums2[j]})\n        j = j + 1\n      end\n    end\n    while i <= m do\n      table.insert(res, {nums1[i], nums2[j]})\n      i = i + 1\n    end\n    while j <= n do\n      table.insert(res, {nums1[i], nums2[j]})\n      j = j + 1\n    end\n    return res\n  end\n  local res = merge(nums1, nums2)\n  local function partition(res, l, r)\n    local pivot = res[l][1] + res[l][2]\n    local i = l\n    for j = l + 1, r do\n      if res[j][1] + res[j][2] < pivot then\n        i = i + 1\n        res[i], res[j] = res[j], res[i]\n      end\n    end\n    res[i], res[l] = res[l], res[i]\n    return i\n  end\n  local function quick_sort(res, l, r)\n    if l < r then\n      local p = partition(res, l, r)\n      quick_sort(res, l, p - 1)\n      quick_sort(res, p + 1, r)\n    end\n  end\n  quick_sort(res, 1, #res)\n  local res = {}\n  for i = 1, k do\n    table.insert(res, res[i])\n  end\n  return res\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local result = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(result, nums1[i])\n                i = i + 1\n            else\n                table.insert(result, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(result, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(result, nums2[j])\n            j = j + 1\n        end\n        return result\n    end",
    "    local function merge(nums1, nums2)\n        local result = {}\n        local i, j = 1, 1\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(result, nums1[i])\n                i = i + 1\n            else\n                table.insert(result, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(result, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(result, nums2[j])\n            j = j + 1\n        end\n        return result\n    end",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then return {} end\n    local heap = {}\n    local function push(i, j, val)\n        heap[#heap + 1] = {i, j, val}\n        local idx = #heap\n        while idx > 1 do\n            local parent = math.floor(idx / 2)\n            if heap[parent][3] > heap[idx][3] then\n                heap[parent], heap[idx] = heap[idx], heap[parent]\n                idx = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local idx = 1\n        while idx * 2 <= #heap do\n            local left = idx * 2\n            local right = idx * 2 + 1\n            local min_idx = left\n            if right <= #heap and heap[right][3] < heap[left][3] then\n                min_idx = right\n            end\n            if heap[idx][3] > heap[min_idx][3] then\n                heap[idx], heap[min_idx] = heap[min_idx], heap[idx]\n                idx = min_idx\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local ret = {}\n    push(1, 1, nums1[1] + nums2[1])\n    while #ret < k and #heap > 0 do\n        local i, j, val = unpack(pop())\n        ret[#ret + 1] = {nums1[i], nums2[j]}\n        if j < len2 then\n            push(i, j + 1, nums1[i] + nums2[j + 1])\n        end\n        if j == 1 and i < len1 then\n            push(i + 1, 1, nums1[i + 1] + nums2[1])\n       ",
    "    local res = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then return res end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= k do\n                local l = i * 2\n                local r = i * 2 + 1\n                local min_i = l\n                if r <= k and heap[r][3] < heap[l][3] then\n                    min_i = r\n                end\n                if heap[min_i][3] < heap[i][3] then\n                    heap[i], heap[min_i] = heap[min_i], heap[i]\n                    i = min_i\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    for i = 1, k do\n        if #heap == 0 then break end\n        local pair = table.remove(heap, 1)\n        table.insert(res, {nums1[pair[1]], nums2[pair[2]]})\n        if pair[2] < len2 then\n            push(pair[1], pair[2] + 1)\n        end\n    end\n    return res\nend",
    "  local function heap_push(heap, item)\n    table.insert(heap, item)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] + heap[j][2] <= heap[i][1] + heap[i][2] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n  end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heapq.heappush(heap, {sum, i, j})\n    elseif heap[1][1] > sum then\n      heapq.heappop(heap)\n      heapq.heappush(heap, {sum, i, j})\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local res = {}\n  for _, v in ipairs(heap) do\n    table.insert(res, {nums1[v[2]], nums2[v[3]]})\n  end\n  return res\nend",
    "    local function cmp(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end\n    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heapinsert(heap, {nums1[i] + nums2[j], i, j}, cmp)\n        end\n    end\n    local function pop()\n        local v = heapremove(heap, cmp)\n        if v then\n            push(v[2] + 1, v[3])\n            return v[1], v[2], v[3]\n        end\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        local v = pop()\n        if not v then\n            break\n        end\n        ret[i] = {nums1[v[2]], nums2[v[3]]}\n    end\n    return ret\nend",
    "  local heap = {}\n  local function heap_push(x, y, val)\n    heap[#heap+1] = {x=x, y=y, val=val}\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i/2)\n      if heap[j].val > heap[i].val then\n        heap[j], heap[i] = heap[i], heap[j]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i*2 <= #heap do\n      local j = i*2\n      if j+1 <= #heap and heap[j+1].val < heap[j].val then\n        j = j+1\n      end\n      if heap[i].val > heap[j].val then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for i=1,#nums1 do\n    for j=1,#nums2 do\n      heap_push(i, j, nums1[i]+nums2[j])\n    end\n  end\n  local ret = {}\n  for i=1,k do\n    local x = heap_pop()\n    if not x then break end\n    ret[#ret+1] = {x.x, x.y}\n  end\n  return ret\nend",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end\n    local function push(heap, num1, num2)\n        if #heap < k then\n            table.insert(heap, {num1 + num2, num1, num2})\n        elseif num1 + num2 < heap[1][1] then\n            heap[1] = {num1 + num2, num1, num2}\n            table.sort(heap, compare)\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(heap, nums1[i], nums2[j])\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        table.insert(result, {heap[i][2], heap[i][3]})\n    end\n    return result\nend",
    "  local result = {}\n  local heap = {}\n  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i][1] + heap[i][2] >= heap[parent][1] + heap[parent][2] then\n        break\n      end\n      heap[i], heap[parent] = heap[parent], heap[i]\n      i = parent\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      local r = i * 2 + 1\n      local min = l\n      if r <= #heap and heap[r][1] + heap[r][2] < heap[l][1] + heap[l][2] then\n        min = r\n      end\n      if heap[i][1] + heap[i][2] <= heap[min][1] + heap[min][2] then\n        break\n      end\n      heap[i], heap[min] = heap[min], heap[i]\n      i = min\n    end\n    return ret\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i], nums2[j]})\n    end\n  end\n  for i = 1, k do\n    if #heap == 0 then\n      break\n    end\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "  local result = {}\n  local heap = {}\n  local function push(x, y, val)\n    if #heap < k then\n      table.insert(heap, {x, y, val})\n      local i = #heap\n      while i > 1 and heap[i][3] < heap[i // 2][3] do\n        heap[i], heap[i // 2] = heap[i // 2], heap[i]\n        i = i // 2\n      end\n    elseif val < heap[1][3] then\n      heap[1] = {x, y, val}\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j < #heap and heap[j + 1][3] < heap[j][3] then\n          j = j + 1\n        end\n        if heap[j][3] < heap[i][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j, nums1[i] + nums2[j])\n    end\n  end\n  for i = 1, #heap do\n    table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return result\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 and heap[i][3] < heap[i // 2][3] do\n                heap[i], heap[i // 2] = heap[i // 2], heap[i]\n                i = i // 2\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local j = i * 2\n                if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n                    j = j + 1\n                end\n                if heap[i][3] <= heap[j][3] then\n                    break\n                end\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local res = {}\n    while #heap > 0 do\n        local i, j, sum = table.unpack(table.remove(heap, 1))\n        table.insert(res, {nums1[i], nums2[j]})\n        if j + 1 <= len2 then\n            push(i, j + 1)\n        end\n    end\n    return res\nend",
    "  local function merge(nums1, nums2)\n    local res = {}\n    local i, j = 1, 1\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        res[#res + 1] = nums1[i]\n        i = i + 1\n      else\n        res[#res + 1] = nums2[j]\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      res[#res + 1] = nums1[i]\n      i = i + 1\n    end\n    while j <= #nums2 do\n      res[#res + 1] = nums2[j]\n      j = j + 1\n    end\n    return res\n  end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return (a[1] + a[2]) < (b[1] + b[2])\n  end\n  local function add_pair(n1, n2, pairs)\n    if #pairs < k then\n      table.insert(pairs, {n1, n2})\n    else\n      local last = pairs[#pairs]\n      if (n1 + n2) < (last[1] + last[2]) then\n        table.remove(pairs)\n        table.insert(pairs, {n1, n2})\n      end\n    end\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      add_pair(nums1[i], nums2[j], pairs)\n    end\n  end\n  table.sort(pairs, compare)\n  return pairs\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > heap[i][3] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local left = i * 2\n        local right = i * 2 + 1\n        local min_child = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          min_child = right\n        end\n        if heap[i][3] > heap[min_child][3] then\n          heap[i], heap[min_child] = heap[min_child], heap[i]\n          i = min_child\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local j = math.floor(i / 2)\n        if heap[j][3] > heap[i][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n          j = j + 1\n        end\n        if heap[i][3] > heap[j][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return result\nend",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] + heap[j][2] > heap[i][1] + heap[i][2] then\n        heap[j], heap[i] = heap[i], heap[j]\n        i = j\n      else\n        break\n      end\n    end\n  end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local heap = {}\n    local function push(x, y)\n        if x <= #nums1 and y <= #nums2 then\n            table.insert(heap, {nums1[x], nums2[y]})\n            table.sort(heap, compare)\n            if #heap > k then\n                table.remove(heap, #heap)\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    return heap\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then\n    return {}\n  end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    heap[#heap + 1] = {sum, i, j}\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] > heap[i][1] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      local min = left\n      if right <= #heap and heap[right][1] < heap[left][1] then\n        min = right\n      end\n      if heap[i][1] > heap[min][1] then\n        heap[i], heap[min] = heap[min], heap[i]\n        i = min\n      else\n        break\n      end\n    end\n    return ret\n  end\n  local ret = {}\n  for i = 1, math.min(len1, k) do\n    push(i, 1)\n  end\n  while k > 0 and #heap > 0 do\n    local pair = pop()\n    ret[#ret + 1] = {nums1[pair[2]], nums2[pair[3]]}\n    k = k - 1\n    if pair[3] < len2 then\n      push(pair[2], pair[3] + 1)\n    end\n  end\n  return ret\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 and heap[i][3] < heap[i // 2][3] do\n                heap[i], heap[i // 2] = heap[i // 2], heap[i]\n                i = i // 2\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local j = i * 2\n                if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n                    j = j + 1\n                end\n                if heap[i][3] <= heap[j][3] then\n                    break\n                end\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        res[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return res\nend",
    "  local len1 = #nums1\n  local len2 = #nums2\n  local heap = {}\n  local heap_size = 0\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    heap_size = heap_size + 1\n    heap[heap_size] = {sum, i, j}\n    local i = heap_size\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][1] > heap[i][1] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[heap_size]\n    heap_size = heap_size - 1\n    local i = 1\n    while i * 2 <= heap_size do\n      local l = i * 2\n      local r = i * 2 + 1\n      local min = l\n      if r <= heap_size and heap[r][1] < heap[l][1] then\n        min = r\n      end\n      if heap[i][1] > heap[min][1] then\n        heap[i], heap[min] = heap[min], heap[i]\n        i = min\n      else\n        break\n      end\n    end\n    return ret\n  end\n  local function empty()\n    return heap_size == 0\n  end\n  local function top()\n    return heap[1]\n  end\n  local function size()\n    return heap_size\n  end\n  local function clear()\n    heap_size = 0\n  end\n  local function print()\n    for i = 1, heap_size do\n      print(heap[i][1])\n    end\n  end\n  for i = 1, math.min(len1, k) do\n    push(i, 1)\n  end\n  local ret = {}\n  for i = 1, k do\n    if empty() then\n      break\n    end\n    local sum, x, y = pop()\n   ",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local function heap_push(heap, item)\n        table.insert(heap, item)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] + heap[j][2] > heap[i][1] + heap[i][2] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end",
    "  local function heap_push(heap, val, idx1, idx2)\n    local i = #heap + 1\n    heap[i] = {val, idx1, idx2}\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][1] > heap[i][1] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local ret = {}\n    for i = 1, k do\n        table.insert(ret, res[i])\n    end\n    return ret\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local res = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(res, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(res, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, res[i])\n  end\n  return result\nend",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] + heap[j][2] <= heap[i][1] + heap[i][2] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n  end",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    local top = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j < #heap and heap[j][1] > heap[j + 1][1] then\n        j = j + 1\n      end\n      if heap[i][1] <= heap[j][1] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n    return top\n  end\n  local function top()\n    return heap[1]\n  end\n  local function size()\n    return #heap\n  end\n  push(1, 1)\n  local result = {}\n  while size() > 0 and #result < k do\n    local top = pop()\n    result[#result + 1] = {nums1[top[2]], nums2[top[3]]}\n    push(top[2], top[3] + 1)\n    if top[3] == 1 then\n      push(top[2] + 1, 1)\n    end\n  end\n  return result\nend",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] <= nums2[j] then\n        table.insert(res, nums1[i])\n        i = i + 1\n      else\n        table.insert(res, nums2[j])\n        j = j + 1\n      end\n    end\n    while i <= m do\n      table.insert(res, nums1[i])\n      i = i + 1\n    end\n    while j <= n do\n      table.insert(res, nums2[j])\n      j = j + 1\n    end\n    return res\n  end\n  local function find_kth(nums1, nums2, k)\n    local m, n = #nums1, #nums2\n    if m > n then\n      return find_kth(nums2, nums1, k)\n    end\n    if m == 0 then\n      return nums2[k]\n    end\n    if k == 1 then\n      return math.min(nums1[1], nums2[1])\n    end\n    local i = math.min(m, math.floor(k / 2))\n    local j = math.min(n, math.floor(k / 2))\n    if nums1[i] > nums2[j] then\n      return find_kth(nums1, {unpack(nums2, j + 1)}, k - j)\n    else\n      return find_kth({unpack(nums1, i + 1)}, nums2, k - i)\n    end\n  end\n  local function find_kth_smallest_pair(nums1, nums2, k)\n    local m, n = #nums1, #nums2\n    local left, right = math.max(nums1[1] + nums2[1], nums1[m] + nums2[1]), nums1[m] + nums2[",
    "    local result = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return result\n    end\n    local heap = {}\n    local function push(val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] + heap[p][2] > heap[i][1] + heap[i][2] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local l = i * 2\n            local r = i * 2 + 1\n            local min = l\n            if r <= #heap and heap[r][1] + heap[r][2] < heap[l][1] + heap[l][2] then\n                min = r\n            end\n            if heap[i][1] + heap[i][2] > heap[min][1] + heap[min][2] then\n                heap[i], heap[min] = heap[min], heap[i]\n                i = min\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, math.min(len1, k) do\n        push({nums1[i], nums2[1], 1})\n    end\n    while #result < k and #heap > 0 do\n        local val = pop()\n        table.insert(result, {val[1], val[2]})\n        if val[3] + 1 <= len2 then\n            push({val[1], nums2[val[3] + 1], val[3] + 1})\n        end\n    end\n    return result\nend",
    "  local function heap_pop(heap)\n    local root = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = left + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[i][1] > heap[left][1] then\n          heap[i], heap[left] = heap[left], heap[i]\n        end\n        break\n      else\n        local min_index = i\n        if heap[left][1] < heap[min_index][1] then\n          min_index = left\n        end\n        if heap[right][1] < heap[min_index][1] then\n          min_index = right\n        end\n        if min_index == i then\n          break\n        else\n          heap[i], heap[min_index] = heap[min_index], heap[i]\n          i = min_index\n        end\n      end\n    end\n    return root\n  end\n  local function heap_push(heap, value)\n    heap[#heap + 1] = value\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i][1] < heap[parent][1] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_top(heap)\n    return heap[1]\n  end\n  local function heap_empty(heap)\n    return #heap == 0\n  end\n  local function heap_size(heap)\n    return #heap\n  end\n  local heap = {}\n  local result = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "    local function heap_pop(heap)\n        local n = #heap\n        if n == 0 then\n            return nil\n        end\n        local v = heap[1]\n        if n == 1 then\n            heap[1] = nil\n            return v\n        end\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = l + 1\n            if l > n then\n                break\n            end\n            local j = l\n            if r <= n and heap[r][1] < heap[l][1] then\n                j = r\n            end\n            if heap[j][1] < heap[i][1] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return v\n    end\n    local function heap_push(heap, v)\n        local n = #heap\n        heap[n + 1] = v\n        local i = n + 1\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] > heap[i][1] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_top(heap)\n        return heap[1]\n    end\n    local function heap_empty(heap)\n        return #heap == 0\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i] + nums2[j], i, j})\n        end\n    end\n    local ret = {}\n    while k > 0 and not heap_empty(heap) do\n        local v = heap_pop(heap)\n        table.insert(ret, {nums1[v[2]], nums2[v[3]]})\n        k = k - 1\n    end\n   ",
    "    local function heap_pop(heap)\n        local v = heap[1]\n        local n = #heap\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = l + 1\n            if l > n then\n                break\n            elseif r > n then\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                end\n                break\n            else\n                local min_i = i\n                if heap[l][1] < heap[min_i][1] then\n                    min_i = l\n                end\n                if heap[r][1] < heap[min_i][1] then\n                    min_i = r\n                end\n                if min_i ~= i then\n                    heap[i], heap[min_i] = heap[min_i], heap[i]\n                    i = min_i\n                else\n                    break\n                end\n            end\n        end\n        return v\n    end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local function heap_pop(heap)\n    local last = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n        j = j + 1\n      end\n      if last[1] <= heap[j][1] then\n        break\n      end\n      heap[i] = heap[j]\n      i = j\n    end\n    heap[i] = last\n    return heap[1]\n  end\n  local function heap_push(heap, item)\n    heap[#heap + 1] = item\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] <= heap[i][1] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n  end\n  local function heap_top(heap)\n    return heap[1]\n  end\n  local function heap_empty(heap)\n    return #heap == 0\n  end\n  local function heap_size(heap)\n    return #heap\n  end\n  local function heap_clear(heap)\n    for i = 1, #heap do\n      heap[i] = nil\n    end\n  end\n  local function heap_new()\n    return {}\n  end\n  local function heap_delete(heap)\n    heap_clear(heap)\n  end\n  local function heap_merge(heap1, heap2)\n    for i = 1, #heap2 do\n      heap_push(heap1, heap2[i])\n    end\n  end\n  local function heap_sort(heap)\n    local result = {}\n    while not heap_empty(heap) do\n      result[#result + 1] = heap_pop(heap)\n    end\n    return result\n  end\n  local function heap_copy(heap)\n",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local function cmp(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end",
    "  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local res = {}\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        table.insert(res, nums1[i])\n        i = i + 1\n      else\n        table.insert(res, nums2[j])\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      table.insert(res, nums1[i])\n      i = i + 1\n    end\n    while j <= #nums2 do\n      table.insert(res, nums2[j])\n      j = j + 1\n    end\n    return res\n  end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(heap, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(heap, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, heap[i])\n    end\n    return result\nend",
    "  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local res = {}\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        table.insert(res, nums1[i])\n        i = i + 1\n      else\n        table.insert(res, nums2[j])\n        j = j + 1\n      end\n    end\n    if i <= #nums1 then\n      for k = i, #nums1 do\n        table.insert(res, nums1[k])\n      end\n    elseif j <= #nums2 then\n      for k = j, #nums2 do\n        table.insert(res, nums2[k])\n      end\n    end\n    return res\n  end\n  local res = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(res, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(res, function(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end)\n  local ret = {}\n  for i = 1, k do\n    table.insert(ret, res[i])\n  end\n  return ret\nend",
    "  local function heap_pop(heap)\n    local n = #heap\n    if n == 0 then\n      return nil\n    end\n    local v = heap[1]\n    if n == 1 then\n      heap[1] = nil\n      return v\n    end\n    heap[1] = heap[n]\n    heap[n] = nil\n    local i = 1\n    while true do\n      local l = i * 2\n      local r = l + 1\n      if l > n then\n        break\n      end\n      local j = l\n      if r <= n and heap[r][1] < heap[l][1] then\n        j = r\n      end\n      if heap[i][1] <= heap[j][1] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n    return v\n  end",
    "  local heap = {}\n  local function push(x, y)\n    local val = nums1[x] + nums2[y]\n    if #heap < k then\n      heap[#heap+1] = {x, y, val}\n      local i = #heap\n      while i > 1 do\n        local j = math.floor(i / 2)\n        if heap[j][3] > val then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    elseif val < heap[1][3] then\n      heap[1] = {x, y, val}\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j+1][3] < heap[j][3] then\n          j = j + 1\n        end\n        if heap[j][3] < val then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local res = {}\n  for i = 1, #heap do\n    res[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return res\nend",
    "  local result = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      local sum = nums1[i] + nums2[j]\n      if #result < k then\n        table.insert(result, {nums1[i], nums2[j]})\n      else\n        local max = result[1][1] + result[1][2]\n        local max_index = 1\n        for index, pair in ipairs(result) do\n          if pair[1] + pair[2] > max then\n            max = pair[1] + pair[2]\n            max_index = index\n          end\n        end\n        if sum < max then\n          table.remove(result, max_index)\n          table.insert(result, {nums1[i], nums2[j]})\n        end\n      end\n    end\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local heap = {}\n    local function push(x, y)\n        if x > #nums1 or y > #nums2 then\n            return\n        end\n        local pair = {nums1[x], nums2[y]}\n        table.insert(heap, pair)\n        table.sort(heap, compare)\n        if #heap > k then\n            table.remove(heap, 1)\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > heap[i][3] then\n          heap[p], heap[i] = heap[i], heap[p]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = l + 1\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          l = r\n        end\n        if heap[i][3] > heap[l][3] then\n          heap[i], heap[l] = heap[l], heap[i]\n          i = l\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local function add_pair(a, b)\n        local pairs = {}\n        for i = 1, #a do\n            for j = 1, #b do\n                table.insert(pairs, {a[i], b[j]})\n            end\n        end\n        table.sort(pairs, compare)\n        return pairs\n    end\n    local pairs = add_pair(nums1, nums2)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > sum then\n          heap[i], heap[parent] = heap[parent], heap[i]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local left = i * 2\n        local right = i * 2 + 1\n        local min_child = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          min_child = right\n        end\n        if heap[i][3] > heap[min_child][3] then\n          heap[i], heap[min_child] = heap[min_child], heap[i]\n          i = min_child\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    local pair = heap[i]\n    table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n  end\n  return result\nend",
    "  local heap = Heap.new()\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap:push({nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local result = {}\n  for i = 1, k do\n    local item = heap:pop()\n    if item then\n      table.insert(result, item[2])\n    end\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > heap[i][3] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif heap[1][3] > sum then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local left = i * 2\n        local right = i * 2 + 1\n        local min_child = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          min_child = right\n        end\n        if heap[i][3] > heap[min_child][3] then\n          heap[i], heap[min_child] = heap[min_child], heap[i]\n          i = min_child\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  local result = {}\n  while #heap > 0 do\n    local i, j, sum = table.unpack(table.remove(heap, 1))\n    table.insert(result, {nums1[i], nums2[j]})\n    if j < #nums2 then\n      push(i, j + 1)\n    end\n  end\n  return result\nend",
    "    local res = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return res\n    end\n    local heap = {}\n    local function push(i, j)\n        local val = nums1[i] + nums2[j]\n        local heap_len = #heap\n        if heap_len < k then\n            heap[heap_len + 1] = {val, i, j}\n            local i = heap_len + 1\n            while i > 1 do\n                local parent = math.floor(i / 2)\n                if heap[parent][1] > heap[i][1] then\n                    heap[parent], heap[i] = heap[i], heap[parent]\n                    i = parent\n                else\n                    break\n                end\n            end\n        elseif val < heap[1][1] then\n            heap[1] = {val, i, j}\n            local i = 1\n            while true do\n                local left = i * 2\n                local right = left + 1\n                if left > heap_len then\n                    break\n                end\n                local min_i = i\n                if heap[left][1] < heap[min_i][1] then\n                    min_i = left\n                end\n                if right <= heap_len and heap[right][1] < heap[min_i][1] then\n                    min_i = right\n                end\n                if min_i ~= i then\n                    heap[min_i], heap[i] = heap[i], heap[min_i]\n                    i = min_i\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        local val, i, j = unpack(table.remove(heap, 1))\n        res[#res + 1] = {nums1[i], nums2[j]}\n        if j < len2 then\n            push(i, j +",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i][1] + heap[i][2] < heap[parent][1] + heap[parent][2] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end",
    "  local function heap_pop(heap)\n    local last = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local left = i * 2\n      local right = left + 1\n      local min_child = left\n      if right <= #heap and heap[right] < heap[left] then\n        min_child = right\n      end\n      if heap[i] <= heap[min_child] then\n        break\n      end\n      heap[i], heap[min_child] = heap[min_child], heap[i]\n      i = min_child\n    end\n    return last\n  end\n  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] >= heap[parent] then\n        break\n      end\n      heap[i], heap[parent] = heap[parent], heap[i]\n      i = parent\n    end\n  end\n  local function heap_top(heap)\n    return heap[1]\n  end\n  local function heap_size(heap)\n    return #heap\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      local val = {nums1[i], nums2[j]}\n      if #heap < k then\n        heap_push(heap, val)\n      else\n        local top = heap_top(heap)\n        if nums1[i] + nums2[j] < top[1] + top[2] then\n          heap_pop(heap)\n          heap_push(heap, val)\n        end\n      end\n    end\n  end\n  local res = {}\n  while heap_size(heap) > 0 do\n    res[#res + 1] = heap_pop(heap)\n  end\n  return res\nend",
    "    local result = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(result, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(result, function(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end)\n    return result\nend",
    "  local function compare(a, b)\n    return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n  end\n  local function heapify(arr, i, n)\n    local l, r, largest = 2 * i, 2 * i + 1, i\n    if l <= n and compare(arr[l], arr[largest]) then largest = l end\n    if r <= n and compare(arr[r], arr[largest]) then largest = r end\n    if largest ~= i then\n      arr[i], arr[largest] = arr[largest], arr[i]\n      heapify(arr, largest, n)\n    end\n  end\n  local function build_heap(arr, n)\n    for i = math.floor(n / 2), 1, -1 do\n      heapify(arr, i, n)\n    end\n  end\n  local function heap_pop(arr, n)\n    local res = arr[1]\n    arr[1], arr[n] = arr[n], arr[1]\n    heapify(arr, 1, n - 1)\n    return res\n  end\n  local function heap_push(arr, n, x)\n    local i = n + 1\n    arr[i] = x\n    while i > 1 and compare(arr[i], arr[math.floor(i / 2)]) do\n      arr[i], arr[math.floor(i / 2)] = arr[math.floor(i / 2)], arr[i]\n      i = math.floor(i / 2)\n    end\n  end\n  local function heap_sort(arr, n)\n    build_heap(arr, n)\n    for i = n, 2, -1 do\n      arr[1], arr[i] = arr[i], arr[1]\n      heapify(arr, 1, i - 1)\n    end\n  end\n  local function heap_top(arr)\n    return arr[1]\n  end\n  local function heap_empty(arr)\n    return #arr == 0\n  end\n  local function heap_size(arr)\n    return #arr\n  end\n",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local ret = {}\n    for i = 1, k do\n        table.insert(ret, res[i])\n    end\n    return ret\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local function merge(a, b)\n    local res = {}\n    local i, j = 1, 1\n    while i <= #a and j <= #b do\n      if a[i][1] + a[i][2] < b[j][1] + b[j][2] then\n        table.insert(res, a[i])\n        i = i + 1\n      else\n        table.insert(res, b[j])\n        j = j + 1\n      end\n    end\n    while i <= #a do\n      table.insert(res, a[i])\n      i = i + 1\n    end\n    while j <= #b do\n      table.insert(res, b[j])\n      j = j + 1\n    end\n    return res\n  end",
    "  local function cmp(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, cmp)\n  local res = {}\n  for i = 1, k do\n    table.insert(res, pairs[i])\n  end\n  return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    l = r\n                end\n                if heap[i][3] > heap[l][3] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    local top = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i, j = 2, 3\n    while heap[i] or heap[j] do\n      if heap[i] and heap[j] then\n        if heap[i][1] < heap[j][1] then\n          if heap[i][1] < heap[1][1] then\n            heap[i], heap[1] = heap[1], heap[i]\n          else\n            break\n          end\n        else\n          if heap[j][1] < heap[1][1] then\n            heap[j], heap[1] = heap[1], heap[j]\n          else\n            break\n          end\n        end\n      elseif heap[i] then\n        if heap[i][1] < heap[1][1] then\n          heap[i], heap[1] = heap[1], heap[i]\n        else\n          break\n        end\n      else\n        if heap[j][1] < heap[1][1] then\n          heap[j], heap[1] = heap[1], heap[j]\n        else\n          break\n        end\n      end\n      i = i + 1\n      j = j + 1\n    end\n    return top\n  end\n  push(1, 1)\n  local result = {}\n  for _ = 1, k do\n    local top = pop()\n    if top then\n      result[#result + 1] = {top[2], top[3]}\n      push(top[2] + 1, top[3])\n      push(top[2], top[3] + 1)\n    end\n  end\n  return result\nend",
    "  local function merge(a, b)\n    local result = {}\n    local i, j = 1, 1\n    while i <= #a and j <= #b do\n      if a[i][1] + a[i][2] < b[j][1] + b[j][2] then\n        table.insert(result, a[i])\n        i = i + 1\n      else\n        table.insert(result, b[j])\n        j = j + 1\n      end\n    end\n    while i <= #a do\n      table.insert(result, a[i])\n      i = i + 1\n    end\n    while j <= #b do\n      table.insert(result, b[j])\n      j = j + 1\n    end\n    return result\n  end\n  local function merge_sort(arr)\n    if #arr <= 1 then return arr end\n    local mid = math.floor(#arr / 2)\n    local left = merge_sort(arr, 1, mid)\n    local right = merge_sort(arr, mid + 1, #arr)\n    return merge(left, right)\n  end\n  local function get_pairs(nums1, nums2)\n    local result = {}\n    for i = 1, #nums1 do\n      for j = 1, #nums2 do\n        table.insert(result, {nums1[i], nums2[j]})\n      end\n    end\n    return result\n  end\n  local pairs = get_pairs(nums1, nums2)\n  pairs = merge_sort(pairs)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    local min = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n        j = j + 1\n      end\n      if heap[j][1] < heap[i][1] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return min\n  end\n  local function heapify()\n    for i = #heap, 1, -1 do\n      local j = i\n      while j * 2 <= #heap do\n        local k = j * 2\n        if k + 1 <= #heap and heap[k + 1][1] < heap[k][1] then\n          k = k + 1\n        end\n        if heap[k][1] < heap[j][1] then\n          heap[j], heap[k] = heap[k], heap[j]\n          j = k\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  heapify()\n  local result = {}\n  for i = 1, k do\n    local pair = pop()\n    if not pair then\n      break\n    end\n    result[#result + 1] = {nums1[pair[2]], nums2[pair[3]]}\n    push(pair[2], pair[3] + 1)\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local function heapify(arr, i, n)\n        local l = 2 * i\n        local r = 2 * i + 1\n        local largest = i\n        if l <= n and compare(arr[l], arr[largest]) then\n            largest = l\n        end\n        if r <= n and compare(arr[r], arr[largest]) then\n            largest = r\n        end\n        if largest ~= i then\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, largest, n)\n        end\n    end\n    local function build_heap(arr)\n        for i = math.floor(#arr / 2), 1, -1 do\n            heapify(arr, i, #arr)\n        end\n    end\n    local function heap_sort(arr)\n        build_heap(arr)\n        for i = #arr, 2, -1 do\n            arr[1], arr[i] = arr[i], arr[1]\n            heapify(arr, 1, i - 1)\n        end\n    end\n    local function heap_insert(arr, val)\n        arr[#arr + 1] = val\n        local i = #arr\n        while i > 1 and compare(arr[i], arr[math.floor(i / 2)]) do\n            arr[i], arr[math.floor(i / 2)] = arr[math.floor(i / 2)], arr[i]\n            i = math.floor(i / 2)\n        end\n    end\n    local function heap_pop(arr)\n        local val = arr[1]\n        arr[1] = arr[#arr]\n        arr[#arr] = nil\n        heapify(arr, 1, #arr)\n        return val\n    end\n    local function heap_top(arr)\n        return arr[1]\n    end\n    local function heap_empty(arr)\n        return #arr == 0\n    end\n    local function heap_size(arr)\n        return #arr\n    end\n    local function",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i][1] + heap[i][2] >= heap[parent][1] + heap[parent][2] then\n        break\n      end\n      heap[i], heap[parent] = heap[parent], heap[i]\n      i = parent\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local child = i * 2\n      if child + 1 <= #heap and heap[child + 1][1] + heap[child + 1][2] < heap[child][1] + heap[child][2] then\n        child = child + 1\n      end\n      if heap[i][1] + heap[i][2] <= heap[child][1] + heap[child][2] then\n        break\n      end\n      heap[i], heap[child] = heap[child], heap[i]\n      i = child\n    end\n    return ret\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      if #heap < k then\n        heap_push(heap, {nums1[i], nums2[j]})\n      elseif nums1[i] + nums2[j] < heap[1][1] + heap[1][2] then\n        heap_pop(heap)\n        heap_push(heap, {nums1[i], nums2[j]})\n      else\n        break\n      end\n    end\n  end\n  local ret = {}\n  for i = 1, #heap do\n    table.insert(ret, heap[i])\n  end\n  return ret\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 and heap[i][3] < heap[i // 2][3] do\n        heap[i], heap[i // 2] = heap[i // 2], heap[i]\n        i = i // 2\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n          j = j + 1\n        end\n        if heap[i][3] <= heap[j][3] then\n          break\n        end\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  local result = {}\n  while #heap > 0 do\n    local i, j, sum = table.unpack(table.remove(heap, 1))\n    result[#result + 1] = {nums1[i], nums1[j]}\n    if j + 1 <= #nums2 then\n      push(i, j + 1)\n    end\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local function heap_pop(heap)\n        local last = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local l = i * 2\n            local r = i * 2 + 1\n            if r <= #heap then\n                if heap[l][1] < heap[r][1] then\n                    if heap[i][1] > heap[l][1] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    if heap[i][1] > heap[r][1] then\n                        heap[i], heap[r] = heap[r], heap[i]\n                        i = r\n                    else\n                        break\n                    end\n                end\n            else\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            end\n        end\n        return last\n    end",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > heap[i][3] then\n          heap[p], heap[i] = heap[i], heap[p]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = i * 2 + 1\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          l = r\n        end\n        if heap[i][3] > heap[l][3] then\n          heap[i], heap[l] = heap[l], heap[i]\n          i = l\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local res = {}\n  for i = 1, #heap do\n    res[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return res\nend",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then return res end\n  local heap = {}\n  local function push(x, y, val)\n    table.insert(heap, {x, y, val})\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][3] > heap[i][3] then\n        heap[j], heap[i] = heap[i], heap[j]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n        j = j + 1\n      end\n      if heap[i][3] > heap[j][3] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  push(1, 1, nums1[1] + nums2[1])\n  while #res < k and #heap > 0 do\n    local x, y, val = unpack(pop())\n    table.insert(res, {nums1[x], nums2[y]})\n    if x < len1 and y < len2 then\n      push(x, y + 1, nums1[x] + nums2[y + 1])\n    end\n    if x < len1 and y == 1 then\n      push(x + 1, y, nums1[x + 1] + nums2[y])\n    end\n  end\n  return res\nend",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] < nums2[j] then\n        res[#res+1] = nums1[i]\n        i = i + 1\n      else\n        res[#res+1] = nums2[j]\n        j = j + 1\n      end\n    end\n    while i <= m do\n      res[#res+1] = nums1[i]\n      i = i + 1\n    end\n    while j <= n do\n      res[#res+1] = nums2[j]\n      j = j + 1\n    end\n    return res\n  end",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    return res\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end",
    "  local function compare(a, b)\n    return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n  end\n  local function push(heap, nums1, nums2, i, j)\n    if i <= #nums1 and j <= #nums2 then\n      table.insert(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    push(heap, nums1, nums2, i, 1)\n  end\n  table.sort(heap, compare)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local pair = table.remove(heap, 1)\n    table.insert(result, pair[2])\n    push(heap, nums1, nums2, pair[2][1], pair[2][2] + 1)\n    table.sort(heap, compare)\n    k = k - 1\n  end\n  return result\nend",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local res = {}\n    for i = 1, k do\n        table.insert(res, pairs[i])\n    end\n    return res\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local pair = table.remove(heap, 1)\n    result[#result + 1] = {nums1[pair[2]], nums2[pair[3]]}\n    push(pair[2], pair[3] + 1)\n    push(pair[2] + 1, pair[3])\n    k = k - 1\n  end\n  return result\nend",
    "\tlocal res = {}\n\tlocal len1 = #nums1\n\tlocal len2 = #nums2\n\tif len1 == 0 or len2 == 0 then\n\t\treturn res\n\tend\n\tlocal heap = {}\n\tlocal function push(x, y, val)\n\t\tlocal p = #heap + 1\n\t\theap[p] = {x, y, val}\n\t\twhile p > 1 do\n\t\t\tlocal q = math.floor(p / 2)\n\t\t\tif heap[q][3] > val then\n\t\t\t\theap[p], heap[q] = heap[q], heap[p]\n\t\t\t\tp = q\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function pop()\n\t\tlocal p = 1\n\t\tlocal ret = heap[p]\n\t\theap[p] = heap[#heap]\n\t\theap[#heap] = nil\n\t\twhile 2 * p <= #heap do\n\t\t\tlocal q = 2 * p\n\t\t\tif q + 1 <= #heap and heap[q + 1][3] < heap[q][3] then\n\t\t\t\tq = q + 1\n\t\t\tend\n\t\t\tif heap[p][3] > heap[q][3] then\n\t\t\t\theap[p], heap[q] = heap[q], heap[p]\n\t\t\t\tp = q\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn ret\n\tend\n\tpush(1, 1, nums1[1] + nums2[1])\n\twhile #res < k and #heap > 0 do\n\t\tlocal x, y, val = table.unpack(pop())\n\t\tres[#res + 1] = {nums1[x], nums2[y]}\n\t\tif y + 1 <= len2 then\n\t\t\tpush(x, y + 1, nums1[x] + nums2[y + 1])\n\t\tend\n\t\tif y == 1 and x + 1 <= len1 then\n\t",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] < nums2[j] then\n        table.insert(res, {nums1[i], nums2[j]})\n        i = i + 1\n      else\n        table.insert(res, {nums1[i], nums2[j]})\n        j = j + 1\n      end\n    end\n    while i <= m do\n      table.insert(res, {nums1[i], nums2[j]})\n      i = i + 1\n    end\n    while j <= n do\n      table.insert(res, {nums1[i], nums2[j]})\n      j = j + 1\n    end\n    return res\n  end\n  local res = merge(nums1, nums2)\n  local function partition(res, l, r)\n    local pivot = res[l][1] + res[l][2]\n    local i = l + 1\n    for j = l + 1, r do\n      if res[j][1] + res[j][2] < pivot then\n        res[i], res[j] = res[j], res[i]\n        i = i + 1\n      end\n    end\n    res[l], res[i - 1] = res[i - 1], res[l]\n    return i - 1\n  end\n  local function quick_select(res, l, r, k)\n    if l == r then return end\n    local p = partition(res, l, r)\n    if p == k then return end\n    if p > k then\n      quick_select(res, l, p - 1, k)\n    else\n      quick_select(res, p + 1, r, k)\n    end\n  end\n  quick_select(res, 1, #res, k)\n  return res\nend",
    "  local function heap_push(heap, val)\n    local i = #heap + 1\n    heap[i] = val\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][1] + heap[p][2] <= heap[i][1] + heap[i][2] then\n        break\n      end\n      heap[i], heap[p] = heap[p], heap[i]\n      i = p\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1][1] + heap[j + 1][2] < heap[j][1] + heap[j][2] then\n        j = j + 1\n      end\n      if heap[i][1] + heap[i][2] <= heap[j][1] + heap[j][2] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n    return ret\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i], nums2[j]})\n      if #heap > k then\n        heap_pop(heap)\n      end\n    end\n  end\n  local ret = {}\n  for i = 1, #heap do\n    ret[i] = heap[i]\n  end\n  return ret\nend",
    "  local function heap_pop(heap)\n    local result = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while true do\n        local left = i * 2\n        local right = left + 1\n        local smallest = i\n        if left <= #heap and heap[left][1] < heap[smallest][1] then\n          smallest = left\n        end\n        if right <= #heap and heap[right][1] < heap[smallest][1] then\n          smallest = right\n        end\n        if smallest == i then\n          break\n        end\n        heap[i], heap[smallest] = heap[smallest], heap[i]\n        i = smallest\n      end\n    end\n    return result\n  end",
    "    local len1, len2 = #nums1, #nums2\n    if len1 == 0 or len2 == 0 then return {} end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap_push(heap, {sum, i, j})\n        else\n            if sum < heap[1][1] then\n                heap_pop(heap)\n                heap_push(heap, {sum, i, j})\n            end\n        end\n    end\n    push(1, 1)\n    local res = {}\n    while #heap > 0 do\n        local _, i, j = unpack(heap_pop(heap))\n        res[#res + 1] = {nums1[i], nums2[j]}\n        if j < len2 then\n            push(i, j + 1)\n        end\n        if j == 1 and i < len1 then\n            push(i + 1, 1)\n        end\n    end\n    return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        table.insert(res, {nums1[heap[i][1]], nums2[heap[i][2]]})\n    end\n    return res\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(heap, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(heap, compare)\n    local res = {}\n    for i = 1, k do\n        table.insert(res, heap[i])\n    end\n    return res\nend",
    "  local res = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(res, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  return res\nend",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][1] > heap[i][1] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > sum then\n          heap[i], heap[p] = heap[p], heap[i]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = i * 2 + 1\n        local j = l\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          j = r\n        end\n        if heap[i][3] > heap[j][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local res = {}\n  for i = 1, #heap do\n    table.insert(res, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return res\nend",
    "    if not nums1 or not nums2 or #nums1 == 0 or #nums2 == 0 then\n        return {}\n    end",
    "    local function heap_push(heap, val)\n        heap[#heap + 1] = val\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] + heap[j][2] > heap[i][1] + heap[i][2] then\n                heap[j], heap[i] = heap[i], heap[j]\n                i = j\n            else\n                break\n            end\n        end\n    end",
    "  local function heap_pop(heap)\n    local last = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j < #heap and heap[j + 1][1] < heap[j][1] then\n        j = j + 1\n      end\n      if last[1] <= heap[j][1] then\n        break\n      end\n      heap[i] = heap[j]\n      i = j\n    end\n    heap[i] = last\n    return heap\n  end\n  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] <= heap[i][1] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n    return heap\n  end\n  local function heap_top(heap)\n    return heap[1]\n  end\n  local function heap_size(heap)\n    return #heap\n  end\n  local function heap_empty(heap)\n    return #heap == 0\n  end\n  local function heap_clear(heap)\n    heap = {}\n    return heap\n  end\n  local function heap_new()\n    return {}\n  end\n  local heap = heap_new()\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      if heap_size(heap) < k then\n        heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n      else\n        if nums1[i] + nums2[j] < heap_top(heap)[1] then\n          heap_pop(heap)\n          heap_push(heap, {nums1[i] + nums2[j], {nums1[i], num",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {i, j, nums1[i] + nums2[j]}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[3] < b[3] end)\n  local result = {}\n  for i = 1, k do\n    if #heap == 0 then break end\n    local pair = table.remove(heap, 1)\n    result[#result + 1] = {nums1[pair[1]], nums2[pair[2]]}\n    push(pair[1], pair[2] + 1)\n    if pair[2] == 1 then\n      push(pair[1] + 1, 1)\n    end\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i, v1 in ipairs(nums1) do\n        for j, v2 in ipairs(nums2) do\n            table.insert(pairs, {v1, v2})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] + heap[j][2] <= heap[i][1] + heap[i][2] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n    end",
    "  local function compare(a, b)\n    return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n  end\n  local function push(heap, nums1, nums2, i, j)\n    if i <= #nums1 and j <= #nums2 then\n      table.insert(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    push(heap, nums1, nums2, i, 1)\n  end\n  table.sort(heap, compare)\n  local result = {}\n  for i = 1, k do\n    if #heap == 0 then\n      break\n    end\n    local pair = table.remove(heap, 1)\n    table.insert(result, pair[2])\n    push(heap, nums1, nums2, pair[2][1], pair[2][2] + 1)\n    table.sort(heap, compare)\n  end\n  return result\nend",
    "  local function heap_pop(heap)\n    local ret = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n          j = j + 1\n        end\n        if heap[j][1] < last[1] then\n          heap[i] = heap[j]\n          i = j\n        else\n          break\n        end\n      end\n      heap[i] = last\n    end\n    return ret\n  end",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    table.sort(heap, function(a, b) return a[1] < b[1] end)\n    local res = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        local pair = table.remove(heap, 1)\n        res[#res + 1] = {nums1[pair[2]], nums2[pair[3]]}\n        push(pair[2], pair[3] + 1)\n    end\n    return res\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i][1] + heap[i][2] > heap[left][1] + heap[left][2] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                local min_idx = i\n                if heap[left][1] + heap[left][2] < heap[min_idx][1] + heap[min_idx][2] then\n                    min_idx = left\n                end\n                if heap[right][1] + heap[right][2] < heap[min_idx][1] + heap[min_idx][2] then\n                    min_idx = right\n                end\n                if min_idx == i then\n                    break\n                else\n                    heap[i], heap[min_idx] = heap[min_idx], heap[i]\n                    i = min_idx\n                end\n            end\n        end\n        return ret\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            if #heap < k then\n                heap_push(heap, {nums1[i], nums2[j]})\n           ",
    "  local len1, len2 = #nums1, #nums2\n  if len1 == 0 or len2 == 0 then return {} end\n  local heap = {}\n  local function push(i, j)\n    local val = nums1[i] + nums2[j]\n    if #heap < k then\n      heap_push(heap, val, {i, j})\n    elseif val < heap[1][1] then\n      heap_pop(heap)\n      heap_push(heap, val, {i, j})\n    end\n  end\n  push(1, 1)\n  local res = {}\n  while #heap > 0 do\n    local _, {i, j} = heap_pop(heap)\n    table.insert(res, {nums1[i], nums2[j]})\n    if j < len2 then\n      push(i, j + 1)\n    elseif i < len1 then\n      push(i + 1, 1)\n    end\n  end\n  return res\nend",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end\n    local function push(heap, elem)\n        table.insert(heap, elem)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if compare(heap[i], heap[j]) then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function pop(heap)\n        local res = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and compare(heap[j + 1], heap[j]) then\n                j = j + 1\n            end\n            if compare(heap[j], heap[i]) then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return res\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(heap, {nums1[i] + nums2[j], nums1[i], nums2[j]})\n            if #heap > k then\n                pop(heap)\n            end\n        end\n    end\n    local res = {}\n    while #heap > 0 do\n        local elem = pop(heap)\n        table.insert(res, {elem[2], elem[3]})\n    end\n    return res\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  local function compare(a, b)\n    return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i] + nums2[j], i, j})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, {nums1[pairs[i][2]], nums2[pairs[i][3]]})\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap + 1] = {i, j, sum}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                if r <= #heap and heap[l][3] > heap[r][3] then\n                    l = r\n                end\n                if heap[i][3] > heap[l][3] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return result\nend",
    "    local len1, len2 = #nums1, #nums2\n    if len1 == 0 or len2 == 0 or k == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(x, y)\n        local sum = nums1[x] + nums2[y]\n        if #heap < k then\n            table.insert(heap, {x, y, sum})\n        elseif sum < heap[1][3] then\n            heap[1] = {x, y, sum}\n        end\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][3] > heap[i][3] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        local x, y = ret[1], ret[2]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n                j = j + 1\n            end\n            if heap[i][3] > heap[j][3] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local ret = {}\n    while #ret < k and #heap > 0 do\n        local x, y, sum = pop()\n        table.insert(ret, {nums1[x], nums2[y]})\n        if y + 1 <= len2 then\n            push(x, y + 1)\n        end\n    end\n    return ret\nend",
    "    local function merge(nums1, nums2)\n        local result = {}\n        local i, j = 1, 1\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(result, nums1[i])\n                i = i + 1\n            else\n                table.insert(result, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(result, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(result, nums2[j])\n            j = j + 1\n        end\n        return result\n    end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] + heap[j][2] <= heap[i][1] + heap[i][2] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n  end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local res = {}\n    for i = 1, k do\n        table.insert(res, pairs[i])\n    end\n    return res\nend",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] < nums2[j] then\n        res[#res + 1] = {nums1[i], nums2[j]}\n        i = i + 1\n      else\n        res[#res + 1] = {nums1[i], nums2[j]}\n        j = j + 1\n      end\n    end\n    while i <= m do\n      res[#res + 1] = {nums1[i], nums2[j]}\n      i = i + 1\n    end\n    while j <= n do\n      res[#res + 1] = {nums1[i], nums2[j]}\n      j = j + 1\n    end\n    return res\n  end",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local res = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end\n    local function merge_sort(nums)\n        if #nums <= 1 then return nums end\n        local mid = math.floor(#nums / 2)\n        local left = merge_sort(nums, 1, mid)\n        local right = merge_sort(nums, mid + 1, #nums)\n        return merge(left, right)\n    end\n    local function find_k_smallest_pairs(nums1, nums2, k)\n        local res = {}\n        for i = 1, #nums1 do\n            for j = 1, #nums2 do\n                table.insert(res, {nums1[i], nums2[j]})\n            end\n        end\n        local function cmp(a, b)\n            return a[1] + a[2] < b[1] + b[2]\n        end\n        table.sort(res, cmp)\n        local k_res = {}\n        for i = 1, k do\n            table.insert(k_res, res[i])\n        end\n        return k_res\n    end\n    nums1 = merge_sort(nums1)\n    nums2 = merge_sort(nums2)\n    return find_k_smallest_pairs(nums1, nums2, k)\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local function add_pair(a, b)\n        local pairs = {}\n        for i = 1, #a do\n            for j = 1, #b do\n                table.insert(pairs, {a[i], b[j]})\n            end\n        end\n        table.sort(pairs, compare)\n        return pairs\n    end\n    local pairs = add_pair(nums1, nums2)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k or sum < heap[1][1] then\n      heapq.heappush(heap, {sum, i, j})\n      if #heap > k then\n        heapq.heappop(heap)\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  local result = {}\n  while #heap > 0 do\n    local _, i, j = table.unpack(heapq.heappop(heap))\n    table.insert(result, {nums1[i], nums2[j]})\n    if j < #nums2 then\n      push(i, j + 1)\n    end\n  end\n  return result\nend",
    "  local function _k_smallest_pairs(nums1, nums2, k, i, j, pairs)\n    if k == 0 then return pairs end\n    if i == #nums1 or j == #nums2 then return pairs end\n    local pair = {nums1[i], nums2[j]}\n    table.insert(pairs, pair)\n    local next_i, next_j = i, j\n    if j == #nums2 then\n      next_i = i + 1\n      next_j = 1\n    else\n      next_j = j + 1\n    end\n    return _k_smallest_pairs(nums1, nums2, k - 1, next_i, next_j, pairs)\n  end\n  return _k_smallest_pairs(nums1, nums2, k, 1, 1, {})\nend",
    "  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then\n    return {}\n  end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local index = #heap\n      while index > 1 do\n        local parent = math.floor(index / 2)\n        if heap[parent][3] > sum then\n          heap[index], heap[parent] = heap[parent], heap[index]\n          index = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local index = 1\n      while index * 2 <= #heap do\n        local left = index * 2\n        local right = left + 1\n        local child = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          child = right\n        end\n        if heap[child][3] < sum then\n          heap[index], heap[child] = heap[child], heap[index]\n          index = child\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, math.min(len1, k) do\n    push(i, 1)\n  end\n  local result = {}\n  while #heap > 0 do\n    local pair = table.remove(heap, 1)\n    table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n    if pair[2] < len2 then\n      push(pair[1], pair[2] + 1)\n    end\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local function merge(a, b)\n    local i, j, m, n = 1, 1, #a, #b\n    local c = {}\n    while i <= m and j <= n do\n      if a[i] < b[j] then\n        c[#c + 1] = a[i]\n        i = i + 1\n      else\n        c[#c + 1] = b[j]\n        j = j + 1\n      end\n    end\n    while i <= m do\n      c[#c + 1] = a[i]\n      i = i + 1\n    end\n    while j <= n do\n      c[#c + 1] = b[j]\n      j = j + 1\n    end\n    return c\n  end\n  local function merge_sort(a)\n    local n = #a\n    if n <= 1 then\n      return a\n    end\n    local m = math.floor(n / 2)\n    local b = merge_sort(a, 1, m)\n    local c = merge_sort(a, m + 1, n)\n    return merge(b, c)\n  end\n  local function find_k_smallest_pairs(a, b, k)\n    local m, n = #a, #b\n    local c = {}\n    for i = 1, m do\n      for j = 1, n do\n        c[#c + 1] = a[i] + b[j]\n      end\n    end\n    c = merge_sort(c)\n    local d = {}\n    for i = 1, k do\n      d[#d + 1] = c[i]\n    end\n    return d\n  end\n  return find_k_smallest_pairs(nums1, nums2, k)\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] + heap[p][2] > heap[i][1] + heap[i][2] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local l = i * 2\n            local r = i * 2 + 1\n            local min_i = i\n            if heap[l][1] + heap[l][2] < heap[min_i][1] + heap[min_i][2] then\n                min_i = l\n            end\n            if r <= #heap and heap[r][1] + heap[r][2] < heap[min_i][1] + heap[min_i][2] then\n                min_i = r\n            end\n            if min_i ~= i then\n                heap[i], heap[min_i] = heap[min_i], heap[i]\n                i = min_i\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i], nums2[j]})\n            if #heap > k then\n                heap_pop(heap)\n            end\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        table.insert(ret, 1, heap_pop(heap))\n    end\n    return ret\nend",
    "    local res = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return res\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > sum then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= k do\n                local l = i * 2\n                local r = i * 2 + 1\n                local min = l\n                if r <= k and heap[r][3] < heap[l][3] then\n                    min = r\n                end\n                if heap[min][3] < heap[i][3] then\n                    heap[i], heap[min] = heap[min], heap[i]\n                    i = min\n                else\n                    break\n                end\n            end\n        end\n    end\n    push(1, 1)\n    for i = 1, k do\n        local h = heap[1]\n        if h == nil then\n            break\n        end\n        table.insert(res, {nums1[h[1]], nums2[h[2]]})\n        if h[2] < len2 then\n            push(h[1], h[2] + 1)\n        end\n        if h[2] == 1 and h[1] < len1 then\n            push(h[1] + 1, 1)\n        end\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local l = i * 2",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap + 1] = {i, j, sum}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local p = l\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    p = r\n                end\n                if heap[p][3] < sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        res[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return res\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local len1, len2 = #nums1, #nums2\n    if len1 == 0 or len2 == 0 then return {} end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= k do\n                local l, r = i * 2, i * 2 + 1\n                local min_i = l\n                if r <= k and heap[r][3] < heap[l][3] then\n                    min_i = r\n                end\n                if heap[min_i][3] < heap[i][3] then\n                    heap[i], heap[min_i] = heap[min_i], heap[i]\n                    i = min_i\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(k, len1) do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then break end\n        local pair = heap[1]\n        table.remove(heap, 1)\n        table.insert(ret, {nums1[pair[1]], nums2[pair[2]]})\n        if pair[2] < len2 then\n            push(pair[1], pair[2] + 1)\n        end\n    end\n    return ret\nend",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then\n    return res\n  end\n  local function insert(nums, num)\n    local len = #nums\n    if len == 0 then\n      nums[1] = num\n      return\n    end\n    local i = 1\n    while i <= len do\n      if nums[i][1] + nums[i][2] > num[1] + num[2] then\n        break\n      end\n      i = i + 1\n    end\n    if i <= len then\n      for j = len, i, -1 do\n        nums[j + 1] = nums[j]\n      end\n      nums[i] = num\n    else\n      nums[len + 1] = num\n    end\n  end\n  for i = 1, len1 do\n    for j = 1, len2 do\n      insert(res, {nums1[i], nums2[j]})\n      if #res > k then\n        table.remove(res)\n      end\n    end\n  end\n  return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        else\n            if heap[1][3] > sum then\n                heap[1] = {i, j, sum}\n                local i = 1\n                while i * 2 <= #heap do\n                    local l = i * 2\n                    local r = l + 1\n                    if r <= #heap and heap[r][3] < heap[l][3] then\n                        l = r\n                    end\n                    if heap[i][3] > heap[l][3] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                        i = l\n                    else\n                        break\n                    end\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        local h = heap[i]\n        table.insert(res, {nums1[h[1]], nums2[h[2]]})\n    end\n    return res\nend",
    "  local len1, len2 = #nums1, #nums2\n  if len1 == 0 or len2 == 0 then return {} end\n  if k == 0 then return {} end\n  if k > len1 * len2 then k = len1 * len2 end",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        else\n            if heap[1][3] > sum then\n                heap[1] = {i, j, sum}\n                local i = 1\n                while i * 2 <= #heap do\n                    local l = i * 2\n                    local r = i * 2 + 1\n                    if r <= #heap and heap[r][3] < heap[l][3] then\n                        l = r\n                    end\n                    if heap[i][3] > heap[l][3] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                        i = l\n                    else\n                        break\n                    end\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n    end\n    return result\nend",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local function get_next(i, j)\n        if j < #nums2 then\n            return i, j + 1\n        elseif i < #nums1 then\n            return i + 1, 1\n        else\n            return nil\n        end\n    end",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end",
    "    local heap = {}\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] + heap[j][2] > heap[i][1] + heap[i][2] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][1] + heap[j + 1][2] < heap[j][1] + heap[j][2] then\n                j = j + 1\n            end\n            if heap[i][1] + heap[i][2] > heap[j][1] + heap[j][2] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local function heap_top(heap)\n        return heap[1]\n    end\n    local function heap_empty(heap)\n        return #heap == 0\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            if #heap < k then\n                heap_push(heap, {nums1[i], nums2[j]})\n            else\n                local top = heap_top(heap)\n                if nums1[i] + nums2[j] < top[1] + top[2] then\n                    heap_pop(heap)\n                    heap_push(heap, {nums1[i], nums2[j]})\n                end\n            end\n        end\n    end\n    local ret =",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        local pos = #heap + 1\n        heap[pos] = {i, j, sum}\n        local parent = math.floor(pos / 2)\n        while parent > 0 and heap[parent][3] > sum do\n            heap[parent], heap[pos] = heap[pos], heap[parent]\n            pos = parent\n            parent = math.floor(pos / 2)\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        local pos = 1\n        local child = pos * 2\n        while child < #heap do\n            if child + 1 < #heap and heap[child + 1][3] < heap[child][3] then\n                child = child + 1\n            end\n            if heap[child][3] < heap[#heap][3] then\n                heap[pos], heap[child] = heap[child], heap[pos]\n                pos = child\n                child = pos * 2\n            else\n                break\n            end\n        end\n        heap[pos] = heap[#heap]\n        heap[#heap] = nil\n        return ret\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        local pair = pop()\n        if not pair then\n            break\n        end\n        table.insert(ret, {nums1[pair[1]], nums2[pair[2]]})\n        if pair[2] < len2 then\n            push(pair[1], pair[2] + 1)\n        end\n    end\n    return ret\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] + heap[p][2] <= heap[i][1] + heap[i][2] then\n                break\n            end\n            heap[i], heap[p] = heap[p], heap[i]\n            i = p\n        end\n    end",
    "    local function heap_pop(heap)\n        local last = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            end\n            if right > #heap then\n                if heap[i][1] > heap[left][1] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            end\n            if heap[i][1] > heap[left][1] or heap[i][1] > heap[right][1] then\n                if heap[left][1] < heap[right][1] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                    i = left\n                else\n                    heap[i], heap[right] = heap[right], heap[i]\n                    i = right\n                end\n            else\n                break\n            end\n        end\n        return last\n    end\n    local function heap_push(heap, item)\n        heap[#heap + 1] = item\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i][1] < heap[parent][1] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        heap_push(heap, {nums1[i] + nums2[1], i, 1})\n    end\n    local result = {}\n    while k > 0 and #heap > 0 do\n        local item = heap_pop(heap)\n        result[#result + 1] = {nums1[item[2]], nums2[item[3]]}\n        if item[3] < #nums2 then\n            heap_push(heap, {nums1[item[2]] + nums2[item[3]",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        table.insert(res, {nums1[heap[i][1]], nums2[heap[i][2]]})\n    end\n    return res\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local last = table.remove(heap)\n        local i = 1\n        while 2 * i <= #heap do\n            local j = 2 * i\n            if j + 1 <= #heap and heap[j + 1] < heap[j] then\n                j = j + 1\n            end\n            if last <= heap[j] then\n                break\n            end\n            heap[i] = heap[j]\n            i = j\n        end\n        heap[i] = last\n        return ret\n    end",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  if #nums1 == 0 or #nums2 == 0 then return {} end\n  local heap = {}\n  local res = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > heap[i][3] then\n          heap[i], heap[p] = heap[p], heap[i]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = i * 2 + 1\n        local min = l\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          min = r\n        end\n        if heap[i][3] > heap[min][3] then\n          heap[i], heap[min] = heap[min], heap[i]\n          i = min\n        else\n          break\n        end\n      end\n    end\n  end\n  push(1, 1)\n  while #res < k and #heap > 0 do\n    local i, j, sum = table.unpack(table.remove(heap, 1))\n    table.insert(res, {nums1[i], nums2[j]})\n    if j < #nums2 then\n      push(i, j + 1)\n    end\n  end\n  return res\nend",
    "  local function heap_pop(heap)\n    local last = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local j = i * 2\n      if j < #heap and heap[j][1] > heap[j + 1][1] then\n        j = j + 1\n      end\n      if last[1] <= heap[j][1] then\n        break\n      end\n      heap[i] = heap[j]\n      i = j\n    end\n    heap[i] = last\n    return last\n  end\n  local function heap_push(heap, item)\n    heap[#heap + 1] = item\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] <= heap[i][1] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    heap_push(heap, {nums1[i] + nums2[1], i, 1})\n  end\n  local result = {}\n  for i = 1, k do\n    if #heap == 0 then\n      break\n    end\n    local item = heap_pop(heap)\n    result[i] = {nums1[item[2]], nums2[item[3]]}\n    if item[3] < #nums2 then\n      heap_push(heap, {nums1[item[2]] + nums2[item[3] + 1], item[2], item[3] + 1})\n    end\n  end\n  return result\nend"
  ]
}