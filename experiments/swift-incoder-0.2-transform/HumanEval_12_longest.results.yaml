language: swift
name: HumanEval_12_longest
results:
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if s.count\
    \ > longest.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8897a3ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8897735561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8897735286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b889773513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8897734bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8897534fc3 <unavailable> + 188355

    6    tmp2suoruxj                        0x0000558e7decadd2 <unavailable> + 7634

    7    tmp2suoruxj                        0x0000558e7deca590 <unavailable> + 5520

    8    libc.so.6                          0x00002b8897c2a460 __libc_start_main +
    245

    9    tmp2suoruxj                        0x0000558e7deca299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpktjg3655.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count { longest = s }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if longest.count < string.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpflrw94hu.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if longest.count < string.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpflrw94hu.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpktjg3655.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if longest.count < string.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longestStringLength)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp673ujon6.swift:11:29: error: cannot find 'longestStringLength'\
    \ in scope\n    return longest(strings, longestStringLength)\n               \
    \             ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp673ujon6.swift:11:29: error: extra\
    \ argument in call\n    return longest(strings, longestStringLength)\n       \
    \           ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.map(String.init))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpph6nb4za.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.map(String.init))\n                   ^\n\
    \                   strings: \n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if longest.count < string.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpflrw94hu.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count { longest = s }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aafc92e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafc8fdb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafc8fdb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafc8fdb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafc8fdabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aafc8ddafc3 <unavailable> + 188355

    6    tmp3oeyxm2e                        0x00005606409eddd2 <unavailable> + 7634

    7    tmp3oeyxm2e                        0x00005606409ed590 <unavailable> + 5520

    8    libc.so.6                          0x00002aafc94d0460 __libc_start_main +
    245

    9    tmp3oeyxm2e                        0x00005606409ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpktjg3655.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpktjg3655.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = \"\"\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpsjouo92k/tmpsjouo92k.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43df7ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43df4e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43df4e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43df4e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsjouo92k                        0x000055ee1257e628 <unavailable> + 5672

    5    libc.so.6                          0x00002b43df9d7460 __libc_start_main +
    245

    6    tmpsjouo92k                        0x000055ee1257e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for string in strings {\n        if longest.count\
    \ < string.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b57de17bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57dde72561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b57dde72286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b57dde7213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b57dde71bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b57ddc71fc3 <unavailable> + 188355

    6    tmphtmoccw9                        0x00005625cc102dd2 <unavailable> + 7634

    7    tmphtmoccw9                        0x00005625cc102590 <unavailable> + 5520

    8    libc.so.6                          0x00002b57de367460 __libc_start_main +
    245

    9    tmphtmoccw9                        0x00005625cc102299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if longest.count < string.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpflrw94hu.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpr54gd4p_.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for s in strings {\n        if longest.count < s.count {\n\
    \            longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpk57m0604.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aafc92e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafc8fdb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafc8fdb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafc8fdb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafc8fdabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aafc8ddafc3 <unavailable> + 188355

    6    tmp3oeyxm2e                        0x00005606409eddd2 <unavailable> + 7634

    7    tmp3oeyxm2e                        0x00005606409ed590 <unavailable> + 5520

    8    libc.so.6                          0x00002aafc94d0460 __libc_start_main +
    245

    9    tmp3oeyxm2e                        0x00005606409ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aafc92e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafc8fdb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafc8fdb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafc8fdb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafc8fdabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aafc8ddafc3 <unavailable> + 188355

    6    tmp3oeyxm2e                        0x00005606409eddd2 <unavailable> + 7634

    7    tmp3oeyxm2e                        0x00005606409ed590 <unavailable> + 5520

    8    libc.so.6                          0x00002aafc94d0460 __libc_start_main +
    245

    9    tmp3oeyxm2e                        0x00005606409ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aafc92e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafc8fdb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafc8fdb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafc8fdb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafc8fdabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aafc8ddafc3 <unavailable> + 188355

    6    tmp3oeyxm2e                        0x00005606409eddd2 <unavailable> + 7634

    7    tmp3oeyxm2e                        0x00005606409ed590 <unavailable> + 5520

    8    libc.so.6                          0x00002aafc94d0460 __libc_start_main +
    245

    9    tmp3oeyxm2e                        0x00005606409ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if longest.count < string.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpflrw94hu.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpvwwcbroy.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings.reduce(\"\
    \") { $0 + $1 }\n    return strings.first { $0.count == longest.count }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpqmyfquau/tmpqmyfquau.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfaa493c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfaa18ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfaa18a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfaa1897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqmyfquau                        0x000055e8f65519aa <unavailable> + 6570

    5    libc.so.6                          0x00002abfaa67f460 __libc_start_main +
    245

    6    tmpqmyfquau                        0x000055e8f6551299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpktjg3655.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for s in strings {\n        if longest.count < s.count {\n\
    \            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpjihp2tdz.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings.reduce(\"\
    \") { (result, string) in\n        return result.characters.count < string.characters.count\
    \ ? result : string\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmhcflcxy.swift:13:23: error: 'characters' is unavailable: Please\
    \ use String directly\n        return result.characters.count < string.characters.count\
    \ ? result : string\n                      ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpmhcflcxy.swift:13:49: error: 'characters'\
    \ is unavailable: Please use String directly\n        return result.characters.count\
    \ < string.characters.count ? result : string\n                              \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if longest.count < string.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpjifay0jm.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8stnccsw.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count { longest = s }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpr54gd4p_.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpktjg3655.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8stnccsw.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for s in strings {\n        if longest.count < s.count {\n\
    \            longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpk57m0604.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longestStringLength)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp673ujon6.swift:11:29: error: cannot find 'longestStringLength'\
    \ in scope\n    return longest(strings, longestStringLength)\n               \
    \             ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp673ujon6.swift:11:29: error: extra\
    \ argument in call\n    return longest(strings, longestStringLength)\n       \
    \           ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = \"\"\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpsjouo92k/tmpsjouo92k.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43df7ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43df4e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43df4e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43df4e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsjouo92k                        0x000055ee1257e628 <unavailable> + 5672

    5    libc.so.6                          0x00002b43df9d7460 __libc_start_main +
    245

    6    tmpsjouo92k                        0x000055ee1257e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpiw90kss4.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpvwwcbroy.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longestStringLength)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp673ujon6.swift:11:29: error: cannot find 'longestStringLength'\
    \ in scope\n    return longest(strings, longestStringLength)\n               \
    \             ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp673ujon6.swift:11:29: error: extra\
    \ argument in call\n    return longest(strings, longestStringLength)\n       \
    \           ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count < string.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aafc92e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafc8fdb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafc8fdb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafc8fdb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafc8fdabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aafc8ddafc3 <unavailable> + 188355

    6    tmp3oeyxm2e                        0x00005606409eddd2 <unavailable> + 7634

    7    tmp3oeyxm2e                        0x00005606409ed590 <unavailable> + 5520

    8    libc.so.6                          0x00002aafc94d0460 __libc_start_main +
    245

    9    tmp3oeyxm2e                        0x00005606409ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(into:\
    \ \"\") { $0.isEmpty ? $1 : $0 + $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmplihnxut5/tmplihnxut5.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad235d68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad235a5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad235a5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad235a5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplihnxut5                        0x000055758104094a <unavailable> + 6474

    5    libc.so.6                          0x00002ad235f54460 __libc_start_main +
    245

    6    tmplihnxut5                        0x0000557581040239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if s.count > longest.count {\n \
    \           longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpo06u7xs9.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuvevd4j.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpsuvevd4j.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aafc92e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafc8fdb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafc8fdb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafc8fdb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafc8fdabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aafc8ddafc3 <unavailable> + 188355

    6    tmp3oeyxm2e                        0x00005606409eddd2 <unavailable> + 7634

    7    tmp3oeyxm2e                        0x00005606409ed590 <unavailable> + 5520

    8    libc.so.6                          0x00002aafc94d0460 __libc_start_main +
    245

    9    tmp3oeyxm2e                        0x00005606409ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for s in strings {\n        if longest.count < s.count {\n \
    \           longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8stnccsw.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, 0)\n                  ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings.reduce(\"\
    \") { $0 + $1 }\n    return strings.first { $0.count == longest.count }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpqmyfquau/tmpqmyfquau.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfaa493c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfaa18ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfaa18a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfaa1897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqmyfquau                        0x000055e8f65519aa <unavailable> + 6570

    5    libc.so.6                          0x00002abfaa67f460 __libc_start_main +
    245

    6    tmpqmyfquau                        0x000055e8f6551299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013948
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvddtnld.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count { longest = s }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013948
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
