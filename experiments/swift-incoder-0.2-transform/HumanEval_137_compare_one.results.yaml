language: swift
name: HumanEval_137_compare_one
results:
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_):\n    case\
    \ .intValue(_):\n        return b\n    case .doubleValue(_):\n        return b\n\
    \    case .stringValue(_):\n        return b\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpypvfdvez/tmpypvfdvez.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b744cb6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b744c861b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b744c861988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b744c8607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpypvfdvez                        0x00005566b4dbb01a <unavailable> + 12314

    5    libc.so.6                          0x00002b744cd56460 __libc_start_main +
    245

    6    tmpypvfdvez                        0x00005566b4db9499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .doubleValue(_):\n            return b // b is\
    \ larger\n        case .stringValue(_):\n            return a // a is larger\n\
    \        case .stringValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .stringValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .stringValue(_):\n            return\
    \ b // b is larger\n        case .stringValue(_):\n            return a // a is\
    \ larger\n        case .stringValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        case\
    \ .stringValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .stringValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .stringValue(_):\n            return b // b is\
    \ larger\n        case .stringValue(_):\n            return a // a is larger\n\
    \        case .stringValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .stringValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .stringValue(_):\n            return\
    \ b // b is larger\n        case .stringValue(_):\n            return a // a is\
    \ larger\n        case .stringValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        case\
    \ .stringValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .stringValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .stringValue(_):\n            return b // b is\
    \ larger\n        case \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7r6wcxmr.swift:89:13: error: expected pattern\n        case \n\
    \            ^\n/tmp/tmp7r6wcxmr.swift:89:13: error: expected ':' after 'case'\n\
    \        case \n            ^\n/tmp/tmp7r6wcxmr.swift:112:66: error: expected\
    \ '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"1\"),\
    \ b: .intValue(1)) == nil)\n                                                 \
    \                ^\n/tmp/tmp7r6wcxmr.swift:22:14: note: to match this opening\
    \ '{'\n    switch a { // Switch on a's type\n             ^\n/tmp/tmp7r6wcxmr.swift:112:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp7r6wcxmr.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp7r6wcxmr.swift:31:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .doubleValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:33:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:35:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:37:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:39:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:41:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:43:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:"
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_):\n    case\
    \ .intValue(_): return b\n    case .doubleValue(_): return b\n    case .stringValue(_):\
    \ return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0r69hik6/tmp0r69hik6.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d638e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d635dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d635da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d635d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0r69hik6                        0x00005595a707e01a <unavailable> + 12314

    5    libc.so.6                          0x00002b6d63acf460 __libc_start_main +
    245

    6    tmp0r69hik6                        0x00005595a707c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpy7ngl63u/tmpy7ngl63u.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2727b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2724aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2724ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2724ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7ngl63u                        0x0000559215cef01a <unavailable> + 12314

    5    libc.so.6                          0x00002ba2729a3460 __libc_start_main +
    245

    6    tmpy7ngl63u                        0x0000559215ced499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n\
    \        switch b { // b is smaller\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpfj9f8osp/tmpfj9f8osp.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad16c40cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad16c103b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad16c103988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad16c1027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfj9f8osp                        0x0000555bef9ada56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad16c5f8460 __libc_start_main +
    245

    6    tmpfj9f8osp                        0x0000555bef9ad499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprrrhu10f.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmprrrhu10f.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmprrrhu10f.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmprrrhu10f.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmprrrhu10f.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmprrrhu10f.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case .intValue(_), .doubleValue(_), .stringValue(_):\n\
    \        switch b { // case .intValue(_), .doubleValue(_), .stringValue(_)\n \
    \       case .intValue(_), .doubleValue(_), .stringValue(_):\n            return\
    \ a\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .intValue(_):\n        switch b { // case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case .intValue(_), .doubleValue(_), .stringValue(_):\n\
    \            return b\n        case .intValue(_):\n            return a\n    \
    \    case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // case .intValue(_), .doubleValue(_), .stringValue(_)\n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_):\n            return a\n        case .intValue(_):\n\
    \            return b\n        case .doubleValue(_):\n            return a\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // case .intValue(_), .doubleValue(_), .stringValue(_)\n \
    \       case .intValue(_), .doubleValue(_), .stringValue(_):\n            return\
    \ a\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpt7h8cf0b/tmpt7h8cf0b.swift:84: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0e54ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0e51e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0e51e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0e51e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt7h8cf0b                        0x000055ec1ef61a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ac0e56d7460 __libc_start_main +
    245

    6    tmpt7h8cf0b                        0x000055ec1ef61499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? a : b\n        case .doubleValue(_):\n            return\
    \ a > b ? b : a\n        case .stringValue(_):\n            return a > b ? b :\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8oozv5nk.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmp8oozv5nk.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp8oozv5nk.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp8oozv5nk.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp8oozv5nk.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_):\n    \
    \    switch b { \n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b { \n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp1bgu57pn/tmp1bgu57pn.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c815ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c812e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c812e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c812e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bgu57pn                        0x0000556ebd16ea56 <unavailable> + 6742

    5    libc.so.6                          0x00002b9c817d7460 __libc_start_main +
    245

    6    tmp1bgu57pn                        0x0000556ebd16e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to enum\n    case\
    \ .intValue(_):\n        switch b { // TODO: Switch to enum\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ TODO: Switch to enum\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ TODO: Switch to enum\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwj3ubfls.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpwj3ubfls.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpwj3ubfls.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpwj3ubfls.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpwj3ubfls.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpwj3ubfls.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpwj3ubfls.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpwj3ubfls.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString):\n        switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        \n        case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString):\n            if aInt == bInt {\n                return\
    \ .intValue(aInt)\n            } else if aDouble == bDouble {\n              \
    \  return .doubleValue(aDouble)\n            } else {\n                return\
    \ .stringValue(aString)\n            }\n            \n        case .stringValue(bString):\n\
    \            return .stringValue(aString)\n            \n        case .intValue(bInt):\n\
    \            return .intValue(aInt)\n            \n        case .doubleValue(bDouble):\n\
    \            return .doubleValue(aDouble)\n            \n        default:\n  \
    \          return nil\n        }\n        \n    case .stringValue(aString), .stringValue(bString):\n\
    \        switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \
    \    \n        case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString):\n\
    \            if aString == bString {\n                return .stringValue(aString)\n\
    \            } else if aInt == bInt {\n                return .intValue(aInt)\n\
    \            } else if aDouble == bDouble {\n                return .doubleValue(aDouble)\n\
    \            } else {\n                return .stringValue(aString)\n        \
    \    }\n            \n        case .stringValue(bString):\n            return\
    \ .stringValue(aString)\n            \n        case .intValue(bInt):\n       \
    \     return .intValue(aInt)\n            \n        case .doubleValue(bDouble):\n\
    \            return .doubleValue(aDouble)\n            \n        default:\n  \
    \          return nil\n        }\n        \n    case .intValue(aInt), .intValue(bInt):\n\
    \        if aInt == bInt {\n            return .intValue(aInt)\n        } else\
    \ {\n            return nil\n        }\n        \n    case .doubleValue(aDouble),\
    \ .doubleValue(bDouble):\n        if aDouble == bDouble {\n            return\
    \ .doubleValue(aDouble)\n        } else {\n            return nil\n        }\n\
    \        \n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1dzyhybp.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp1dzyhybp.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString):\n                    \
    \                           ^\n/tmp/tmp1dzyhybp.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString):\n                       ^\n/tmp/tmp1dzyhybp.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString):\n                    \
    \                                                      ^\n/tmp/tmp1dzyhybp.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString):\n                    \
    \   ^\n/tmp/tmp1dzyhybp.swift:25:71: error: expected ':' after 'case'\n      \
    \  switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n          \
    \                                                            ^\n/tmp/tmp1dzyhybp.swift:27:52:\
    \ error: 'bDouble' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString):\n                    \
    \                               ^\n/tmp/tmp1dzyhybp.swift:27:28: error: 'bInt'\
    \ must be bound in every pattern\n        case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString):\n                           ^\n/tmp/tmp1dzyhybp.swift:27:79:\
    \ error: 'bString' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString):\n                    \
    \                                                          ^\n/tmp/tmp1dzyhybp.swift:27:28:\
    \ error: 'bInt' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString):\n       "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n     \
    \   case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsnuvevoh.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpsnuvevoh.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpsnuvevoh.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpsnuvevoh.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpsnuvevoh.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpsnuvevoh.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default: return nil\n    }\n    \n    switch b {\
    \ case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default: return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxg5877d1.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpxg5877d1.swift:27:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyy2hadb5.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpyy2hadb5.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpyy2hadb5.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpyy2hadb5.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpyy2hadb5.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpyy2hadb5.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpyy2hadb5.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpyy2hadb5.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpyy2hadb5.s"
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to switch case\
    \ for performance\n    case .intValue(_):\n        switch b { // TODO: Switch\
    \ to switch case for performance\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // TODO: Switch to switch case for performance\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: Switch to switch case for performance\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpdgxpo6d6/tmpdgxpo6d6.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae518523c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae51821ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae51821a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5182197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdgxpo6d6                        0x000056061a6ada56 <unavailable> + 6742

    5    libc.so.6                          0x00002ae51870f460 __libc_start_main +
    245

    6    tmpdgxpo6d6                        0x000056061a6ad499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return a // a is larger\n        case .doubleValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .none:\n            return b // b is\
    \ larger\n        }\n    case .doubleValue(_):\n        switch b { // Switch on\
    \ the type of b\n        case .intValue(_):\n            return a // a is larger\n\
    \        case .doubleValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .none:\n\
    \            return b // b is larger\n        }\n    case .stringValue(_):\n \
    \       switch b { // Switch on the type of b\n        case .intValue(_):\n  \
    \          return a // a is larger\n        case .doubleValue(_):\n          \
    \  return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .none:\n            return b // b is larger\n\
    \        }\n    case .none:\n        switch b { // Switch on the type of b\n \
    \       case .intValue(_):\n            return a // a is larger\n        case\
    \ .doubleValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .none:\n            return\
    \ b // b is larger\n        }\n    }\n    return nil // a is equal to b\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprsaegeff.swift:56:11: error: type 'Value' has no member 'none'\n\
    \    case .none:\n         ~^~~~\n/tmp/tmprsaegeff.swift:31:15: error: type 'Value'\
    \ has no member 'none'\n        case .none:\n             ~^~~~\n/tmp/tmprsaegeff.swift:42:15:\
    \ error: type 'Value' has no member 'none'\n        case .none:\n            \
    \ ~^~~~\n/tmp/tmprsaegeff.swift:53:15: error: type 'Value' has no member 'none'\n\
    \        case .none:\n             ~^~~~\n/tmp/tmprsaegeff.swift:64:15: error:\
    \ type 'Value' has no member 'none'\n        case .none:\n             ~^~~~\n"
  stdout: ''
  timestamp: 1659825067
