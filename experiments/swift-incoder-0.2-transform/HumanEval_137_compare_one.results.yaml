language: swift
name: HumanEval_137_compare_one
results:
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_):\n    case\
    \ .intValue(_):\n        return b\n    case .doubleValue(_):\n        return b\n\
    \    case .stringValue(_):\n        return b\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpypvfdvez/tmpypvfdvez.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b744cb6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b744c861b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b744c861988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b744c8607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpypvfdvez                        0x00005566b4dbb01a <unavailable> + 12314

    5    libc.so.6                          0x00002b744cd56460 __libc_start_main +
    245

    6    tmpypvfdvez                        0x00005566b4db9499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .doubleValue(_):\n            return b // b is\
    \ larger\n        case .stringValue(_):\n            return a // a is larger\n\
    \        case .stringValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .stringValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .stringValue(_):\n            return\
    \ b // b is larger\n        case .stringValue(_):\n            return a // a is\
    \ larger\n        case .stringValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        case\
    \ .stringValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .stringValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .stringValue(_):\n            return b // b is\
    \ larger\n        case .stringValue(_):\n            return a // a is larger\n\
    \        case .stringValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .stringValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .stringValue(_):\n            return\
    \ b // b is larger\n        case .stringValue(_):\n            return a // a is\
    \ larger\n        case .stringValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        case\
    \ .stringValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .stringValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .stringValue(_):\n            return b // b is\
    \ larger\n        case \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7r6wcxmr.swift:89:13: error: expected pattern\n        case \n\
    \            ^\n/tmp/tmp7r6wcxmr.swift:89:13: error: expected ':' after 'case'\n\
    \        case \n            ^\n/tmp/tmp7r6wcxmr.swift:112:66: error: expected\
    \ '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"1\"),\
    \ b: .intValue(1)) == nil)\n                                                 \
    \                ^\n/tmp/tmp7r6wcxmr.swift:22:14: note: to match this opening\
    \ '{'\n    switch a { // Switch on a's type\n             ^\n/tmp/tmp7r6wcxmr.swift:112:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp7r6wcxmr.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp7r6wcxmr.swift:31:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .doubleValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:33:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:35:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:37:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:39:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:41:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:43:14: warning: case is\
    \ already handled by previous patterns; consider removing it\n        case .stringValue(_):\n\
    \             ^~~~~~~~~~~~~~~\n/tmp/tmp7r6wcxmr.swift:"
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_):\n    case\
    \ .intValue(_): return b\n    case .doubleValue(_): return b\n    case .stringValue(_):\
    \ return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0r69hik6/tmp0r69hik6.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d638e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d635dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d635da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d635d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0r69hik6                        0x00005595a707e01a <unavailable> + 12314

    5    libc.so.6                          0x00002b6d63acf460 __libc_start_main +
    245

    6    tmp0r69hik6                        0x00005595a707c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpy7ngl63u/tmpy7ngl63u.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2727b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2724aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2724ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2724ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7ngl63u                        0x0000559215cef01a <unavailable> + 12314

    5    libc.so.6                          0x00002ba2729a3460 __libc_start_main +
    245

    6    tmpy7ngl63u                        0x0000559215ced499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n\
    \        switch b { // b is smaller\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpfj9f8osp/tmpfj9f8osp.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad16c40cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad16c103b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad16c103988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad16c1027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfj9f8osp                        0x0000555bef9ada56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad16c5f8460 __libc_start_main +
    245

    6    tmpfj9f8osp                        0x0000555bef9ad499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprrrhu10f.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmprrrhu10f.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmprrrhu10f.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmprrrhu10f.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmprrrhu10f.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmprrrhu10f.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case .intValue(_), .doubleValue(_), .stringValue(_):\n\
    \        switch b { // case .intValue(_), .doubleValue(_), .stringValue(_)\n \
    \       case .intValue(_), .doubleValue(_), .stringValue(_):\n            return\
    \ a\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .intValue(_):\n        switch b { // case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case .intValue(_), .doubleValue(_), .stringValue(_):\n\
    \            return b\n        case .intValue(_):\n            return a\n    \
    \    case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // case .intValue(_), .doubleValue(_), .stringValue(_)\n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_):\n            return a\n        case .intValue(_):\n\
    \            return b\n        case .doubleValue(_):\n            return a\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // case .intValue(_), .doubleValue(_), .stringValue(_)\n \
    \       case .intValue(_), .doubleValue(_), .stringValue(_):\n            return\
    \ a\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpt7h8cf0b/tmpt7h8cf0b.swift:84: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0e54ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0e51e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0e51e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0e51e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt7h8cf0b                        0x000055ec1ef61a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ac0e56d7460 __libc_start_main +
    245

    6    tmpt7h8cf0b                        0x000055ec1ef61499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? a : b\n        case .doubleValue(_):\n            return\
    \ a > b ? b : a\n        case .stringValue(_):\n            return a > b ? b :\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8oozv5nk.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmp8oozv5nk.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp8oozv5nk.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp8oozv5nk.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp8oozv5nk.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp8oozv5nk.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_):\n    \
    \    switch b { \n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b { \n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp1bgu57pn/tmp1bgu57pn.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c815ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c812e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c812e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c812e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bgu57pn                        0x0000556ebd16ea56 <unavailable> + 6742

    5    libc.so.6                          0x00002b9c817d7460 __libc_start_main +
    245

    6    tmp1bgu57pn                        0x0000556ebd16e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to enum\n    case\
    \ .intValue(_):\n        switch b { // TODO: Switch to enum\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ TODO: Switch to enum\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ TODO: Switch to enum\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwj3ubfls.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpwj3ubfls.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpwj3ubfls.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpwj3ubfls.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpwj3ubfls.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpwj3ubfls.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpwj3ubfls.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpwj3ubfls.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString):\n        switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        \n        case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString):\n            if aInt == bInt {\n                return\
    \ .intValue(aInt)\n            } else if aDouble == bDouble {\n              \
    \  return .doubleValue(aDouble)\n            } else {\n                return\
    \ .stringValue(aString)\n            }\n            \n        case .stringValue(bString):\n\
    \            return .stringValue(aString)\n            \n        case .intValue(bInt):\n\
    \            return .intValue(aInt)\n            \n        case .doubleValue(bDouble):\n\
    \            return .doubleValue(aDouble)\n            \n        default:\n  \
    \          return nil\n        }\n        \n    case .stringValue(aString), .stringValue(bString):\n\
    \        switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \
    \    \n        case let .intValue(bInt), let .doubleValue(bDouble), let .stringValue(bString):\n\
    \            if aString == bString {\n                return .stringValue(aString)\n\
    \            } else if aInt == bInt {\n                return .intValue(aInt)\n\
    \            } else if aDouble == bDouble {\n                return .doubleValue(aDouble)\n\
    \            } else {\n                return .stringValue(aString)\n        \
    \    }\n            \n        case .stringValue(bString):\n            return\
    \ .stringValue(aString)\n            \n        case .intValue(bInt):\n       \
    \     return .intValue(aInt)\n            \n        case .doubleValue(bDouble):\n\
    \            return .doubleValue(aDouble)\n            \n        default:\n  \
    \          return nil\n        }\n        \n    case .intValue(aInt), .intValue(bInt):\n\
    \        if aInt == bInt {\n            return .intValue(aInt)\n        } else\
    \ {\n            return nil\n        }\n        \n    case .doubleValue(aDouble),\
    \ .doubleValue(bDouble):\n        if aDouble == bDouble {\n            return\
    \ .doubleValue(aDouble)\n        } else {\n            return nil\n        }\n\
    \        \n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1dzyhybp.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp1dzyhybp.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString):\n                    \
    \                           ^\n/tmp/tmp1dzyhybp.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString):\n                       ^\n/tmp/tmp1dzyhybp.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString):\n                    \
    \                                                      ^\n/tmp/tmp1dzyhybp.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString):\n                    \
    \   ^\n/tmp/tmp1dzyhybp.swift:25:71: error: expected ':' after 'case'\n      \
    \  switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n          \
    \                                                            ^\n/tmp/tmp1dzyhybp.swift:27:52:\
    \ error: 'bDouble' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString):\n                    \
    \                               ^\n/tmp/tmp1dzyhybp.swift:27:28: error: 'bInt'\
    \ must be bound in every pattern\n        case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString):\n                           ^\n/tmp/tmp1dzyhybp.swift:27:79:\
    \ error: 'bString' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString):\n                    \
    \                                                          ^\n/tmp/tmp1dzyhybp.swift:27:28:\
    \ error: 'bInt' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString):\n       "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n     \
    \   case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsnuvevoh.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpsnuvevoh.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpsnuvevoh.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpsnuvevoh.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpsnuvevoh.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpsnuvevoh.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default: return nil\n    }\n    \n    switch b {\
    \ case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default: return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxg5877d1.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpxg5877d1.swift:27:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyy2hadb5.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpyy2hadb5.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpyy2hadb5.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpyy2hadb5.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpyy2hadb5.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpyy2hadb5.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpyy2hadb5.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpyy2hadb5.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpyy2hadb5.s"
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to switch case\
    \ for performance\n    case .intValue(_):\n        switch b { // TODO: Switch\
    \ to switch case for performance\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // TODO: Switch to switch case for performance\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: Switch to switch case for performance\n        case\
    \ .intValue(_):\n            return a\n        case .doubleValue(_):\n       \
    \     return b\n        case .stringValue(_):\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpdgxpo6d6/tmpdgxpo6d6.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae518523c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae51821ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae51821a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5182197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdgxpo6d6                        0x000056061a6ada56 <unavailable> + 6742

    5    libc.so.6                          0x00002ae51870f460 __libc_start_main +
    245

    6    tmpdgxpo6d6                        0x000056061a6ad499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of a\n  \
    \  case .intValue(_):\n        switch b { // Switch on the type of b\n       \
    \ case .intValue(_):\n            return a // a is larger\n        case .doubleValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        case .none:\n            return b // b is\
    \ larger\n        }\n    case .doubleValue(_):\n        switch b { // Switch on\
    \ the type of b\n        case .intValue(_):\n            return a // a is larger\n\
    \        case .doubleValue(_):\n            return b // b is larger\n        case\
    \ .stringValue(_):\n            return a // a is larger\n        case .none:\n\
    \            return b // b is larger\n        }\n    case .stringValue(_):\n \
    \       switch b { // Switch on the type of b\n        case .intValue(_):\n  \
    \          return a // a is larger\n        case .doubleValue(_):\n          \
    \  return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        case .none:\n            return b // b is larger\n\
    \        }\n    case .none:\n        switch b { // Switch on the type of b\n \
    \       case .intValue(_):\n            return a // a is larger\n        case\
    \ .doubleValue(_):\n            return b // b is larger\n        case .stringValue(_):\n\
    \            return a // a is larger\n        case .none:\n            return\
    \ b // b is larger\n        }\n    }\n    return nil // a is equal to b\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprsaegeff.swift:56:11: error: type 'Value' has no member 'none'\n\
    \    case .none:\n         ~^~~~\n/tmp/tmprsaegeff.swift:31:15: error: type 'Value'\
    \ has no member 'none'\n        case .none:\n             ~^~~~\n/tmp/tmprsaegeff.swift:42:15:\
    \ error: type 'Value' has no member 'none'\n        case .none:\n            \
    \ ~^~~~\n/tmp/tmprsaegeff.swift:53:15: error: type 'Value' has no member 'none'\n\
    \        case .none:\n             ~^~~~\n/tmp/tmprsaegeff.swift:64:15: error:\
    \ type 'Value' has no member 'none'\n        case .none:\n             ~^~~~\n"
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue() {\n          \
    \  return bInt > aInt ? .intValue(aInt) : bInt < aInt ? .intValue(aInt) : nil\n\
    \        }\n        if let bDouble = b.doubleValue() {\n            return bDouble\
    \ > aDouble ? .doubleValue(aDouble) : bDouble < aDouble ? .doubleValue(aDouble)\
    \ : nil\n        }\n        if let bString = b.stringValue() {\n            return\
    \ bString > aString ? .stringValue(aString) : bString < aString ? .stringValue(aString)\
    \ : nil\n        }\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqs1bqx5q.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpqs1bqx5q.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpqs1bqx5q.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpqs1bqx5q.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpqs1bqx5q.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpqs1bqx5q.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpqs1bqx5q.swift:25:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue() {\n         \
    \             ^\n                      Value\n/tmp/tmpqs1bqx5q.swift:25:34: error:\
    \ missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpqs1bqx5q.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpqs1bqx5q.swift:28:26: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        if let bDouble = b.doubleValue() {\n\
    \                         ^\n                         Value\n/tmp/tmpqs1bqx5q.swift:28:40:\
    \ error: missing argument for parameter #1 in call\n        if let bDouble = b.doubleValue()\
    \ {\n                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue(), bInt == aInt\
    \ {\n            return a\n        }\n        \n        if let bDouble = b.doubleValue(),\
    \ bDouble == aDouble {\n            return a\n        }\n        \n        if\
    \ let bString = b.stringValue(), bString == aString {\n            return a\n\
    \        }\n        \n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfoexheuh.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpfoexheuh.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpfoexheuh.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpfoexheuh.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpfoexheuh.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpfoexheuh.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpfoexheuh.swift:25:34: error: missing argument for parameter\
    \ #1 in call\n        if let bInt = b.intValue(), bInt == aInt {\n           \
    \                      ^\n                                 <#Int#>\n/tmp/tmpfoexheuh.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpfoexheuh.swift:25:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        if\
    \ let bInt = b.intValue(), bInt == aInt {\n                      ^\n         \
    \             Value\n/tmp/tmpfoexheuh.swift:29:40: error: missing argument for\
    \ parameter #1 in call\n        if let bDouble = b.doubleValue(), bDouble == aDouble\
    \ {\n                                       ^\n                              \
    \         <#Double#>\n/tmp/tmpfoexheuh.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doub"
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a // a is larger\n        case .doubleValue(_):\n        \
    \    return b // b is larger\n        case .stringValue(_):\n            return\
    \ a // a is larger\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return a // a is\
    \ larger\n        case .doubleValue(_):\n            return b // b is larger\n\
    \        case .stringValue(_):\n            return a // a is larger\n        }\n\
    \    case .stringValue(_):\n        switch b { // Switch on b's type\n       \
    \ case .intValue(_):\n            return a // a is larger\n        case .doubleValue(_):\n\
    \            return b // b is larger\n        case .stringValue(_):\n        \
    \    return a // a is larger\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp809l6q9z/tmp809l6q9z.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6ccca0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6cc997b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6cc997988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6cc9967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp809l6q9z                        0x0000560cf7d5fa56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad6cce8c460 __libc_start_main +
    245

    6    tmp809l6q9z                        0x0000560cf7d5f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    \n    default: return nil\n    }\n   \
    \ \n    if a.intValue() > b.intValue() { return .intValue() }\n    if a.doubleValue()\
    \ > b.doubleValue() { return .doubleValue() }\n    if a.stringValue() > b.stringValue()\
    \ { return .stringValue() }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpz6iex_63.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpz6iex_63.swift:26:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpz6iex_63.swift:31:8: error: enum case 'intValue' cannot be\
    \ used as an instance member\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n       ^\n       Value\n/tmp/tmpz6iex_63.swift:31:19: error: missing argument\
    \ for parameter #1 in call\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n                  ^\n                  <#Int#>\n/tmp/tmpz6iex_63.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpz6iex_63.swift:31:21:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmpz6iex_63.swift:31:21:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() > b.intValue() { return .intValue() }\n                 \
    \   ^\n/tmp/tmpz6iex_63.swift:31:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() > b.intValue() { return .intValue() }\n       \
    \                          ^\n                                 <#Int#>\n/tmp/tmpz6iex_63.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpz6iex_63.swift:31:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n                      ^\n           \
    \           Value\n/tmp/tmpz6iex_63.swift:31:55: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \                                 "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8z8rsdln.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp8z8rsdln.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp8z8rsdln.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp8z8rsdln.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp8z8rsdln.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp8z8rsdln.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp8z8rsdln.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp8z8rsdln.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp8z8rsdln.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp8z8rsdln.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on b.\n  \
    \      case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue\
    \ ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphrm_hcg6.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmphrm_hcg6.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmphrm_hcg6.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmphrm_hcg6.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmphrm_hcg6.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmphrm_hcg6.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmphrm_hcg6.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmphrm_hcg6.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8z8rsdln.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp8z8rsdln.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp8z8rsdln.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp8z8rsdln.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp8z8rsdln.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp8z8rsdln.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp8z8rsdln.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp8z8rsdln.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp8z8rsdln.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp8z8rsdln.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(a), let .doubleValue(b), let .stringValue(aString),\
    \ let .stringValue(bString)\n            if aString == bString {\n           \
    \     return a\n            }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplegnu7an.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmplegnu7an.swift:23:49:\
    \ error: 'b' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                                            ^\n/tmp/tmplegnu7an.swift:23:28:\
    \ error: 'a' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                       ^\n/tmp/tmplegnu7an.swift:23:70: error: 'aString' must\
    \ be bound in every pattern\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                ^\n/tmp/tmplegnu7an.swift:23:28:\
    \ error: 'a' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                       ^\n/tmp/tmplegnu7an.swift:23:97: error: 'bString' must\
    \ be bound in every pattern\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                                           ^\n\
    /tmp/tmplegnu7an.swift:23:28: error: 'a' must be bound in every pattern\n    \
    \    case let .intValue(a), let .doubleValue(b), let .stringValue(aString), let\
    \ .stringValue(bString)\n                           ^\n/tmp/tmplegnu7an.swift:23:105:\
    \ error: expected ':' after 'case'\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                                            \
    \       ^\n/tmp/tmplegnu7an.swift:24:16: error: cannot find 'aString' in scope\n\
    \            if aString == bString {\n               ^~~~~~~\n/tmp/tmplegnu7an.swift:24:27:\
    \ error: cannot find 'bString' in scope\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n\
    \        return b == .intValue(a) ? .intValue(a) : nil\n    case .doubleValue(_):\n\
    \        return b == .doubleValue(a) ? .doubleValue(a) : nil\n    case .stringValue(_):\n\
    \        return b == .stringValue(a) ? .stringValue(a) : nil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa8nfwt0v.swift:24:31: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n        return b == .intValue(a) ? .intValue(a)\
    \ : nil\n                              ^\n/tmp/tmpa8nfwt0v.swift:24:46: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Int'\n     \
    \   return b == .intValue(a) ? .intValue(a) : nil\n                          \
    \                   ^\n/tmp/tmpa8nfwt0v.swift:26:34: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Double'\n        return b == .doubleValue(a)\
    \ ? .doubleValue(a) : nil\n                                 ^\n/tmp/tmpa8nfwt0v.swift:26:52:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \        return b == .doubleValue(a) ? .doubleValue(a) : nil\n               \
    \                                    ^\n/tmp/tmpa8nfwt0v.swift:28:34: error: cannot\
    \ convert value of type 'Value' to expected argument type 'String'\n        return\
    \ b == .stringValue(a) ? .stringValue(a) : nil\n                             \
    \    ^\n/tmp/tmpa8nfwt0v.swift:28:52: error: cannot convert value of type 'Value'\
    \ to expected argument type 'String'\n        return b == .stringValue(a) ? .stringValue(a)\
    \ : nil\n                                                   ^\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n    if a.doubleValue() < b.doubleValue()\
    \ { return .doubleValue(a) }\n    if a.stringValue() < b.stringValue() { return\
    \ .stringValue(a) }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmph8ajn2so.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmph8ajn2so.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmph8ajn2so.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n   \
    \               ^\n                  <#Int#>\n/tmp/tmph8ajn2so.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmph8ajn2so.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n       ^\n       Value\n/tmp/tmph8ajn2so.swift:28:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmph8ajn2so.swift:28:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmph8ajn2so.swift:28:23: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                      ^\n                      Value\n/tmp/tmph8ajn2so.swift:28:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n                                 ^\n              \
    \                   <#Int#>\n/tmp/tmph8ajn2so.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmph8ajn2so.swift:28:55: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Int'\n    if\
    \ a.intValue() < b.intValue() { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp67j6cjl1.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp67j6cjl1.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp67j6cjl1.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp67j6cjl1.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp67j6cjl1.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp67j6cjl1.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp67j6cjl1.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp67j6cjl1.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp67j6cjl1.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp67j6cjl1.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp666rbu_1.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp666rbu_1.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp666rbu_1.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp666rbu_1.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp666rbu_1.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to perform\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to perform\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to perform\n        case .intValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to perform\n        case .intValue(_):\n        \
    \    return .stringValue(a.stringValue > b.stringValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpaendtcjt.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpaendtcjt.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpaendtcjt.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpaendtcjt.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpaendtcjt.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpaendtcjt.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpaendtcjt.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpaendtcjt.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpaendtcjt.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpaendtcjt.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n    if a.doubleValue() > b.doubleValue()\
    \ { return .doubleValue() }\n    if a.stringValue() > b.stringValue() { return\
    \ .stringValue() }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4il9c2jr.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp4il9c2jr.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmp4il9c2jr.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \              ^\n                  <#Int#>\n/tmp/tmp4il9c2jr.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp4il9c2jr.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n       ^\n       Value\n/tmp/tmp4il9c2jr.swift:28:21:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmp4il9c2jr.swift:28:21:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() > b.intValue() { return .intValue() }\n                 \
    \   ^\n/tmp/tmp4il9c2jr.swift:28:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() > b.intValue() { return .intValue() }\n       \
    \                          ^\n                                 <#Int#>\n/tmp/tmp4il9c2jr.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp4il9c2jr.swift:28:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n                      ^\n           \
    \           Value\n/tmp/tmp4il9c2jr.swift:28:55: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \                                 "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        switch b { // b is bigger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0fnq2imt/tmp0fnq2imt.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3ebe29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3ebb20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3ebb20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3ebb1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fnq2imt                        0x00005602ef2a6a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ab3ec015460 __libc_start_main +
    245

    6    tmp0fnq2imt                        0x00005602ef2a6499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprrrhu10f.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmprrrhu10f.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmprrrhu10f.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmprrrhu10f.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmprrrhu10f.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmprrrhu10f.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8z8rsdln.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp8z8rsdln.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp8z8rsdln.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp8z8rsdln.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp8z8rsdln.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp8z8rsdln.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp8z8rsdln.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp8z8rsdln.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp8z8rsdln.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp8z8rsdln.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue:\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpjkatjycs/tmpjkatjycs.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b497ab95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b497a88cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b497a88c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b497a88b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjkatjycs                        0x000055610d17701a <unavailable> + 12314

    5    libc.so.6                          0x00002b497ad81460 __libc_start_main +
    245

    6    tmpjkatjycs                        0x000055610d175499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n  \
    \          return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .stringValue(_):\n        switch b { // Switch on type to determine which\
    \ comparison to use\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp159inz28.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp159inz28.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp159inz28.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp159inz28.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp159inz28.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp159inz28.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp159inz28.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp159inz28.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp159inz28.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp159inz28.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Switch on b's type\n        case .intValue(_):\n            return .doubleValue(DoubleMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .doubleValue(DoubleMax)\n  \
    \      }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .stringValue(StringMax)\n    \
    \    case .doubleValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .stringValue(_):\n            return .stringValue(StringMax)\n      \
    \  }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpm_unm3ua.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpm_unm3ua.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmpm_unm3ua.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpm_unm3ua.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Switch on b's type\n        case .intValue(_):\n            return .doubleValue(DoubleMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .doubleValue(DoubleMax)\n  \
    \      }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .stringValue(StringMax)\n    \
    \    case .doubleValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .stringValue(_):\n            return .stringValue(StringMax)\n      \
    \  }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpm_unm3ua.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpm_unm3ua.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmpm_unm3ua.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpm_unm3ua.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // Switch on b.\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on b.\n  \
    \      case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvs4ios9n.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpvs4ios9n.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpvs4ios9n.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpvs4ios9n.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpvs4ios9n.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpvs4ios9n.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpvs4ios9n.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpvs4ios9n.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpvs4ios9n.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpvs4ios9n.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp666rbu_1.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp666rbu_1.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp666rbu_1.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp666rbu_1.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp666rbu_1.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_):\n    case\
    \ .intValue(_):\n        switch b { // case .doubleValue(_):\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return a\n \
    \       case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .doubleValue(_):\n        switch b { // case .intValue(_):\n\
    \        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b { // case .intValue(_):\n\
    \        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp3gy08qah/tmp3gy08qah.swift:83: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb8af48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb8ac3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb8ac3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb8ac3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3gy08qah                        0x00005652c240ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002aeb8b134460 __libc_start_main +
    245

    6    tmp3gy08qah                        0x00005652c240c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n\
    \        switch b { // b is smaller\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpfj9f8osp/tmpfj9f8osp.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad16c40cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad16c103b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad16c103988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad16c1027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfj9f8osp                        0x0000555bef9ada56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad16c5f8460 __libc_start_main +
    245

    6    tmpfj9f8osp                        0x0000555bef9ad499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n            \n        case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString)\n            if aInt == bInt {\n                return\
    \ .intValue(aInt)\n            } else if aDouble == bDouble {\n              \
    \  return .doubleValue(aDouble)\n            } else {\n                return\
    \ .stringValue(aString)\n            }\n            \n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n            if aString == bString {\n    \
    \            return .stringValue(aString)\n            } else {\n            \
    \    return nil\n            }\n            \n        case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n            if aInt == bInt {\n                return .intValue(aInt)\n\
    \            } else {\n                return nil\n            }\n           \
    \ \n        case .intValue(_), .doubleValue(_), .stringValue(_)\n            if\
    \ aDouble == bDouble {\n                return .doubleValue(aDouble)\n       \
    \     } else {\n                return nil\n            }\n            \n    \
    \    case .intValue(_), .doubleValue(_), .stringValue(_)\n            if aString\
    \ == bString {\n                return .stringValue(aString)\n            } else\
    \ {\n                return nil\n            }\n            \n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n            if aInt == bInt {\n          \
    \      return .intValue(aInt)\n            } else {\n                return nil\n\
    \            }\n            \n        case .intValue(_), .doubleValue(_), .stringValue(_)\n\
    \            if aDouble == bDouble {\n                return .doubleValue(aDouble)\n\
    \            } else {\n                return nil\n            }\n           \
    \ \n        case .intValue(_), .doubleValue(_), .stringValue(_)\n            if\
    \ aString == bString {\n                return .stringValue(aString)\n       \
    \     } else {\n                return nil\n            }\n            \n    \
    \    case .intValue(_), .doubleValue(_), .stringValue(_)\n            if aInt\
    \ == bInt {\n                return .intValue(aInt)\n            } else {\n  \
    \              return nil\n            }\n            \n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n            if aDouble == bDouble {\n    \
    \            return .doubleValue(aDouble)\n            } else {\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7ui70ea4.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp7ui70ea4.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmp7ui70ea4.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmp7ui70ea4.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmp7ui70ea4.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmp7ui70ea4.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmp7ui70ea4.swift:25:71: error: expected ':' after 'case'\n   \
    \     switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n       \
    \                                                               ^\n/tmp/tmp7ui70ea4.swift:27:52:\
    \ error: 'bDouble' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString)\n                     \
    \                              ^\n/tmp/tmp7ui70ea4.swift:27:28: error: 'bInt'\
    \ must be bound in every pattern\n        case let .intValue(bInt), let .doubleValue(bDouble),\
    \ let .stringValue(bString)\n                           ^\n/tmp/tmp7ui70ea4.swift:27:79:\
    \ error: 'bString' must be bound in every pattern\n        case let .intValue(bInt),\
    \ let .doubleValue(bDouble), let .stringValue(bString)\n                     \
    \      "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue(), bInt == aInt\
    \ {\n            return a\n        }\n        if let bDouble = b.doubleValue(),\
    \ bDouble == aDouble {\n            return a\n        }\n        if let bString\
    \ = b.stringValue(), bString == aString {\n            return a\n        }\n \
    \   }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeyx33ftf.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpeyx33ftf.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpeyx33ftf.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpeyx33ftf.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpeyx33ftf.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpeyx33ftf.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpeyx33ftf.swift:25:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue(), bInt == aInt\
    \ {\n                      ^\n                      Value\n/tmp/tmpeyx33ftf.swift:25:34:\
    \ error: missing argument for parameter #1 in call\n        if let bInt = b.intValue(),\
    \ bInt == aInt {\n                                 ^\n                       \
    \          <#Int#>\n/tmp/tmpeyx33ftf.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmpeyx33ftf.swift:28:26: error: enum\
    \ case 'doubleValue' cannot be used as an instance member\n        if let bDouble\
    \ = b.doubleValue(), bDouble == aDouble {\n                         ^\n      \
    \                   Value\n/tmp/tmpeyx33ftf.swift:28:40: error: missing argument\
    \ for parameter #1 in call\n        if "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpqgi0m9d9.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpqgi0m9d9.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmpqgi0m9d9.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmpqgi0m9d9.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpqgi0m9d9.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmpqgi0m9d9.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpqgi0m9d9.swift:30:48: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                               ^\n/tmp/tmpqgi0m9d9.swift:30:48:\
    \ note: found candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                               ^\n/tmp/tmpqgi0m9d9.swift:30:48:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \                    ^\n/tmp/tmpqgi0m9d9.swift:30:48: note: found candidate wi"
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8vs_6l2j.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp8vs_6l2j.swift:291:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp8vs_6l2j.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp8vs_6l2j.swift:272:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp666rbu_1.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp666rbu_1.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp666rbu_1.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp666rbu_1.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp666rbu_1.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_):\n    \
    \    switch b { \n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b { \n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp1bgu57pn/tmp1bgu57pn.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c815ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c812e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c812e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c812e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bgu57pn                        0x0000556ebd16ea56 <unavailable> + 6742

    5    libc.so.6                          0x00002b9c817d7460 __libc_start_main +
    245

    6    tmp1bgu57pn                        0x0000556ebd16e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.intValue ? a.stringValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcwg4drf3.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpcwg4drf3.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpcwg4drf3.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcwg4drf3.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcwg4drf3.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpcwg4drf3.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpcwg4drf3.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpcwg4drf3.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphee_h68n.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmphee_h68n.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // Switch on b.\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b.\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpu6ds3y04.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpu6ds3y04.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpu6ds3y04.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpu6ds3y04.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpu6ds3y04.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpu6ds3y04.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpu6ds3y04.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpu6ds3y04.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpu6ds3y04.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpu6ds3y04.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphee_h68n.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmphee_h68n.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyy2hadb5.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpyy2hadb5.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpyy2hadb5.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpyy2hadb5.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpyy2hadb5.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpyy2hadb5.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpyy2hadb5.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpyy2hadb5.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpyy2hadb5.s"
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp666rbu_1.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp666rbu_1.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp666rbu_1.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp666rbu_1.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp666rbu_1.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        \n    default: return nil\n    }\n    switch b { case\
    \ .intValue(_), .doubleValue(_), .stringValue(_)\n        \n    default: return\
    \ nil\n    }\n    \n    if a.intValue() < b.intValue() { return .intValue(a) }\n\
    \    if a.intValue() > b.intValue() { return .intValue(b) }\n    if a.doubleValue()\
    \ < b.doubleValue() { return .doubleValue(a) }\n    if a.doubleValue() > b.doubleValue()\
    \ { return .doubleValue(b) }\n    if a.stringValue() < b.stringValue() { return\
    \ .stringValue(a) }\n    if a.stringValue() > b.stringValue() { return .stringValue(b)\
    \ }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv5z35ila.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpv5z35ila.swift:26:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpv5z35ila.swift:31:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n   \
    \               ^\n                  <#Int#>\n/tmp/tmpv5z35ila.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpv5z35ila.swift:31:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n       ^\n       Value\n/tmp/tmpv5z35ila.swift:31:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmpv5z35ila.swift:31:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmpv5z35ila.swift:31:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n      \
    \                           ^\n                                 <#Int#>\n/tmp/tmpv5z35ila.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpv5z35ila.swift:31:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n                      ^\n          \
    \            Value\n/tmp/tmpv5z35ila.swift:31:55: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpy7ngl63u/tmpy7ngl63u.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2727b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2724aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2724ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2724ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7ngl63u                        0x0000559215cef01a <unavailable> + 12314

    5    libc.so.6                          0x00002ba2729a3460 __libc_start_main +
    245

    6    tmpy7ngl63u                        0x0000559215ced499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        switch b { // b is bigger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0fnq2imt/tmp0fnq2imt.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3ebe29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3ebb20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3ebb20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3ebb1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fnq2imt                        0x00005602ef2a6a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ab3ec015460 __libc_start_main +
    245

    6    tmp0fnq2imt                        0x00005602ef2a6499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n\
    \        switch b { // b is smaller\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpfj9f8osp/tmpfj9f8osp.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad16c40cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad16c103b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad16c103988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad16c1027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfj9f8osp                        0x0000555bef9ada56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad16c5f8460 __libc_start_main +
    245

    6    tmpfj9f8osp                        0x0000555bef9ad499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default: return nil\n    }\n    \n    switch b {\
    \ case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default: return\
    \ nil\n    }\n    \n    if a.intValue() < b.intValue() { return .intValue(a) }\n\
    \    if a.doubleValue() < b.doubleValue() { return .doubleValue(a) }\n    if a.stringValue()\
    \ < b.stringValue() { return .stringValue(a) }\n    \n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5kd0gmbk.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp5kd0gmbk.swift:27:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmp5kd0gmbk.swift:32:8: error: enum case 'intValue' cannot be\
    \ used as an instance member\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n       ^\n       Value\n/tmp/tmp5kd0gmbk.swift:32:19: error: missing argument\
    \ for parameter #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                  ^\n                  <#Int#>\n/tmp/tmp5kd0gmbk.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp5kd0gmbk.swift:32:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmp5kd0gmbk.swift:32:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmp5kd0gmbk.swift:32:23: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                      ^\n                      Value\n/tmp/tmp5kd0gmbk.swift:32:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n                                 ^\n              \
    \                   <#Int#>\n/tmp/tmp5kd0gmbk.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmp5kd0gmbk.swift:32:55: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Int'\n    if\
    \ a.intValue() < b.intValue() { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprrrhu10f.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmprrrhu10f.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmprrrhu10f.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmprrrhu10f.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmprrrhu10f.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmprrrhu10f.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .stringValue(aString),\
    \ let .intValue(aInt), let .doubleValue(aDouble)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .stringValue(aString), let\
    \ .intValue(aInt), let .doubleValue(aDouble)\n            where b == .doubleValue(aDouble)\n\
    \            return .doubleValue(aDouble)\n        case let .stringValue(aString),\
    \ let .intValue(aInt), let .doubleValue(aDouble)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpuf_5xql2.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpuf_5xql2.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpuf_5xql2.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpuf_5xql2.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpuf_5xql2.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpuf_5xql2.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpuf_5xql2.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpuf_5xql2.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpuf_5xql2.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpuf_5xql2.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpuf_5xql2.s"
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare a to b\n    case .intValue(_):\n\
    \        switch b { // Compare b to a\n        case .intValue(_):\n          \
    \  return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Compare b to a\n        case .intValue(_):\n          \
    \  return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare b to a\n        case .intValue(_):\n          \
    \  return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    }\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpd2v4lknm/tmpd2v4lknm.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c041bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8c0112b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8c0112988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8c01117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2v4lknm                        0x000055666df0ca56 <unavailable> + 6742

    5    libc.so.6                          0x00002ae8c0607460 __libc_start_main +
    245

    6    tmpd2v4lknm                        0x000055666df0c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_):\n    \
    \    switch b { \n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b { \n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp1bgu57pn/tmp1bgu57pn.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c815ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c812e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c812e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c812e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bgu57pn                        0x0000556ebd16ea56 <unavailable> + 6742

    5    libc.so.6                          0x00002b9c817d7460 __libc_start_main +
    245

    6    tmp1bgu57pn                        0x0000556ebd16e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8z8rsdln.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp8z8rsdln.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp8z8rsdln.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp8z8rsdln.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp8z8rsdln.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp8z8rsdln.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp8z8rsdln.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp8z8rsdln.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp8z8rsdln.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp8z8rsdln.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt) || b == .doubleValue(aDouble)\
    \ || b == .stringValue(aString)\n        {\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvw818i8u.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpvw818i8u.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpvw818i8u.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpvw818i8u.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpvw818i8u.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpvw818i8u.swift:27:10: error: expected ':' after 'case'\n   \
    \     }\n         ^\n/tmp/tmpvw818i8u.swift:24:34: error: cannot find 'aInt' in\
    \ scope\n            where b == .intValue(aInt) || b == .doubleValue(aDouble)\
    \ || b == .stringValue(aString)\n                                 ^~~~\n/tmp/tmpvw818i8u.swift:24:61:\
    \ error: cannot find 'aDouble' in scope\n            where b == .intValue(aInt)\
    \ || b == .doubleValue(aDouble) || b == .stringValue(aString)\n              \
    \                                              ^~~~~~~\n/tmp/tmpvw818i8u.swift:24:75:\
    \ error: binary operator '==' cannot be applied to operands of type 'Value' and\
    \ '_'\n            where b == .intValue(aInt) || b == .doubleValue(aDouble) ||\
    \ b == .stringValue(aString)\n                                               \
    \                         ~ ^  ~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvw818i8u.swift:24:79:\
    \ error: reference to member 'stringValue' cannot be resolved without a contextual\
    \ type\n            where b == .intValue(aInt) || b == .doubleValu"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two integers\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return nil\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Compare two doubles\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return nil\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return a\n        case .doubleValue(_):\n            return b\n      \
    \  case .stringValue(_):\n            return nil\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp7gl0vfn7/tmp7gl0vfn7.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84d7cbec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84d79b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84d79b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84d79b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7gl0vfn7                        0x000056290b521a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b84d7eaa460 __libc_start_main +
    245

    6    tmp7gl0vfn7                        0x000056290b521499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Switch on b's type\n        case .intValue(_):\n            return .doubleValue(DoubleMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .doubleValue(DoubleMax)\n  \
    \      }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .stringValue(StringMax)\n    \
    \    case .doubleValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .stringValue(_):\n            return .stringValue(StringMax)\n      \
    \  }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpm_unm3ua.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpm_unm3ua.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmpm_unm3ua.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpm_unm3ua.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpm_unm3ua.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyy2hadb5.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpyy2hadb5.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpyy2hadb5.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpyy2hadb5.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpyy2hadb5.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpyy2hadb5.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpyy2hadb5.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpyy2hadb5.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpyy2hadb5.s"
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return.\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which case to return.\n        case .intValue(_):\n   \
    \         return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return.\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return.\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.intValue ? a.stringValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7vgsue0e.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmp7vgsue0e.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmp7vgsue0e.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp7vgsue0e.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmp7vgsue0e.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmp7vgsue0e.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmp7vgsue0e.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmp7vgsue0e.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return a > b ? a : b\n        case .doubleValue(_):\n            return a >\
    \ b ? b : a\n        case .stringValue(_):\n            return a > b ? b : a\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return a > b ? a : b\n        case .doubleValue(_):\n\
    \            return a > b ? b : a\n        case .stringValue(_):\n           \
    \ return a > b ? b : a\n        }\n    case .stringValue(_):\n        switch b\
    \ { // Switch on type\n        case .intValue(_):\n            return a > b ?\
    \ a : b\n        case .doubleValue(_):\n            return a > b ? b : a\n   \
    \     case .stringValue(_):\n            return a > b ? b : a\n        }\n   \
    \ }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpquclqrc4.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpquclqrc4.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmpquclqrc4.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpquclqrc4.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpquclqrc4.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpquclqrc4.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmpquclqrc4.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpquclqrc4.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmpquclqrc4.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n              "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue() {\n          \
    \  return .intValue(aInt > bInt ? aInt : bInt)\n        } else if let bDouble\
    \ = b.doubleValue() {\n            return .doubleValue(aDouble > bDouble ? aDouble\
    \ : bDouble)\n        } else if let bString = b.stringValue() {\n            return\
    \ .stringValue(aString > bString ? aString : bString)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp479s10wi.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp479s10wi.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmp479s10wi.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmp479s10wi.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmp479s10wi.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmp479s10wi.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmp479s10wi.swift:25:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue() {\n         \
    \             ^\n                      Value\n/tmp/tmp479s10wi.swift:25:34: error:\
    \ missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmp479s10wi.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmp479s10wi.swift:27:33: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        } else if let bDouble = b.doubleValue()\
    \ {\n                                ^\n                                Value\n\
    /tmp/tmp479s10wi.swift:27:47: error: missing argument for parameter #1 in call\n\
    \        } else if let bDouble = b.doub"
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to switch case\
    \ when Swift 4 is released\n    case .intValue(_):\n        switch b { // TODO:\
    \ Switch to switch case when Swift 4 is released\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // TODO: Switch to switch case when Swift 4 is released\n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { // TODO: Switch to switch\
    \ case when Swift 4 is released\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp3sw78xwc/tmp3sw78xwc.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78e40a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78e3d9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78e3d9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78e3d9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3sw78xwc                        0x00005654c101da56 <unavailable> + 6742

    5    libc.so.6                          0x00002b78e4292460 __libc_start_main +
    245

    6    tmp3sw78xwc                        0x00005654c101d499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphee_h68n.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmphee_h68n.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? a : b\n\
    \        case .doubleValue(_):\n            return a > b ? b : a\n        case\
    \ .stringValue(_):\n            return a > b ? b : a\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? a : b\n        case .doubleValue(_):\n            return\
    \ a > b ? b : a\n        case .stringValue(_):\n            return a > b ? b :\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3ala2o4h.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmp3ala2o4h.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp3ala2o4h.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp3ala2o4h.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmp3ala2o4h.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n              "
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_):\n    \
    \    switch b { \n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b { \n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp1bgu57pn/tmp1bgu57pn.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c815ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c812e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c812e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c812e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bgu57pn                        0x0000556ebd16ea56 <unavailable> + 6742

    5    libc.so.6                          0x00002b9c817d7460 __libc_start_main +
    245

    6    tmp1bgu57pn                        0x0000556ebd16e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), let .doubleValue(aDouble), let\
    \ .stringValue(aString)\n        if let bInt = b.intValue() {\n            return\
    \ .intValue(aInt > bInt ? aInt : bInt)\n        } else if let bDouble = b.doubleValue()\
    \ {\n            return .doubleValue(aDouble > bDouble ? aDouble : bDouble)\n\
    \        } else if let bString = b.stringValue() {\n            return .stringValue(aString\
    \ > bString ? aString : bString)\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprfql9jox.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmprfql9jox.swift:23:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmprfql9jox.swift:23:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmprfql9jox.swift:23:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmprfql9jox.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmprfql9jox.swift:23:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmprfql9jox.swift:24:34: error: missing argument for parameter\
    \ #1 in call\n        if let bInt = b.intValue() {\n                         \
    \        ^\n                                 <#Int#>\n/tmp/tmprfql9jox.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmprfql9jox.swift:24:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        if\
    \ let bInt = b.intValue() {\n                      ^\n                      Value\n\
    /tmp/tmprfql9jox.swift:26:33: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n        } else if let bDouble = b.doubleValue() {\n    \
    \                            ^\n                                Value\n/tmp/tmprfql9jox.swift:26:47:\
    \ error: missing argument for parameter #1 in call\n        } else if let bDouble\
    \ = b.doub"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of the first\
    \ value.\n    case .intValue(_):\n        switch b { // Switch on the type of\
    \ the second value.\n        case .intValue(_):\n            return .intValue(IntMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .stringValue(StringMax)\n  \
    \      }\n    case .doubleValue(_):\n        switch b { // Switch on the type\
    \ of the second value.\n        case .intValue(_):\n            return .doubleValue(DoubleMax)\n\
    \        case .doubleValue(_):\n            return .doubleValue(DoubleMax)\n \
    \       case .stringValue(_):\n            return .stringValue(StringMax)\n  \
    \      }\n    case .stringValue(_):\n        switch b { // Switch on the type\
    \ of the second value.\n        case .intValue(_):\n            return .stringValue(StringMax)\n\
    \        case .doubleValue(_):\n            return .stringValue(StringMax)\n \
    \       case .stringValue(_):\n            return .stringValue(StringMax)\n  \
    \      }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwsrraogs.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpwsrraogs.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpwsrraogs.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpwsrraogs.swift:35:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpwsrraogs.swift:37:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpwsrraogs.swift:39:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpwsrraogs.swift:44:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpwsrraogs.swift:46:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmpwsrraogs.swift:48:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.intValue ? a.stringValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcwg4drf3.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpcwg4drf3.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpcwg4drf3.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcwg4drf3.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcwg4drf3.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpcwg4drf3.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpcwg4drf3.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpcwg4drf3.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n        default: return nil\n    }\n    if\
    \ a.intValue() < b.intValue() { return .intValue(a) }\n    if a.doubleValue()\
    \ < b.doubleValue() { return .doubleValue(a) }\n    if a.stringValue() < b.stringValue()\
    \ { return .stringValue(a) }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0wde6jv6.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp0wde6jv6.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmp0wde6jv6.swift:28:8: error: enum case 'intValue' cannot be\
    \ used as an instance member\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n       ^\n       Value\n/tmp/tmp0wde6jv6.swift:28:19: error: missing argument\
    \ for parameter #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                  ^\n                  <#Int#>\n/tmp/tmp0wde6jv6.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp0wde6jv6.swift:28:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmp0wde6jv6.swift:28:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmp0wde6jv6.swift:28:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n      \
    \                           ^\n                                 <#Int#>\n/tmp/tmp0wde6jv6.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp0wde6jv6.swift:28:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n                      ^\n          \
    \            Value\n/tmp/tmp0wde6jv6.swift:28:55: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two integers\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Compare two doubles\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzb_84jww.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpzb_84jww.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpzb_84jww.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpzb_84jww.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpzb_84jww.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpzb_84jww.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpzb_84jww.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpzb_84jww.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .stringValue(a.stringValue > b.doubleValue\
    \ ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprrrhu10f.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmprrrhu10f.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmprrrhu10f.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmprrrhu10f.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmprrrhu10f.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmprrrhu10f.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmprrrhu10f.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), let .doubleValue(aDouble), let\
    \ .stringValue(aString)\n        if let bInt = b.intValue(), bInt == aInt {\n\
    \            return a\n        } else if let bDouble = b.doubleValue(), bDouble\
    \ == aDouble {\n            return a\n        } else if let bString = b.stringValue(),\
    \ bString == aString {\n            return a\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwm7lcxxu.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpwm7lcxxu.swift:23:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpwm7lcxxu.swift:23:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpwm7lcxxu.swift:23:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpwm7lcxxu.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpwm7lcxxu.swift:23:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpwm7lcxxu.swift:24:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue(), bInt == aInt\
    \ {\n                      ^\n                      Value\n/tmp/tmpwm7lcxxu.swift:24:34:\
    \ error: missing argument for parameter #1 in call\n        if let bInt = b.intValue(),\
    \ bInt == aInt {\n                                 ^\n                       \
    \          <#Int#>\n/tmp/tmpwm7lcxxu.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmpwm7lcxxu.swift:26:47: error: missing\
    \ argument for parameter #1 in call\n        } else if let bDouble = b.doubleValue(),\
    \ bDouble == aDouble {\n                                              ^\n    \
    \                                          <#Double#>\n/tmp/tmpwm7lcxxu.swift:4:10:\
    \ note: 'doubleValue' declar"
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return a\n        case .doubleValue(_):\n            return b\n        case\
    \ .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on type to determine which case to return\n    \
    \    case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { // Switch on type to\
    \ determine which case to return\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpltds6ajn/tmpltds6ajn.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1678a66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b167875db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b167875d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b167875c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpltds6ajn                        0x0000557bdc4e1a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b1678c52460 __libc_start_main +
    245

    6    tmpltds6ajn                        0x0000557bdc4e1499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        switch b { // b is bigger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0fnq2imt/tmp0fnq2imt.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3ebe29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3ebb20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3ebb20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3ebb1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fnq2imt                        0x00005602ef2a6a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ab3ec015460 __libc_start_main +
    245

    6    tmp0fnq2imt                        0x00005602ef2a6499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .doubleValue(_):\n        switch b { // Switch on b.\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b.\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpu6ds3y04.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpu6ds3y04.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpu6ds3y04.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpu6ds3y04.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpu6ds3y04.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpu6ds3y04.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpu6ds3y04.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpu6ds3y04.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpu6ds3y04.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpu6ds3y04.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphee_h68n.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmphee_h68n.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n    if a.doubleValue() > b.doubleValue()\
    \ { return .doubleValue() }\n    if a.stringValue() > b.stringValue() { return\
    \ .stringValue() }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4il9c2jr.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp4il9c2jr.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmp4il9c2jr.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \              ^\n                  <#Int#>\n/tmp/tmp4il9c2jr.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp4il9c2jr.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n       ^\n       Value\n/tmp/tmp4il9c2jr.swift:28:21:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() > b.intValue() { return .intValue()\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmp4il9c2jr.swift:28:21:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() > b.intValue() { return .intValue() }\n                 \
    \   ^\n/tmp/tmp4il9c2jr.swift:28:34: error: missing argument for parameter #1\
    \ in call\n    if a.intValue() > b.intValue() { return .intValue() }\n       \
    \                          ^\n                                 <#Int#>\n/tmp/tmp4il9c2jr.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp4il9c2jr.swift:28:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ > b.intValue() { return .intValue() }\n                      ^\n           \
    \           Value\n/tmp/tmp4il9c2jr.swift:28:55: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() > b.intValue() { return .intValue() }\n    \
    \                                 "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbkw9iire.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpbkw9iire.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpbkw9iire.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpbkw9iire.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpbkw9iire.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpbkw9iire.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpbkw9iire.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpbkw9iire.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpbkw9iire.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpbkw9iire.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .intValue(aInt)\n        \
    \    return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .intValue(aInt)\n\
    \            return .intValue(aInt)\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n            where b == .doubleValue(aDouble)\n  \
    \          return .doubleValue(aDouble)\n        case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n            where b == .stringValue(aString)\n\
    \            return .stringValue(aString)\n        case let .intValue(aInt\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyy2hadb5.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpyy2hadb5.swift:23:52:\
    \ error: 'aDouble' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                              ^\n/tmp/tmpyy2hadb5.swift:23:28: error: 'aInt'\
    \ must be bound in every pattern\n        case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                           ^\n/tmp/tmpyy2hadb5.swift:23:79:\
    \ error: 'aString' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                         ^\n/tmp/tmpyy2hadb5.swift:23:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:24:39: error: expected ':' after 'case'\n   \
    \         where b == .intValue(aInt)\n                                      ^\n\
    /tmp/tmpyy2hadb5.swift:26:52: error: 'aDouble' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                   ^\n/tmp/tmpyy2hadb5.swift:26:28:\
    \ error: 'aInt' must be bound in every pattern\n        case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \      ^\n/tmp/tmpyy2hadb5.swift:26:79: error: 'aString' must be bound in every\
    \ pattern\n        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \  ^\n/tmp/tmpyy2hadb5.swift:26:28: error: 'aInt' must be bound in every pattern\n\
    \        case let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                           ^\n/tmp/tmpyy2hadb5.s"
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to enum\n    case\
    \ .intValue(_):\n        switch b { // TODO: Switch to enum\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // TODO: Switch to enum\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: Switch to enum\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpk4sdqcse/tmpk4sdqcse.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89b1d24c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89b1a1bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89b1a1b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89b1a1a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk4sdqcse                        0x000055f3d9bf3a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b89b1f10460 __libc_start_main +
    245

    6    tmpk4sdqcse                        0x000055f3d9bf3499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare values\n    case .intValue(_):\n\
    \        switch b { // Compare values\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare values\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare values\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpiyz9yfrt.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpiyz9yfrt.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpiyz9yfrt.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpiyz9yfrt.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpiyz9yfrt.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpiyz9yfrt.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpiyz9yfrt.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpiyz9yfrt.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpiyz9yfrt.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpiyz9yfrt.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .doubleValue(DoubleMax)\n        case .stringValue(_):\n        \
    \    return .stringValue(StringMax)\n        }\n    case .doubleValue(_):\n  \
    \      switch b { // Switch on b's type\n        case .intValue(_):\n        \
    \    return .intValue(IntMax)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(DoubleMax)\n        case .stringValue(_):\n            return .stringValue(StringMax)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .intValue(IntMax)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(DoubleMax)\n        case .stringValue(_):\n\
    \            return .stringValue(StringMax)\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp6qf2fh1q.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmp6qf2fh1q.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp6qf2fh1q.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp6qf2fh1q.swift:35:30: error:\
    \ cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n      \
    \                       ^~~~~~\n/tmp/tmp6qf2fh1q.swift:37:33: error: cannot find\
    \ 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n         \
    \                       ^~~~~~~~~\n/tmp/tmp6qf2fh1q.swift:39:33: error: cannot\
    \ find 'StringMax' in scope\n            return .stringValue(StringMax)\n    \
    \                            ^~~~~~~~~\n/tmp/tmp6qf2fh1q.swift:44:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmp6qf2fh1q.swift:46:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp6qf2fh1q.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Make this more efficient\n\
    \    case .intValue(_):\n        switch b {\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b {\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ {\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp1kecjsja/tmp1kecjsja.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b280577bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2805472b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2805472988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28054717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1kecjsja                        0x0000558e3e05da56 <unavailable> + 6742

    5    libc.so.6                          0x00002b2805967460 __libc_start_main +
    245

    6    tmp1kecjsja                        0x0000558e3e05d499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case .intValue(_), .doubleValue(_), .stringValue(_):\n\
    \        switch b { // case .intValue(_), .doubleValue(_), .stringValue(_)\n \
    \       case .intValue(_), .doubleValue(_), .stringValue(_):\n            return\
    \ a\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .intValue(_):\n        switch b { // case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case .intValue(_), .doubleValue(_), .stringValue(_):\n\
    \            return b\n        case .intValue(_):\n            return a\n    \
    \    case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return a\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // case .intValue(_), .doubleValue(_), .stringValue(_)\n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_):\n            return a\n        case .intValue(_):\n\
    \            return b\n        case .doubleValue(_):\n            return a\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // case .intValue(_), .doubleValue(_), .stringValue(_)\n \
    \       case .intValue(_), .doubleValue(_), .stringValue(_):\n            return\
    \ a\n        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return b\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpt7h8cf0b/tmpt7h8cf0b.swift:84: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0e54ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0e51e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0e51e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0e51e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt7h8cf0b                        0x000055ec1ef61a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ac0e56d7460 __libc_start_main +
    245

    6    tmpt7h8cf0b                        0x000055ec1ef61499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(a), let .doubleValue(b), let .stringValue(aString),\
    \ let .stringValue(bString)\n            if aString == bString {\n           \
    \     return a\n            }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplegnu7an.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmplegnu7an.swift:23:49:\
    \ error: 'b' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                                            ^\n/tmp/tmplegnu7an.swift:23:28:\
    \ error: 'a' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                       ^\n/tmp/tmplegnu7an.swift:23:70: error: 'aString' must\
    \ be bound in every pattern\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                ^\n/tmp/tmplegnu7an.swift:23:28:\
    \ error: 'a' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString), let .stringValue(bString)\n    \
    \                       ^\n/tmp/tmplegnu7an.swift:23:97: error: 'bString' must\
    \ be bound in every pattern\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                                           ^\n\
    /tmp/tmplegnu7an.swift:23:28: error: 'a' must be bound in every pattern\n    \
    \    case let .intValue(a), let .doubleValue(b), let .stringValue(aString), let\
    \ .stringValue(bString)\n                           ^\n/tmp/tmplegnu7an.swift:23:105:\
    \ error: expected ':' after 'case'\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString), let .stringValue(bString)\n                     \
    \                                                                            \
    \       ^\n/tmp/tmplegnu7an.swift:24:16: error: cannot find 'aString' in scope\n\
    \            if aString == bString {\n               ^~~~~~~\n/tmp/tmplegnu7an.swift:24:27:\
    \ error: cannot find 'bString' in scope\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), let .doubleValue(aDouble), let\
    \ .stringValue(aString)\n        if b == .intValue(aInt) {\n            return\
    \ .intValue(aInt)\n        } else if b == .doubleValue(aDouble) {\n          \
    \  return .doubleValue(aDouble)\n        } else if b == .stringValue(aString)\
    \ {\n            return .stringValue(aString)\n        } else {\n            return\
    \ nil\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7ky62rsv.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp7ky62rsv.swift:23:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmp7ky62rsv.swift:23:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmp7ky62rsv.swift:23:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmp7ky62rsv.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmp7ky62rsv.swift:23:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmp7ky62rsv.swift:26:37: error: cannot find 'aDouble' in scope\n\
    \        } else if b == .doubleValue(aDouble) {\n                            \
    \        ^~~~~~~\n/tmp/tmp7ky62rsv.swift:27:33: error: cannot find 'aDouble' in\
    \ scope\n            return .doubleValue(aDouble)\n                          \
    \      ^~~~~~~\n/tmp/tmp7ky62rsv.swift:28:37: error: cannot find 'aString' in\
    \ scope\n        } else if b == .stringValue(aString) {\n                    \
    \                ^~~~~~~\n/tmp/tmp7ky62rsv.swift:29:33: error: cannot find 'aString'\
    \ in scope\n            return .stringValue(aString)\n                       \
    \         ^~~~~~~\n/tmp/tmp7ky62rsv.swift:23:10: warning: case is already handled\
    \ by previous patterns; consider removing it\n    case let .intValue(aInt), let\
    \ .doubleValue(aDouble), let .stringValue(aString)\n  "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on b's type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnb_r5v5s.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpnb_r5v5s.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpnb_r5v5s.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpnb_r5v5s.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpnb_r5v5s.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpnb_r5v5s.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpnb_r5v5s.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpnb_r5v5s.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpnb_r5v5s.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpnb_r5v5s.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(IntMax)\n        case .doubleValue(_):\n       \
    \     return .doubleValue(DoubleMax)\n        case .stringValue(_):\n        \
    \    return .stringValue(StringMax)\n        }\n    case .doubleValue(_):\n  \
    \      switch b { // Switch on b's type\n        case .intValue(_):\n        \
    \    return .doubleValue(DoubleMax)\n        case .doubleValue(_):\n         \
    \   return .doubleValue(DoubleMax)\n        case .stringValue(_):\n          \
    \  return .stringValue(StringMax)\n        }\n    case .stringValue(_):\n    \
    \    switch b { // Switch on b's type\n        case .intValue(_):\n          \
    \  return .stringValue(StringMax)\n        case .doubleValue(_):\n           \
    \ return .stringValue(StringMax)\n        case .stringValue(_):\n            return\
    \ .stringValue(StringMax)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0k3pgcbc.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmp0k3pgcbc.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp0k3pgcbc.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp0k3pgcbc.swift:35:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp0k3pgcbc.swift:37:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp0k3pgcbc.swift:39:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp0k3pgcbc.swift:44:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp0k3pgcbc.swift:46:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmp0k3pgcbc.swift:48:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a.\n    case .intValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on b.\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue ? a.doubleValue : b.intValue)\n    \
    \    case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b { // Switch on b.\n  \
    \      case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue\
    \ ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphrm_hcg6.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmphrm_hcg6.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmphrm_hcg6.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmphrm_hcg6.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmphrm_hcg6.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmphrm_hcg6.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmphrm_hcg6.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmphrm_hcg6.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on type to determine which case to return\n    \
    \    case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue\
    \ ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcuzc2jhq.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpcuzc2jhq.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpcuzc2jhq.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcuzc2jhq.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcuzc2jhq.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpcuzc2jhq.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpcuzc2jhq.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpcuzc2jhq.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp666rbu_1.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp666rbu_1.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp666rbu_1.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp666rbu_1.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp666rbu_1.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp67j6cjl1.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp67j6cjl1.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp67j6cjl1.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp67j6cjl1.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp67j6cjl1.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp67j6cjl1.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp67j6cjl1.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp67j6cjl1.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp67j6cjl1.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp67j6cjl1.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to switch on enum\n\
    \    case .intValue(_):\n        switch b { // TODO: Switch to switch on enum\n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .doubleValue(_):\n        switch b { // TODO: Switch to switch\
    \ on enum\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { // TODO: Switch to switch\
    \ on enum\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp9logj8jt/tmp9logj8jt.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0dd2dbdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0dd2ab4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0dd2ab4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0dd2ab37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9logj8jt                        0x0000557463029a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b0dd2fa9460 __libc_start_main +
    245

    6    tmp9logj8jt                        0x0000557463029499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? b : a\n\
    \        case .doubleValue(_):\n            return a > b ? a : b\n        case\
    \ .stringValue(_):\n            return a > b ? a : b\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? b : a\n        case .doubleValue(_):\n            return\
    \ a > b ? a : b\n        case .stringValue(_):\n            return a > b ? a :\
    \ b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprkr4waks.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmprkr4waks.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmprkr4waks.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmprkr4waks.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmprkr4waks.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmprkr4waks.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmprkr4waks.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmprkr4waks.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmprkr4waks.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n              "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n     \
    \   case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsnuvevoh.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpsnuvevoh.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpsnuvevoh.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpsnuvevoh.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpsnuvevoh.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpsnuvevoh.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: Switch to enum\n    case\
    \ .intValue(_):\n        switch b { // TODO: Switch to enum\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // TODO: Switch to enum\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: Switch to enum\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpk4sdqcse/tmpk4sdqcse.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89b1d24c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89b1a1bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89b1a1b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89b1a1a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk4sdqcse                        0x000055f3d9bf3a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b89b1f10460 __libc_start_main +
    245

    6    tmpk4sdqcse                        0x000055f3d9bf3499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n  \
    \          return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .stringValue(_):\n        switch b { // Switch on type to determine which\
    \ comparison to use\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp159inz28.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp159inz28.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp159inz28.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp159inz28.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp159inz28.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp159inz28.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp159inz28.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp159inz28.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp159inz28.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp159inz28.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default: return nil\n    }\n    \n    switch b {\
    \ case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default: return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxg5877d1.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpxg5877d1.swift:27:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        switch b { // b is bigger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0fnq2imt/tmp0fnq2imt.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3ebe29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3ebb20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3ebb20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3ebb1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fnq2imt                        0x00005602ef2a6a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ab3ec015460 __libc_start_main +
    245

    6    tmp0fnq2imt                        0x00005602ef2a6499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case let .intValue(aInt), .doubleValue(aDouble), .stringValue(aString)\n\
    \        if let bInt = b.intValue() {\n            return .intValue(aInt > bInt\
    \ ? aInt : bInt)\n        } else if let bDouble = b.doubleValue() {\n        \
    \    return .doubleValue(aDouble > bDouble ? aDouble : bDouble)\n        } else\
    \ if let bString = b.stringValue() {\n            return .stringValue(aString\
    \ > bString ? aString : bString)\n        }\n        return nil\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjb1_ch5j.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpjb1_ch5j.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ .doubleValue(aDouble), .stringValue(aString)\n                       ^\n/tmp/tmpjb1_ch5j.swift:23:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ .doubleValue(aDouble), .stringValue(aString)\n                       ^\n/tmp/tmpjb1_ch5j.swift:23:75:\
    \ error: expected ':' after 'case'\n    case let .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString)\n                                                    \
    \                      ^\n/tmp/tmpjb1_ch5j.swift:23:44: error: cannot find 'aDouble'\
    \ in scope\n    case let .intValue(aInt), .doubleValue(aDouble), .stringValue(aString)\n\
    \                                           ^~~~~~~\n/tmp/tmpjb1_ch5j.swift:23:67:\
    \ error: cannot find 'aString' in scope\n    case let .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString)\n                                                    \
    \              ^~~~~~~\n/tmp/tmpjb1_ch5j.swift:24:23: error: enum case 'intValue'\
    \ cannot be used as an instance member\n        if let bInt = b.intValue() {\n\
    \                      ^\n                      Value\n/tmp/tmpjb1_ch5j.swift:24:34:\
    \ error: missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpjb1_ch5j.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpjb1_ch5j.swift:26:47: error: missing argument for parameter\
    \ #1 in call\n        } else if let bDouble = b.doubleValue() {\n            \
    \                                  ^\n                                       \
    \       <#Double#>\n/tmp/tmpjb1_ch5j.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doubleValue(Double)\n         ^\n/tmp/tmpjb1_ch5j.swift:26:33:\
    \ error: enum case 'doubleValue' cannot "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on the type of the first\
    \ argument.\n    case .intValue(_):\n        switch b { // Switch on the type\
    \ of the second argument.\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n        case .doubleValue(_):\n   \
    \         return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue :\
    \ b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .doubleValue(_):\n\
    \        switch b { // Switch on the type of the second argument.\n        case\
    \ .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue ?\
    \ a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on the type of the second argument.\n        case .intValue(_):\n   \
    \         return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjy77kbhv.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpjy77kbhv.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpjy77kbhv.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpjy77kbhv.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpjy77kbhv.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpjy77kbhv.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpjy77kbhv.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpjy77kbhv.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.intValue)\n        case .doubleValue(_):\n  \
    \          return .doubleValue(a.doubleValue > b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        }\n \
    \   case .stringValue(_):\n        switch b { // Switch on type to determine which\
    \ comparison to use\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp159inz28.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp159inz28.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp159inz28.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp159inz28.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp159inz28.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp159inz28.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp159inz28.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp159inz28.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp159inz28.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp159inz28.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type to\
    \ determine which comparison to use\n        case .intValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8z8rsdln.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp8z8rsdln.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp8z8rsdln.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp8z8rsdln.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp8z8rsdln.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp8z8rsdln.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp8z8rsdln.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp8z8rsdln.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp8z8rsdln.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp8z8rsdln.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default: return nil\n    }\n    switch b { case .intValue(_),\
    \ .doubleValue(_), .stringValue(_)\n    default: return nil\n    }\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n    if a.doubleValue() < b.doubleValue()\
    \ { return .doubleValue(a) }\n    if a.stringValue() < b.stringValue() { return\
    \ .stringValue(a) }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmph8ajn2so.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmph8ajn2so.swift:25:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmph8ajn2so.swift:28:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() { return .intValue(a) }\n   \
    \               ^\n                  <#Int#>\n/tmp/tmph8ajn2so.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmph8ajn2so.swift:28:8:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() { return .intValue(a) }\n       ^\n       Value\n/tmp/tmph8ajn2so.swift:28:21:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                    ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\n\
    public protocol Comparable : Equatable {\n                ^\n/tmp/tmph8ajn2so.swift:28:21:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.intValue() < b.intValue() { return .intValue(a) }\n                \
    \    ^\n/tmp/tmph8ajn2so.swift:28:23: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue() < b.intValue() { return .intValue(a)\
    \ }\n                      ^\n                      Value\n/tmp/tmph8ajn2so.swift:28:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() < b.intValue()\
    \ { return .intValue(a) }\n                                 ^\n              \
    \                   <#Int#>\n/tmp/tmph8ajn2so.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmph8ajn2so.swift:28:55: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Int'\n    if\
    \ a.intValue() < b.intValue() { return .intValue(a) }\n   "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n        case let .intValue(a), let .doubleValue(b), let .stringValue(aString):\n\
    \            switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n\
    \                case let .intValue(b), let .doubleValue(bString):\n         \
    \           if aString == bString {\n                        return a\n      \
    \              }\n                    return nil\n                case let .stringValue(bString):\n\
    \                    if aString < bString {\n                        return a\n\
    \                    }\n                    return nil\n            }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp19hugwpn.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmp19hugwpn.swift:23:49:\
    \ error: 'b' must be bound in every pattern\n        case let .intValue(a), let\
    \ .doubleValue(b), let .stringValue(aString):\n                              \
    \                  ^\n/tmp/tmp19hugwpn.swift:23:28: error: 'a' must be bound in\
    \ every pattern\n        case let .intValue(a), let .doubleValue(b), let .stringValue(aString):\n\
    \                           ^\n/tmp/tmp19hugwpn.swift:23:70: error: 'aString'\
    \ must be bound in every pattern\n        case let .intValue(a), let .doubleValue(b),\
    \ let .stringValue(aString):\n                                               \
    \                      ^\n/tmp/tmp19hugwpn.swift:23:28: error: 'a' must be bound\
    \ in every pattern\n        case let .intValue(a), let .doubleValue(b), let .stringValue(aString):\n\
    \                           ^\n/tmp/tmp19hugwpn.swift:24:75: error: expected ':'\
    \ after 'case'\n            switch b { case .intValue(_), .doubleValue(_), .stringValue(_)\n\
    \                                                                          ^\n\
    /tmp/tmp19hugwpn.swift:25:57: error: 'bString' must be bound in every pattern\n\
    \                case let .intValue(b), let .doubleValue(bString):\n         \
    \                                               ^\n/tmp/tmp19hugwpn.swift:25:36:\
    \ error: 'b' must be bound in every pattern\n                case let .intValue(b),\
    \ let .doubleValue(bString):\n                                   ^\n/tmp/tmp19hugwpn.swift:26:24:\
    \ error: cannot find 'aString' in scope\n                    if aString == bString\
    \ {\n                       ^~~~~~~\n/tmp/tmp19hugwpn.swift:26:35: error: cannot\
    \ find 'bString' in scope\n                    if aString == bString {\n     \
    \                             ^~~~~~~\n/tmp/tmp19hugwpn.swift:27:32: error: cannot\
    \ convert return expression of type 'Int' to return type 'Value?'\n          \
    \              return a\n                               ^"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue() {\n          \
    \  return .intValue(aInt > bInt ? aInt : bInt)\n        }\n        if let bDouble\
    \ = b.doubleValue() {\n            return .doubleValue(aDouble > bDouble ? aDouble\
    \ : bDouble)\n        }\n        if let bString = b.stringValue() {\n        \
    \    return .stringValue(aString > bString ? aString : bString)\n        }\n \
    \       return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprgirrm4c.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmprgirrm4c.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmprgirrm4c.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmprgirrm4c.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmprgirrm4c.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmprgirrm4c.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmprgirrm4c.swift:25:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue() {\n         \
    \             ^\n                      Value\n/tmp/tmprgirrm4c.swift:25:34: error:\
    \ missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmprgirrm4c.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmprgirrm4c.swift:28:26: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        if let bDouble = b.doubleValue() {\n\
    \                         ^\n                         Value\n/tmp/tmprgirrm4c.swift:28:40:\
    \ error: missing argument for parameter #1 in call\n        if let bDouble = b.doubleValue()\
    \ {\n                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue() {\n          \
    \  return .intValue(aInt > bInt ? aInt : bInt)\n        } else if let bDouble\
    \ = b.doubleValue() {\n            return .doubleValue(aDouble > bDouble ? aDouble\
    \ : bDouble)\n        } else if let bString = b.stringValue() {\n            return\
    \ .stringValue(aString > bString ? aString : bString)\n        }\n        \n \
    \       return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmh9_w68p.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpmh9_w68p.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmpmh9_w68p.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmpmh9_w68p.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmpmh9_w68p.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmpmh9_w68p.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmpmh9_w68p.swift:25:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue() {\n         \
    \             ^\n                      Value\n/tmp/tmpmh9_w68p.swift:25:34: error:\
    \ missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpmh9_w68p.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpmh9_w68p.swift:27:47: error: missing argument for parameter\
    \ #1 in call\n        } else if let bDouble = b.doubleValue() {\n            \
    \                                  ^\n                                       \
    \       <#Double#>\n/tmp/tmpmh9_w68p.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doubleValue(Double)\n         ^\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two values\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare two values\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare two values\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp007wyfxk.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp007wyfxk.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp007wyfxk.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp007wyfxk.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp007wyfxk.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp007wyfxk.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp007wyfxk.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmp007wyfxk.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmp007wyfxk.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmp007wyfxk.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ .intValue(a)\n        case .doubleValue(_):\n            return .doubleValue(a)\n\
    \        case .stringValue(_):\n            return .stringValue(a)\n        }\n\
    \    case .doubleValue(_):\n        switch b { // b is larger\n        case .intValue(_):\n\
    \            return .doubleValue(a)\n        case .doubleValue(_):\n         \
    \   return .doubleValue(a)\n        case .stringValue(_):\n            return\
    \ .stringValue(a)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ b is larger\n        case .intValue(_):\n            return .stringValue(a)\n\
    \        case .doubleValue(_):\n            return .stringValue(a)\n        case\
    \ .stringValue(_):\n            return .stringValue(a)\n        }\n    }\n   \
    \ return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp582d044r.swift:26:30: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n            return .intValue(a)\n         \
    \                    ^\n/tmp/tmp582d044r.swift:28:33: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Double'\n            return .doubleValue(a)\n\
    \                                ^\n/tmp/tmp582d044r.swift:30:33: error: cannot\
    \ convert value of type 'Value' to expected argument type 'String'\n         \
    \   return .stringValue(a)\n                                ^\n/tmp/tmp582d044r.swift:35:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \            return .doubleValue(a)\n                                ^\n/tmp/tmp582d044r.swift:37:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \            return .doubleValue(a)\n                                ^\n/tmp/tmp582d044r.swift:39:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \            return .stringValue(a)\n                                ^\n/tmp/tmp582d044r.swift:44:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \            return .stringValue(a)\n                                ^\n/tmp/tmp582d044r.swift:46:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \            return .stringValue(a)\n                                ^\n/tmp/tmp582d044r.swift:48:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \            return .stringValue(a)\n                                ^\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare first by type\n    case\
    \ .intValue(_):\n        switch b { // Compare second by type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare second by\
    \ type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Compare second by type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpokjk2qw3.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpokjk2qw3.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpokjk2qw3.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpokjk2qw3.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpokjk2qw3.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpokjk2qw3.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpokjk2qw3.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpokjk2qw3.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpokjk2qw3.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpokjk2qw3.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        switch b { // b is bigger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is bigger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0fnq2imt/tmp0fnq2imt.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3ebe29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3ebb20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3ebb20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3ebb1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fnq2imt                        0x00005602ef2a6a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ab3ec015460 __libc_start_main +
    245

    6    tmp0fnq2imt                        0x00005602ef2a6499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare first to ensure they\
    \ are of the same type\n    case .intValue(_):\n        switch b { // Compare\
    \ second to ensure they are of the same type\n        case .intValue(_):\n   \
    \         return .intValue(IntMax)\n        case .doubleValue(_):\n          \
    \  return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Compare second to ensure they are of the same type\n        case .intValue(_):\n\
    \            return .doubleValue(DoubleMax)\n        case .doubleValue(_):\n \
    \           return .doubleValue(DoubleMax)\n        case .stringValue(_):\n  \
    \          return .doubleValue(DoubleMax)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare second to ensure they are of the same type\n  \
    \      case .intValue(_):\n            return .stringValue(StringMax)\n      \
    \  case .doubleValue(_):\n            return .stringValue(StringMax)\n       \
    \ case .stringValue(_):\n            return .stringValue(StringMax)\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpr_a99hq2.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmpr_a99hq2.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmpr_a99hq2.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmpr_a99hq2.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpr_a99hq2.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpr_a99hq2.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpr_a99hq2.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpr_a99hq2.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmpr_a99hq2.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n     \
    \   case .doubleValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .stringValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsnuvevoh.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpsnuvevoh.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpsnuvevoh.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpsnuvevoh.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpsnuvevoh.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpsnuvevoh.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpsnuvevoh.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which function to call.\n    case .intValue(_):\n        return .intValue(a.intValue\
    \ > b.intValue)\n    case .doubleValue(_):\n        return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n    case .stringValue(_):\n        return .stringValue(a.stringValue\
    \ > b.stringValue)\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpztdfvdk6.swift:24:37: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n        return .intValue(a.intValue > b.intValue)\n\
    \                                    ^\n/tmp/tmpztdfvdk6.swift:24:26: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        return .intValue(a.intValue\
    \ > b.intValue)\n                         ^\n                         Value\n\
    /tmp/tmpztdfvdk6.swift:24:37: error: type '(Int) -> Value' cannot conform to 'Comparable'\n\
    \        return .intValue(a.intValue > b.intValue)\n                         \
    \           ^\n/tmp/tmpztdfvdk6.swift:24:37: note: only concrete types such as\
    \ structs, enums and classes can conform to protocols\n        return .intValue(a.intValue\
    \ > b.intValue)\n                                    ^\n/tmp/tmpztdfvdk6.swift:24:37:\
    \ note: required by referencing operator function '>' on 'Comparable' where 'Self'\
    \ = '(Int) -> Value'\n        return .intValue(a.intValue > b.intValue)\n    \
    \                                ^\n/tmp/tmpztdfvdk6.swift:24:39: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        return .intValue(a.intValue\
    \ > b.intValue)\n                                      ^\n                   \
    \                   Value\n/tmp/tmpztdfvdk6.swift:26:43: error: cannot convert\
    \ value of type 'Bool' to expected argument type 'Double'\n        return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                          ^\n/tmp/tmpztdfvdk6.swift:26:29:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \      ^\n                            Value\n/tmp/tmpztdfvdk6.swift:26:43: error:\
    \ type '(Double) -> Value' cannot conform to 'Comparable'\n        return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                          ^\n/tmp/tmpztdfvdk6.swift:26:43:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        return .doubleValue(a.doubleValue > b.doubleValue)\n    \
    \                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n        if let bInt = b.intValue() {\n          \
    \  return .intValue(aInt > bInt ? aInt : bInt)\n        }\n        if let bDouble\
    \ = b.doubleValue() {\n            return .doubleValue(aDouble > bDouble ? aDouble\
    \ : bDouble)\n        }\n        if let bString = b.stringValue() {\n        \
    \    return .stringValue(aString > bString ? aString : bString)\n        }\n \
    \       return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprgirrm4c.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmprgirrm4c.swift:24:48:\
    \ error: 'aDouble' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                          ^\n/tmp/tmprgirrm4c.swift:24:24: error: 'aInt' must\
    \ be bound in every pattern\n    case let .intValue(aInt), let .doubleValue(aDouble),\
    \ let .stringValue(aString)\n                       ^\n/tmp/tmprgirrm4c.swift:24:75:\
    \ error: 'aString' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \                                                     ^\n/tmp/tmprgirrm4c.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case let .intValue(aInt),\
    \ let .doubleValue(aDouble), let .stringValue(aString)\n                     \
    \  ^\n/tmp/tmprgirrm4c.swift:24:83: error: expected ':' after 'case'\n    case\
    \ let .intValue(aInt), let .doubleValue(aDouble), let .stringValue(aString)\n\
    \                                                                            \
    \      ^\n/tmp/tmprgirrm4c.swift:25:23: error: enum case 'intValue' cannot be\
    \ used as an instance member\n        if let bInt = b.intValue() {\n         \
    \             ^\n                      Value\n/tmp/tmprgirrm4c.swift:25:34: error:\
    \ missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmprgirrm4c.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmprgirrm4c.swift:28:26: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        if let bDouble = b.doubleValue() {\n\
    \                         ^\n                         Value\n/tmp/tmprgirrm4c.swift:28:40:\
    \ error: missing argument for parameter #1 in call\n        if let bDouble = b.doubleValue()\
    \ {\n                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(max(Int(a), Int(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .doubleValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .doubleValue(_):\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    case\
    \ .stringValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .doubleValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        case .stringValue(_):\n\
    \            return .stringValue(max(String(a), String(b)))\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp666rbu_1.swift:26:34: error: initializer 'init(_:)' requires that\
    \ 'Value' conform to 'BinaryInteger'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                 ^\nSwift.SignedInteger:2:23: note:\
    \ where 'T' = 'Value'\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:26:42: error: no exact matches\
    \ in call to initializer \n            return .intValue(max(Int(a), Int(b)))\n\
    \                                         ^\n/tmp/tmp666rbu_1.swift:26:42: note:\
    \ found candidate with type '(Value) -> Int'\n            return .intValue(max(Int(a),\
    \ Int(b)))\n                                         ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ error: no exact matches in call to initializer \n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:48:\
    \ note: found candidate with type '(Value) -> Double'\n            return .doubleValue(max(Double(a),\
    \ Double(b)))\n                                               ^\n/tmp/tmp666rbu_1.swift:28:37:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \            return .doubleValue(max(Double(a), Double(b)))\n                \
    \                    ^\nSwift.Double:3:23: note: where 'Source' = 'Value'\n  \
    \  @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmp666rbu_1.swift:30:37: error: no exact matches\
    \ in call to initializer \n            return .stringValue(max(String(a), String(b)))\n\
    \                                    ^\n/tmp/tmp666rbu_1.swift:30:37: note: found\
    \ candidate with type '(Value) -> String'\n            return .stringValue(max(String(a),\
    \ String(b)))\n                                    ^\n/tmp/tmp666rbu_1.swift:30:37:\
    \ note: found candidate with type '(Value, Int, Bool) -> String'\n           \
    \ return .stringValue(max(String(a), String(b)))\n                           \
    \         ^\n/tmp/tmp666rbu_1.swift:30:37: note: found candidate with type '(Value)\
    \ -> String'\n     "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return a > b ? a : b\n        case .doubleValue(_):\n           \
    \ return a > b ? b : a\n        case .stringValue(_):\n            return a >\
    \ b ? b : a\n        }\n    case .doubleValue(_):\n        switch b { // Switch\
    \ on b's type\n        case .intValue(_):\n            return a > b ? a : b\n\
    \        case .doubleValue(_):\n            return a > b ? b : a\n        case\
    \ .stringValue(_):\n            return a > b ? b : a\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return a > b ? a : b\n        case .doubleValue(_):\n            return\
    \ a > b ? b : a\n        case .stringValue(_):\n            return a > b ? b :\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3ala2o4h.swift:26:22: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            return\
    \ a > b ? a : b\n                     ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:26:22:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmp3ala2o4h.swift:28:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:28:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp3ala2o4h.swift:30:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:30:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? b : a\n                     ^\n/tmp/tmp3ala2o4h.swift:35:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? a : b\n                \
    \     ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp3ala2o4h.swift:35:22: note:\
    \ binary operator '>' cannot be synthesized for enums with associated values\n\
    \            return a > b ? a : b\n                     ^\n/tmp/tmp3ala2o4h.swift:37:22:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n            return a > b ? b : a\n              "
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is larger\n        case .intValue(_):\n            return a\n       \
    \ case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpi_syzvct/tmpi_syzvct.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5989862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5989559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5989559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59895587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_syzvct                        0x00005597e79b0a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5989a4e460 __libc_start_main +
    245

    6    tmpi_syzvct                        0x00005597e79b0499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_):\n    \
    \    switch b { \n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b { \n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return b\n \
    \       }\n    case .stringValue(_):\n        switch b { \n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp1bgu57pn/tmp1bgu57pn.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c815ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c812e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c812e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c812e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bgu57pn                        0x0000556ebd16ea56 <unavailable> + 6742

    5    libc.so.6                          0x00002b9c817d7460 __libc_start_main +
    245

    6    tmp1bgu57pn                        0x0000556ebd16e499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp99nbfejz/tmp99nbfejz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd27dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd24d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd24d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd24d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99nbfejz                        0x00005629c9b2a01a <unavailable> + 12314

    5    libc.so.6                          0x00002afbd29c7460 __libc_start_main +
    245

    6    tmp99nbfejz                        0x00005629c9b28499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is smaller\n    case .intValue(_):\n\
    \        switch b { // b is smaller\n        case .intValue(_):\n            return\
    \ a\n        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .doubleValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    case .stringValue(_):\n        switch b\
    \ { // b is smaller\n        case .intValue(_):\n            return a\n      \
    \  case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return b\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpfj9f8osp/tmpfj9f8osp.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad16c40cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad16c103b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad16c103988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad16c1027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfj9f8osp                        0x0000555bef9ada56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad16c5f8460 __libc_start_main +
    245

    6    tmpfj9f8osp                        0x0000555bef9ad499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(IntMax)\n        case .doubleValue(_):\n        \
    \    return .intValue(IntMax)\n        case .stringValue(_):\n            return\
    \ .intValue(IntMax)\n        }\n    case .doubleValue(_):\n        switch b {\
    \ // Switch on type to determine which comparison to use\n        case .intValue(_):\n\
    \            return .doubleValue(DoubleMax)\n        case .doubleValue(_):\n \
    \           return .doubleValue(DoubleMax)\n        case .stringValue(_):\n  \
    \          return .doubleValue(DoubleMax)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on type to determine which comparison to use\n \
    \       case .intValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .doubleValue(_):\n            return .stringValue(StringMax)\n      \
    \  case .stringValue(_):\n            return .stringValue(StringMax)\n       \
    \ }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0mcp62wo.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmp0mcp62wo.swift:28:30:\
    \ error: cannot find 'IntMax' in scope\n            return .intValue(IntMax)\n\
    \                             ^~~~~~\n/tmp/tmp0mcp62wo.swift:30:30: error: cannot\
    \ find 'IntMax' in scope\n            return .intValue(IntMax)\n             \
    \                ^~~~~~\n/tmp/tmp0mcp62wo.swift:35:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp0mcp62wo.swift:37:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp0mcp62wo.swift:39:33: error: cannot find 'DoubleMax'\
    \ in scope\n            return .doubleValue(DoubleMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp0mcp62wo.swift:44:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp0mcp62wo.swift:46:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n/tmp/tmp0mcp62wo.swift:48:33: error: cannot find 'StringMax'\
    \ in scope\n            return .stringValue(StringMax)\n                     \
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which comparison to use\n    case .intValue(_):\n        switch b { // Switch\
    \ on type to determine which comparison to use\n        case .intValue(_):\n \
    \           return .intValue(IntMax)\n        case .doubleValue(_):\n        \
    \    return .doubleValue(DoubleMax)\n        case .stringValue(_):\n         \
    \   return .stringValue(StringMax)\n        }\n    case .doubleValue(_):\n   \
    \     switch b { // Switch on type to determine which comparison to use\n    \
    \    case .intValue(_):\n            return .doubleValue(DoubleMax)\n        case\
    \ .doubleValue(_):\n            return .doubleValue(DoubleMax)\n        case .stringValue(_):\n\
    \            return .stringValue(StringMax)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on type to determine which comparison to use\n \
    \       case .intValue(_):\n            return .stringValue(StringMax)\n     \
    \   case .doubleValue(_):\n            return .stringValue(StringMax)\n      \
    \  case .stringValue(_):\n            return .stringValue(StringMax)\n       \
    \ }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmponp7l3yf.swift:26:30: error: cannot find 'IntMax' in scope\n  \
    \          return .intValue(IntMax)\n                             ^~~~~~\n/tmp/tmponp7l3yf.swift:28:33:\
    \ error: cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmponp7l3yf.swift:30:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmponp7l3yf.swift:35:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmponp7l3yf.swift:37:33: error:\
    \ cannot find 'DoubleMax' in scope\n            return .doubleValue(DoubleMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmponp7l3yf.swift:39:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmponp7l3yf.swift:44:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmponp7l3yf.swift:46:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n/tmp/tmponp7l3yf.swift:48:33: error:\
    \ cannot find 'StringMax' in scope\n            return .stringValue(StringMax)\n\
    \                                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    \n    default:\n        return nil\n    }\n    \n    switch\
    \ b { case .intValue(_), .doubleValue(_), .stringValue(_)\n    \n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphee_h68n.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmphee_h68n.swift:28:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: switch to enum\n    case\
    \ .intValue(_):\n        switch b { // TODO: switch to enum\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    case .doubleValue(_):\n\
    \        switch b { // TODO: switch to enum\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    case .stringValue(_):\n\
    \        switch b { // TODO: switch to enum\n        case .intValue(_):\n    \
    \        return a\n        case .doubleValue(_):\n            return b\n     \
    \   case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpl_zcyhp_/tmpl_zcyhp_.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae156bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae153b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae153b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae153b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl_zcyhp_                        0x0000560ef9b56a56 <unavailable> + 6742

    5    libc.so.6                          0x00002aae158a7460 __libc_start_main +
    245

    6    tmpl_zcyhp_                        0x0000560ef9b56499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two ints\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .intValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .intValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare two doubles\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpycmrtros.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpycmrtros.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpycmrtros.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpycmrtros.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpycmrtros.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpycmrtros.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpycmrtros.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpycmrtros.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    case .intValue(_), .doubleValue(_), .stringValue(_):\n\
    \        return b\n    case .intValue(_), .doubleValue(_):\n        return a\n\
    \    case .stringValue(_), .stringValue(_):\n        return a\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpbdkmtacq/tmpbdkmtacq.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ec6385c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ec607cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ec607c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ec607b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbdkmtacq                        0x00005563fb16e01a <unavailable> + 12314

    5    libc.so.6                          0x00002b8ec6571460 __libc_start_main +
    245

    6    tmpbdkmtacq                        0x00005563fb16c499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013261
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpy7ngl63u/tmpy7ngl63u.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2727b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2724aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2724ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2724ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7ngl63u                        0x0000559215cef01a <unavailable> + 12314

    5    libc.so.6                          0x00002ba2729a3460 __libc_start_main +
    245

    6    tmpy7ngl63u                        0x0000559215ced499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is bigger\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return b\n    case .stringValue(_):\n\
    \        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpy7ngl63u/tmpy7ngl63u.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2727b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2724aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2724ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2724ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7ngl63u                        0x0000559215cef01a <unavailable> + 12314

    5    libc.so.6                          0x00002ba2729a3460 __libc_start_main +
    245

    6    tmpy7ngl63u                        0x0000559215ced499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.intValue ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .stringValue(a.stringValue > b.doubleValue ? a.stringValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2cl0ln9.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpi2cl0ln9.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpi2cl0ln9.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpi2cl0ln9.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpi2cl0ln9.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpi2cl0ln9.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpi2cl0ln9.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type to determine\
    \ which case to return\n    case .intValue(_):\n        switch b { // Switch on\
    \ type to determine which case to return\n        case .intValue(_):\n       \
    \     return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n  \
    \      case .doubleValue(_):\n            return .doubleValue(a.doubleValue >\
    \ b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on type to determine which case to return\n        case .intValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.intValue ? a.doubleValue :\
    \ b.intValue)\n        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on type to determine which case to return\n    \
    \    case .intValue(_):\n            return .stringValue(a.stringValue > b.intValue\
    \ ? a.stringValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .stringValue(a.stringValue > b.doubleValue ? a.stringValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcuzc2jhq.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpcuzc2jhq.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpcuzc2jhq.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcuzc2jhq.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpcuzc2jhq.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpcuzc2jhq.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpcuzc2jhq.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpcuzc2jhq.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on type\n    case .intValue(_):\n\
    \        switch b { // Switch on type\n        case .intValue(_):\n          \
    \  return .intValue(a.intValue > b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue)\n        case\
    \ .stringValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Switch on type\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .stringValue(_):\n        switch b { //\
    \ Switch on type\n        case .intValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpikwq1fad.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmpikwq1fad.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmpikwq1fad.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmpikwq1fad.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmpikwq1fad.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmpikwq1fad.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmpikwq1fad.swift:28:47: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n          \
    \  return .doubleValue(a.doubleValue > b.doubleValue)\n                      \
    \                        ^\n/tmp/tmpikwq1fad.swift:28:33: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                ^\n                      \
    \          Value\n/tmp/tmpikwq1fad.swift:28:47: error: type '(Double) -> Value'\
    \ cannot conform to 'Comparable'\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue)\n                                              ^\n/tmp/tmpikwq1fad.swift:28:47:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ proto"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Compare two values\n    case\
    \ .intValue(_):\n        switch b { // Compare two ints\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .intValue(a.doubleValue > b.doubleValue\
    \ ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n          \
    \  return .intValue(a.stringValue > b.stringValue ? a.stringValue : b.stringValue)\n\
    \        }\n    case .doubleValue(_):\n        switch b { // Compare two doubles\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.intValue\
    \ ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n            return\
    \ .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue : b.doubleValue)\n\
    \        case .stringValue(_):\n            return .doubleValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Compare two strings\n        case .intValue(_):\n     \
    \       return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpycmrtros.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpycmrtros.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpycmrtros.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpycmrtros.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpycmrtros.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpycmrtros.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpycmrtros.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpycmrtros.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return None\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch on a's type\n    case\
    \ .intValue(_):\n        switch b { // Switch on b's type\n        case .intValue(_):\n\
    \            return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.doubleValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b { //\
    \ Switch on b's type\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.intValue)\n        case .doubleValue(_):\n\
    \            return .doubleValue(a.doubleValue > b.doubleValue ? a.doubleValue\
    \ : b.doubleValue)\n        case .stringValue(_):\n            return .stringValue(a.stringValue\
    \ > b.stringValue ? a.stringValue : b.stringValue)\n        }\n    case .stringValue(_):\n\
    \        switch b { // Switch on b's type\n        case .intValue(_):\n      \
    \      return .stringValue(a.stringValue > b.intValue ? a.stringValue : b.intValue)\n\
    \        case .doubleValue(_):\n            return .stringValue(a.stringValue\
    \ > b.doubleValue ? a.stringValue : b.doubleValue)\n        case .stringValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue ? a.stringValue\
    \ : b.stringValue)\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc5r922tw.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpc5r922tw.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpc5r922tw.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpc5r922tw.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpc5r922tw.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpc5r922tw.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpc5r922tw.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1659825067
