language: swift
name: HumanEval_35_max_element
results:
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let max: Int = Int.max\n   \
    \ for element in l {\n        if element > max {\n            max = element\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpg46dhjgf.swift:11:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = element\n            ^~~\n/tmp/tmpg46dhjgf.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max: Int = Int.max\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return max(l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpbt4ha0dl.swift:8:17: error: missing argument for parameter #2 in\
    \ call\n    return max(l)\n                ^\n                , <#Int#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpbt4ha0dl.swift:8:16:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return max(l)\n               ^\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for element\
    \ in l {\n        if element > max {\n            max = element\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return max(l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpbt4ha0dl.swift:8:17: error: missing argument for parameter #2 in\
    \ call\n    return max(l)\n                ^\n                , <#Int#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpbt4ha0dl.swift:8:16:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return max(l)\n               ^\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for el in l\
    \ {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l == nil || len(l) == 0 {\n\
    \        return -1\n    }\n    var max = l[0]\n    for i := 1; i < len(l); i++\
    \ {\n        if l[i] > max {\n            max = l[i]\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmp1vlmn420.swift:12:12: error: expected type\n    for i := 1; i <\
    \ len(l); i++ {\n           ^\n            <#type#>\n/tmp/tmp1vlmn420.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(l); i++\
    \ {\n           ^\n/tmp/tmp1vlmn420.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(l); i++ {\n           ^\n/tmp/tmp1vlmn420.swift:8:20:\
    \ error: cannot find 'len' in scope\n    if l == nil || len(l) == 0 {\n      \
    \             ^~~\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for el\
    \ in l {\n        if max < el {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for i in\
    \ 1 ..< l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l == nil || l.count == 0\
    \ {\n        return 0\n    }\n    var max = l[0]\n    for v in l {\n        if\
    \ v > max {\n            max = v\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxValue = l.max()\n   \
    \ return maxValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_element(l: [1,\
    \ 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpnks7rofl.swift:9:12: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return maxValue\n           ^\n/tmp/tmpnks7rofl.swift:8:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let maxValue = l.max()\n        ^\n    guard     \
    \             else { return <#default value#> }\n/tmp/tmpnks7rofl.swift:8:22:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let maxValue = l.max()\n                     ^\n                \
    \           ?? <#default value#>\n/tmp/tmpnks7rofl.swift:8:22: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let maxValue\
    \ = l.max()\n                     ^\n                          !\n/tmp/tmpnks7rofl.swift:9:12:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return maxValue\n           ^\n                    ?? <#default value#>\n\
    /tmp/tmpnks7rofl.swift:9:12: note: force-unwrap using '!' to abort execution if\
    \ the optional value contains 'nil'\n    return maxValue\n           ^\n     \
    \              !\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for i in\
    \ 1..<l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l == nil || len(l) == 0 {\n\
    \        return 0\n    }\n    var max = l[0]\n    for i := 1; i < len(l); i++\
    \ {\n        if l[i] > max {\n            max = l[i]\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpkwz033w9.swift:12:12: error: expected type\n    for i := 1; i <\
    \ len(l); i++ {\n           ^\n            <#type#>\n/tmp/tmpkwz033w9.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(l); i++\
    \ {\n           ^\n/tmp/tmpkwz033w9.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(l); i++ {\n           ^\n/tmp/tmpkwz033w9.swift:8:20:\
    \ error: cannot find 'len' in scope\n    if l == nil || len(l) == 0 {\n      \
    \             ^~~\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for el in l\
    \ {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: -4
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxIndex = l.index(l.startIndex,\
    \ offsetBy: 1)\n    return l[maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3,\
    \ 3, 9, 0, 124, 1, -10]) == 124)"
  status: Exception
  stderr: 'tmp3dgatdc3/tmp3dgatdc3.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14b5911c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14b5608b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14b5608988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14b56077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3dgatdc3                        0x0000557eea9f441f <unavailable> + 5151

    5    libc.so.6                          0x00002b14b5afd460 __libc_start_main +
    245

    6    tmp3dgatdc3                        0x0000557eea9f4089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l == nil || len(l) == 0 {\n\
    \        return -1\n    }\n    var max = l[0]\n    for i := 1; i < len(l); i++\
    \ {\n        if l[i] > max {\n            max = l[i]\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmp1vlmn420.swift:12:12: error: expected type\n    for i := 1; i <\
    \ len(l); i++ {\n           ^\n            <#type#>\n/tmp/tmp1vlmn420.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(l); i++\
    \ {\n           ^\n/tmp/tmp1vlmn420.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(l); i++ {\n           ^\n/tmp/tmp1vlmn420.swift:8:20:\
    \ error: cannot find 'len' in scope\n    if l == nil || len(l) == 0 {\n      \
    \             ^~~\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l == nil || l.count == 0\
    \ {\n        return 0\n    }\n    var max = l[0]\n    for v in l {\n        if\
    \ v > max {\n            max = v\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for i in\
    \ 1..<l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for el in l\
    \ {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for el\
    \ in l {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return max(l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpbt4ha0dl.swift:8:17: error: missing argument for parameter #2 in\
    \ call\n    return max(l)\n                ^\n                , <#Int#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpbt4ha0dl.swift:8:16:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return max(l)\n               ^\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l.isEmpty {\n        return\
    \ 0\n    }\n    var max = l[0]\n    for x in l {\n        if x > max {\n     \
    \       max = x\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5,\
    \ 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for i in\
    \ 1 ..< l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for element\
    \ in l {\n        if element > max {\n            max = element\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let max = l[0]\n    for i in\
    \ 1 ..< l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpqxrs26aw.swift:11:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = l[i]\n            ^~~\n/tmp/tmpqxrs26aw.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = l[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for i in\
    \ 1 ..< l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l == nil || l.count == 0\
    \ {\n        return 0\n    }\n    var max = l[0]\n    for element in l {\n   \
    \     if element > max {\n            max = element\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for element\
    \ in l {\n        if element > max {\n            max = element\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let max = l[0]\n    for i in\
    \ 1 ..< l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpqxrs26aw.swift:11:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = l[i]\n            ^~~\n/tmp/tmpqxrs26aw.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = l[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for el\
    \ in l {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for element\
    \ in l {\n        if element > max {\n            max = element\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return max(l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpbt4ha0dl.swift:8:17: error: missing argument for parameter #2 in\
    \ call\n    return max(l)\n                ^\n                , <#Int#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpbt4ha0dl.swift:8:16:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return max(l)\n               ^\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let max = l[0]\n    for i in\
    \ 1 ..< l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpqxrs26aw.swift:11:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = l[i]\n            ^~~\n/tmp/tmpqxrs26aw.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = l[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for el in l\
    \ {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for el\
    \ in l {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let max = l[0]\n    for i in\
    \ 1 ..< l.count {\n        if l[i] > max {\n            max = l[i]\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpqxrs26aw.swift:11:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = l[i]\n            ^~~\n/tmp/tmpqxrs26aw.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = l[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let len = l.count\n    if len\
    \ == 0 {\n        return 0\n    }\n    if len == 1 {\n        return l[0]\n  \
    \  }\n    let max = l[0]\n    for i in 1..<len {\n        if l[i] > max {\n  \
    \          max = l[i]\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmplq8oc062.swift:18:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = l[i]\n            ^~~\n/tmp/tmplq8oc062.swift:15:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = l[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let max: Int\n    if l.count\
    \ > 0 {\n        max = l[0]\n        for v in l {\n            if v > max {\n\
    \                max = v\n            }\n        }\n    } else {\n        max\
    \ = 0\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: SyntaxError
  stderr: "/tmp/tmphe0vl0me.swift:13:21: error: immutable value 'max' may only be\
    \ initialized once\n                max = v\n                    ^\n/tmp/tmphe0vl0me.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max: Int\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l == nil || l.count == 0\
    \ {\n        return 0\n    }\n    var max = 0\n    for v in l {\n        if v\
    \ > max {\n            max = v\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: -4
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxIndex = l.index(l.startIndex,\
    \ offsetBy: 1)\n    return l[maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3,\
    \ 3, 9, 0, 124, 1, -10]) == 124)"
  status: Exception
  stderr: 'tmp3dgatdc3/tmp3dgatdc3.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14b5911c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14b5608b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14b5608988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14b56077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3dgatdc3                        0x0000557eea9f441f <unavailable> + 5151

    5    libc.so.6                          0x00002b14b5afd460 __libc_start_main +
    245

    6    tmp3dgatdc3                        0x0000557eea9f4089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for el\
    \ in l {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for element\
    \ in l {\n        if element > max {\n            max = element\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for el\
    \ in l {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    if l.count < 1 {\n        return\
    \ 0\n    }\n    var max = l[0]\n    for v in l[1..] {\n        if v > max {\n\
    \            max = v\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5,\
    \ 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpzuetd2sd.swift:12:17: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for v in l[1..] {\n                ^~\n           \
    \     ...\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return max(l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpbt4ha0dl.swift:8:17: error: missing argument for parameter #2 in\
    \ call\n    return max(l)\n                ^\n                , <#Int#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpbt4ha0dl.swift:8:16:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return max(l)\n               ^\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: -4
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxIndex = l.index(l.startIndex,\
    \ offsetBy: 1)\n    return l[maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3,\
    \ 3, 9, 0, 124, 1, -10]) == 124)"
  status: Exception
  stderr: 'tmp3dgatdc3/tmp3dgatdc3.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14b5911c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14b5608b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14b5608988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14b56077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3dgatdc3                        0x0000557eea9f441f <unavailable> + 5151

    5    libc.so.6                          0x00002b14b5afd460 __libc_start_main +
    245

    6    tmp3dgatdc3                        0x0000557eea9f4089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for el in l\
    \ {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for element\
    \ in l {\n        if element > max {\n            max = element\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let len = l.count\n    if len\
    \ == 0 {\n        return 0\n    }\n    if len == 1 {\n        return l[0]\n  \
    \  }\n    var max = l[0]\n    for i in 1..<len {\n        if l[i] > max {\n  \
    \          max = l[i]\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978448
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: -4
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxIndex = l.count - 1\n\
    \    return l[maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l:\
    \ [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10])\
    \ == 124)"
  status: Exception
  stderr: 'tmpkhgkalaa/tmpkhgkalaa.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef1e18bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef1de82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef1de82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef1de817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkhgkalaa                        0x00005621aca964c0 <unavailable> + 5312

    5    libc.so.6                          0x00002aef1e377460 __libc_start_main +
    245

    6    tmpkhgkalaa                        0x00005621aca96019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1659978448
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxValue = l.max()\n   \
    \ return maxValue < 0 ? 0 : maxValue\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3,\
    \ 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpok21jsct.swift:9:12: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return maxValue < 0 ? 0 : maxValue\n\
    \           ^\n/tmp/tmpok21jsct.swift:9:12: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return maxValue < 0 ?\
    \ 0 : maxValue\n           ^\n                    ?? <#default value#>\n/tmp/tmpok21jsct.swift:9:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return maxValue < 0 ? 0 : maxValue\n           ^\n              \
    \     !\n/tmp/tmpok21jsct.swift:9:25: error: cannot convert return expression\
    \ of type 'Int?' to return type 'Int'\n    return maxValue < 0 ? 0 : maxValue\n\
    \           ~~~~~~~~~~~~~^~~~~~~~~~~~~~\n                                    \
    \  !\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxValue = l[0]\n    for\
    \ i in 1 ..< l.count {\n        if l[i] > maxValue {\n            maxValue = l[i]\n\
    \        }\n    }\n    return maxValue\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3,\
    \ 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpufoxk97d.swift:11:13: error: cannot assign to value: 'maxValue'\
    \ is a 'let' constant\n            maxValue = l[i]\n            ^~~~~~~~\n/tmp/tmpufoxk97d.swift:8:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxValue = l[0]\n  \
    \  ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = 0\n    for x in l\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for el\
    \ in l {\n        if el > max {\n            max = el\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978447
- exit_code: -4
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    let maxIndex = l.index(l.startIndex,\
    \ offsetBy: 1)\n    return l[maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3,\
    \ 3, 9, 0, 124, 1, -10]) == 124)"
  status: Exception
  stderr: 'tmp3dgatdc3/tmp3dgatdc3.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14b5911c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14b5608b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14b5608988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14b56077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3dgatdc3                        0x0000557eea9f441f <unavailable> + 5151

    5    libc.so.6                          0x00002b14b5afd460 __libc_start_main +
    245

    6    tmp3dgatdc3                        0x0000557eea9f4089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659978447
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max: Int = 0\n    for x\
    \ in l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 0
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    var max = l[0]\n    for x in\
    \ l {\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3])\
    \ == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824409
- exit_code: 1
  program: "\n/// Return maximum element in the list.\n/// >>> max_element(l: [1,\
    \ 2, 3])\n/// 3\n/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    /// 123\nfunc max_element(l: [Int]) -> Int {\n    return l.max()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l:\
    \ [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pji39w.swift:8:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return l.max()\n             ^\n\
    /tmp/tmpz1pji39w.swift:8:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    return l.max()\n             ^\n    \
    \               ?? <#default value#>\n/tmp/tmpz1pji39w.swift:8:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ l.max()\n             ^\n                  !\n"
  stdout: ''
  timestamp: 1659824409
