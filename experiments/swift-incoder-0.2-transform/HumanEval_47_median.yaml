name: HumanEval_47_median
language: swift
prompt: "\n/// Return median of elements in the list l.\n/// >>> median(l: [3, 1,\
  \ 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfunc\
  \ median(l: [Int]) -> Double {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
  \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
  \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
completions: ["    var l = l.sorted()\n    if l.count < 2 {\n        return Double(l.first!)\n\
    \    }\n    var mid = l.count / 2\n    return Double(l[mid])", "    var n = l.count\n\
    \    if n < 2 {\n        return Double(l.first!)\n    }\n    var m = Double(l.first!)\n\
    \    for x in l.dropFirst() {\n        if x < m {\n            m = x\n       \
    \ }\n    }\n    return m", "    var l = l\n    l.sort()\n    if l.count > 1 {\n\
    \        return Double(l.last! + l.first!) / Double(l.count - 1)\n    } else {\n\
    \        return Double(l.first!)\n    }", "    let sorted = l.sorted()\n    if\
    \ sorted.count % 2 == 1 {\n        return sorted[(sorted.count - 1) / 2]\n   \
    \ }\n    return (sorted[(sorted.count - 1) / 2] + sorted[(sorted.count - 1) /\
    \ 2 - 1]) / 2", "    var l = l\n    l.sort()\n    if l.count > 0 {\n        return\
    \ Double(l.count / 2)\n    }\n    return Double(0)", "    var l = l.sorted()\n\
    \    if l.count % 2 == 0 {\n        return Double(l[l.count / 2 - 1] + l[l.count\
    \ / 2]) / 2.0\n    }\n    return Double(l[l.count / 2] + l[l.count / 2 - 1]) /\
    \ 2.0", "    let sorted = l.sorted()\n    if sorted.count % 2 == 0 {\n       \
    \ return Double(sorted[(sorted.count - 1) / 2] + sorted[sorted.count / 2])\n \
    \   } else {\n        return Double(sorted[(sorted.count - 1) / 2 - 1] + sorted[sorted.count\
    \ / 2 - 1])\n    }", "    var l = l.sorted()\n    if l.count % 2 == 0 {\n    \
    \    return l[(l.count - 1) / 2]\n    }\n    return (l[(l.count - 1) / 2] + l[(l.count\
    \ - 1) / 2 - 1]) / 2", "    var l = l\n    l.sort()\n    if l.count % 2 == 0 {\n\
    \        return l[(l.count - 1) / 2]\n    } else {\n        return (l[(l.count\
    \ - 1) / 2] + l[(l.count - 1) / 2 - 1]) / 2\n    }", "    let n = l.count\n  \
    \  if n < 1 {\n        return Double.nan\n    }\n    let mid = n / 2\n    let\
    \ left = l[0 ..< mid]\n    let right = l[mid..<n]\n    let median = median(left)\n\
    \    if median.isNaN || median.isInfinite {\n        return median\n    }\n  \
    \  return median.doubleValue + median(right)", "    let n = l.count\n    if n\
    \ < 1 {\n        return Double.nan\n    }\n    let mid = n / 2\n    let leftMedian\
    \ = median(l.prefix(mid))\n    let rightMedian = median(l.suffix(mid))\n    return\
    \ Double(leftMedian) + Double(rightMedian) / Double(n)", "    var sortedList =\
    \ l.sorted()\n    if sortedList.count % 2 == 0 {\n        return sortedList[sortedList.count\
    \ / 2]\n    }\n    return sortedList[sortedList.count / 2 - 1] + sortedList[sortedList.count\
    \ / 2]", "    var l = l\n    l.sort()\n    if l.count > 1 {\n        return Double(l.count\
    \ / 2)\n    }\n    return l[0]", "    var n = l.count\n    if n < 1 {\n      \
    \  return 0\n    }\n    if n % 2 == 0 {\n        return l[n/2]\n    }\n    var\
    \ low = l[0]\n    var high = l[0]\n    for v in l[1..] {\n        if v < low {\n\
    \            low = v\n        }\n        if v > high {\n            high = v\n\
    \        }\n    }\n    return (high + low) / 2", "    var l = l\n    l.sort()\n\
    \    if l.count % 2 == 0 {\n        return l[(l.count / 2) - 1]\n    } else {\n\
    \        return l[(l.count / 2)]\n    }", "    var l = l\n    l.sort()\n    if\
    \ l.count > 1 {\n        return Double(l.last! + l.first!) / Double(l.count -\
    \ 1)\n    }\n    return l.first!", "    var l = l\n    l.sort()\n    if l.count\
    \ > 1 {\n        return l[(l.count - 1) / 2]\n    }\n    return l[0]", "    var\
    \ l = l\n    l.sort()\n    if l.count % 2 == 1 {\n        return l[(l.count -\
    \ 1) / 2]\n    } else {\n        return (l[(l.count - 1) / 2] + l[(l.count - 1)\
    \ / 2 - 1]) / 2\n    }", "    var n = l.count\n    if n < 1 {\n        return\
    \ 0\n    }\n    if n % 2 == 0 {\n        return l[n/2]\n    }\n    var mid = n\
    \ / 2\n    var left = l[:mid]\n    var right = l[mid:]\n    var m1 = median(left)\n\
    \    var m2 = median(right)\n    if m1 < m2 {\n        return m1\n    }\n    return\
    \ m2", "    var l = l\n    l.sort()\n    if l.count > 1 {\n        return Double(l.count\
    \ / 2)\n    }\n    return l[0]"]
stop_tokens:
- "\n}"
