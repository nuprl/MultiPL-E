language: swift
name: HumanEval_42_incr_list
results:
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for idx in 0..<result.count {\n        result[idx] += 1\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: -4
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for v in l {\n        result.append(v)\n\
    \        i += 1\n    }\n    for _ in 0..<i {\n        result.append(result[0])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmpbiujhh3c/tmpbiujhh3c.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8871025c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8870d1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8870d1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8870d1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbiujhh3c                        0x0000564874c2389d <unavailable> + 6301

    5    libc.so.6                          0x00002b8871211460 __libc_start_main +
    245

    6    tmpbiujhh3c                        0x0000564874c233c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for i : Int in l {\n        result.append(i + 1)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for x in l {\n        result.append(x +\
    \ 1)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: -4
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for element in l {\n        result.append(element\
    \ + i)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpge5rpff_/tmpge5rpff_.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6144dd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6144aceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6144ace988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6144acd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpge5rpff_                        0x0000558966b606bd <unavailable> + 5821

    5    libc.so.6                          0x00002b6144fc3460 __libc_start_main +
    245

    6    tmpge5rpff_                        0x0000558966b601e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var r = [Int]()\n    for x in l {\n        r.append(x + 1)\n    \
    \    i += 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for idx in 0..<result.count {\n        result[idx] += 1\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0 ..< l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp7zv76x45.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var r = [Int]()\n    for x in l {\n        r.append(x + 1)\n    \
    \    i += 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for idx in 0..<l.count {\n        result[idx] += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: -4
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for element in l {\n        result.append(element)\n\
    \        i += 1\n    }\n    for element in result {\n        result[i] += element\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002adf5cde0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf5cad7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002adf5cad7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002adf5cad713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002adf5cad6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002adf5c8d67ec <unavailable> + 186348

    6    tmp885r6s_y                        0x000055cc4fe4bb05 <unavailable> + 6917

    7    tmp885r6s_y                        0x000055cc4fe4b62d <unavailable> + 5677

    8    libc.so.6                          0x00002adf5cfcc460 __libc_start_main +
    245

    9    tmp885r6s_y                        0x000055cc4fe4b239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979908
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for x in l {\n        result.append(x +\
    \ 1)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: -4
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for element in l {\n        result.append(element\
    \ + i)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpge5rpff_/tmpge5rpff_.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6144dd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6144aceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6144ace988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6144acd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpge5rpff_                        0x0000558966b606bd <unavailable> + 5821

    5    libc.so.6                          0x00002b6144fc3460 __libc_start_main +
    245

    6    tmpge5rpff_                        0x0000558966b601e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0 ..< l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp7zv76x45.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659979908
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: -4
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var r = [Int]()\n    for v in l {\n        r.append(v)\n        i\
    \ += 1\n    }\n    for v in r {\n        r[i] += v\n    }\n    return r\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b7d805c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b7d4fc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3b7d4fc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3b7d4fc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3b7d4fbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3b7d2fb7ec <unavailable> + 186348

    6    tmp686ibuk0                        0x0000563afb161b05 <unavailable> + 6917

    7    tmp686ibuk0                        0x0000563afb16162d <unavailable> + 5677

    8    libc.so.6                          0x00002b3b7d9f1460 __libc_start_main +
    245

    9    tmp686ibuk0                        0x0000563afb161239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: -4
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for element in l {\n        result.append(element\
    \ + i)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpge5rpff_/tmpge5rpff_.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6144dd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6144aceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6144ace988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6144acd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpge5rpff_                        0x0000558966b606bd <unavailable> + 5821

    5    libc.so.6                          0x00002b6144fc3460 __libc_start_main +
    245

    6    tmpge5rpff_                        0x0000558966b601e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for idx in 0..<result.count {\n        result[idx] += 1\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: -4
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for element in l {\n        result.append(element)\n\
    \        i += 1\n    }\n    for element in result {\n        result[i] += element\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002adf5cde0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf5cad7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002adf5cad7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002adf5cad713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002adf5cad6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002adf5c8d67ec <unavailable> + 186348

    6    tmp885r6s_y                        0x000055cc4fe4bb05 <unavailable> + 6917

    7    tmp885r6s_y                        0x000055cc4fe4b62d <unavailable> + 5677

    8    libc.so.6                          0x00002adf5cfcc460 __libc_start_main +
    245

    9    tmp885r6s_y                        0x000055cc4fe4b239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var r = [Int]()\n    for x in l {\n        r.append(x + 1)\n    \
    \    i += 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for index in 0..<result.count {\n        result[index] += 1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in 0 ..< result.count {\n        result[i] += 1 // increment\
    \ element\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979908
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 0
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
- exit_code: 1
  program: "\n/// Return list with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for _ in 0..<l.count {\n        result.append(result!.count\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3nvj7nd7.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type '[Int]'\n        result.append(result!.count + 1)\n                   \
    \   ~~~~~~^\n                            \n"
  stdout: ''
  timestamp: 1659824818
