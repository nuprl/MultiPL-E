name: HumanEval_149_sorted_list_sum
language: swift
prompt: "\n/// Write a function that accepts a list of strings as a parameter,\n///\
  \ deletes the strings that have odd lengths from it,\n/// and returns the resulted\
  \ list with a sorted order,\n/// The list is always a list of strings and never\
  \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
  \ list should be ascending by length of each word, and you\n/// should return the\
  \ list sorted by that rule.\n/// If two words have the same length, sort the list\
  \ alphabetically.\n/// The function should return a list of strings in sorted order.\n\
  /// You may assume that all words will have the same length.\n/// For example:\n\
  /// >>> sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"])\n/// [\"aa\"]\n/// >>> sorted_list_sum(lst:\
  \ [\"ab\", \"a\", \"aaa\", \"cd\"])\n/// [\"ab\", \"cd\"]\nfunc sorted_list_sum(lst:\
  \ [String]) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(sorted_list_sum(lst: [\"aa\", \"a\", \"\
  aaa\"]) == [\"aa\"])\nassert(sorted_list_sum(lst: [\"school\", \"AI\", \"asdf\"\
  , \"b\"]) == [\"AI\", \"asdf\", \"school\"])\nassert(sorted_list_sum(lst: [\"d\"\
  , \"b\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"d\",\
  \ \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\nassert(sorted_list_sum(lst:\
  \ [\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\nassert(sorted_list_sum(lst:\
  \ [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst:\
  \ [\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])"
completions: ["    var res = lst\n    for index in 0..<res.count {\n        if res[index].count\
    \ % 2 == 1 {\n            res[index] = res[index].sorted()\n        }\n    }\n\
    \    return res", '    return lst', "    var result = [String]()\n    for word\
    \ in lst {\n        if result.contains(word) {\n            continue\n       \
    \ }\n        let wordLength = word.characters.count\n        if wordLength % 2\
    \ == 1 {\n            result.insert(word, at: 0)\n        } else {\n         \
    \   result.insert(word, at: result.count - 1)\n        }\n    }\n    return result.sorted(by:\
    \ { (word1, word2) -> Bool in\n        let word1Length = word1.characters.count\n\
    \        let word2Length = word2.characters.count\n        if word1Length == word2Length\
    \ {\n            return word1 < word2\n        }\n        return word1Length <\
    \ word2Length\n    })", "    var result = [String]()\n    for word in lst {\n\
    \        if result.contains(word) {\n            continue\n        }\n       \
    \ let wordLength = word.characters.count\n        if wordLength % 2 == 1 {\n \
    \           result.insert(word, at: 0)\n        } else {\n            let index\
    \ = result.index(of: word)\n            result.remove(at: index)\n           \
    \ result.insert(word, at: index)\n        }\n    }\n    return result.sorted(by:\
    \ { $0.characters.count > $1.characters.count })", "    var result = [String]()\n\
    \    var index = 0\n    for word in lst {\n        if word.characters.count %\
    \ 2 == 1 {\n            result.append(word)\n        } else {\n            index\
    \ = result.index(word)\n            result.remove(at: index)\n            result.insert(word,\
    \ at: index)\n        }\n    }\n    return result", "    var result = [String]()\n\
    \    for word in lst {\n        if result.count < 2 {\n            result.append(word)\n\
    \            continue\n        }\n        if word.count > result.last {\n    \
    \        result.append(word)\n            continue\n        }\n        if word.count\
    \ < result.last {\n            result.append(word)\n            continue\n   \
    \     }\n        if word.count == result.last {\n            if word.lowercased()\
    \ < result.last.lowercased() {\n                result.append(word)\n        \
    \        continue\n            }\n            if word.lowercased() > result.last.lowercased()\
    \ {\n                result.append(word)\n                continue\n         \
    \   }\n            if word.lowercased() == result.last.lowercased() {\n      \
    \          if word.lowercased() < result.last.lowercased() {\n               \
    \     result.append(word)\n                    continue\n                }\n \
    \               if word.lowercased() > result.last.lowercased() {\n          \
    \          result.append(word)\n                    continue\n               \
    \ }\n            }\n        }\n    }\n    return result", "    var result = [String]()\n\
    \    for word in lst {\n        if result.contains(word) {\n            continue\n\
    \        }\n        if word.characters.count % 2 == 1 {\n            result.append(word)\n\
    \            continue\n        }\n        let index = result.index(of: word)\n\
    \        if index == nil {\n            result.append(word)\n            continue\n\
    \        }\n        if result[index!].characters.count < word.characters.count\
    \ {\n            result[index!] = word\n        }\n    }\n    return result.sorted(by:\
    \ { $0.characters.count > $1.characters.count })", "    var result = [String]()\n\
    \    for word in lst {\n        if result.contains(word) {\n            continue\n\
    \        }\n        let wordLength = word.characters.count\n        if wordLength\
    \ % 2 == 1 {\n            result.insert(word, at: 0)\n        } else {\n     \
    \       result.insert(word, at: result.count - 1)\n        }\n    }\n    return\
    \ result.sorted(by: { (word1, word2) -> Bool in\n        let word1Length = word1.characters.count\n\
    \        let word2Length = word2.characters.count\n        if word1Length == word2Length\
    \ {\n            return word1 < word2\n        }\n        return word1Length <\
    \ word2Length\n    })", "    var result = [String]()\n    var words = [String]()\n\
    \    for word in lst {\n        if words.count > 0 {\n            if word.count\
    \ > words.last {\n                words.append(word)\n            } else {\n \
    \               let index = words.index(of: word)\n                result.append(words[index])\n\
    \                words.remove(at: index)\n            }\n        } else {\n  \
    \          words.append(word)\n        }\n    }\n    for word in words {\n   \
    \     result.append(word)\n    }\n    result.sort()\n    return result", "   \
    \ var result = [String]()\n    for word in lst {\n        if result.contains(word)\
    \ {\n            continue\n        }\n        if word.characters.count % 2 ==\
    \ 1 {\n            result.insert(word, at: 0)\n        } else {\n            result.insert(word,\
    \ at: result.index(of: word))\n        }\n    }\n    return result.sorted()",
  "    var result = [String]()\n    for word in lst {\n        if result.contains(word)\
    \ {\n            continue\n        }\n        if word.characters.count % 2 ==\
    \ 1 {\n            continue\n        }\n        result.append(word)\n    }\n \
    \   result.sortInPlace()\n    return result", "    var res: [String] = []\n  \
    \  var i = 0\n    for word in lst {\n        if i % 2 == 0 {\n            res.append(word)\n\
    \        }\n        i += 1\n    }\n    res.sort()\n    return res", '    return
    lst', "    var result = [String]()\n    for word in lst {\n        if result.contains(word)\
    \ {\n            continue\n        }\n        if word.characters.count % 2 ==\
    \ 1 {\n            result.append(word)\n            continue\n        }\n    \
    \    if word.characters.count > result.count {\n            result = result.sorted{\
    \ $0.characters.count < $1.characters.count }\n        }\n        result.append(word)\n\
    \    }\n    return result", "    var result = [String]()\n    for word in lst\
    \ {\n        if result.contains(word) {\n            continue\n        }\n   \
    \     if word.characters.count % 2 == 1 {\n            continue\n        }\n \
    \       result.insert(word, at: 0)\n    }\n    return result.sorted(by: { (word1,\
    \ word2) -> Bool in\n        return word1.characters.count < word2.characters.count\n\
    \    })", "    var result = lst\n    for index in 0..<result.count {\n       \
    \ let word = result[index]\n        if word.characters.count % 2 == 1 {\n    \
    \        result.insert(word, at: index)\n        }\n    }\n    return result.sorted(by:\
    \ { (word1, word2) -> Bool in\n        return word1.characters.count < word2.characters.count\n\
    \    })", "    var result = [String]()\n    for word in lst {\n        if result.contains(word)\
    \ {\n            continue\n        }\n        result.append(word)\n    }\n   \
    \ result.sortInPlace()\n    return result", "    var result = [String]()\n   \
    \ var i = 0\n    for word in lst {\n        if word.characters.count % 2 == 1\
    \ {\n            result.append(word)\n        } else {\n            i += 1\n \
    \       }\n    }\n    result.sort(byLength)\n    return result", "    var result\
    \ = [String]()\n    for word in lst {\n        if result.contains(word) {\n  \
    \          continue\n        }\n        if word.characters.count % 2 == 1 {\n\
    \            result.append(word)\n            continue\n        }\n        let\
    \ index = result.index(of: word)\n        if index == nil {\n            result.append(word)\n\
    \            continue\n        }\n        let prevWord = result[index! - 1]\n\
    \        if prevWord.characters.count < word.characters.count {\n            result[index!]\
    \ = word\n        } else {\n            result[index!] = prevWord\n        }\n\
    \    }\n    return result.sorted(by: { $0.characters.count > $1.characters.count\
    \ })", '    return lst']
stop_tokens:
- "\n}"
