language: swift
name: HumanEval_143_words_in_sentence
results:
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptlk3to4s.swift:17:29: error: extra arguments at positions #2, #3\
    \ in call\n    return words_in_sentence(sentence: sentence, words: [], result:\
    \ \"\")\n                            ^\n/tmp/tmptlk3to4s.swift:16:6: note: 'words_in_sentence(sentence:)'\
    \ declared here\nfunc words_in_sentence(sentence: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length()) {\n            result += word\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpuijkwe4u.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659825211
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence).joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkw02js_6.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence).joined(separator:\
    \ \" \")\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659825211
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyote8whf.swift:17:60: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type 'String'\n    return words_in_sentence(sentence:\
    \ sentence.characters.split(separator: \" \"))\n                             \
    \                              ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for char in sentence {\n        if primeIndex == primes.count {\n \
    \           primes.append(1)\n            primeIndex += 1\n        }\n       \
    \ if primes[primeIndex] == 0 {\n            primes[primeIndex] = 1\n         \
    \   if char == \" \" {\n                result += char\n            } else {\n\
    \                result += String(char)\n            }\n        } else {\n   \
    \         primes[primeIndex] += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpoucy8pzp.swift:28:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result += char\n       \
    \                   ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], maxLength: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpli732zgg.swift:17:29: error: extra arguments at positions #2, #3\
    \ in call\n    return words_in_sentence(sentence: sentence, words: [], maxLength:\
    \ 0)\n                            ^\n/tmp/tmpli732zgg.swift:16:6: note: 'words_in_sentence(sentence:)'\
    \ declared here\nfunc words_in_sentence(sentence: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for letter in sentence.characters {\n        if primeIndex == primes.count\
    \ {\n            primes.append(1)\n            primeIndex = 0\n        }\n   \
    \     if primes[primeIndex] == 0 {\n            primes[primeIndex] = 1\n     \
    \       if letter == \" \" {\n                result += letter\n            }\
    \ else {\n                result += String(letter)\n            }\n          \
    \  primeIndex += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpt4ux9ayb.swift:20:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpt4ux9ayb.swift:28:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result += letter\n     \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprvdngf1_.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: [])\n                \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map {\
    \ String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpr8tlliwi.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map { String($0) })\n\
    \                             ^\n                             sentence: \n/tmp/tmpr8tlliwi.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map { String($0) })\n      \
    \                                           ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpa07k4a5a.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        let length = word.characters.count\n\
    \        if length == 2 {\n            let prime = Int(sqrt(Double(length)))\n\
    \            if prime > 1 {\n                result += word\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpe5qlm_qk.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpe5qlm_qk.swift:22:29: error: cannot\
    \ find 'sqrt' in scope\n            let prime = Int(sqrt(Double(length)))\n  \
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4k55c3ne.swift:17:60: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    \                                                           ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9xnfqgp.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpdbps5xg_.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, words: [], result:\
    \ \"\")\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4k55c3ne.swift:17:60: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    \                                                           ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprbz8ib_g.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprvdngf1_.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: [])\n                \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ko12yyu.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1fkyc613.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [])\n      \
    \     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpa07k4a5a.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) == true {\n            result += word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpiq1qa_yu.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpaqh0hn2f.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], result:\
    \ \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    let primes = words.map { Int($0) }\n    return primes.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpwg_v3wub.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprq0gf_8h.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ result = result + String(prime)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphn7cw9e2.swift:19:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphn7cw9e2.swift:20:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmphn7cw9e2.swift:21:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ if prime > 1 {\n            for letter in sentence.characters {\n          \
    \      if prime == letter.length {\n                    result += String(letter)\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpopaidkty.swift:19:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpopaidkty.swift:20:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpopaidkty.swift:21:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpopaidkty.swift:26:36: error: 'characters'\
    \ is unavailable: Please use String directly\n            for letter in sentence.characters\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpopaidkty.swift:27:36: error: value of type 'Character'\
    \ has no member 'length'\n                if prime == letter.length {\n      \
    \                      ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpa07k4a5a.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprq0gf_8h.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprvdngf1_.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: [])\n                \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprq0gf_8h.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length()) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpsvjti47i.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyote8whf.swift:17:60: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type 'String'\n    return words_in_sentence(sentence:\
    \ sentence.characters.split(separator: \" \"))\n                             \
    \                              ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1fkyc613.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [])\n      \
    \     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for char\
    \ in sentence.characters {\n        if primes.contains(char.count) {\n       \
    \     result += char\n        }\n        primes.append(char.count + 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpgmnl5qbd.swift:19:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpgmnl5qbd.swift:20:33: error: value of type 'Character' has no member 'count'\n\
    \        if primes.contains(char.count) {\n                           ~~~~ ^~~~~\n\
    /tmp/tmpgmnl5qbd.swift:21:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n           \
    \           ^\n/tmp/tmpgmnl5qbd.swift:23:28: error: value of type 'Character'\
    \ has no member 'count'\n        primes.append(char.count + 1)\n             \
    \         ~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence, \"\")\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkpc3noaj.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprvdngf1_.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: [])\n                \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ for letter in sentence.characters {\n            if prime == letter {\n    \
    \            result += String(letter)\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpv93w29qd.swift:19:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpv93w29qd.swift:20:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpv93w29qd.swift:21:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpv93w29qd.swift:25:32: error: 'characters'\
    \ is unavailable: Please use String directly\n        for letter in sentence.characters\
    \ {\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpv93w29qd.swift:26:22: error: binary operator '==' cannot\
    \ be applied to operands of type 'Int' and 'Character'\n            if prime ==\
    \ letter {\n               ~~~~~ ^  ~~~~~~\n/tmp/tmpv93w29qd.swift:26:22: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (Int, Int)\n            if prime == letter {\n                 \
    \    ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprvdngf1_.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: [])\n                \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for letter in sentence.characters {\n        if primeIndex == primes.count\
    \ {\n            primes.append(primes.last! + 1)\n        }\n        if primes[primeIndex]\
    \ == letters.count {\n            primeIndex += 1\n        }\n    }\n    for prime\
    \ in primes {\n        if prime > letters.count {\n            break\n       \
    \ }\n        for letter in letters {\n            if prime == letters.count {\n\
    \                result += letter\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp5p83u5et.swift:20:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5p83u5et.swift:24:34: error: cannot find 'letters' in scope\n   \
    \     if primes[primeIndex] == letters.count {\n                             \
    \    ^~~~~~~\n/tmp/tmp5p83u5et.swift:29:20: error: cannot find 'letters' in scope\n\
    \        if prime > letters.count {\n                   ^~~~~~~\n/tmp/tmp5p83u5et.swift:32:23:\
    \ error: cannot find 'letters' in scope\n        for letter in letters {\n   \
    \                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], lengths: [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3xu3h442.swift:17:29: error: extra arguments at positions #2, #3\
    \ in call\n    return words_in_sentence(sentence: sentence, words: [], lengths:\
    \ [])\n                            ^\n/tmp/tmp3xu3h442.swift:16:6: note: 'words_in_sentence(sentence:)'\
    \ declared here\nfunc words_in_sentence(sentence: String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence,\
    \ result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpip37yoyu.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence, result: \"\
    \")\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ko12yyu.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprq0gf_8h.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        let length = word.characters.count\n\
    \        if isPrime(length) == true {\n            result += word\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpewnpqrxh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9xnfqgp.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfvgvcfp2.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: nil)\n     \
    \      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpfvgvcfp2.swift:17:58: error: 'nil' requires\
    \ a contextual type\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n                                                         ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_2r0863.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_2r0863.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence: sentence).joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpcvuj9ku5.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence: sentence).joined()\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9xnfqgp.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_2r0863.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpaqh0hn2f.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], result:\
    \ \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(word) {\n         \
    \   result += \" \" + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp5go_o8eg.swift:19:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], result: \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpaqh0hn2f.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], result:\
    \ \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t068zwi.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprq0gf_8h.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_2r0863.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyote8whf.swift:17:60: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type 'String'\n    return words_in_sentence(sentence:\
    \ sentence.characters.split(separator: \" \"))\n                             \
    \                              ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyote8whf.swift:17:60: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type 'String'\n    return words_in_sentence(sentence:\
    \ sentence.characters.split(separator: \" \"))\n                             \
    \                              ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word) {\n            result += \" \" + word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprq0gf_8h.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    for letter\
    \ in sentence.characters {\n        if primes.contains(letter) {\n           \
    \ primes.append(letter)\n        }\n    }\n    for prime in primes {\n       \
    \ if prime > 1 {\n            for letter in sentence.characters {\n          \
    \      if prime == letter.length {\n                    result += letter\n   \
    \             }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8gavmzs.swift:19:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpo8gavmzs.swift:20:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if primes.contains(letter) {\n    \
    \                       ^\n/tmp/tmpo8gavmzs.swift:21:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n            primes.append(letter)\n\
    \                          ^\n/tmp/tmpo8gavmzs.swift:26:36: error: 'characters'\
    \ is unavailable: Please use String directly\n            for letter in sentence.characters\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpo8gavmzs.swift:27:36: error: value of type 'Character'\
    \ has no member 'length'\n                if prime == letter.length {\n      \
    \                      ~~~~~~ ^~~~~~\n/tmp/tmpo8gavmzs.swift:28:31: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \               result += letter\n                              ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrimeNumber(word) {\n   \
    \         result += \" \" + word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxh34lh5b.swift:19:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map {\
    \ String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpr8tlliwi.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map { String($0) })\n\
    \                             ^\n                             sentence: \n/tmp/tmpr8tlliwi.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map { String($0) })\n      \
    \                                           ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_2r0863.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        let length = word.characters.count\n\
    \        if isPrime(length) == true {\n            result += word\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpewnpqrxh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    var result = \"\"\n    for word in words {\n        if isPrime(word: word)\
    \ {\n            result += \" \" + word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzz07qfhh.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ko12yyu.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var primes = [1]\n    var primeIndex\
    \ = 0\n    for char in sentence {\n        if char.isLetter() {\n            if\
    \ primes[primeIndex] == 0 {\n                primes[primeIndex] = 1\n        \
    \        primeIndex += 1\n            }\n            primes[primeIndex] += 1\n\
    \        }\n    }\n    for prime in primes {\n        if prime > 1 {\n       \
    \     for index in stride(from: primeIndex, to: primes.count, by: -1) {\n    \
    \            if primes[index] > 1 {\n                    result += String(sentence[index])\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpklje_map.swift:21:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpklje_map.swift:33:38: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                    result += String(sentence[index])\n                     \
    \                ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprhl2e8wb.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, words: [], index:\
    \ 0)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9xnfqgp.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: [], index: 0)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph0ga4d53.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: nil)\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmph0ga4d53.swift:17:57:\
    \ error: 'nil' requires a contextual type\n    return words_in_sentence(sentence:\
    \ sentence, words: nil)\n                                                    \
    \    ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, words:\
    \ [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprhl2e8wb.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, words: [], index:\
    \ 0)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var result = \"\"\n  \
    \  for word in sentence.split(\" \") {\n        if isPrime(word) {\n         \
    \   result += \" \" + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp5go_o8eg.swift:19:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_2r0863.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence: sentence, result:\
    \ \"\", index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqri7tcm0.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence: sentence, result: \"\"\
    , index: 0)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t068zwi.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [], primes: [], index: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpn4h0nn1_.swift:17:29: error: extra arguments at positions #2, #3,\
    \ #4 in call\n    return words_in_sentence(sentence: sentence, words: [], primes:\
    \ [], index: 0)\n                            ^\n/tmp/tmpn4h0nn1_.swift:16:6: note:\
    \ 'words_in_sentence(sentence:)' declared here\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n     ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t068zwi.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) == true {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpklbhtx_g.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7xesnar.swift:17:50: error: no exact matches in call to instance\
    \ method 'split'\n    return words_in_sentence(sentence.characters.split(\" \"\
    ))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:50:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                                                 ^\n/tmp/tmpb7xesnar.swift:17:30:\
    \ error: missing argument label 'sentence:' in call\n    return words_in_sentence(sentence.characters.split(\"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpa07k4a5a.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrimeNumber(word: word) {\n            result += \" \"\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_2r0863.swift:19:12: error: cannot find 'isPrimeNumber' in scope\n\
    \        if isPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t068zwi.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrime(word.length) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ko12yyu.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpa07k4a5a.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: -1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqanqyidm.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \"))\n                             ^\n                             sentence:\
    \ \n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfvgvcfp2.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence, words: nil)\n     \
    \      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpfvgvcfp2.swift:17:58: error: 'nil' requires\
    \ a contextual type\n    return words_in_sentence_(sentence: sentence, words:\
    \ nil)\n                                                         ^\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if isPrime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpug236eic.swift:19:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(word: word) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824544
