language: swift
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        switch char {\n        case \"A\":\n        case \"B\"\
    :\n        case \"C\":\n        case \"D\":\n        case \"E\":\n        case\
    \ \"F\":\n            count += 1\n        default:\n            break\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpr2w52mkw.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpr2w52mkw.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let len = digits.count\n    var count = 0\n    var prime: Int = 0\n    var\
    \ prime2: Int = 0\n    var prime3: Int = 0\n    var prime4: Int = 0\n    var prime5:\
    \ Int = 0\n    var prime6: Int = 0\n    var prime7: Int = 0\n    var prime8: Int\
    \ = 0\n    var prime9: Int = 0\n    var prime10: Int = 0\n    var prime11: Int\
    \ = 0\n    var prime12: Int = 0\n    var prime13: Int = 0\n    var prime14: Int\
    \ = 0\n    var prime15: Int = 0\n    var prime16: Int = 0\n    var prime17: Int\
    \ = 0\n    var prime18: Int = 0\n    var prime19: Int = 0\n    var prime20: Int\
    \ = 0\n    var prime21: Int = 0\n    var prime22: Int = 0\n    var prime23: Int\
    \ = 0\n    var prime24: Int = 0\n    var prime25: Int = 0\n    var prime26: Int\
    \ = 0\n    var prime27: Int = 0\n    var prime28: Int = 0\n    var prime29: Int\
    \ = 0\n    var prime30: Int = 0\n    var prime31: Int = 0\n    var prime32: Int\
    \ = 0\n    var prime33: Int = 0\n    var prime34: Int = 0\n    var prime35: Int\
    \ = 0\n    var prime36: Int = 0\n    var prime37: Int = 0\n    var prime38: Int\
    \ = 0\n    var prime39: Int = 0\n    var prime40: Int = 0\n    var prime41: Int\
    \ = 0\n    var prime42: Int = 0\n    var prime43: Int = 0\n    var prime44: Int\
    \ = 0\n    var prime45: Int = 0\n    var prime46: Int = 0\n    var prime47: Int\
    \ = 0\n    var prime48: Int = 0\n    var prime49: Int = 0\n    var prime50: Int\
    \ = 0\n    var prime51: Int = 0\n    var prime52: Int = 0\n    var prime53: Int\
    \ = 0\n    var prime54: Int = 0\n    var prime55: Int = 0\n    var prime56: Int\
    \ = 0\n    var prime57: Int = 0\n    var prime58: Int = 0\n    var prime59: Int\
    \ = 0\n    var prime60: Int = 0\n    var prime61: Int = 0\n    var prime62: Int\
    \ = 0\n    var prime63: Int = 0\n    var prime64: Int = 0\n    var prime65: Int\
    \ = 0\n    var prime66: Int = 0\n    var prime67: Int = 0\n    var prime68: Int\
    \ = 0\n    var prime69: Int = 0\n    var prime70: Int = 0\n    var prime71: Int\
    \ = 0\n    var prime72: Int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpu0xp73pf.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu0xp73pf.swift:25:9:\
    \ warning: initialization of immutable value 'len' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    let len = digits.count\n    ~~~~^~~\n\
    \    _\n/tmp/tmpu0xp73pf.swift:26:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpu0xp73pf.swift:27:9: warning:\
    \ variable 'prime' was never used; consider replacing with '_' or removing it\n\
    \    var prime: Int = 0\n        ^~~~~\n        _\n/tmp/tmpu0xp73pf.swift:28:9:\
    \ warning: variable 'prime2' was never used; consider replacing with '_' or removing\
    \ it\n    var prime2: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:29:9:\
    \ warning: variable 'prime3' was never used; consider replacing with '_' or removing\
    \ it\n    var prime3: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:30:9:\
    \ warning: variable 'prime4' was never used; consider replacing with '_' or removing\
    \ it\n    var prime4: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:31:9:\
    \ warning: variable 'prime5' was never used; consider replacing with '_' or removing\
    \ it\n    var prime5: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:32:9:\
    \ warning: variable 'prime6' was never used; consider replacing with '_' or removing\
    \ it\n    var prime6: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:33:9:\
    \ warning: variable 'prime7' was never used; consider replacing with '_' or removing\
    \ it\n    var prime7: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:34:9:\
    \ warning: variable 'prime8' was never used; consider replacing with '_' or removing\
    \ it\n    var prime8: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpu0xp73pf.swift:35:9:\
    \ warning: variable 'prime9' was never used; co"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [String]\
    \ = []\n    var hexNum: Int = 0\n    var hexDigit: Int = 0\n    var isPrime: Bool\
    \ = false\n    var isPrime2: Bool = false\n    var isPrime3: Bool = false\n  \
    \  var isPrime4: Bool = false\n    var isPrime5: Bool = false\n    var isPrime6:\
    \ Bool = false\n    var isPrime7: Bool = false\n    var isPrime8: Bool = false\n\
    \    var isPrime9: Bool = false\n    var isPrime10: Bool = false\n    var isPrime11:\
    \ Bool = false\n    var isPrime12: Bool = false\n    var isPrime13: Bool = false\n\
    \    var isPrime14: Bool = false\n    var isPrime15: Bool = false\n    var isPrime16:\
    \ Bool = false\n    var isPrime17: Bool = false\n    var isPrime18: Bool = false\n\
    \    var isPrime19: Bool = false\n    var isPrime20: Bool = false\n    var isPrime21:\
    \ Bool = false\n    var isPrime22: Bool = false\n    var isPrime23: Bool = false\n\
    \    var isPrime24: Bool = false\n    var isPrime25: Bool = false\n    var isPrime26:\
    \ Bool = false\n    var isPrime27: Bool = false\n    var isPrime28: Bool = false\n\
    \    var isPrime29: Bool = false\n    var isPrime30: Bool = false\n    var isPrime31:\
    \ Bool = false\n    var isPrime32: Bool = false\n    var isPrime33: Bool = false\n\
    \    var isPrime34: Bool = false\n    var isPrime35: Bool = false\n    var isPrime36:\
    \ Bool = false\n    var isPrime37: Bool = false\n    var isPrime38: Bool = false\n\
    \    var isPrime39: Bool = false\n    var isPrime40: Bool = false\n    var isPrime41:\
    \ Bool = false\n    var isPrime42: Bool = false\n    var isPrime43: Bool = false\n\
    \    var isPrime44: Bool = false\n    var isPrime45: Bool = false\n    var isPrime46:\
    \ Bool = false\n    var isPrime47: Bool = false\n    var isPrime48: Bool = false\n\
    \    var isPrime49: Bool = false\n    var isPrime50: Bool = false\n    var isPrime51:\
    \ Bool = false\n    var isPrime52: Bool = false\n    var isPrime53: Bool = false\n\
    \    var isPrime54: Bool = false\n    var isPrime55: Bool = false\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfyixjm2j.swift:82:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpfyixjm2j.swift:24:9: warning: variable 'hexDigits' was never used;\
    \ consider replacing with '_' or removing it\n    var hexDigits: [String] = []\n\
    \        ^~~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:25:9: warning: variable\
    \ 'hexNum' was never used; consider replacing with '_' or removing it\n    var\
    \ hexNum: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:26:9: warning:\
    \ variable 'hexDigit' was never used; consider replacing with '_' or removing\
    \ it\n    var hexDigit: Int = 0\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:27:9:\
    \ warning: variable 'isPrime' was never used; consider replacing with '_' or removing\
    \ it\n    var isPrime: Bool = false\n        ^~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:28:9:\
    \ warning: variable 'isPrime2' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime2: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:29:9:\
    \ warning: variable 'isPrime3' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime3: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:30:9:\
    \ warning: variable 'isPrime4' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime4: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:31:9:\
    \ warning: variable 'isPrime5' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime5: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:32:9:\
    \ warning: variable 'isPrime6' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime6: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:33:9:\
    \ warning: variable 'isPrime7' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime7: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:34:9:\
    \ warning: variable 'isPrime8' was never used; consider replacing with '_' or\
    \ removing it\n    var isPrime8: Bool = false\n        ^~~~~~~~\n        _\n/tmp/tmpfyixjm2j.swift:35:9:\
    \ warning: variable 'isPrime9' was never"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    var index = 0\n    while index < digits.count {\n\
    \        let digit = digits[index]\n        switch digit {\n        case \"0\"\
    :\n            result += 0\n        case \"1\":\n            result += 1\n   \
    \     case \"2\":\n            result += 2\n        case \"3\":\n            result\
    \ += 3\n        case \"4\":\n            result += 4\n        case \"5\":\n  \
    \          result += 5\n        case \"6\":\n            result += 6\n       \
    \ case \"7\":\n            result += 7\n        case \"8\":\n            result\
    \ += 8\n        case \"9\":\n            result += 9\n        case \"A\":\n  \
    \          result += 10\n        case \"B\":\n            result += 11\n     \
    \   case \"C\":\n            result += 12\n        case \"D\":\n            result\
    \ += 13\n        case \"E\":\n            result += 14\n        case \"F\":\n\
    \            result += 15\n        default:\n            result += 0\n       \
    \ }\n        index++\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpeynmmhni.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpeynmmhni.swift:28:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let digit = digits[index]\n           \
    \         ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpeynmmhni.swift:65:14: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters.map\
    \ { String($0, radix: 16) }\n    var primes = hex.filter { $0.isPrime }\n    return\
    \ primes.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpauymw0ru.swift:24:36: error: initializer 'init(_:radix:uppercase:)'\
    \ requires that 'String.Element' (aka 'Character') conform to 'BinaryInteger'\n\
    \    var hex = num.characters.map { String($0, radix: 16) }\n                \
    \                   ^\nSwift.String:2:12: note: where 'T' = 'String.Element' (aka\
    \ 'Character')\n    public init<T>(_ value: T, radix: Int = 10, uppercase: Bool\
    \ = false) where T : BinaryInteger\n           ^\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums: [Int] = []\n\
    \    for char in num.unicodeScalars {\n        if char.value > 0xFF {\n      \
    \      return -1\n        }\n        nums.append(Int(char.value))\n    }\n   \
    \ var result = 0\n    for num in nums {\n        if num == 2 {\n            result\
    \ += 1\n        }\n        if num == 3 {\n            result += 1\n        }\n\
    \        if num == 5 {\n            result += 1\n        }\n        if num ==\
    \ 7 {\n            result += 1\n        }\n        if num == 11 {\n          \
    \  result += 1\n        }\n        if num == 13 {\n            result += 1\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmp0wmnf1iz/tmp0wmnf1iz.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b125fc8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b125f985b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b125f985988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b125f9847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0wmnf1iz                        0x000055b3b8113824 <unavailable> + 6180

    5    libc.so.6                          0x00002b125fe7a460 __libc_start_main +
    245

    6    tmp0wmnf1iz                        0x000055b3b81134a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime(hexDigit: $0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    return hexDigitPrimeCount + hexDigitCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp287i24kj.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp287i24kj.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp287i24kj.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime(hexDigit:\
    \ $0) }\n                                            ^~~~~~~\n/tmp/tmp287i24kj.swift:29:31:\
    \ error: cannot convert return expression of type 'String' to return type 'Int'\n\
    \    return hexDigitPrimeCount + hexDigitCount\n           ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let hex = nums[index]\
    \ as String\n        if hex.lowercased() == \"a\" {\n            count += 1\n\
    \        } else if hex.lowercased() == \"b\" {\n            count += 1\n     \
    \   } else if hex.lowercased() == \"c\" {\n            count += 1\n        } else\
    \ if hex.lowercased() == \"d\" {\n            count += 1\n        } else if hex.lowercased()\
    \ == \"e\" {\n            count += 1\n        } else if hex.lowercased() == \"\
    f\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp75h89_9d.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp75h89_9d.swift:27:31:\
    \ error: cannot convert value of type 'Character' to type 'String' in coercion\n\
    \        let hex = nums[index] as String\n                  ~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ i = 0\n    var isPrime = true\n    for char in num {\n        switch char {\n\
    \        case \"A\":\n        case \"B\":\n        case \"C\":\n        case \"\
    D\":\n        case \"E\":\n        case \"F\":\n            isPrime = false\n\
    \        default:\n            break\n        }\n        if isPrime {\n      \
    \      result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9xey99zw.swift:29:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp9xey99zw.swift:30:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp9xey99zw.swift:31:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9xey99zw.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9xey99zw.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp9xey99zw.swift:25:9:\
    \ warning: initialization of variable 'i' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var i = 0\n    ~~~~^\n    _\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexNumsCount = 0\n    var hexNumsPrimeCount\
    \ = 0\n    var hexNumsPrimePrimeCount = 0\n    var hexNumsPrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimeCount = 0\n    var hexNumsPrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimeCount = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var\
    \ hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpeb0qegl5.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpeb0qegl5.swift:41:9:\
    \ error: invalid redeclaration of 'hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\n\
    \    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpeb0qegl5.swift:40:9: note: 'hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount'\
    \ previously declared here\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = 0\n        ^\n/tmp/tmpeb0qegl5.swift:45:9: error: type annotation missing\
    \ in pattern\n    var hexNumsPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = \"\"\n    for c in num {\n        digits = digits + String(c)\n   \
    \ }\n    for c in digits {\n        if c >= '0' && c <= '9' {\n            count\
    \ = count + 1\n        }\n    }\n    if count >= 2 {\n        return count\n \
    \   }\n    if count >= 3 {\n        return count + 1\n    }\n    if count >= 5\
    \ {\n        return count + 2\n    }\n    if count >= 7 {\n        return count\
    \ + 3\n    }\n    if count >= 11 {\n        return count + 4\n    }\n    if count\
    \ >= 13 {\n        return count + 5\n    }\n    if count >= 17 {\n        return\
    \ count + 6\n    }\n    if count >= 19 {\n        return count + 7\n    }\n  \
    \  if count >= 21 {\n        return count + 8\n    }\n    if count >= 23 {\n \
    \       return count + 9\n    }\n    if count >= 29 {\n        return count +\
    \ 10\n    }\n    if count >= 31 {\n        return count + 11\n    }\n    if count\
    \ >= 33 {\n        return count + 12\n    }\n    if count >= 37 {\n        return\
    \ count + 13\n    }\n    if count >= 41 {\n        return count + 14\n    }\n\
    \    if count >= 43 {\n        return count + 15\n    }\n    if count >= 47 {\n\
    \        return count + 16\n    }\n    if count >= 51 {\n        return count\
    \ + 17\n    }\n    if count >= 55 {\n        return count + 18\n    }\n    if\
    \ count >= 59 {\n        return count + 19\n    }\n    if count >= 63 {\n    \
    \    return count + 20\n    }\n    if count >= 67 {\n        return count + 21\n\
    \    }\n    if count >= 71 {\n        return count + 22\n    }\n    if count >=\
    \ 73 {\n        return count + 23\n    }\n    if count >= 79 {\n        return\
    \ count + 24\n    }\n    if count >= 83 {\n        return count + 25\n    }\n\
    \    if count >= 89 {\n        return count + 26\n    }\n    if count >= 97 {\n\
    \        return count + 27\n    }\n    if count >= 101 {\n        return count\
    \ + 28\n    }\n    if count >= 103 {\n        return count + 29\n    }\n    if\
    \ count >= 107 {\n        return count + 30\n    }\n    if count >= 109 {\n  \
    \      return count + 31\n    }\n    if count >= 113 {\n        return count +\
    \ 32\n    }\n    if count >= 117 {\n        return count + 33\n    }\n    if count\
    \ >= 121 {\n        return count + 34\n    }\n    if count >= 123 {\n        return\
    \ count + 35\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvvhz04fq.swift:30:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpvvhz04fq.swift:30:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    var digit = digits[0]\n    var prime = primes[digit]\n\
    \    if prime == nil {\n        return -1\n    }\n    for digit in digits {\n\
    \        result += primes[digit]\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp5p_13qop.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5p_13qop.swift:26:17:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    var digit = digits[0]\n                ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5p_13qop.swift:27:17:\
    \ error: cannot find 'primes' in scope\n    var prime = primes[digit]\n      \
    \          ^~~~~~\n/tmp/tmp5p_13qop.swift:32:19: error: cannot find 'primes' in\
    \ scope\n        result += primes[digit]\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    var prime = 1\n    for digit in digits {\n        if digit\
    \ == \"A\" {\n            prime = 2\n        } else if digit == \"B\" {\n    \
    \        prime = 3\n        } else if digit == \"C\" {\n            prime = 5\n\
    \        } else if digit == \"D\" {\n            prime = 7\n        } else if\
    \ digit == \"E\" {\n            prime = 11\n        } else if digit == \"F\" {\n\
    \            prime = 13\n        } else {\n            prime = digit - 48\n  \
    \      }\n        if prime > 1 {\n            count += prime - 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpe2d__28z.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpe2d__28z.swift:41:21:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            prime = digit - 48\n                    ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num\n    var\
    \ count = 0\n    for char in hex {\n        if char >= '0' && char <= '9' {\n\
    \            count = count + 1\n        }\n    }\n    if count % 2 == 0 {\n  \
    \      return count\n    }\n    var hex2 = hex\n    var hex3 = hex\n    var hex4\
    \ = hex\n    var hex5 = hex\n    var hex6 = hex\n    var hex7 = hex\n    var hex8\
    \ = hex\n    var hex9 = hex\n    var hex10 = hex\n    var hex11 = hex\n    var\
    \ hex12 = hex\n    var hex13 = hex\n    var hex14 = hex\n    var hex15 = hex\n\
    \    var hex16 = hex\n    var hex17 = hex\n    var hex18 = hex\n    var hex19\
    \ = hex\n    var hex20 = hex\n    var hex21 = hex\n    var hex22 = hex\n    var\
    \ hex23 = hex\n    var hex24 = hex\n    var hex25 = hex\n    var hex26 = hex\n\
    \    var hex27 = hex\n    var hex28 = hex\n    var hex29 = hex\n    var hex30\
    \ = hex\n    var hex31 = hex\n    var hex32 = hex\n    var hex33 = hex\n    var\
    \ hex34 = hex\n    var hex35 = hex\n    var hex36 = hex\n    var hex37 = hex\n\
    \    var hex38 = hex\n    var hex39 = hex\n    var hex40 = hex\n    var hex41\
    \ = hex\n    var hex42 = hex\n    var hex43 = hex\n    var hex44 = hex\n    var\
    \ hex45 = hex\n    var hex46 = hex\n    var hex47 = hex\n    var hex48 = hex\n\
    \    var hex49 = hex\n    var hex50 = hex\n    var hex51 = hex\n    var hex52\
    \ = hex\n    var hex53 = hex\n    var hex54 = hex\n    var hex55 = hex\n    var\
    \ hex56 = hex\n    var hex57 = hex\n    var hex58 = hex\n    var hex59 = hex\n\
    \    var hex60 = hex\n    var hex61 = hex\n    var hex62 = hex\n    var hex63\
    \ = hex\n    var hex64 = hex\n    var hex65 = hex\n    var hex66 = hex\n    var\
    \ hex67 = hex\n    var hex68 = hex\n    var hex69 = hex\n    var hex70 = hex\n\
    \    var hex71 = hex\n    var hex72 = hex\n    var hex73 = hex\n    var hex74\
    \ = hex\n    var hex75 = hex\n    var hex76 = hex\n    var hex77 = hex\n    var\
    \ hex78 = hex\n    var hex79 = hex\n    var hex80 = hex\n    var hex8\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpctvq6z2v.swift:27:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpctvq6z2v.swift:27:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpctvq6z2v.swift:113:9: error: type annotation missing in pattern\n    var\
    \ hex8\n        ^\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        switch char {\n        case \"A\":\n        case \"B\"\
    :\n        case \"C\":\n        case \"D\":\n        case \"E\":\n        case\
    \ \"F\":\n            count += 1\n        default:\n            break\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpr2w52mkw.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpr2w52mkw.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpr2w52mkw.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit\
    \ == \"F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxfqn6bhi.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxfqn6bhi.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        if c >= '0' && c <= '9' {\n            count = count * 16\
    \ + c - '0'\n        } else if c == 'A' || c == 'B' || c == 'C' || c == 'D' ||\
    \ c == 'E' || c == 'F' {\n            count = count * 16 + 10 + c - 'A'\n    \
    \    } else {\n            return -1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpv5fgjbwj.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpv5fgjbwj.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpv5fgjbwj.swift:27:38: error:\
    \ single-quoted string literal found, use '\"'\n            count = count * 16\
    \ + c - '0'\n                                     ^~~\n                      \
    \               \"0\"\n/tmp/tmpv5fgjbwj.swift:28:24: error: single-quoted string\
    \ literal found, use '\"'\n        } else if c == 'A' || c == 'B' || c == 'C'\
    \ || c == 'D' || c == 'E' || c == 'F' {\n                       ^~~\n        \
    \               \"A\"\n/tmp/tmpv5fgjbwj.swift:28:36: error: single-quoted string\
    \ literal found, use '\"'\n        } else if c == 'A' || c == 'B' || c == 'C'\
    \ || c == 'D' || c == 'E' || c == 'F' {\n                                   ^~~\n\
    \                                   \"B\"\n/tmp/tmpv5fgjbwj.swift:28:48: error:\
    \ single-quoted string literal found, use '\"'\n        } else if c == 'A' ||\
    \ c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n               \
    \                                ^~~\n                                       \
    \        \"C\"\n/tmp/tmpv5fgjbwj.swift:28:60: error: single-quoted string literal\
    \ found, use '\"'\n        } else if c == 'A' || c == 'B' || c == 'C' || c ==\
    \ 'D' || c == 'E' || c == 'F' {\n                                            \
    \               ^~~\n                                                        \
    \   \"D\"\n/tmp/tmpv5fgjbwj.swift:28:72: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c == 'A' || c == 'B' || c == 'C' || c == 'D' ||\
    \ c == 'E' || c == 'F' {\n                                                   \
    \                    ^~~\n                                                   \
    \                    \"E\"\n/tmp/tmpv5fgjbwj.swift:28:84: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c == 'A' || c == 'B' || c\
    \ == 'C' || c == 'D' || c ="
  stdout: ''
  timestamp: 1660014350
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num {\n        sum += Int(char) - 48\n    }\n    return sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvuy1f4b9.swift:26:16: error: no exact matches in call to initializer\
    \ \n        sum += Int(char) - 48\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var count = 0\n    for hex in hex {\n        switch hex {\n        case 0x30,\
    \ 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41:\n        case 0x42,\
    \ 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C:\n        case 0x4D,\
    \ 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57:\n        case 0x58,\
    \ 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69:\n        case\
    \ 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75:\n  \
    \      case 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,\
    \ 0x36:\n        case 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\
    \ 0x48, 0x49:\n        case 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,\
    \ 0x53, 0x54, 0x55:\n        case 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63,\
    \ 0x64, 0x65, 0x66, 0x67:\n        case 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,\
    \ 0x6F, 0x70, 0x71, 0x72, 0x73:\n        case 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\
    \ 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34:\n        case 0x35, 0x36, 0x37, 0x38, 0x39,\
    \ 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47:\n        case 0x48, 0x49, 0x4A, 0x4B,\
    \ 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53:\n        case 0x54, 0x55, 0x56,\
    \ 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65:\n        case 0x66, 0x67,\
    \ 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71:\n        case 0x72,\
    \ 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32:\n        case\
    \ 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45:\n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1mx0bwjk.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 0x30, 0x31, 0x32, 0x33, 0x34,\
    \ 0x35, 0x36, 0x37, 0x38, 0x39, 0x41:\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \   break\n/tmp/tmp1mx0bwjk.swift:29:9: error: 'case' label in a 'switch' must\
    \ have at least one executable statement\n        case 0x42, 0x43, 0x44, 0x45,\
    \ 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C:\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \   break\n/tmp/tmp1mx0bwjk.swift:30:9: error: 'case' label in a 'switch' must\
    \ have at least one executable statement\n        case 0x4D, 0x4E, 0x4F, 0x50,\
    \ 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57:\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \   break\n/tmp/tmp1mx0bwjk.swift:31:9: error: 'case' label in a 'switch' must\
    \ have at least one executable statement\n        case 0x58, 0x59, 0x5A, 0x61,\
    \ 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69:\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \         break\n/tmp/tmp1mx0bwjk.swift:32:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 0x6A, 0x6B, 0x6C,\
    \ 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75:\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \         break\n/tmp/tmp1mx0bwjk.swift:33:9: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n        case 0x76, 0x77, 0x78,\
    \ 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36:\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for char in nums {\n        switch char {\n        case\
    \ \"A\":\n        case \"B\":\n        case \"C\":\n        case \"D\":\n    \
    \    case \"E\":\n        case \"F\":\n            result += 1\n        default:\n\
    \            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp4wh5_8vf.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp4wh5_8vf.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp4wh5_8vf.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4wh5_8vf.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4wh5_8vf.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp4wh5_8vf.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp4wh5_8vf.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNum = nums.map { String($0) }\n    var hexNums = hexNum.map { String($0)\
    \ }\n    var hexNumsCount = hexNums.count\n    var hexNumsCount2 = hexNumsCount\
    \ * hexNumsCount\n    var hexNumsCount3 = hexNumsCount2 * hexNumsCount\n    var\
    \ hexNumsCount4 = hexNumsCount3 * hexNumsCount\n    var hexNumsCount5 = hexNumsCount4\
    \ * hexNumsCount\n    var hexNumsCount6 = hexNumsCount5 * hexNumsCount\n    var\
    \ hexNumsCount7 = hexNumsCount6 * hexNumsCount\n    var hexNumsCount8 = hexNumsCount7\
    \ * hexNumsCount\n    var hexNumsCount9 = hexNumsCount8 * hexNumsCount\n    var\
    \ hexNumsCount10 = hexNumsCount9 * hexNumsCount\n    var hexNumsCount11 = hexNumsCount10\
    \ * hexNumsCount\n    var hexNumsCount12 = hexNumsCount11 * hexNumsCount\n   \
    \ var hexNumsCount13 = hexNumsCount12 * hexNumsCount\n    var hexNumsCount14 =\
    \ hexNumsCount13 * hexNumsCount\n    var hexNumsCount15 = hexNumsCount14 * hexNumsCount\n\
    \    var hexNumsCount16 = hexNumsCount15 * hexNumsCount\n    var hexNumsCount17\
    \ = hexNumsCount16 * hexNumsCount\n    var hexNumsCount18 = hexNumsCount17 * hexNumsCount\n\
    \    var hexNumsCount19 = hexNumsCount18 * hexNumsCount\n    var hexNumsCount20\
    \ = hexNumsCount19 * hexNumsCount\n    var hexNumsCount21 = hexNumsCount20 * hexNumsCount\n\
    \    var hexNumsCount22 = hexNumsCount21 * hexNumsCount\n    var hexNumsCount23\
    \ = hexNumsCount22 * hexNumsCount\n    var hexNumsCount24 = hexNumsCount23 * hexNumsCount\n\
    \    var hexNumsCount25 = hexNumsCount24 * hexNumsCount\n    var hexNumsCount26\
    \ = hexNumsCount25 * hexNumsCount\n    var hexNumsCount27 = hexNumsCount26 * hexNumsCount\n\
    \    var hexNumsCount28 = hexNumsCount27 * hexNumsCount\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxffjvy5c.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxffjvy5c.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpxffjvy5c.swift:25:9:\
    \ warning: variable 'hexNum' was never mutated; consider changing to 'let' constant\n\
    \    var hexNum = nums.map { String($0) }\n    ~~~ ^\n    let\n/tmp/tmpxffjvy5c.swift:26:9:\
    \ warning: variable 'hexNums' was never mutated; consider changing to 'let' constant\n\
    \    var hexNums = hexNum.map { String($0) }\n    ~~~ ^\n    let\n/tmp/tmpxffjvy5c.swift:27:9:\
    \ warning: variable 'hexNumsCount' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount = hexNums.count\n    ~~~ ^\n    let\n/tmp/tmpxffjvy5c.swift:28:9:\
    \ warning: variable 'hexNumsCount2' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount2 = hexNumsCount * hexNumsCount\n    ~~~ ^\n \
    \   let\n/tmp/tmpxffjvy5c.swift:29:9: warning: variable 'hexNumsCount3' was never\
    \ mutated; consider changing to 'let' constant\n    var hexNumsCount3 = hexNumsCount2\
    \ * hexNumsCount\n    ~~~ ^\n    let\n/tmp/tmpxffjvy5c.swift:30:9: warning: variable\
    \ 'hexNumsCount4' was never mutated; consider changing to 'let' constant\n   \
    \ var hexNumsCount4 = hexNumsCount3 * hexNumsCount\n    ~~~ ^\n    let\n/tmp/tmpxffjvy5c.swift:31:9:\
    \ warning: variable 'hexNumsCount5' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount5 = hexNumsCount4 * hexNumsCount\n    ~~~ ^\n\
    \    let\n/tmp/tmpxffjvy5c.swift:32:9: warning: variable 'hexNumsCount6' was never\
    \ mutated; consider changing to 'let' constant\n    var hexNumsCount6 = hexNumsCount5\
    \ * hexNumsCount\n    ~~~ ^\n    let\n/tmp/tmpxffjvy5c.swift:33:9: warning: variable\
    \ 'hexNumsCount7' was never mutated; consider changing to 'let' constant\n   \
    \ var hexNumsCount7 = hexNumsC"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var count = 0\n    for c in num.unicodeScalars {\n        if c.value > 0xFF\
    \ {\n            return -1\n        }\n        nums.append(c.value)\n    }\n \
    \   for num in nums {\n        if num == 0xB {\n            count += 1\n     \
    \   } else if num == 0xD {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpw0c2cjku.swift:30:23: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'Int'\n        nums.append(c.value)\n            \
    \          ^\n                    Int(   )\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNum = nums.map { Int($0) }\n    var hexNums = hexNum.map { String($0)\
    \ }\n    var hexNumsCount = hexNums.count\n    var hexNumsCount2 = hexNumsCount\
    \ * hexNumsCount\n    var hexNumsCount3 = hexNumsCount2 * hexNumsCount\n    var\
    \ hexNumsCount4 = hexNumsCount3 * hexNumsCount\n    var hexNumsCount5 = hexNumsCount4\
    \ * hexNumsCount\n    var hexNumsCount6 = hexNumsCount5 * hexNumsCount\n    var\
    \ hexNumsCount7 = hexNumsCount6 * hexNumsCount\n    var hexNumsCount8 = hexNumsCount7\
    \ * hexNumsCount\n    var hexNumsCount9 = hexNumsCount8 * hexNumsCount\n    var\
    \ hexNumsCount10 = hexNumsCount9 * hexNumsCount\n    var hexNumsCount11 = hexNumsCount10\
    \ * hexNumsCount\n    var hexNumsCount12 = hexNumsCount11 * hexNumsCount\n   \
    \ var hexNumsCount13 = hexNumsCount12 * hexNumsCount\n    var hexNumsCount14 =\
    \ hexNumsCount13 * hexNumsCount\n    var hexNumsCount15 = hexNumsCount14 * hexNumsCount\n\
    \    var hexNumsCount16 = hexNumsCount15 * hexNumsCount\n    var hexNumsCount17\
    \ = hexNumsCount16 * hexNumsCount\n    var hexNumsCount18 = hexNumsCount17 * hexNumsCount\n\
    \    var hexNumsCount19 = hexNumsCount18 * hexNumsCount\n    var hexNumsCount20\
    \ = hexNumsCount19 * hexNumsCount\n    var hexNumsCount21 = hexNumsCount20 * hexNumsCount\n\
    \    var hexNumsCount22 = hexNumsCount21 * hexNumsCount\n    var hexNumsCount23\
    \ = hexNumsCount22 * hexNumsCount\n    var hexNumsCount24 = hexNumsCount23 * hexNumsCount\n\
    \    var hexNumsCount25 = hexNumsCount24 * hexNumsCount\n    var hexNumsCount26\
    \ = hexNumsCount25 * hexNumsCount\n    var hexNumsCount27 = hexNumsCount26 * hexNumsCount\n\
    \    var hexNumsCount28 = hexNumsCount27 * hexNumsCount\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbyv5bygq.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbyv5bygq.swift:25:29:\
    \ error: no exact matches in call to initializer \n    var hexNum = nums.map {\
    \ Int($0) }\n                            ^\nSwift.Int:7:12: note: candidate expects\
    \ value of type 'Float16' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    public init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'String.Element' (aka\
    \ 'Character'))\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'String.Element' (aka 'Character'))\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'String.Element' (aka 'Character'))\n    public init(_\
    \ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for char in nums {\n        let hex = Int(char) ?? 0\n\
    \        if hex == 0 || hex > 9 {\n            continue\n        }\n        if\
    \ hex == hex_key(hex: hex) {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphyn2ab7u.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphyn2ab7u.swift:27:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        let hex = Int(char) ?? 0\n                      ^\n/tmp/tmphyn2ab7u.swift:31:26:\
    \ error: incorrect argument label in call (have 'hex:', expected 'num:')\n   \
    \     if hex == hex_key(hex: hex) {\n                         ^~~~\n         \
    \                 num\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    \n    // Your code here\n\
    \    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpi8og8fk8/tmpi8og8fk8.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d9d564c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d9d25bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d9d25b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d9d25a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8og8fk8                        0x00005648430a2264 <unavailable> + 4708

    5    libc.so.6                          0x00002b7d9d750460 __libc_start_main +
    245

    6    tmpi8og8fk8                        0x00005648430a1ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = Set<Int>()\n    var prime = Int(2)\n    var\
    \ isPrime = true\n    for char in nums {\n        if char == \"A\" {\n       \
    \     prime = Int(11)\n        } else if char == \"B\" {\n            prime =\
    \ Int(13)\n        } else if char == \"C\" {\n            prime = Int(17)\n  \
    \      } else if char == \"D\" {\n            prime = Int(19)\n        } else\
    \ if char == \"E\" {\n            prime = Int(23)\n        } else if char == \"\
    F\" {\n            prime = Int(29)\n        } else {\n            prime = Int(Int(char)\
    \ - Int(Int(char.unicodeScalars.first!.value - 65)))\n        }\n        if prime\
    \ > 1 {\n            primes.insert(Int(prime))\n        }\n    }\n    for prime\
    \ in primes {\n        if nums.contains(String(prime)) {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpyw5so4fb.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyw5so4fb.swift:43:25:\
    \ error: no exact matches in call to initializer \n            prime = Int(Int(char)\
    \ - Int(Int(char.unicodeScalars.first!.value - 65)))\n                       \
    \ ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects\
    \ value of type 'Float80' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_\
    \ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects\
    \ value of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public\
    \ init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    var prime: Int = 0\n\
    \    var prime2: Int = 0\n    var prime3: Int = 0\n    var prime4: Int = 0\n \
    \   var prime5: Int = 0\n    var prime6: Int = 0\n    var prime7: Int = 0\n  \
    \  var prime8: Int = 0\n    var prime9: Int = 0\n    var prime10: Int = 0\n  \
    \  var prime11: Int = 0\n    var prime12: Int = 0\n    var prime13: Int = 0\n\
    \    var prime14: Int = 0\n    var prime15: Int = 0\n    var prime16: Int = 0\n\
    \    var prime17: Int = 0\n    var prime18: Int = 0\n    var prime19: Int = 0\n\
    \    var prime20: Int = 0\n    var prime21: Int = 0\n    var prime22: Int = 0\n\
    \    var prime23: Int = 0\n    var prime24: Int = 0\n    var prime25: Int = 0\n\
    \    var prime26: Int = 0\n    var prime27: Int = 0\n    var prime28: Int = 0\n\
    \    var prime29: Int = 0\n    var prime30: Int = 0\n    var prime31: Int = 0\n\
    \    var prime32: Int = 0\n    var prime33: Int = 0\n    var prime34: Int = 0\n\
    \    var prime35: Int = 0\n    var prime36: Int = 0\n    var prime37: Int = 0\n\
    \    var prime38: Int = 0\n    var prime39: Int = 0\n    var prime40: Int = 0\n\
    \    var prime41: Int = 0\n    var prime42: Int = 0\n    var prime43: Int = 0\n\
    \    var prime44: Int = 0\n    var prime45: Int = 0\n    var prime46: Int = 0\n\
    \    var prime47: Int = 0\n    var prime48: Int = 0\n    var prime49: Int = 0\n\
    \    var prime50: Int = 0\n    var prime51: Int = 0\n    var prime52: Int = 0\n\
    \    var prime53: Int = 0\n    var prime54: Int = 0\n    var prime55: Int = 0\n\
    \    var prime56: Int = 0\n    var prime57: Int = 0\n    var prime58: Int = 0\n\
    \    var prime59: Int = 0\n    var prime60: Int = 0\n    var prime61: Int = 0\n\
    \    var prime62: Int = 0\n    var prime63: Int = 0\n    var prime64: Int = 0\n\
    \    var prime65: Int = 0\n    var prime66: Int = 0\n    var prime67: Int = 0\n\
    \    var prime68: Int = 0\n    var prime69: Int = 0\n    var prime70: Int = 0\n\
    \    var prime71: Int = 0\n    var prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmph9ecuuiq.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmph9ecuuiq.swift:99:9: error:\
    \ type annotation missing in pattern\n    var prime\n        ^\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums: [Int] = []\n\
    \    var numStr = \"\"\n    for c in num {\n        if c.isUpper() {\n       \
    \     numStr += c.lowercased()\n        } else {\n            numStr += c\n  \
    \      }\n    }\n    for c in numStr {\n        if c.isDigit() {\n           \
    \ nums.append(Int(c))\n        }\n    }\n    var prime: Int = 0\n    var primes:\
    \ [Int] = []\n    for c in nums {\n        if c % 2 == 0 {\n            primes.append(c)\n\
    \        }\n    }\n    for p in primes {\n        if p > 1 {\n            for\
    \ c in nums {\n                if c % p == 0 {\n                    primes.append(p)\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return primes.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcbik4vgn.swift:27:14: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if c.isUpper() {\n           ~ ^~~~~~~\n/tmp/tmpcbik4vgn.swift:30:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            numStr += c\n                      ^\n/tmp/tmpcbik4vgn.swift:34:14:\
    \ error: value of type 'Character' has no member 'isDigit'\n        if c.isDigit()\
    \ {\n           ~ ^~~~~~~\n/tmp/tmpcbik4vgn.swift:35:25: error: no exact matches\
    \ in call to initializer \n            nums.append(Int(c))\n                 \
    \       ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float16)\n       \
    \    ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float)\n           ^\nSwift.Int:12:12:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects\
    \ value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public\
    \ init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate\
    \ expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n  \
    \  public init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime($0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitCount < hexDigitPrimeCount {\n        return 0\n    }\n    return\
    \ hexDigitPrimes.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpet2pxhpa.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpet2pxhpa.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpet2pxhpa.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime($0)\
    \ }\n                                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [Int] =\
    \ []\n    var numDigits = num.characters.count\n    for i in 0..<numDigits {\n\
    \        let digit = Int(num.characters[i])\n        if digit < 48 || digit >\
    \ 57 {\n            return -1\n        }\n        hexDigits.append(digit)\n  \
    \  }\n    var hexKey = 0\n    for i in 0..<hexDigits.count {\n        let digit\
    \ = hexDigits[i]\n        if digit == 0 {\n            continue\n        }\n \
    \       if digit == 1 {\n            hexKey += 2\n            continue\n     \
    \   }\n        if digit == 2 {\n            hexKey += 3\n            continue\n\
    \        }\n        if digit == 3 {\n            hexKey += 5\n            continue\n\
    \        }\n        if digit == 4 {\n            hexKey += 7\n            continue\n\
    \        }\n        if digit == 5 {\n            hexKey += 11\n            continue\n\
    \        }\n        if digit == 6 {\n            hexKey += 13\n            continue\n\
    \        }\n        if digit == 7 {\n            hexKey += 17\n            continue\n\
    \        }\n        if digit == 8 {\n            hexKey += 19\n            continue\n\
    \        }\n        if digit == 9 {\n            hexKey += 23\n            continue\n\
    \        }\n        if digit == 10 {\n            hexKey += 29\n            continue\n\
    \        }\n        if digit == 11 {\n            hexKey += 31\n            continue\n\
    \        }\n        if digit == 12 {\n            hexKey += 37\n            continue\n\
    \        }\n        if digit == 13 {\n            hexKey += 41\n            continue\n\
    \        }\n        if digit == 14 {\n            hexKey += 43\n            continue\n\
    \        }\n        if digit == 15 {\n            hexKey += 47\n            continue\n\
    \        }\n        if digit == 16 {\n            hexKey += 53\n            continue\n\
    \        }\n        if digit == 17 {\n            hexKey += 59\n            continue\n\
    \        }\n        if digit == 18 {\n            hexKey += 61\n            continue\n\
    \        }\n        if digit == 19 {\n            hexKey += 67\n            continue\n\
    \        }\n        if digit == 20 {\n            hexKey += 71\n            continue\n\
    \        }\n        if digit == 21 {\n            hexKey += 73\n            continue\n\
    \        }\n        if digit == 22 {\n            hexKey += 79\n            continue\n\
    \        }\n        if digit == 23 {\n            hexKey += 83\n            continue\n\
    \        }\n        if digit == 24 {\n            hexKey += 89\n            continue\n\
    \        }\n        if digit == 25 {\n            hexKey += 97\n            continue\n\
    \        }\n        if digit == 26 {\n            hexKey += 101\n            continue\n\
    \        }\n        if digit == 27 {\n            hexKey += 103\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp54aculxg.swift:165:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmp54aculxg.swift:34:34:\
    \ note: to match this opening '{'\n    for i in 0..<hexDigits.count {\n      \
    \                           ^\n/tmp/tmp54aculxg.swift:165:63: error: expected\
    \ '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmp54aculxg.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmp54aculxg.swift:25:25: error: 'characters'\
    \ is unavailable: Please use String directly\n    var numDigits = num.characters.count\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp54aculxg.swift:27:39: error: no exact matches in call to\
    \ subscript \n        let digit = Int(num.characters[i])\n                   \
    \                   ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmp54aculxg.swift:148:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters.map\
    \ { String($0) }\n    var hexDigits: [String] = []\n    var primeCount = 0\n \
    \   var prime: Int = 0\n    var primes: [Int] = []\n    var primesCount = 0\n\
    \    var primesSum = 0\n    var primesSum2 = 0\n    var primesSum3 = 0\n    var\
    \ primesSum4 = 0\n    var primesSum5 = 0\n    var primesSum6 = 0\n    var primesSum7\
    \ = 0\n    var primesSum8 = 0\n    var primesSum9 = 0\n    var primesSum10 = 0\n\
    \    var primesSum11 = 0\n    var primesSum12 = 0\n    var primesSum13 = 0\n \
    \   var primesSum14 = 0\n    var primesSum15 = 0\n    var primesSum16 = 0\n  \
    \  var primesSum17 = 0\n    var primesSum18 = 0\n    var primesSum19 = 0\n   \
    \ var primesSum20 = 0\n    var primesSum21 = 0\n    var primesSum22 = 0\n    var\
    \ primesSum23 = 0\n    var primesSum24 = 0\n    var primesSum25 = 0\n    var primesSum26\
    \ = 0\n    var primesSum27 = 0\n    var primesSum28 = 0\n    var primesSum29 =\
    \ 0\n    var primesSum30 = 0\n    var primesSum31 = 0\n    var primesSum32 = 0\n\
    \    var primesSum33 = 0\n    var primesSum34 = 0\n    var primesSum35 = 0\n \
    \   var primesSum36 = 0\n    var primesSum37 = 0\n    var primesSum38 = 0\n  \
    \  var primesSum39 = 0\n    var primesSum40 = 0\n    var primesSum41 = 0\n   \
    \ var primesSum42 = 0\n    var primesSum43 = 0\n    var primesSum44 = 0\n    var\
    \ primesSum45 = 0\n    var primesSum46 = 0\n    var primesSum47 = 0\n    var primesSum48\
    \ = 0\n    var primesSum49 = 0\n    var primesSum50 = 0\n    var primesSum51 =\
    \ 0\n    var primesSum52 = 0\n    var primesSum53 = 0\n    var primesSum54 = 0\n\
    \    var primesSum55 = 0\n    var primesSum56 = 0\n    var primesSum57 = 0\n \
    \   var primesSum58 = 0\n    var primesSum59 = 0\n    var primesSum60 = 0\n  \
    \  var primesSum61 = 0\n    var primesSum62 = 0\n    var primesSum63 = 0\n   \
    \ var primesSum64 = 0\n    var primesSum65 = 0\n    var primesSum66 = 0\n    var\
    \ primesSum67 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvqxpjie1.swift:97:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpvqxpjie1.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters.map { String($0) }\n     \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvqxpjie1.swift:24:9: warning: initialization of variable 'hex' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ hex = num.characters.map { String($0) }\n    ~~~~^~~\n    _\n/tmp/tmpvqxpjie1.swift:25:9:\
    \ warning: variable 'hexDigits' was never used; consider replacing with '_' or\
    \ removing it\n    var hexDigits: [String] = []\n        ^~~~~~~~~\n        _\n\
    /tmp/tmpvqxpjie1.swift:26:9: warning: initialization of variable 'primeCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primeCount = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpvqxpjie1.swift:27:9:\
    \ warning: variable 'prime' was never used; consider replacing with '_' or removing\
    \ it\n    var prime: Int = 0\n        ^~~~~\n        _\n/tmp/tmpvqxpjie1.swift:28:9:\
    \ warning: variable 'primes' was never used; consider replacing with '_' or removing\
    \ it\n    var primes: [Int] = []\n        ^~~~~~\n        _\n/tmp/tmpvqxpjie1.swift:29:9:\
    \ warning: initialization of variable 'primesCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primesCount = 0\n    ~~~~^~~~~~~~~~~\n\
    \    _\n/tmp/tmpvqxpjie1.swift:30:9: warning: initialization of variable 'primesSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primesSum = 0\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpvqxpjie1.swift:31:9:\
    \ warning: initialization of variable 'primesSum2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primesSum2 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpvqxpjie1.swift:32:9: warning: initialization of variable 'primesSum3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primesS"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    var i = 0\n    for _ in 0..<num.characters.count\
    \ {\n        if digits[i] == \"A\" {\n            result += 2\n        } else\
    \ if digits[i] == \"B\" {\n            result += 3\n        } else if digits[i]\
    \ == \"C\" {\n            result += 5\n        } else if digits[i] == \"D\" {\n\
    \            result += 7\n        } else if digits[i] == \"E\" {\n           \
    \ result += 11\n        } else if digits[i] == \"F\" {\n            result +=\
    \ 13\n        } else {\n            result += digits[i] - 48\n        }\n    \
    \    i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz40s36y6.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpz40s36y6.swift:27:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for _ in\
    \ 0..<num.characters.count {\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpz40s36y6.swift:28:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if digits[i] == \"A\" {\n           ^~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpz40s36y6.swift:30:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if digits[i] == \"B\" {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpz40s36y6.swift:32:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if digits[i] == \"C\" {\n      \
    \            ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpz40s36y6.swift:34:19: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        }\
    \ else if digits[i] == \"D\" {\n                  ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpz40s36y6.swift:36:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String wit"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for i in 0..<digits.count {\n        let digit\
    \ = digits[i]\n        if digit == \"A\" || digit == \"B\" || digit == \"C\" ||\
    \ digit == \"D\" || digit == \"E\" || digit == \"F\" {\n            result +=\
    \ 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3j4gxaj5.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3j4gxaj5.swift:27:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let digit = digits[i]\n               \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp3j4gxaj5.swift:25:9: warning: variable 'digits' was never\
    \ mutated; consider changing to 'let' constant\n    var digits = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"A\":\n        case \"B\":\n \
    \       case \"C\":\n        case \"D\":\n        case \"E\":\n        case \"\
    F\":\n            count += 1\n        default:\n            break\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp7vrpggv_.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp7vrpggv_.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp7vrpggv_.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp7vrpggv_.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp7vrpggv_.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            count += 1\n        } else if digit == \"B\" {\n            count\
    \ += 1\n        } else if digit == \"C\" {\n            count += 1\n        }\
    \ else if digit == \"D\" {\n            count += 1\n        } else if digit ==\
    \ \"E\" {\n            count += 1\n        } else if digit == \"F\" {\n      \
    \      count += 1\n        } else if digit == \"0\" {\n            count += 1\n\
    \        } else if digit == \"1\" {\n            count += 1\n        } else if\
    \ digit == \"2\" {\n            count += 1\n        } else if digit == \"3\" {\n\
    \            count += 1\n        } else if digit == \"4\" {\n            count\
    \ += 1\n        } else if digit == \"5\" {\n            count += 1\n        }\
    \ else if digit == \"6\" {\n            count += 1\n        } else if digit ==\
    \ \"7\" {\n            count += 1\n        } else if digit == \"8\" {\n      \
    \      count += 1\n        } else if digit == \"9\" {\n            count += 1\n\
    \        } else if digit == \"a\" {\n            count += 1\n        } else if\
    \ digit == \"b\" {\n            count += 1\n        } else if digit == \"c\" {\n\
    \            count += 1\n        } else if digit == \"d\" {\n            count\
    \ += 1\n        } else if digit == \"e\" {\n            count += 1\n        }\
    \ else if digit == \"f\" {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz2vnkb3x.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpz2vnkb3x.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        switch digit {\n\
    \        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"\
    3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case\
    \ \"7\":\n        case \"8\":\n        case \"9\":\n        case \"A\":\n    \
    \    case \"B\":\n        case \"C\":\n        case \"D\":\n        case \"E\"\
    :\n        case \"F\":\n        default:\n            result += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpgyyjekuk.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpgyyjekuk.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpgyyjekuk.swift:40:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    var isPrime = true\n    var isHex = true\n    var isHexDigit\
    \ = true\n    var isHexDigit2 = true\n    var isHexDigit3 = true\n    var isHexDigit4\
    \ = true\n    var isHexDigit5 = true\n    var isHexDigit6 = true\n    var isHexDigit7\
    \ = true\n    var isHexDigit8 = true\n    var isHexDigit9 = true\n    var isHexDigit0\
    \ = true\n    var isHexDigit1 = true\n    var isHexDigit2 = true\n    var isHexDigit3\
    \ = true\n    var isHexDigit4 = true\n    var isHexDigit5 = true\n    var isHexDigit6\
    \ = true\n    var isHexDigit7 = true\n    var isHexDigit8 = true\n    var isHexDigit9\
    \ = true\n    var isHexDigit0 = true\n    var isHexDigit1 = true\n    var isHexDigit2\
    \ = true\n    var isHexDigit3 = true\n    var isHexDigit4 = true\n    var isHexDigit5\
    \ = true\n    var isHexDigit6 = true\n    var isHexDigit7 = true\n    var isHexDigit8\
    \ = true\n    var isHexDigit9 = true\n    var isHexDigit0 = true\n    var isHexDigit1\
    \ = true\n    var isHexDigit2 = true\n    var isHexDigit3 = true\n    var isHexDigit4\
    \ = true\n    var isHexDigit5 = true\n    var isHexDigit6 = true\n    var isHexDigit7\
    \ = true\n    var isHexDigit8 = true\n    var isHexDigit9 = true\n    var isHexDigit0\
    \ = true\n    var isHexDigit1 = true\n    var isHexDigit2 = true\n    var isHexDigit3\
    \ = true\n    var isHexDigit4 = true\n    var isHexDigit5 = true\n    var isHexDigit6\
    \ = true\n    var isHexDigit7 = true\n    var isHexDigit8 = true\n    var isHexDigit9\
    \ = true\n    var isHexDigit0 = true\n    var isHexDigit1 = true\n    var isHexDigit2\
    \ = true\n    var isHexDigit3 = true\n    var isHexDigit4 = true\n    var isHexDigit5\
    \ = true\n    var isHexDigit6 = true\n    var isHexDigit7 = true\n    var isHexDigit8\
    \ = true\n    var isHexDigit9 = true\n    var isHexDigit0 = true\n    var isHexDigit1\
    \ = true\n    var isHexDigit2 = true\n    var isHexDigit3 = true\n    var isHexDigit4\
    \ = true\n    var isHexDigit5 = true\n    var isHexDigit6 = true\n    var isHexDigit7\
    \ = true\n    var isHexDigit8 = true\n    var isHexDigit9 = true\n    var isHexDigit0\
    \ = true\n    var isHexDigit1 = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp5f4ti1ki.swift:98:22: error: expected initial value after '='\n\
    \    var isHexDigit1 = \n                     ^\n/tmp/tmp5f4ti1ki.swift:39:9:\
    \ error: invalid redeclaration of 'isHexDigit2'\n    var isHexDigit2 = true\n\
    \        ^\n/tmp/tmp5f4ti1ki.swift:29:9: note: 'isHexDigit2' previously declared\
    \ here\n    var isHexDigit2 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:40:9: error:\
    \ invalid redeclaration of 'isHexDigit3'\n    var isHexDigit3 = true\n       \
    \ ^\n/tmp/tmp5f4ti1ki.swift:30:9: note: 'isHexDigit3' previously declared here\n\
    \    var isHexDigit3 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:41:9: error: invalid\
    \ redeclaration of 'isHexDigit4'\n    var isHexDigit4 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:31:9:\
    \ note: 'isHexDigit4' previously declared here\n    var isHexDigit4 = true\n \
    \       ^\n/tmp/tmp5f4ti1ki.swift:42:9: error: invalid redeclaration of 'isHexDigit5'\n\
    \    var isHexDigit5 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:32:9: note: 'isHexDigit5'\
    \ previously declared here\n    var isHexDigit5 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:43:9:\
    \ error: invalid redeclaration of 'isHexDigit6'\n    var isHexDigit6 = true\n\
    \        ^\n/tmp/tmp5f4ti1ki.swift:33:9: note: 'isHexDigit6' previously declared\
    \ here\n    var isHexDigit6 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:44:9: error:\
    \ invalid redeclaration of 'isHexDigit7'\n    var isHexDigit7 = true\n       \
    \ ^\n/tmp/tmp5f4ti1ki.swift:34:9: note: 'isHexDigit7' previously declared here\n\
    \    var isHexDigit7 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:45:9: error: invalid\
    \ redeclaration of 'isHexDigit8'\n    var isHexDigit8 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:35:9:\
    \ note: 'isHexDigit8' previously declared here\n    var isHexDigit8 = true\n \
    \       ^\n/tmp/tmp5f4ti1ki.swift:46:9: error: invalid redeclaration of 'isHexDigit9'\n\
    \    var isHexDigit9 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:36:9: note: 'isHexDigit9'\
    \ previously declared here\n    var isHexDigit9 = true\n        ^\n/tmp/tmp5f4ti1ki.swift:47:9:\
    \ error: invalid redeclaration of 'isHexDigit0'\n    var isHexDigit0 = true\n\
    \        ^\n/tmp/tmp5f4ti1ki.swift:37:9: note: '"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    var digits\
    \ = num.characters\n    for i in 0..<digits.count {\n        let digit = Int(digits[i])\n\
    \        if digit == 0 || digit == 1 {\n            continue\n        }\n    \
    \    if digit % 2 == 0 {\n            sum += digit\n        }\n        else {\n\
    \            sum += digit * 3\n        }\n    }\n    return sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpezp0ip0r.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpezp0ip0r.swift:27:31:\
    \ error: no exact matches in call to subscript \n        let digit = Int(digits[i])\n\
    \                              ^\nSwift.String:3:12: note: candidate expects value\
    \ of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  var numString = num\n    var numStringArray: [String] = numString.characters\n\
    \    var numStringArrayLength = numStringArray.count\n    var numStringArrayIndex\
    \ = 0\n    var hexString = \"\"\n    var hexStringArray: [String] = hexString.characters\n\
    \    var hexStringArrayLength = hexStringArray.count\n    var hexStringArrayIndex\
    \ = 0\n    var hexStringArrayIndex2 = 0\n    var hexStringArrayIndex3 = 0\n  \
    \  var hexStringArrayIndex4 = 0\n    var hexStringArrayIndex5 = 0\n    var hexStringArrayIndex6\
    \ = 0\n    var hexStringArrayIndex7 = 0\n    var hexStringArrayIndex8 = 0\n  \
    \  var hexStringArrayIndex9 = 0\n    var hexStringArrayIndex10 = 0\n    var hexStringArrayIndex11\
    \ = 0\n    var hexStringArrayIndex12 = 0\n    var hexStringArrayIndex13 = 0\n\
    \    var hexStringArrayIndex14 = 0\n    var hexStringArrayIndex15 = 0\n    var\
    \ hexStringArrayIndex16 = 0\n    var hexStringArrayIndex17 = 0\n    var hexStringArrayIndex18\
    \ = 0\n    var hexStringArrayIndex19 = 0\n    var hexStringArrayIndex20 = 0\n\
    \    var hexStringArrayIndex21 = 0\n    var hexStringArrayIndex22 = 0\n    var\
    \ hexStringArrayIndex23 = 0\n    var hexStringArrayIndex24 = 0\n    var hexStringArrayIndex25\
    \ = 0\n    var hexStringArrayIndex26 = 0\n    var hexStringArrayIndex27 = 0\n\
    \    var hexStringArrayIndex28 = 0\n    var hexStringArrayIndex29 = 0\n    var\
    \ hexStringArrayIndex30 = 0\n    var hexStringArrayIndex31 = 0\n    var hexStringArrayIndex32\
    \ = 0\n    var hexStringArrayIndex33 = 0\n    var hexStringArrayIndex34 = 0\n\
    \    var hexStringArrayIndex35 = 0\n    var hexStringArrayIndex36 = 0\n    var\
    \ hexStringArrayIndex37 = 0\n    var hexStringArrayIndex38 = 0\n    var hexStringArrayIndex39\
    \ = 0\n    var hexStringArrayIndex40 = 0\n    var hexStringArrayIndex41 = 0\n\
    \    var hexStringArrayIndex42 = 0\n    var hexStringArrayIndex43 = 0\n    var\
    \ hexStringArrayIndex44 = 0\n    var hexStringArrayIndex45 = 0\n    var hexStringArrayIndex46\
    \ = 0\n    var hexStringArrayIndex47 = 0\n    var hexStringArrayIndex48 = 0\n\
    \    var hexStringArrayIndex49 = 0\n    var hexStringArrayIndex50 = 0\n    var\
    \ hexStringArrayIndex51 = 0\n    var hexStringArrayIndex52 = 0\n    var hexStringArrayIndex53\
    \ = 0\n    var hexStringArrayIndex54 = 0\n    var hexStringArrayIndex55 = 0\n\
    \    var hexStringArrayIndex56 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpmylav9m9.swift:88:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpmylav9m9.swift:26:46: error: cannot convert value of type 'String'\
    \ to specified type '[String]'\n    var numStringArray: [String] = numString.characters\n\
    \                                   ~~~~~~~~~~^~~~~~~~~~\n/tmp/tmpmylav9m9.swift:30:46:\
    \ error: cannot convert value of type 'String' to specified type '[String]'\n\
    \    var hexStringArray: [String] = hexString.characters\n                   \
    \                ~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = [UInt8](repeating:\
    \ 0, count: 16)\n    var digits = [UInt8](repeating: 0, count: 16)\n    var numDigits\
    \ = num.count\n    var numHexDigits = numDigits.toHexString().count\n    var numHexChars\
    \ = numHexDigits.toHexString().count\n    var numHexCharsRemaining = numHexChars\n\
    \    var hexDigitIndex = 0\n    var hexCharIndex = 0\n    var hexChar = UInt8(0)\n\
    \    var hexCharRemaining = UInt8(0)\n    var hexDigit = UInt8(0)\n    var hexDigitRemaining\
    \ = UInt8(0)\n    var primeCount = 0\n    var primeCountRemaining = UInt8(0)\n\
    \    var prime = UInt8(0)\n    var primeRemaining = UInt8(0)\n    var isPrime\
    \ = true\n    var isPrimeRemaining = true\n    var isPrime2 = true\n    var isPrime2Remaining\
    \ = true\n    var isPrime3 = true\n    var isPrime3Remaining = true\n    var isPrime4\
    \ = true\n    var isPrime4Remaining = true\n    var isPrime5 = true\n    var isPrime5Remaining\
    \ = true\n    var isPrime6 = true\n    var isPrime6Remaining = true\n    var isPrime7\
    \ = true\n    var isPrime7Remaining = true\n    var isPrime8 = true\n    var isPrime8Remaining\
    \ = true\n    var isPrime9 = true\n    var isPrime9Remaining = true\n    var isPrime10\
    \ = true\n    var isPrime10Remaining = true\n    var isPrime11 = true\n    var\
    \ isPrime11Remaining = true\n    var isPrime12 = true\n    var isPrime12Remaining\
    \ = true\n    var isPrime13 = true\n    var isPrime13Remaining = true\n    var\
    \ isPrime14 = true\n    var isPrime14Remaining = true\n    var isPrime15 = true\n\
    \    var isPrime15Remaining = true\n    var isPrime16 = true\n    var isPrime16Remaining\
    \ = true\n    var isPrime17 = true\n    var isPrime17Remaining = true\n    var\
    \ isPrime18 = true\n    var isPrime18Remaining = true\n    var isPrime19 = true\n\
    \    var isPrime19Remaining = true\n    var isPrime20 = true\n    var isPrime20Remaining\
    \ = true\n    var isPrime21 = true\n    var isPrime21Remaining = true\n    var\
    \ isPrime22 = true\n    var isPrime22Remaining = true\n    var isPrime23 = true\n\
    \    var isPrime23\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpk2y6r0t6.swift:27:34: error: value of type 'Int' has no member\
    \ 'toHexString'\n    var numHexDigits = numDigits.toHexString().count\n      \
    \                 ~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpk2y6r0t6.swift:85:9: error: type\
    \ annotation missing in pattern\n    var isPrime23\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for _ in 0..<nums.count\
    \ {\n        if nums[_] >= 'A' && nums[_] <= 'F' {\n            count += 1\n \
    \       }\n    }\n    for _ in 0..<nums.count {\n        if nums[_] >= '0' &&\
    \ nums[_] <= '9' {\n            if primes.contains(Int(nums[_])) {\n         \
    \       count += 1\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfnv3f3jf.swift:28:23: error: single-quoted string literal found,\
    \ use '\"'\n        if nums[_] >= 'A' && nums[_] <= 'F' {\n                  \
    \    ^~~\n                      \"A\"\n/tmp/tmpfnv3f3jf.swift:28:41: error: single-quoted\
    \ string literal found, use '\"'\n        if nums[_] >= 'A' && nums[_] <= 'F'\
    \ {\n                                        ^~~\n                           \
    \             \"F\"\n/tmp/tmpfnv3f3jf.swift:33:23: error: single-quoted string\
    \ literal found, use '\"'\n        if nums[_] >= '0' && nums[_] <= '9' {\n   \
    \                   ^~~\n                      \"0\"\n/tmp/tmpfnv3f3jf.swift:33:41:\
    \ error: single-quoted string literal found, use '\"'\n        if nums[_] >= '0'\
    \ && nums[_] <= '9' {\n                                        ^~~\n         \
    \                               \"9\"\n/tmp/tmpfnv3f3jf.swift:24:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    var nums = num.characters\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfnv3f3jf.swift:28:17: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        if nums[_] >= 'A' && nums[_] <= 'F'\
    \ {\n                ^\n/tmp/tmpfnv3f3jf.swift:33:17: error: '_' can only appear\
    \ in a pattern or on the left side of an assignment\n        if nums[_] >= '0'\
    \ && nums[_] <= '9' {\n                ^\n/tmp/tmpfnv3f3jf.swift:34:41: error:\
    \ '_' can only appear in a pattern or on the left side of an assignment\n    \
    \        if primes.contains(Int(nums[_])) {\n                                \
    \        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    var count = 0\n    for char in numAsString {\n        if char == \"a\" ||\
    \ char == \"b\" || char == \"c\" || char == \"d\" || char == \"e\" || char ==\
    \ \"f\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpg3z8o8ko/tmpg3z8o8ko.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ac8ba1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ac8898b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ac8898988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ac88977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg3z8o8ko                        0x000055e21b38b474 <unavailable> + 5236

    5    libc.so.6                          0x00002b4ac8d8d460 __libc_start_main +
    245

    6    tmpg3z8o8ko                        0x000055e21b38b0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\n\
    \        if char == \"A\" || char == \"B\" || char == \"C\" || char == \"D\" ||\
    \ char == \"E\" || char == \"F\" {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp63w5wa39.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp63w5wa39.swift:27:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = nums[index]\n              \
    \     ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp63w5wa39.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var prime = 0\n    var prime_found = false\n    var prime_found2\
    \ = false\n    var prime_found3 = false\n    var prime_found4 = false\n    var\
    \ prime_found5 = false\n    var prime_found6 = false\n    var prime_found7 = false\n\
    \    var prime_found8 = false\n    var prime_found9 = false\n    var prime_found10\
    \ = false\n    var prime_found11 = false\n    var prime_found12 = false\n    var\
    \ prime_found13 = false\n    var prime_found14 = false\n    var prime_found15\
    \ = false\n    var prime_found16 = false\n    var prime_found17 = false\n    var\
    \ prime_found18 = false\n    var prime_found19 = false\n    var prime_found20\
    \ = false\n    var prime_found21 = false\n    var prime_found22 = false\n    var\
    \ prime_found23 = false\n    var prime_found24 = false\n    var prime_found25\
    \ = false\n    var prime_found26 = false\n    var prime_found27 = false\n    var\
    \ prime_found28 = false\n    var prime_found29 = false\n    var prime_found30\
    \ = false\n    var prime_found31 = false\n    var prime_found32 = false\n    var\
    \ prime_found33 = false\n    var prime_found34 = false\n    var prime_found35\
    \ = false\n    var prime_found36 = false\n    var prime_found37 = false\n    var\
    \ prime_found38 = false\n    var prime_found39 = false\n    var prime_found40\
    \ = false\n    var prime_found41 = false\n    var prime_found42 = false\n    var\
    \ prime_found43 = false\n    var prime_found44 = false\n    var prime_found45\
    \ = false\n    var prime_found46 = false\n    var prime_found47 = false\n    var\
    \ prime_found48 = false\n    var prime_found49 = false\n    var prime_found50\
    \ = false\n    var prime_found51 = false\n    var prime_found52 = false\n    var\
    \ prime_found53 = false\n    var prime_found54 = false\n    var prime_found55\
    \ = false\n    var prime_found56 = false\n    var prime_found57 = false\n    var\
    \ prime_found58 = false\n    var prime_found59 = false\n    var prime_found60\
    \ = false\n    var prime_found61 = false\n    var prime_found62 = false\n    var\
    \ prime_found63 = false\n    var prime_found64 = false\n    var prime_found65\
    \ = false\n    var prime_found66 = false\n    var prime_found67 = false\n    var\
    \ prime_found68 = false\n    var prime_found69 = false\n    var prime_\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpdkj48xui.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdkj48xui.swift:96:9:\
    \ error: type annotation missing in pattern\n    var prime_\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        if digit == \"A\" || digit\
    \ == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"\
    F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpdxnnxpa1.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.characters.map\
    \ { String($0) }\n    var hexNumString = hexNum.joined()\n    var hexNumArray\
    \ = hexNumString.characters.map { String($0) }\n    var hexNumArrayString = hexNumArray.joined()\n\
    \    var hexNumArrayArray = hexNumArrayString.characters.map { String($0) }\n\
    \    var hexNumArrayArrayString = hexNumArrayArray.joined()\n    var hexNumArrayArrayArray\
    \ = hexNumArrayArrayString.characters.map { String($0) }\n    var hexNumArrayArrayArrayString\
    \ = hexNumArrayArrayArray.joined()\n    var hexNumArrayArrayArrayArray = hexNumArrayArrayArrayString.characters.map\
    \ { String($0) }\n    var hexNumArrayArrayArrayArrayString = hexNumArrayArrayArrayArray.joined()\n\
    \    var hexNumArrayArrayArrayArrayArray = hexNumArrayArrayArrayArrayString.characters.map\
    \ { String($0) }\n    var hexNumArrayArrayArrayArrayArrayString = hexNumArrayArrayArrayArrayArray.joined()\n\
    \    var hexNumArrayArrayArrayArrayArrayArray = hexNumArrayArrayArrayArrayArrayString.characters.map\
    \ { String($0) }\n    var hexNumArrayArrayArrayArrayArrayArrayString = hexNumArrayArrayArrayArrayArrayArray.joined()\n\
    \    var hexNumArrayArrayArrayArrayArrayArrayArray = hexNumArrayArrayArrayArrayArrayArrayString.characters.map\
    \ { String($0) }\n    var hexNumArrayArrayArrayArrayArrayArrayArrayString = hexNumArrayArrayArrayArrayArrayArrayArrayArray.joined()\n\
    \    var hexNumArrayArrayArrayArrayArrayArrayArrayArray = hexNumArrayArrayArrayArrayArrayArrayArrayArrayString.characters.map\
    \ { String($0) }\n    var hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayString\
    \ = hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayString.joined()\n\
    \    var hexNumArrayArrayArrayArrayArrayArrayArrayArrayArray = hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayString.characters.map\
    \ { String($0) }\n    var hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayString\
    \ = hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayString.joined()\n\
    \    var hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray =\
    \ hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayString.characters.map\
    \ { String($0) }\n    var hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayString\
    \ = hexNumArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayString.joined()\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_l3g26l6.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexNum = num.characters.map { String($0) }\n  \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_l3g26l6.swift:26:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexNumArray = hexNumString.characters.map { String($0)\
    \ }\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_l3g26l6.swift:28:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    var hexNumArrayArray = hexNumArrayString.characters.map\
    \ { String($0) }\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp_l3g26l6.swift:30:56: error: 'characters'\
    \ is unavailable: Please use String directly\n    var hexNumArrayArrayArray =\
    \ hexNumArrayArrayString.characters.map { String($0) }\n                     \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_l3g26l6.swift:32:66: error: 'characters' is unavailable:\
    \ Please use String directly\n    var hexNumArrayArrayArrayArray = hexNumArrayArrayArrayString.characters.map\
    \ { String($0) }\n                                                           \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_l3g26l6.swift:34:76:\
    \ error: 'characters' is unavailable: Please use String directly\n    var hexNumArrayArrayArrayArrayArray\
    \ = hexNumArrayArrayArrayArrayString.characters.map { String($0) }\n         \
    \                                                                  ^~~~~~~~~~\n\
    Swift.String"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.unicodeScalars.filter{\
    \ $0.isHexadecimal() }\n    if hexNum.count == 0 {\n        return 0\n    }\n\
    \    var primeNum = hexNum.count\n    var primeNum2 = primeNum\n    var primeNum3\
    \ = primeNum\n    var primeNum4 = primeNum\n    var primeNum5 = primeNum\n   \
    \ var primeNum6 = primeNum\n    var primeNum7 = primeNum\n    var primeNum8 =\
    \ primeNum\n    var primeNum9 = primeNum\n    var primeNum10 = primeNum\n    var\
    \ primeNum11 = primeNum\n    var primeNum12 = primeNum\n    var primeNum13 = primeNum\n\
    \    var primeNum14 = primeNum\n    var primeNum15 = primeNum\n    var primeNum16\
    \ = primeNum\n    var primeNum17 = primeNum\n    var primeNum18 = primeNum\n \
    \   var primeNum19 = primeNum\n    var primeNum20 = primeNum\n    var primeNum21\
    \ = primeNum\n    var primeNum22 = primeNum\n    var primeNum23 = primeNum\n \
    \   var primeNum24 = primeNum\n    var primeNum25 = primeNum\n    var primeNum26\
    \ = primeNum\n    var primeNum27 = primeNum\n    var primeNum28 = primeNum\n \
    \   var primeNum29 = primeNum\n    var primeNum30 = primeNum\n    var primeNum31\
    \ = primeNum\n    var primeNum32 = primeNum\n    var primeNum33 = primeNum\n \
    \   var primeNum34 = primeNum\n    var primeNum35 = primeNum\n    var primeNum36\
    \ = primeNum\n    var primeNum37 = primeNum\n    var primeNum38 = primeNum\n \
    \   var primeNum39 = primeNum\n    var primeNum40 = primeNum\n    var primeNum41\
    \ = primeNum\n    var primeNum42 = primeNum\n    var primeNum43 = primeNum\n \
    \   var primeNum44 = primeNum\n    var primeNum45 = primeNum\n    var primeNum46\
    \ = primeNum\n    var primeNum47 = primeNum\n    var primeNum48 = primeNum\n \
    \   var primeNum49 = primeNum\n    var primeNum50 = primeNum\n    var primeNum51\
    \ = primeNum\n    var primeNum52 = primeNum\n    var primeNum53 = primeNum\n \
    \   var primeNum54 = primeNum\n    var primeNum55 = primeNum\n    var primeNum56\
    \ = primeNum\n    var primeNum57 = primeNum\n    var primeNum58 = primeNum\n \
    \   var primeNum59 = primeNum\n    var primeNum60 = primeNum\n    var primeNum61\
    \ = primeNum\n    var primeNum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8r46zle4.swift:24:48: error: value of type 'Unicode.Scalar' has\
    \ no member 'isHexadecimal'\n    var hexNum = num.unicodeScalars.filter{ $0.isHexadecimal()\
    \ }\n                                            ~~ ^~~~~~~~~~~~~\n/tmp/tmp8r46zle4.swift:89:9:\
    \ error: type annotation missing in pattern\n    var primeNum\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    var prime = 0\n    var\
    \ prime_found = false\n    var prime_found2 = false\n    var prime_found3 = false\n\
    \    var prime_found4 = false\n    var prime_found5 = false\n    var prime_found6\
    \ = false\n    var prime_found7 = false\n    var prime_found8 = false\n    var\
    \ prime_found9 = false\n    var prime_found10 = false\n    var prime_found11 =\
    \ false\n    var prime_found12 = false\n    var prime_found13 = false\n    var\
    \ prime_found14 = false\n    var prime_found15 = false\n    var prime_found16\
    \ = false\n    var prime_found17 = false\n    var prime_found18 = false\n    var\
    \ prime_found19 = false\n    var prime_found20 = false\n    var prime_found21\
    \ = false\n    var prime_found22 = false\n    var prime_found23 = false\n    var\
    \ prime_found24 = false\n    var prime_found25 = false\n    var prime_found26\
    \ = false\n    var prime_found27 = false\n    var prime_found28 = false\n    var\
    \ prime_found29 = false\n    var prime_found30 = false\n    var prime_found31\
    \ = false\n    var prime_found32 = false\n    var prime_found33 = false\n    var\
    \ prime_found34 = false\n    var prime_found35 = false\n    var prime_found36\
    \ = false\n    var prime_found37 = false\n    var prime_found38 = false\n    var\
    \ prime_found39 = false\n    var prime_found40 = false\n    var prime_found41\
    \ = false\n    var prime_found42 = false\n    var prime_found43 = false\n    var\
    \ prime_found44 = false\n    var prime_found45 = false\n    var prime_found46\
    \ = false\n    var prime_found47 = false\n    var prime_found48 = false\n    var\
    \ prime_found49 = false\n    var prime_found50 = false\n    var prime_found51\
    \ = false\n    var prime_found52 = false\n    var prime_found53 = false\n    var\
    \ prime_found54 = false\n    var prime_found55 = false\n    var prime_found56\
    \ = false\n    var prime_found57 = false\n    var prime_found58 = false\n    var\
    \ prime_found59 = false\n    var prime_found60 = false\n    var prime_found61\
    \ = false\n    var prime_found62 = false\n    var prime_found63 = false\n    var\
    \ prime_found64 = false\n    var prime_found65 = false\n    var prime_found66\
    \ = false\n    var prime_found67 = false\n    var prime_found68 = false\n    var\
    \ prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpth76pnyg.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmpth76pnyg.swift:97:9: error:\
    \ type annotation missing in pattern\n    var prime\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexArray = hex.characters\n  \
    \  var count = 0\n    for char in hexArray {\n        let hexDigit = Int(char)\
    \ ?? 0\n        if hexDigit == hexDigit {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpnynvhqgq.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpnynvhqgq.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let hexDigits = digits.map { String($0, radix: 16) }\n    let hexDigitCount\
    \ = hexDigits.count\n    let hexDigitPrimes = hexDigits.filter { isPrime($0) }\n\
    \    let hexDigitPrimeCount = hexDigitPrimes.count\n    if hexDigitCount < hexDigitPrimeCount\
    \ {\n        return 0\n    }\n    return hexDigitPrimeCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp5kxzbg8w.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5kxzbg8w.swift:25:34:\
    \ error: initializer 'init(_:radix:uppercase:)' requires that 'String.Element'\
    \ (aka 'Character') conform to 'BinaryInteger'\n    let hexDigits = digits.map\
    \ { String($0, radix: 16) }\n                                 ^\nSwift.String:2:12:\
    \ note: where 'T' = 'String.Element' (aka 'Character')\n    public init<T>(_ value:\
    \ T, radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger\n     \
    \      ^\n/tmp/tmp5kxzbg8w.swift:27:45: error: cannot find 'isPrime' in scope\n\
    \    let hexDigitPrimes = hexDigits.filter { isPrime($0) }\n                 \
    \                           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    0x\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"0\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n    hex =\
    \ hex.stringByReplacingOccurrencesOfString(\"0x\", withString: \"\", options:\
    \ NSStringCompareOptions.LiteralSearch, range: nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \    hex = hex.stringByReplacingOccurrencesOfString(\"0x\", withString: \"\",\
    \ options: NSStringCompareOptions.LiteralSearch, range: nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \    hex = hex.stringByReplacingOccurrencesOfString(\"0x\", withString: \"\",\
    \ options: NSStringCompareOptions.LiteralSearch, range: nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \    hex = hex.stringByReplacingOccurrencesOfString(\"0x\", withString: \"\",\
    \ options: NSStringCompareOptions.LiteralSearch, range: nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \    hex = hex.stringByReplacingOccurrencesOfString(\"0x\", withString: \"\",\
    \ options: NSStringCompareOptions.LiteralSearch, range: nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \    hex = hex.stringByReplacingOccurrencesOfString(\"0x\", withString: \"\",\
    \ options: NSStringCompareOptions.LiteralSearch, range: nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \    hex = hex.stringByReplacingOccurrencesOfString(\"0x\", withString: \"\",\
    \ options: NSStringCompareOptions.LiteralSearch, range: nil)\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpgv_reey6.swift:24:87: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n    var hex = num.stringByReplacingOccurrencesOfString(\"0x\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n         \
    \                                                                            \
    \ ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgv_reey6.swift:24:19: error: value of type 'String'\
    \ has no member 'stringByReplacingOccurrencesOfString'\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    0x\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n              ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgv_reey6.swift:24:132:\
    \ error: 'nil' requires a contextual type\n    var hex = num.stringByReplacingOccurrencesOfString(\"\
    0x\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n                                                                     \
    \                                                              ^\n/tmp/tmpgv_reey6.swift:25:82:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \                                                                            \
    \     ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgv_reey6.swift:25:127: error: 'nil' requires\
    \ a contextual type\n    hex = hex.stringByReplacingOccurrencesOfString(\"0\"\
    , withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \                                                                            \
    \                                                  ^\n/tmp/tmpgv_reey6.swift:26:83:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n    hex = hex.stringByReplacingOccurrencesOfString(\"\
    0x\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n                                                                     \
    \             ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgv_reey6.swift:26:128: error: 'nil'\
    \ requires a contextual type\n    hex = hex.stringByReplacingOccurr"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num\n    var\
    \ count = 0\n    for char in hex {\n        switch char {\n        case \"A\"\
    : hex = \"0\"; break\n        case \"B\": hex = \"1\"; break\n        case \"\
    C\": hex = \"2\"; break\n        case \"D\": hex = \"3\"; break\n        case\
    \ \"E\": hex = \"4\"; break\n        case \"F\": hex = \"5\"; break\n        case\
    \ \"0\": hex = \"6\"; break\n        case \"1\": hex = \"7\"; break\n        case\
    \ \"2\": hex = \"8\"; break\n        case \"3\": hex = \"9\"; break\n        case\
    \ \"5\": hex = \"A\"; break\n        case \"7\": hex = \"B\"; break\n        case\
    \ \"9\": hex = \"C\"; break\n        case \"A\": hex = \"D\"; break\n        case\
    \ \"B\": hex = \"E\"; break\n        case \"C\": hex = \"F\"; break\n        default:\
    \ break\n        }\n    }\n    for char in hex {\n        switch char {\n    \
    \    case \"2\": count++; break\n        case \"3\": count++; break\n        case\
    \ \"5\": count++; break\n        case \"7\": count++; break\n        case \"B\"\
    : count++; break\n        case \"D\": count++; break\n        case \"E\": count++;\
    \ break\n        case \"F\": count++; break\n        default: break\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfm4qqqgq.swift:41:14: warning: literal value is already handled\
    \ by previous pattern; consider removing it\n        case \"A\": hex = \"D\";\
    \ break\n             ^~~\n/tmp/tmpfm4qqqgq.swift:28:14: note: first occurrence\
    \ of identical literal pattern is here\n        case \"A\": hex = \"0\"; break\n\
    \             ^~~\n/tmp/tmpfm4qqqgq.swift:42:14: warning: literal value is already\
    \ handled by previous pattern; consider removing it\n        case \"B\": hex =\
    \ \"E\"; break\n             ^~~\n/tmp/tmpfm4qqqgq.swift:29:14: note: first occurrence\
    \ of identical literal pattern is here\n        case \"B\": hex = \"1\"; break\n\
    \             ^~~\n/tmp/tmpfm4qqqgq.swift:43:14: warning: literal value is already\
    \ handled by previous pattern; consider removing it\n        case \"C\": hex =\
    \ \"F\"; break\n             ^~~\n/tmp/tmpfm4qqqgq.swift:30:14: note: first occurrence\
    \ of identical literal pattern is here\n        case \"C\": hex = \"2\"; break\n\
    \             ^~~\n/tmp/tmpfm4qqqgq.swift:49:24: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n        case \"2\": count++; break\n       \
    \                ^~\n/tmp/tmpfm4qqqgq.swift:50:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"3\": count++; break\n  \
    \                     ^~\n/tmp/tmpfm4qqqgq.swift:51:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"5\": count++; break\n  \
    \                     ^~\n/tmp/tmpfm4qqqgq.swift:52:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"7\": count++; break\n  \
    \                     ^~\n/tmp/tmpfm4qqqgq.swift:53:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"B\": count++; break\n  \
    \                     ^~\n/tmp/tmpfm4qqqgq.swift:54:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"D\": count++; break\n  \
    \                     ^~\n/tmp/tmpfm4qqqgq.swift:55:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"E\": count++; break\n  \
    \                     ^~\n/tmp/tmpfm4qqqgq.swift:56:24: error: cannot find oper"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted) else {\n        return 0\n    }\n    var\
    \ count = 0\n    var prime = 2 // prime number\n    var isPrime = true\n    var\
    \ isPrime2 = true\n    var isPrime3 = true\n    var isPrime4 = true\n    var isPrime5\
    \ = true\n    var isPrime6 = true\n    var isPrime7 = true\n    var isPrime8 =\
    \ true\n    var isPrime9 = true\n    var isPrime10 = true\n    var isPrime11 =\
    \ true\n    var isPrime12 = true\n    var isPrime13 = true\n    var isPrime14\
    \ = true\n    var isPrime15 = true\n    var isPrime16 = true\n    var isPrime17\
    \ = true\n    var isPrime18 = true\n    var isPrime19 = true\n    var isPrime20\
    \ = true\n    var isPrime21 = true\n    var isPrime22 = true\n    var isPrime23\
    \ = true\n    var isPrime24 = true\n    var isPrime25 = true\n    var isPrime26\
    \ = true\n    var isPrime27 = true\n    var isPrime28 = true\n    var isPrime29\
    \ = true\n    var isPrime30 = true\n    var isPrime31 = true\n    var isPrime32\
    \ = true\n    var isPrime33 = true\n    var isPrime34 = true\n    var isPrime35\
    \ = true\n    var isPrime36 = true\n    var isPrime37 = true\n    var isPrime38\
    \ = true\n    var isPrime39 = true\n    var isPrime40 = true\n    var isPrime41\
    \ = true\n    var isPrime42 = true\n    var isPrime43 = true\n    var isPrime44\
    \ = true\n    var isPrime45 = true\n    var isPrime46 = true\n    var isPrime47\
    \ = true\n    var isPrime48 = true\n    var isPrime49 = true\n    var isPrime50\
    \ = true\n    var isPrime51 = true\n    var isPrime52 = true\n    var isPrime53\
    \ = true\n    var isPrime54 = true\n    var isPrime55 = true\n    var isPrime56\
    \ = true\n    var isPrime57 = true\n    var isPrime58 = true\n    var isPrime59\
    \ = true\n    var isPrime60 = true\n    var isPrime61 = true\n    var isPrime62\
    \ = true\n    var isPrime63 = true\n    var isPrime64 = true\n    var isPrime65\
    \ = true\n    var isPrime66 = true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphcrvcy35.swift:24:48: error: cannot find 'CharacterSet' in scope\n\
    \    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\
    \ else {\n                                               ^~~~~~~~~~~~\n/tmp/tmphcrvcy35.swift:24:25:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    guard\
    \ let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) else\
    \ {\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit\
    \ == \"F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxfqn6bhi.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxfqn6bhi.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.uppercaseCharacterSet())\n\
    \    var hexDigits: [Int] = []\n    for char in hex {\n        let digit = Int(char,\
    \ radix: 16)\n        hexDigits.append(digit)\n    }\n    var primeCount = 0\n\
    \    for digit in hexDigits {\n        if digit % 2 == 0 {\n            primeCount\
    \ += 1\n        }\n    }\n    return primeCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp__le5ky5.swift:24:51: error: cannot find 'NSCharacterSet' in scope\n\
    \    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.uppercaseCharacterSet())\n\
    \                                                  ^~~~~~~~~~~~~~\n/tmp/tmp__le5ky5.swift:24:19:\
    \ error: value of type 'String' has no member 'stringByTrimmingCharactersInSet'\n\
    \    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.uppercaseCharacterSet())\n\
    \              ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    var primesLen =\
    \ primes.count\n    var primesLen2 = primesLen * primesLen\n    var primesLen3\
    \ = primesLen2 * primesLen\n    var primesLen4 = primesLen3 * primesLen\n    var\
    \ primesLen5 = primesLen4 * primesLen\n    var primesLen6 = primesLen5 * primesLen\n\
    \    var primesLen7 = primesLen6 * primesLen\n    var primesLen8 = primesLen7\
    \ * primesLen\n    var primesLen9 = primesLen8 * primesLen\n    var primesLen10\
    \ = primesLen9 * primesLen\n    var primesLen11 = primesLen10 * primesLen\n  \
    \  var primesLen12 = primesLen11 * primesLen\n    var primesLen13 = primesLen12\
    \ * primesLen\n    var primesLen14 = primesLen13 * primesLen\n    var primesLen15\
    \ = primesLen14 * primesLen\n    var primesLen16 = primesLen15 * primesLen\n \
    \   var primesLen17 = primesLen16 * primesLen\n    var primesLen18 = primesLen17\
    \ * primesLen\n    var primesLen19 = primesLen18 * primesLen\n    var primesLen20\
    \ = primesLen19 * primesLen\n    var primesLen21 = primesLen20 * primesLen\n \
    \   var primesLen22 = primesLen21 * primesLen\n    var primesLen23 = primesLen22\
    \ * primesLen\n    var primesLen24 = primesLen23 * primesLen\n    var primesLen25\
    \ = primesLen24 * primesLen\n    var primesLen26 = primesLen25 * primesLen\n \
    \   var primesLen27 = primesLen26 * primesLen\n    var primesLen28 = primesLen27\
    \ * primesLen\n    var primesLen29 = primesLen28 * primesLen\n    var primesLen30\
    \ = primesLen29 * primesLen\n    var primesLen31 = primesLen30 * primesLen\n \
    \   var primesLen32 = primesLen31 * primesLen\n    var primesLen33 = primesLen32\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpimf15uj1.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpimf15uj1.swift:24:9:\
    \ warning: initialization of variable 'nums' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums = num.characters\n    ~~~~^~~~\n\
    \    _\n/tmp/tmpimf15uj1.swift:25:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpimf15uj1.swift:26:9: warning:\
    \ variable 'primes' was never mutated; consider changing to 'let' constant\n \
    \   var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    ~~~ ^\n    let\n/tmp/tmpimf15uj1.swift:27:9:\
    \ warning: variable 'primesLen' was never mutated; consider changing to 'let'\
    \ constant\n    var primesLen = primes.count\n    ~~~ ^\n    let\n/tmp/tmpimf15uj1.swift:28:9:\
    \ warning: variable 'primesLen2' was never mutated; consider changing to 'let'\
    \ constant\n    var primesLen2 = primesLen * primesLen\n    ~~~ ^\n    let\n/tmp/tmpimf15uj1.swift:29:9:\
    \ warning: variable 'primesLen3' was never mutated; consider changing to 'let'\
    \ constant\n    var primesLen3 = primesLen2 * primesLen\n    ~~~ ^\n    let\n\
    /tmp/tmpimf15uj1.swift:30:9: warning: variable 'primesLen4' was never mutated;\
    \ consider changing to 'let' constant\n    var primesLen4 = primesLen3 * primesLen\n\
    \    ~~~ ^\n    let\n/tmp/tmpimf15uj1.swift:31:9: warning: variable 'primesLen5'\
    \ was never mutated; consider changing to 'let' constant\n    var primesLen5 =\
    \ primesLen4 * primesLen\n    ~~~ ^\n    let\n/tmp/tmpimf15uj1.swift:32:9: warning:\
    \ variable 'primesLen6' was never mutated; consider changing to 'let' constant\n\
    \    var primesLen6 = primesLen5 * primesLen\n    ~~~ ^\n    let\n/tmp/tmpimf15uj1.swift:33:9:\
    \ warning: variable 'primesLen7' was never mutated; consider changing "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let nums = num.characters\n\
    \    let numsCount = nums.count\n    var hexDigits = [String]()\n    var hexDigitCount\
    \ = 0\n    var hexDigitCount2 = 0\n    var hexDigitCount3 = 0\n    var hexDigitCount4\
    \ = 0\n    var hexDigitCount5 = 0\n    var hexDigitCount6 = 0\n    var hexDigitCount7\
    \ = 0\n    var hexDigitCount8 = 0\n    var hexDigitCount9 = 0\n    var hexDigitCount10\
    \ = 0\n    var hexDigitCount11 = 0\n    var hexDigitCount12 = 0\n    var hexDigitCount13\
    \ = 0\n    var hexDigitCount14 = 0\n    var hexDigitCount15 = 0\n    var hexDigitCount16\
    \ = 0\n    var hexDigitCount17 = 0\n    var hexDigitCount18 = 0\n    var hexDigitCount19\
    \ = 0\n    var hexDigitCount20 = 0\n    var hexDigitCount21 = 0\n    var hexDigitCount22\
    \ = 0\n    var hexDigitCount23 = 0\n    var hexDigitCount24 = 0\n    var hexDigitCount25\
    \ = 0\n    var hexDigitCount26 = 0\n    var hexDigitCount27 = 0\n    var hexDigitCount28\
    \ = 0\n    var hexDigitCount29 = 0\n    var hexDigitCount30 = 0\n    var hexDigitCount31\
    \ = 0\n    var hexDigitCount32 = 0\n    var hexDigitCount33 = 0\n    var hexDigitCount34\
    \ = 0\n    var hexDigitCount35 = 0\n    var hexDigitCount36 = 0\n    var hexDigitCount37\
    \ = 0\n    var hexDigitCount38 = 0\n    var hexDigitCount39 = 0\n    var hexDigitCount40\
    \ = 0\n    var hexDigitCount41 = 0\n    var hexDigitCount42 = 0\n    var hexDigitCount43\
    \ = 0\n    var hexDigitCount44 = 0\n    var hexDigitCount45 = 0\n    var hexDigitCount46\
    \ = 0\n    var hexDigitCount47 = 0\n    var hexDigitCount48 = 0\n    var hexDigitCount49\
    \ = 0\n    var hexDigitCount50 = 0\n    var hexDigitCount51 = 0\n    var hexDigitCount52\
    \ = 0\n    var hexDigitCount53 = 0\n    var hexDigitCount54 = 0\n    var hexDigitCount55\
    \ = 0\n    var hexDigitCount56 = 0\n    var hexDigitCount57 = 0\n    var hexDigitCount58\
    \ = 0\n    var hexDigitCount59 = 0\n    var hexDigitCount60 = 0\n    var hexDigitCount61\
    \ = 0\n    var hexDigitCount62 = 0\n    var hexDigitCount63 = 0\n    var hexDigitCount64\
    \ = 0\n    var hexDigitCount65 = 0\n    var hexDigitCount66 = 0\n    var hexDigitCount67\
    \ = 0\n    var hexDigitCount68 = 0\n    var hexDigitCount69 = 0\n    var hexDigitCount70\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp34ezl514.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp34ezl514.swift:25:9:\
    \ warning: initialization of immutable value 'numsCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    let numsCount = nums.count\n\
    \    ~~~~^~~~~~~~~\n    _\n/tmp/tmp34ezl514.swift:26:9: warning: initialization\
    \ of variable 'hexDigits' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var hexDigits = [String]()\n    ~~~~^~~~~~~~~\n    _\n\
    /tmp/tmp34ezl514.swift:27:9: warning: initialization of variable 'hexDigitCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp34ezl514.swift:28:9:\
    \ warning: initialization of variable 'hexDigitCount2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount2 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp34ezl514.swift:29:9: warning: initialization\
    \ of variable 'hexDigitCount3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount3 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp34ezl514.swift:30:9: warning: initialization of variable 'hexDigitCount4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount4 = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp34ezl514.swift:31:9:\
    \ warning: initialization of variable 'hexDigitCount5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount5 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp34ezl514.swift:32:9: warning: initialization\
    \ of variable 'hexDigitCount6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount6 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp34ezl514.swift:33:9: warning: initialization of variable 'hexDigitCount7'\
    \ was n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters.map\
    \ { String($0) }\n    hex = hex.filter{ $0.isHexadecimal() }\n    hex = hex.filter{\
    \ $0.isUppercase() }\n    hex = hex.filter{ $0.count > 1 }\n    hex = hex.filter{\
    \ $0.count <= hex.count }\n    return hex.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmppyk3rzh5.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters.map { String($0) }\n     \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmppyk3rzh5.swift:25:26: error: value of type 'String' has no member\
    \ 'isHexadecimal'\n    hex = hex.filter{ $0.isHexadecimal() }\n              \
    \        ~~ ^~~~~~~~~~~~~\n/tmp/tmppyk3rzh5.swift:26:26: error: value of type\
    \ 'String' has no member 'isUppercase'\n    hex = hex.filter{ $0.isUppercase()\
    \ }\n                      ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var prime = 0\n    var prime_count = 0\n    var digit_count = 0\n    for\
    \ digit in digits {\n        if digit == \"A\" {\n            digit_count += 1\n\
    \        }\n        if digit == \"B\" {\n            digit_count += 1\n      \
    \  }\n        if digit == \"C\" {\n            digit_count += 1\n        }\n \
    \       if digit == \"D\" {\n            digit_count += 1\n        }\n       \
    \ if digit == \"E\" {\n            digit_count += 1\n        }\n        if digit\
    \ == \"F\" {\n            digit_count += 1\n        }\n    }\n    if digit_count\
    \ == 0 {\n        return 0\n    }\n    if digit_count == 1 {\n        if digit_count\
    \ == 2 {\n            if digit_count == 3 {\n                if digit_count ==\
    \ 5 {\n                    if digit_count == 7 {\n                        if digit_count\
    \ == 11 {\n                            if digit_count == 13 {\n              \
    \                  if digit_count == 17 {\n                                  \
    \  if digit_count == 19 {\n                                        if digit_count\
    \ == 21 {\n                                            if digit_count == 25 {\n\
    \                                                if digit_count == 29 {\n    \
    \                                                if digit_count == 31 {\n    \
    \                                                    if digit_count == 37 {\n\
    \                                                            if digit_count ==\
    \ 41 {\n                                                                if digit_count\
    \ == 47 {\n                                                    if digit_count\
    \ == 53 {\n                                                        if digit_count\
    \ == 59 {\n                                                            if digit_count\
    \ == 63 {\n                                                                if\
    \ digit_count == 67 {\n                                                    if\
    \ digit_count == 71 {\n                                                      \
    \  if digit_count == 79 {\n                                                  \
    \          if digit_count == 83 {\n                                          \
    \                      if digit_count == 89 {\n                              \
    \                      if digit_count == 97 {\n                              \
    \                          if digit_count == 101 {\n                         \
    \                                   if digit_count == 107 {\n                \
    \                                                if digit_count == 113 {\n   \
    \                                                                 if digit_count\
    \ == 119 {\n                                                                 \
    \       if digit_count == 123 {\n                                            \
    \                                if digit_count == 127 {\n                   \
    \                                                             if digit_count ==\
    \ 131 {\n                                                                    \
    \                if digit_count == 137 {\n                                   \
    \                                                     if digit_count == 143 {\n\
    \                                                                            \
    \                if digit_count == 149 {\n                                   \
    \                                                             if digit_count ==\
    \ 153 {\n                                                                    \
    \                                if digit_count == 159 {\n                   \
    \                                                                            \
    \         if digit_count == 163 {\n                                          \
    \                                                                  if digit_count\
    \ == 167 {\n                                                                 \
    \                                               if digit_count == 171 {\n    \
    \                                                                            \
    \                                    if digit_count == 177 {\n               \
    \                                                                            \
    \                             if digit_count == 183 {\n                      \
    \                                                                            \
    \                          if digit_count == 189 {\n                         \
    \                                                                            \
    \                           if digit_count == 193 {\n                        \
    \                                                                            \
    \                                if digit_count == 197 {\n                   \
    \                                                                            \
    \                                         if digit_count == 201 {\n          \
    \                                                                            \
    \                                                      if digit_count == 207 {\n\
    \                                                                            \
    \                                                                    if digit_count\
    \ == 211 {\n                                                                 \
    \                                                                            \
    \       if digit_count == 215 {\n                                            \
    \                                                                            \
    \                                if digit_count == 219 {\n                   \
    \                                                                            \
    \                                                             if digit_count ==\
    \ 223 {\n                                                                    \
    \                                                                            \
    \                if digit_count == 227 {\n                                   \
    \                                                                            \
    \                                                     if digit_count == 231 {\n\
    \                                                                            \
    \                                                                            \
    \                if digit_count == 237 {\n                                   \
    \                                                                            \
    \                                                             if digit_count ==\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\n\
    assert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\n\
    assert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpekymunz9.swift:106:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpekymunz9.swift:126:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpekymunz9.swift:103:187:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                              if digit_count == 231 {\n     \
    \                                                                            \
    \                                                                            \
    \                             ^\n/tmp/tmpekymunz9.swift:126:63: error: expected\
    \ '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpekymunz9.swift:102:183:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                          if digit_count == 227 {\n         \
    \                                                                            \
    \                                                                            \
    \                     ^\n/tmp/tmpekymunz9.swift:126:63: error: expected '}' at\
    \ end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpekymunz9.swift:101:179:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                      if digit_count == 223 {\n             \
    \                                                                            \
    \                                                                            \
    \             ^\n/tmp/tmpekymunz9.swift:126:63: error: expected '}' at end of\
    \ bra"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexDigits = hex.count\n    var hexDigit = 0\n    var hexDigitCount =\
    \ 0\n    var hexDigitCount2 = 0\n    var hexDigitCount3 = 0\n    var hexDigitCount4\
    \ = 0\n    var hexDigitCount5 = 0\n    var hexDigitCount6 = 0\n    var hexDigitCount7\
    \ = 0\n    var hexDigitCount8 = 0\n    var hexDigitCount9 = 0\n    var hexDigitCount10\
    \ = 0\n    var hexDigitCount11 = 0\n    var hexDigitCount12 = 0\n    var hexDigitCount13\
    \ = 0\n    var hexDigitCount14 = 0\n    var hexDigitCount15 = 0\n    var hexDigitCount16\
    \ = 0\n    var hexDigitCount17 = 0\n    var hexDigitCount18 = 0\n    var hexDigitCount19\
    \ = 0\n    var hexDigitCount20 = 0\n    var hexDigitCount21 = 0\n    var hexDigitCount22\
    \ = 0\n    var hexDigitCount23 = 0\n    var hexDigitCount24 = 0\n    var hexDigitCount25\
    \ = 0\n    var hexDigitCount26 = 0\n    var hexDigitCount27 = 0\n    var hexDigitCount28\
    \ = 0\n    var hexDigitCount29 = 0\n    var hexDigitCount30 = 0\n    var hexDigitCount31\
    \ = 0\n    var hexDigitCount32 = 0\n    var hexDigitCount33 = 0\n    var hexDigitCount34\
    \ = 0\n    var hexDigitCount35 = 0\n    var hexDigitCount36 = 0\n    var hexDigitCount37\
    \ = 0\n    var hexDigitCount38 = 0\n    var hexDigitCount39 = 0\n    var hexDigitCount40\
    \ = 0\n    var hexDigitCount41 = 0\n    var hexDigitCount42 = 0\n    var hexDigitCount43\
    \ = 0\n    var hexDigitCount44 = 0\n    var hexDigitCount45 = 0\n    var hexDigitCount46\
    \ = 0\n    var hexDigitCount47 = 0\n    var hexDigitCount48 = 0\n    var hexDigitCount49\
    \ = 0\n    var hexDigitCount50 = 0\n    var hexDigitCount51 = 0\n    var hexDigitCount52\
    \ = 0\n    var hexDigitCount53 = 0\n    var hexDigitCount54 = 0\n    var hexDigitCount55\
    \ = 0\n    var hexDigitCount56 = 0\n    var hexDigitCount57 = 0\n    var hexDigitCount58\
    \ = 0\n    var hexDigitCount59 = 0\n    var hexDigitCount60 = 0\n    var hexDigitCount61\
    \ = 0\n    var hexDigitCount62 = 0\n    var hexDigitCount63 = 0\n    var hexDigitCount64\
    \ = 0\n    var hexDigitCount65 = 0\n    var hexDigitCount66 = 0\n    var hexDigitCount67\
    \ = 0\n    var hexDigitCount68 = 0\n    var hexDigitCount69 = 0\n    var hexDigitCount70\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp6c6wpln7.swift:97:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp6c6wpln7.swift:24:9: warning: variable 'hex' was never mutated; consider\
    \ changing to 'let' constant\n    var hex = num.unicodeScalars\n    ~~~ ^\n  \
    \  let\n/tmp/tmp6c6wpln7.swift:25:9: warning: initialization of variable 'hexDigits'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigits = hex.count\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:26:9:\
    \ warning: initialization of variable 'hexDigit' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var hexDigit = 0\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmp6c6wpln7.swift:27:9: warning: initialization of variable 'hexDigitCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:28:9:\
    \ warning: initialization of variable 'hexDigitCount2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount2 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:29:9: warning: initialization\
    \ of variable 'hexDigitCount3' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount3 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp6c6wpln7.swift:30:9: warning: initialization of variable 'hexDigitCount4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount4 = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:31:9:\
    \ warning: initialization of variable 'hexDigitCount5' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount5 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp6c6wpln7.swift:32:9: warning: initialization\
    \ of variable 'hexDigitCount6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount6 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp6c6wpln7.swift:33:9: warning: initialization of variable 'hexDigitCount7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \  "
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime(hexDigit: $0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    if hexDigitPrimeCount > hexDigitCount {\n        return hexDigitPrimeCount\n\
    \    } else {\n        return hexDigitCount\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbkvsedk9.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpbkvsedk9.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpbkvsedk9.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime(hexDigit:\
    \ $0) }\n                                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for i in 0..<nums.count\
    \ {\n        if nums[i] == 'A' || nums[i] == 'B' || nums[i] == 'C' || nums[i]\
    \ == 'D' || nums[i] == 'E' || nums[i] == 'F' {\n            count += 1\n     \
    \   }\n    }\n    for i in 0..<primes.count {\n        if nums.contains(String(primes[i]))\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpma5pthsd.swift:28:23: error: single-quoted string literal found,\
    \ use '\"'\n        if nums[i] == 'A' || nums[i] == 'B' || nums[i] == 'C' || nums[i]\
    \ == 'D' || nums[i] == 'E' || nums[i] == 'F' {\n                      ^~~\n  \
    \                    \"A\"\n/tmp/tmpma5pthsd.swift:28:41: error: single-quoted\
    \ string literal found, use '\"'\n        if nums[i] == 'A' || nums[i] == 'B'\
    \ || nums[i] == 'C' || nums[i] == 'D' || nums[i] == 'E' || nums[i] == 'F' {\n\
    \                                        ^~~\n                               \
    \         \"B\"\n/tmp/tmpma5pthsd.swift:28:59: error: single-quoted string literal\
    \ found, use '\"'\n        if nums[i] == 'A' || nums[i] == 'B' || nums[i] == 'C'\
    \ || nums[i] == 'D' || nums[i] == 'E' || nums[i] == 'F' {\n                  \
    \                                        ^~~\n                               \
    \                           \"C\"\n/tmp/tmpma5pthsd.swift:28:77: error: single-quoted\
    \ string literal found, use '\"'\n        if nums[i] == 'A' || nums[i] == 'B'\
    \ || nums[i] == 'C' || nums[i] == 'D' || nums[i] == 'E' || nums[i] == 'F' {\n\
    \                                                                            ^~~\n\
    \                                                                            \"\
    D\"\n/tmp/tmpma5pthsd.swift:28:95: error: single-quoted string literal found,\
    \ use '\"'\n        if nums[i] == 'A' || nums[i] == 'B' || nums[i] == 'C' || nums[i]\
    \ == 'D' || nums[i] == 'E' || nums[i] == 'F' {\n                             \
    \                                                                 ^~~\n      \
    \                                                                            \
    \            \"E\"\n/tmp/tmpma5pthsd.swift:28:113: error: single-quoted string\
    \ literal found, use '\"'\n        if nums[i] == 'A' || nums[i] == 'B' || nums[i]\
    \ == 'C' || nums[i] == 'D' || nums[i] == 'E' || nums[i] == 'F' {\n           \
    \                                                                            \
    \                         ^~~\n                                              \
    \                                                                  \"F\"\n/"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\
    \ as Character\n        if char == hexDigits.first {\n            count += 1\n\
    \        } else if char == hexDigits.second {\n            count += 1\n      \
    \  } else if char == hexDigits.third {\n            count += 1\n        } else\
    \ if char == hexDigits.fourth {\n            count += 1\n        } else if char\
    \ == hexDigits.fifth {\n            count += 1\n        } else if char == hexDigits.sixth\
    \ {\n            count += 1\n        } else if char == hexDigits.seventh {\n \
    \           count += 1\n        } else if char == hexDigits.eighth {\n       \
    \     count += 1\n        } else if char == hexDigits.ninth {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp60q_a6vr.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp60q_a6vr.swift:27:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = nums[index] as Character\n \
    \                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp60q_a6vr.swift:28:20: error: cannot find 'hexDigits'\
    \ in scope\n        if char == hexDigits.first {\n                   ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:30:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.second {\n                          ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:32:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.third {\n                          ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:34:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.fourth {\n                          ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:36:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.fifth {\n                          ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:38:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.sixth {\n                          ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:40:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.seventh {\n                          ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:42:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.eighth {\n                          ^~~~~~~~~\n\
    /tmp/tmp60q_a6vr.swift:44:27: error: cannot find 'hexDigits' in scope\n      \
    \  } else if char == hexDigits.ninth {\n                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsLen = nums.count\n    var primesLen = numsLen / 2\n    var primes\
    \ = [Int](repeating: 0, count: primesLen)\n    var primesLen2 = primes.count\n\
    \    var primes2 = [Int](repeating: 0, count: primesLen2)\n    var primesLen3\
    \ = primes2.count\n    var primes3 = [Int](repeating: 0, count: primesLen3)\n\
    \    var primesLen4 = primes3.count\n    var primes4 = [Int](repeating: 0, count:\
    \ primesLen4)\n    var primesLen5 = primes4.count\n    var primes5 = [Int](repeating:\
    \ 0, count: primesLen5)\n    var primesLen6 = primes5.count\n    var primes6 =\
    \ [Int](repeating: 0, count: primesLen6)\n    var primesLen7 = primes6.count\n\
    \    var primes7 = [Int](repeating: 0, count: primesLen7)\n    var primesLen8\
    \ = primes7.count\n    var primes8 = [Int](repeating: 0, count: primesLen8)\n\
    \    var primesLen9 = primes8.count\n    var primes9 = [Int](repeating: 0, count:\
    \ primesLen9)\n    var primesLen10 = primes9.count\n    var primes10 = [Int](repeating:\
    \ 0, count: primesLen10)\n    var primesLen11 = primes10.count\n    var primes11\
    \ = [Int](repeating: 0, count: primesLen11)\n    var primesLen12 = primes11.count\n\
    \    var primes12 = [Int](repeating: 0, count: primesLen12)\n    var primesLen13\
    \ = primes12.count\n    var primes13 = [Int](repeating: 0, count: primesLen13)\n\
    \    var primesLen14 = primes13.count\n    var primes14 = [Int](repeating: 0,\
    \ count: primesLen14)\n    var primesLen15 = primes14.count\n    var primes15\
    \ = [Int](repeating: 0, count: primesLen15)\n    var primesLen16 = primes15.count\n\
    \    var primes16 = [Int](repeating: 0, count: primesLen16)\n    var primesLen17\
    \ = primes16.count\n    var primes17 = [Int](repeating: 0, count: primesLen17)\n\
    \    var primesLen18 = primes17.count\n    var primes18 = [Int](repeating: 0,\
    \ count: primesLen18)\n    var primesLen19 = primes18.count\n    var primes19\
    \ = [Int](repeating: 0, count: primesLen19)\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpmh5j7cpg.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmh5j7cpg.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:25:9:\
    \ warning: variable 'numsLen' was never mutated; consider changing to 'let' constant\n\
    \    var numsLen = nums.count\n    ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:26:9:\
    \ warning: variable 'primesLen' was never mutated; consider changing to 'let'\
    \ constant\n    var primesLen = numsLen / 2\n    ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:27:9:\
    \ warning: variable 'primes' was never mutated; consider changing to 'let' constant\n\
    \    var primes = [Int](repeating: 0, count: primesLen)\n    ~~~ ^\n    let\n\
    /tmp/tmpmh5j7cpg.swift:28:9: warning: variable 'primesLen2' was never mutated;\
    \ consider changing to 'let' constant\n    var primesLen2 = primes.count\n   \
    \ ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:29:9: warning: variable 'primes2' was\
    \ never mutated; consider changing to 'let' constant\n    var primes2 = [Int](repeating:\
    \ 0, count: primesLen2)\n    ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:30:9: warning:\
    \ variable 'primesLen3' was never mutated; consider changing to 'let' constant\n\
    \    var primesLen3 = primes2.count\n    ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:31:9:\
    \ warning: variable 'primes3' was never mutated; consider changing to 'let' constant\n\
    \    var primes3 = [Int](repeating: 0, count: primesLen3)\n    ~~~ ^\n    let\n\
    /tmp/tmpmh5j7cpg.swift:32:9: warning: variable 'primesLen4' was never mutated;\
    \ consider changing to 'let' constant\n    var primesLen4 = primes3.count\n  \
    \  ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:33:9: warning: variable 'primes4' was\
    \ never mutated; consider changing to 'let' constant\n    var primes4 = [Int](repeating:\
    \ 0, count: primesLen4)\n    ~~~ ^\n    let\n/tmp/tmpmh5j7cpg.swift:34:9: warning:\
    \ v"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for _ in 0..<nums.count {\n        let digit = Int(nums[_],\
    \ radix: 16)\n        if digit == 0 || digit == 1 {\n            continue\n  \
    \      }\n        if digit % 2 == 0 {\n            result += 1\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpg_m_7rca.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpg_m_7rca.swift:27:30:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let digit = Int(nums[_], radix: 16)\n                             ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var primes = Array<Int>()\n    var prime_digits = Array<Int>()\n    var prime_digits_count\
    \ = Array<Int>()\n    var prime_digits_count_max = Array<Int>()\n    var prime_digits_count_min\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<Int>()\n    var prime_digits_count_min = Array<Int>()\n    var prime_digits_count_max\
    \ = Array<\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpaw_muul5.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpaw_muul5.swift:30:9:\
    \ error: invalid redeclaration of 'prime_digits_count_min'\n    var prime_digits_count_min\
    \ = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:29:9: note: 'prime_digits_count_min'\
    \ previously declared here\n    var prime_digits_count_min = Array<Int>()\n  \
    \      ^\n/tmp/tmpaw_muul5.swift:31:9: error: invalid redeclaration of 'prime_digits_count_max'\n\
    \    var prime_digits_count_max = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:28:9:\
    \ note: 'prime_digits_count_max' previously declared here\n    var prime_digits_count_max\
    \ = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:32:9: error: invalid redeclaration\
    \ of 'prime_digits_count_min'\n    var prime_digits_count_min = Array<Int>()\n\
    \        ^\n/tmp/tmpaw_muul5.swift:29:9: note: 'prime_digits_count_min' previously\
    \ declared here\n    var prime_digits_count_min = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:33:9:\
    \ error: invalid redeclaration of 'prime_digits_count_max'\n    var prime_digits_count_max\
    \ = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:28:9: note: 'prime_digits_count_max'\
    \ previously declared here\n    var prime_digits_count_max = Array<Int>()\n  \
    \      ^\n/tmp/tmpaw_muul5.swift:34:9: error: invalid redeclaration of 'prime_digits_count_min'\n\
    \    var prime_digits_count_min = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:29:9:\
    \ note: 'prime_digits_count_min' previously declared here\n    var prime_digits_count_min\
    \ = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:35:9: error: invalid redeclaration\
    \ of 'prime_digits_count_max'\n    var prime_digits_count_max = Array<Int>()\n\
    \        ^\n/tmp/tmpaw_muul5.swift:28:9: note: 'prime_digits_count_max' previously\
    \ declared here\n    var prime_digits_count_max = Array<Int>()\n        ^\n/tmp/tmpaw_muul5.swift:36:9:\
    \ error: invalid redeclaration of 'prime_d"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var prime = 0\n    var count = 0\n    for digit in digits {\n        switch\
    \ digit {\n        case \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"\
    , \"8\", \"9\":\n            prime = prime * 10 + Int(digit)!\n        case \"\
    A\", \"B\", \"C\", \"D\", \"E\", \"F\":\n            prime = prime * 10 + Int(digit)!\n\
    \        default:\n            count = count + 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxld8qi6s.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxld8qi6s.swift:30:38:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prime = prime * 10 + Int(digit)!\n                              \
    \       ^\n/tmp/tmpxld8qi6s.swift:32:38: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            prime = prime * 10 + Int(digit)!\n\
    \                                     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted) else {\n        return 0\n    }\n    var\
    \ count = 0\n    for char in num.unicodeScalars {\n        let hex = char.value\
    \ as UInt\n        if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n\
    \        if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n       \
    \ if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n        if hex\
    \ > 57 { continue }\n        if hex > 47 { hex -= 48 }\n        if hex > 57 {\
    \ continue }\n        if hex > 47 { hex -= 48 }\n        if hex > 57 { continue\
    \ }\n        if hex > 47 { hex -= 48 }\n        if hex > 57 { continue }\n   \
    \     if hex > 47 { hex -= 48 }\n        if hex > 57 { continue }\n        if\
    \ hex > 47 { hex -= 48 }\n        if hex > 57 { continue }\n        if hex > 47\
    \ { hex -= 48 }\n        if hex > 57 { continue }\n        if hex > 47 { hex -=\
    \ 48 }\n        if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n\
    \        if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n       \
    \ if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n        if hex\
    \ > 57 { continue }\n        if hex > 47 { hex -= 48 }\n        if hex > 57 {\
    \ continue }\n        if hex > 47 { hex -= 48 }\n        if hex > 57 { continue\
    \ }\n        if hex > 47 { hex -= 48 }\n        if hex > 57 { continue }\n   \
    \     if hex > 47 { hex -= 48 }\n        if hex > 57 { continue }\n        if\
    \ hex > 47 { hex -= 48 }\n        if hex > 57 { continue }\n        if hex > 47\
    \ { hex -= 48 }\n        if hex > 57 { continue }\n        if hex > 47 { hex -=\
    \ 48 }\n        if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n\
    \        if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n       \
    \ if hex > 57 { continue }\n        if hex > 47 { hex -= 48 }\n        if hex\
    \ > 57 \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp45dzhmwq.swift:76:20: error: expected '{' after 'if' condition\n\
    \        if hex > 57 \n                   ^\n/tmp/tmp45dzhmwq.swift:97:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmp45dzhmwq.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmp45dzhmwq.swift:24:48: error: cannot find\
    \ 'CharacterSet' in scope\n    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\
    \ else {\n                                               ^~~~~~~~~~~~\n/tmp/tmp45dzhmwq.swift:24:25:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    guard\
    \ let num = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) else\
    \ {\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp45dzhmwq.swift:80:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for index in 0..<digits.count {\n        let digit\
    \ = digits[index]\n        if digit == \"A\" {\n            result += 2\n    \
    \    } else if digit == \"B\" {\n            result += 3\n        } else if digit\
    \ == \"C\" {\n            result += 5\n        } else if digit == \"D\" {\n  \
    \          result += 7\n        } else if digit == \"E\" {\n            result\
    \ += 11\n        } else if digit == \"F\" {\n            result += 13\n      \
    \  } else {\n            result += digit.unicodeScalars.filter({$0.isUppercase}).count\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9a1m_0xy.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9a1m_0xy.swift:27:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let digit = digits[index]\n           \
    \         ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp9a1m_0xy.swift:41:55: error: value of type 'Unicode.Scalar'\
    \ has no member 'isUppercase'\n            result += digit.unicodeScalars.filter({$0.isUppercase}).count\n\
    \                                                   ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var primes = Set<Int>()\n    var prime: Int = 0\n    var primeCount = 0\n\
    \    for index in 0..<nums.count {\n        let digit = Int(nums[index])\n   \
    \     if digit < 48 || digit > 57 {\n            return -1\n        }\n      \
    \  if prime == 0 {\n            prime = digit\n        }\n        if prime % 2\
    \ == 0 {\n            primes.insert(prime)\n        }\n        if prime % 3 ==\
    \ 0 {\n            primes.insert(prime + 2)\n        }\n        if prime % 5 ==\
    \ 0 {\n            primes.insert(prime + 3)\n        }\n        if prime % 7 ==\
    \ 0 {\n            primes.insert(prime + 5)\n        }\n        if prime % 11\
    \ == 0 {\n            primes.insert(prime + 7)\n        }\n        if prime %\
    \ 13 == 0 {\n            primes.insert(prime + 11)\n        }\n        if prime\
    \ % 17 == 0 {\n            primes.insert(prime + 13)\n        }\n        if prime\
    \ % 19 == 0 {\n            primes.insert(prime + 17)\n        }\n        if prime\
    \ % 23 == 0 {\n            primes.insert(prime + 19)\n        }\n        if prime\
    \ % 29 == 0 {\n            primes.insert(prime + 23)\n        }\n        if prime\
    \ % 31 == 0 {\n            primes.insert(prime + 29)\n        }\n        if prime\
    \ % 37 == 0 {\n            primes.insert(prime + 31)\n        }\n        if prime\
    \ % 41 == 0 {\n            primes.insert(prime + 37)\n        }\n        if prime\
    \ % 43 == 0 {\n            primes.insert(prime + 41)\n        }\n        if prime\
    \ % 47 == 0 {\n            primes.insert(prime + 43)\n        }\n        if prime\
    \ % 53 == 0 {\n            primes.insert(prime + 47)\n        }\n        if prime\
    \ % 59 == 0 {\n            primes.insert(prime + 53)\n        }\n        if prime\
    \ % 61 == 0 {\n            primes.insert(prime + 59)\n        }\n        if prime\
    \ % 67 == 0 {\n            primes.insert(prime + 61)\n        }\n        if prime\
    \ % 71 == 0 {\n            primes.insert(prime + 67)\n        }\n        if prime\
    \ % 73 == 0 {\n            primes.insert(prime + 71)\n        }\n        if prime\
    \ % 79 == 0 {\n            primes.insert(prime + 73)\n        }\n        if prime\
    \ % 83 == 0 {\n            primes.insert(prime + 79)\n        }\n        if prime\
    \ % 89 == 0 {\n            primes.insert(prime + 83)\n        }\n        if prime\
    \ % 97 == 0 {\n            primes.insert(prime + 89)\n        }\n        if prime\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\n\
    assert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\n\
    assert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphy_buggl.swift:111:17: error: expected '{' after 'if' condition\n\
    \        if prime \n                ^\n/tmp/tmphy_buggl.swift:132:63: error: expected\
    \ '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmphy_buggl.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmphy_buggl.swift:24:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    var nums = num.characters\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphy_buggl.swift:29:29: error: no exact matches in call to subscript\
    \ \n        let digit = Int(nums[index])\n                            ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmphy_buggl.swift:111:12: error: type 'Int' cannot be used\
    \ as a boolean; test for '!= 0' instead\n        if prime \n           ^\n   \
    \        (     != 0)\n/tmp/tmphy_buggl.swift:115:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            count += 2\n        } else if digit == \"B\" {\n            count\
    \ += 1\n        } else if digit == \"C\" {\n            count += 3\n        }\
    \ else if digit == \"D\" {\n            count += 5\n        } else if digit ==\
    \ \"E\" {\n            count += 7\n        } else if digit == \"F\" {\n      \
    \      count += 11\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpw6wgufpl.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw6wgufpl.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { Int($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0 % 2 == 0 }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimePrimes = hexDigitPrimes.filter { $0 % 3 == 0 }\n    let\
    \ hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n    let hexDigitPrimePrimePrimes\
    \ = hexDigitPrimePrimes.filter { $0 % 5 == 0 }\n    let hexDigitPrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter\
    \ { $0 % 7 == 0 }\n    let hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter\
    \ { $0 % 11 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter\
    \ { $0 % 13 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimeCount =\
    \ hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter { $0 % 19 ==\
    \ 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpod8uxc1i.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpod8uxc1i.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpod8uxc1i.swift:39:51: error: cannot find\
    \ 'hexDigitPrimePrimePrimePrimePrimePrimePrimes' in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter { $0 % 17 == 0 }\n   \
    \                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpod8uxc1i.swift:40:60: error: use of local variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ before its declaration\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n                \
    \                                           ^\n/tmp/tmpod8uxc1i.swift:41:9: note:\
    \ 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes' declared here\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter { $0 % 19 ==\
    \ 0 }\n        ^\n/tmp/tmpod8uxc1i.swift:41:61: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 19 == 0 }\n                                                         \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var numAsString = \"\"\
    \n    for c in num {\n        if c.isUpper() {\n            numAsString += \"\
    A\"\n        } else {\n            numAsString += String(c)\n        }\n    }\n\
    \    var numAsInt = Int(numAsString)\n    var primesAsInt = 2\n    var primesAsString\
    \ = \"\"\n    for prime in primesAsInt...1000 {\n        if numAsInt == prime\
    \ {\n            primesAsString += String(prime)\n        }\n    }\n    if primesAsString.isEmpty\
    \ {\n        return 0\n    }\n    return primesAsString.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpg__o3hrd.swift:26:14: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if c.isUpper() {\n           ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexDigits = \"\"\n    var primeDigits = \"\"\n    var primeCount = 0\n\
    \    var primeCountDigits = 0\n    var primeCountHexDigits = 0\n    var primeCountHexDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimes = 0\n    var primeCountHexDigitPrimesDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPrimesDigitDigits = 0\n    var primeCountHexDigitPrimesDigitDigits\
    \ = 0\n    var primeCountHexDigitPri\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp4a7ki4_u.swift:34:9: error: invalid redeclaration of 'primeCountHexDigitPrimesDigitDigits'\n\
    \    var primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:33:9:\
    \ note: 'primeCountHexDigitPrimesDigitDigits' previously declared here\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:35:9:\
    \ error: invalid redeclaration of 'primeCountHexDigitPrimesDigitDigits'\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:33:9:\
    \ note: 'primeCountHexDigitPrimesDigitDigits' previously declared here\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:36:9:\
    \ error: invalid redeclaration of 'primeCountHexDigitPrimesDigitDigits'\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:33:9:\
    \ note: 'primeCountHexDigitPrimesDigitDigits' previously declared here\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:37:9:\
    \ error: invalid redeclaration of 'primeCountHexDigitPrimesDigitDigits'\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:33:9:\
    \ note: 'primeCountHexDigitPrimesDigitDigits' previously declared here\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:38:9:\
    \ error: invalid redeclaration of 'primeCountHexDigitPrimesDigitDigits'\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:33:9:\
    \ note: 'primeCountHexDigitPrimesDigitDigits' previously declared here\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:39:9:\
    \ error: invalid redeclaration of 'primeCountHexDigitPrimesDigitDigits'\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:33:9:\
    \ note: 'primeCountHexDigitPrimesDigitDigits' previously declared here\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki4_u.swift:40:9:\
    \ error: invalid redeclaration of 'primeCountHexDigitPrimesDigitDigits'\n    var\
    \ primeCountHexDigitPrimesDigitDigits = 0\n        ^\n/tmp/tmp4a7ki"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            count += 2\n        } else if digit == \"B\" {\n            count\
    \ += 1\n        } else if digit == \"C\" {\n            count += 3\n        }\
    \ else if digit == \"D\" {\n            count += 5\n        } else if digit ==\
    \ \"E\" {\n            count += 7\n        } else if digit == \"F\" {\n      \
    \      count += 11\n        } else {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpk8iwou48.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk8iwou48.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexArray = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexCount = hexArray.count\n    let hexDigits = hexArray.map\
    \ { Int($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0 % 2 == 0 }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimePrimes = hexDigitPrimes.filter { $0 % 3 == 0 }\n    let\
    \ hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n    let hexDigitPrimePrimePrimes\
    \ = hexDigitPrimePrimes.filter { $0 % 5 == 0 }\n    let hexDigitPrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimes.count\n    let hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter\
    \ { $0 % 7 == 0 }\n    let hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter\
    \ { $0 % 11 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 13 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n    let\
    \ hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8zclat_9.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp8zclat_9.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp8zclat_9.swift:39:51: error: use of local\
    \ variable 'hexDigitPrimePrimePrimePrimePrimePrimes' before its declaration\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 13 == 0 }\n                                                  ^\n/tmp/tmp8zclat_9.swift:39:9:\
    \ note: 'hexDigitPrimePrimePrimePrimePrimePrimes' declared here\n    let hexDigitPrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimes.filter { $0 % 13 == 0 }\n        ^\n\
    /tmp/tmp8zclat_9.swift:40:55: error: use of local variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimes'\
    \ before its declaration\n    let hexDigitPrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimes.count\n                     \
    \                                 ^\n/tmp/tmp8zclat_9.swift:41:9: note: 'hexDigitPrimePrimePrimePrimePrimePrimePrimes'\
    \ declared here\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter\
    \ { $0 % 17 == 0 }\n        ^\n/tmp/tmp8zclat_9.swift:41:56: error: cannot find\
    \ 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes' in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter { $0 % 17 ==\
    \ 0 }\n                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8zclat_9.swift:42:65: error: use of local variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ before its declaration\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePri"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums: [Int] = []\n\
    \    var num: Int = 0\n    for c in num {\n        if c >= '0' && c <= '9' {\n\
    \            num = num * 16 + Int(c - UInt('0'))\n        } else if c >= 'A' &&\
    \ c <= 'F' {\n            num = num * 16 + Int(c - UInt('A') + 10)\n        }\
    \ else if c >= 'a' && c <= 'f' {\n            num = num * 16 + Int(c - UInt('a')\
    \ + 10)\n        } else {\n            return -1\n        }\n        nums.append(num)\n\
    \    }\n    for num in nums {\n        if num == 2 {\n            return num\n\
    \        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp35vrxs91.swift:27:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmp35vrxs91.swift:27:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmp35vrxs91.swift:28:43: error:\
    \ single-quoted string literal found, use '\"'\n            num = num * 16 + Int(c\
    \ - UInt('0'))\n                                          ^~~\n              \
    \                            \"0\"\n/tmp/tmp35vrxs91.swift:29:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'A' && c <= 'F' {\n \
    \                      ^~~\n                       \"A\"\n/tmp/tmp35vrxs91.swift:29:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'A' && c <= 'F' {\n                                   ^~~\n                \
    \                   \"F\"\n/tmp/tmp35vrxs91.swift:30:43: error: single-quoted\
    \ string literal found, use '\"'\n            num = num * 16 + Int(c - UInt('A')\
    \ + 10)\n                                          ^~~\n                     \
    \                     \"A\"\n/tmp/tmp35vrxs91.swift:31:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'a' && c <= 'f' {\n \
    \                      ^~~\n                       \"a\"\n/tmp/tmp35vrxs91.swift:31:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'a' && c <= 'f' {\n                                   ^~~\n                \
    \                   \"f\"\n/tmp/tmp35vrxs91.swift:32:43: error: single-quoted\
    \ string literal found, use '\"'\n            num = num * 16 + Int(c - UInt('a')\
    \ + 10)\n                                          ^~~\n                     \
    \                     \"a\"\n/tmp/tmp35vrxs91.swift:26:14: error: for-in loop\
    \ requires 'Int' to conform to 'Sequence'\n    for c in num {\n             ^~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexDigits = [UInt8]()\n    var hexDigitsCount\
    \ = nums.count\n    var hexDigitsCount2 = hexDigitsCount\n    var hexDigitsCount3\
    \ = hexDigitsCount2\n    var hexDigitsCount4 = hexDigitsCount3\n    var hexDigitsCount5\
    \ = hexDigitsCount4\n    var hexDigitsCount6 = hexDigitsCount5\n    var hexDigitsCount7\
    \ = hexDigitsCount6\n    var hexDigitsCount8 = hexDigitsCount7\n    var hexDigitsCount9\
    \ = hexDigitsCount8\n    var hexDigitsCount10 = hexDigitsCount9\n    var hexDigitsCount11\
    \ = hexDigitsCount10\n    var hexDigitsCount12 = hexDigitsCount11\n    var hexDigitsCount13\
    \ = hexDigitsCount12\n    var hexDigitsCount14 = hexDigitsCount13\n    var hexDigitsCount15\
    \ = hexDigitsCount14\n    var hexDigitsCount16 = hexDigitsCount15\n    var hexDigitsCount17\
    \ = hexDigitsCount16\n    var hexDigitsCount18 = hexDigitsCount17\n    var hexDigitsCount19\
    \ = hexDigitsCount18\n    var hexDigitsCount20 = hexDigitsCount19\n    var hexDigitsCount21\
    \ = hexDigitsCount20\n    var hexDigitsCount22 = hexDigitsCount21\n    var hexDigitsCount23\
    \ = hexDigitsCount22\n    var hexDigitsCount24 = hexDigitsCount23\n    var hexDigitsCount25\
    \ = hexDigitsCount24\n    var hexDigitsCount26 = hexDigitsCount25\n    var hexDigitsCount27\
    \ = hexDigitsCount26\n    var hexDigitsCount28 = hexDigitsCount27\n    var hexDigitsCount29\
    \ = hexDigitsCount28\n    var hexDigitsCount30 = hexDigitsCount29\n    var hexDigitsCount31\
    \ = hexDigitsCount30\n    var hexDigitsCount32 = hexDigitsCount31\n    var hexDigitsCount33\
    \ = hexDigitsCount32\n    var hexDigitsCount34 = hexDigitsCount33\n    var hexDigitsCount35\
    \ = hexDigitsCount34\n    var hexDigitsCount36 = hexDigitsCount35\n    var hexDigitsCount37\
    \ = hexDigitsCount36\n    var hexDigitsCount38 = hexDigitsCount37\n    var hexDigitsCount39\
    \ = hexDigitsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpizbn_xni.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpizbn_xni.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:25:9:\
    \ warning: initialization of variable 'numsCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsCount = nums.count\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpizbn_xni.swift:26:9: warning: initialization of variable 'hexDigits'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigits = [UInt8]()\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpizbn_xni.swift:27:9:\
    \ warning: variable 'hexDigitsCount' was never mutated; consider changing to 'let'\
    \ constant\n    var hexDigitsCount = nums.count\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:28:9:\
    \ warning: variable 'hexDigitsCount2' was never mutated; consider changing to\
    \ 'let' constant\n    var hexDigitsCount2 = hexDigitsCount\n    ~~~ ^\n    let\n\
    /tmp/tmpizbn_xni.swift:29:9: warning: variable 'hexDigitsCount3' was never mutated;\
    \ consider changing to 'let' constant\n    var hexDigitsCount3 = hexDigitsCount2\n\
    \    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:30:9: warning: variable 'hexDigitsCount4'\
    \ was never mutated; consider changing to 'let' constant\n    var hexDigitsCount4\
    \ = hexDigitsCount3\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:31:9: warning:\
    \ variable 'hexDigitsCount5' was never mutated; consider changing to 'let' constant\n\
    \    var hexDigitsCount5 = hexDigitsCount4\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:32:9:\
    \ warning: variable 'hexDigitsCount6' was never mutated; consider changing to\
    \ 'let' constant\n    var hexDigitsCount6 = hexDigitsCount5\n    ~~~ ^\n    let\n\
    /tmp/tmpizbn_xni.swift:33:9: warning: variable 'hexDigitsCount7' was never mutated;\
    \ consider changing to 'let' constant\n    var h"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased(),\
    \ num.isEmpty else {\n        return 0\n    }\n    var count = 0\n    var prime\
    \ = 2 // start from 2\n    var prime2 = 2\n    var prime3 = 2\n    var prime4\
    \ = 2\n    var prime5 = 2\n    var prime6 = 2\n    var prime7 = 2\n    var prime8\
    \ = 2\n    var prime9 = 2\n    var prime10 = 2\n    var prime11 = 2\n    var prime12\
    \ = 2\n    var prime13 = 2\n    var prime14 = 2\n    var prime15 = 2\n    var\
    \ prime16 = 2\n    var prime17 = 2\n    var prime18 = 2\n    var prime19 = 2\n\
    \    var prime20 = 2\n    var prime21 = 2\n    var prime22 = 2\n    var prime23\
    \ = 2\n    var prime24 = 2\n    var prime25 = 2\n    var prime26 = 2\n    var\
    \ prime27 = 2\n    var prime28 = 2\n    var prime29 = 2\n    var prime30 = 2\n\
    \    var prime31 = 2\n    var prime32 = 2\n    var prime33 = 2\n    var prime34\
    \ = 2\n    var prime35 = 2\n    var prime36 = 2\n    var prime37 = 2\n    var\
    \ prime38 = 2\n    var prime39 = 2\n    var prime40 = 2\n    var prime41 = 2\n\
    \    var prime42 = 2\n    var prime43 = 2\n    var prime44 = 2\n    var prime45\
    \ = 2\n    var prime46 = 2\n    var prime47 = 2\n    var prime48 = 2\n    var\
    \ prime49 = 2\n    var prime50 = 2\n    var prime51 = 2\n    var prime52 = 2\n\
    \    var prime53 = 2\n    var prime54 = 2\n    var prime55 = 2\n    var prime56\
    \ = 2\n    var prime57 = 2\n    var prime58 = 2\n    var prime59 = 2\n    var\
    \ prime60 = 2\n    var prime61 = 2\n    var prime62 = 2\n    var prime63 = 2\n\
    \    var prime64 = 2\n    var prime65 = 2\n    var prime66 = 2\n    var prime67\
    \ = 2\n    var prime68 = 2\n    var prime69 = 2\n    var prime70 = 2\n    var\
    \ prime71 = 2\n    var prime72 = 2\n    var prime73 = 2\n    var prime74 = 2\n\
    \    var prime75 = 2\n    var prime76 = 2\n    var prime77 = 2\n    var prime78\
    \ = 2\n    var prime79 = 2\n    var prime80 = 2\n    var prime81 = 2\n    var\
    \ prime82 = 2\n    var prime83 = 2\n    var prime84 = 2\n    var prime85 = 2\n\
    \    var prime86 = 2\n    var prime87 = 2\n    var prime88 = 2\n    var prime89\
    \ = 2\n    var prime90 = 2\n    var prime91 = 2\n    var prime92 = 2\n    var\
    \ prime9\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpynirn9_x.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased(),\
    \ num.isEmpty else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmpynirn9_x.swift:120:9:\
    \ error: type annotation missing in pattern\n    var prime9\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    var prime = 0\n    var\
    \ prime2 = 0\n    var prime3 = 0\n    var prime4 = 0\n    var prime5 = 0\n   \
    \ var prime6 = 0\n    var prime7 = 0\n    var prime8 = 0\n    var prime9 = 0\n\
    \    var prime10 = 0\n    var prime11 = 0\n    var prime12 = 0\n    var prime13\
    \ = 0\n    var prime14 = 0\n    var prime15 = 0\n    var prime16 = 0\n    var\
    \ prime17 = 0\n    var prime18 = 0\n    var prime19 = 0\n    var prime20 = 0\n\
    \    var prime21 = 0\n    var prime22 = 0\n    var prime23 = 0\n    var prime24\
    \ = 0\n    var prime25 = 0\n    var prime26 = 0\n    var prime27 = 0\n    var\
    \ prime28 = 0\n    var prime29 = 0\n    var prime30 = 0\n    var prime31 = 0\n\
    \    var prime32 = 0\n    var prime33 = 0\n    var prime34 = 0\n    var prime35\
    \ = 0\n    var prime36 = 0\n    var prime37 = 0\n    var prime38 = 0\n    var\
    \ prime39 = 0\n    var prime40 = 0\n    var prime41 = 0\n    var prime42 = 0\n\
    \    var prime43 = 0\n    var prime44 = 0\n    var prime45 = 0\n    var prime46\
    \ = 0\n    var prime47 = 0\n    var prime48 = 0\n    var prime49 = 0\n    var\
    \ prime50 = 0\n    var prime51 = 0\n    var prime52 = 0\n    var prime53 = 0\n\
    \    var prime54 = 0\n    var prime55 = 0\n    var prime56 = 0\n    var prime57\
    \ = 0\n    var prime58 = 0\n    var prime59 = 0\n    var prime60 = 0\n    var\
    \ prime61 = 0\n    var prime62 = 0\n    var prime63 = 0\n    var prime64 = 0\n\
    \    var prime65 = 0\n    var prime66 = 0\n    var prime67 = 0\n    var prime68\
    \ = 0\n    var prime69 = 0\n    var prime70 = 0\n    var prime71 = 0\n    var\
    \ prime72 = 0\n    var prime73 = 0\n    var prime74 = 0\n    var prime75 = 0\n\
    \    var prime76 = 0\n    var prime77 = 0\n    var prime78 = 0\n    var prime79\
    \ = 0\n    var prime80 = 0\n    var prime81 = 0\n    var prime82 = 0\n    var\
    \ prime83 = 0\n    var prime84 = 0\n    var prime85 = 0\n    var prime86 = 0\n\
    \    var prime87 = 0\n    var prime88 = 0\n    var prime89 = 0\n    var prime90\
    \ = 0\n    var prime91 = 0\n    var prime92 = 0\n    var prime93 = 0\n    var\
    \ prime94 = 0\n    var prime95 = 0\n    var prime96 = 0\n    var prime97 = 0\n\
    \    var prime98 = 0\n    var prime99 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp83qpl283.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmp83qpl283.swift:24:15:\
    \ warning: value 'num' was defined but never used; consider replacing with boolean\
    \ test\n    guard let num = num.lowercased() else {\n          ~~~~^~~~~~\n  \
    \                                   != nil\n/tmp/tmp83qpl283.swift:27:9: warning:\
    \ initialization of variable 'count' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmp83qpl283.swift:28:9:\
    \ warning: initialization of variable 'prime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime = 0\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmp83qpl283.swift:29:9: warning: initialization of variable 'prime2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime2 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:30:9: warning:\
    \ initialization of variable 'prime3' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var prime3 = 0\n    ~~~~^~~~~~\n    _\n\
    /tmp/tmp83qpl283.swift:31:9: warning: initialization of variable 'prime4' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ prime4 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:32:9: warning: initialization\
    \ of variable 'prime5' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var prime5 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:33:9:\
    \ warning: initialization of variable 'prime6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime6 = 0\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp83qpl283.swift:34:9: warning: initialization of variable 'prime7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime7 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:35:9: warning:\
    \ initialization of variable 'prime8' was never used; consider replacing with\
    \ assignment to '_' or removi"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for _ in 0..<nums.count {\n        if nums[_] == \"A\"\
    \ {\n            count += 1\n        } else if nums[_] == \"B\" {\n          \
    \  count += 1\n        } else if nums[_] == \"C\" {\n            count += 1\n\
    \        } else if nums[_] == \"D\" {\n            count += 1\n        } else\
    \ if nums[_] == \"E\" {\n            count += 1\n        } else if nums[_] ==\
    \ \"F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9wsikfem.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9wsikfem.swift:27:17:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        if nums[_] == \"A\" {\n                ^\n/tmp/tmp9wsikfem.swift:29:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"B\" {\n                       ^\n/tmp/tmp9wsikfem.swift:31:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"C\" {\n                       ^\n/tmp/tmp9wsikfem.swift:33:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"D\" {\n                       ^\n/tmp/tmp9wsikfem.swift:35:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"E\" {\n                       ^\n/tmp/tmp9wsikfem.swift:37:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"F\" {\n                       ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    for char in num {\n\
    \        guard let digit = Int(String(char).uppercased(), radix: 16) else {\n\
    \            return 0\n        }\n        if digit == 11 || digit == 13 {\n  \
    \          count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmppwf8k85k.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\":\n        case \"1\":\n \
    \       case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"\
    5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case\
    \ \"9\":\n        case \"A\":\n        case \"B\":\n        case \"C\":\n    \
    \    case \"D\":\n        case \"E\":\n        case \"F\":\n            count\
    \ += 1\n        default:\n            break\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_l2vf8_4.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_l2vf8_4.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:39:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    var hexDigits: [Int] = []\n    var primeCount = 0\n    for char in numAsString.unicodeScalars\
    \ {\n        let hexDigit = Int(char.value)\n        hexDigits.append(hexDigit)\n\
    \    }\n    for hexDigit in hexDigits {\n        if hexDigit == hexDigits.last!\
    \ {\n            primeCount += 1\n        }\n    }\n    return primeCount\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpd7hjh8qs/tmpd7hjh8qs.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada853f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada850e7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada850e7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada850e67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd7hjh8qs                        0x00005633c26daa5b <unavailable> + 6747

    5    libc.so.6                          0x00002ada855dc460 __libc_start_main +
    245

    6    tmpd7hjh8qs                        0x00005633c26da639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num {\n        sum += Int(char) - 48\n    }\n    if sum < 2 {\n        return\
    \ 0\n    }\n    if sum < 4 {\n        return 1\n    }\n    if sum < 6 {\n    \
    \    return 2\n    }\n    if sum < 8 {\n        return 3\n    }\n    if sum <\
    \ 10 {\n        return 4\n    }\n    if sum < 12 {\n        return 5\n    }\n\
    \    if sum < 14 {\n        return 6\n    }\n    if sum < 16 {\n        return\
    \ 7\n    }\n    if sum < 18 {\n        return 8\n    }\n    if sum < 20 {\n  \
    \      return 9\n    }\n    if sum < 22 {\n        return 10\n    }\n    if sum\
    \ < 24 {\n        return 11\n    }\n    if sum < 26 {\n        return 12\n   \
    \ }\n    if sum < 28 {\n        return 13\n    }\n    if sum < 30 {\n        return\
    \ 14\n    }\n    if sum < 32 {\n        return 15\n    }\n    if sum < 34 {\n\
    \        return 16\n    }\n    if sum < 36 {\n        return 17\n    }\n    if\
    \ sum < 38 {\n        return 18\n    }\n    if sum < 40 {\n        return 19\n\
    \    }\n    if sum < 42 {\n        return 20\n    }\n    if sum < 44 {\n     \
    \   return 21\n    }\n    if sum < 46 {\n        return 22\n    }\n    if sum\
    \ < 48 {\n        return 23\n    }\n    if sum < 50 {\n        return 24\n   \
    \ }\n    if sum < 52 {\n        return 25\n    }\n    if sum < 54 {\n        return\
    \ 26\n    }\n    if sum < 56 {\n        return 27\n    }\n    if sum < 58 {\n\
    \        return 28\n    }\n    if sum < 60 {\n        return 29\n    }\n    if\
    \ sum < 62 {\n        return 30\n    }\n    if sum < 64 {\n        return 31\n\
    \    }\n    if sum < 66 {\n        return 32\n    }\n    if sum < 68 {\n     \
    \   return 33\n    }\n    if sum < 70 {\n        return 34\n    }\n    if sum\
    \ < 72 {\n        return 35\n    }\n    if sum < 74 {\n        return 36\n   \
    \ }\n    if sum < 76 {\n        return 37\n    }\n    if sum < 78 {\n        return\
    \ 38\n    }\n    if sum < 80 {\n        return 39\n    }\n    if sum < 82 {\n\
    \        return 40\n    }\n    if sum < 84 {\n        return 41\n    }\n    if\
    \ sum < 86 {\n        return 42\n    }\n    if sum < 88 {\n        return 43\n\
    \    }\n    if sum < 90 {\n        return 44\n    }\n    if sum < \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpav5ezauq.swift:164:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpav5ezauq.swift:26:16: error: no exact matches in call to initializer\
    \ \n        sum += Int(char) - 48\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.characters\n \
    \   var count = 0\n    for digit in hexDigits {\n        guard let digitInt =\
    \ Int(digit, radix: 16) else {\n            return count\n        }\n        if\
    \ digitInt == 2 {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxpube2l2.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpxpube2l2.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitCount\
    \ = hexDigitCount * hexDigitCount\n    let hexDigitCount = hexDigitCount / hexDigits.count\n\
    \    let hexDigitCount = hexDigitCount * hexDigitCount\n    let hexDigitCount\
    \ = hexDigitCount / hexDigits.count\n    let hexDigitCount = hexDigitCount * hexDigitCount\n\
    \    let hexDigitCount = hexDigitCount / hexDigits.count\n    let hexDigitCount\
    \ = hexDigitCount * hexDigitCount\n    let hexDigitCount = hexDigitCount / hexDigits.count\n\
    \    let hexDigitCount = hexDigitCount * hexDigitCount\n    let hexDigitCount\
    \ = hexDigitCount / hexDigits.count\n    let hexDigitCount = hexDigitCount * hexDigitCount\n\
    \    let hexDigitCount = hexDigitCount / hexDigits.count\n    let hexDigitCount\
    \ = hexDigitCount * hexDigitCount\n    let hexDigitCount = hexDigitCount / hexDigits.count\n\
    \    let hexDigitCount = hexDigitCount * hexDigitCount\n    let hexDigitCount\
    \ = hexDigitCount / hexDigits.count\n    let hexDigitCount = hexDigitCount * hexDigitCount\n\
    \    let hexDigitCount = hexDigitCount / hexDigits.count\n    let hexDigitCount\
    \ = hexDigitCount * hexDigitCount\n    let hexDigitCount = hexDigitCount / hexDigits.count\n\
    \    let hexDigitCount = hexDigitCount * hexDigitCount\n    let hexDigitCount\
    \ = hexDigitCount / hexDigits.count\n    let hexDigitCount = hexDigitCount * hexDigitCount\n\
    \    let hexDigitCount = hexDigitCount / hexDigits.count\n    let hexDigitCount\
    \ = hexDigitCount * hexDigitCount\n    let hexDigitCount = hexDigitCount / hexDigits.count\n\
    \    let hexDigitCount = hexDigitCount * hexDigitCount\n    let hexDigitCount\
    \ = hexDigitCount / hexDigits.count\n    let hexDigitCount = hexDigitCount * hexDigitCount\n\
    \    let hexDigitCount = hexDigitCount / hexDigits.count\n    let hexDigitCount\
    \ = hexDigitCount * hexDigitCount\n    let hexDigitCount = hexDigitCount / hexDigits.count\n\
    \    let hexDigitCount = hexDigitCount * hexDigitCount\n    let hexDigitCount\
    \ = hexDigitCount / hexDigits.count\n    let hexDigitCount = hexDigitCount * hexDigitCount\n\
    \    let hexDigitCount = hexDigitCount / hexDigits.count\n    let hexDigitCount\
    \ = hexDigitCount * hexDigitCount\n    let hexDigitCount = \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpb6xhxhgb.swift:64:24: error: expected initial value after '='\n\
    \    let hexDigitCount = \n                       ^\n/tmp/tmpb6xhxhgb.swift:24:42:\
    \ error: cannot find 'CharacterSet' in scope\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n                                     \
    \    ^~~~~~~~~~~~\n/tmp/tmpb6xhxhgb.swift:24:19: error: value of type 'String'\
    \ has no member 'trimmingCharacters'\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n              ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    var hex = num\n    var hexDigit = hex\n    var hexDigits = hex.characters\n\
    \    var hexDigitCount = hexDigits.count\n    \n    for _ in 0..<hexDigitCount\
    \ {\n        digit = hexDigits.first!\n        hexDigits.remove(at: 0)\n     \
    \   \n        if digit == hexDigit {\n            count += 1\n        }\n    }\n\
    \    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpa5s1pugx.swift:28:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexDigits = hex.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpa5s1pugx.swift:32:32:\
    \ error: cannot assign value of type 'String.Element' (aka 'Character') to type\
    \ 'Int'\n        digit = hexDigits.first!\n                ~~~~~~~~~~~~~~~^\n\
    /tmp/tmpa5s1pugx.swift:33:30: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n        hexDigits.remove(at: 0)\n            \
    \                 ^\n/tmp/tmpa5s1pugx.swift:35:18: error: binary operator '=='\
    \ cannot be applied to operands of type 'Int' and 'String'\n        if digit ==\
    \ hexDigit {\n           ~~~~~ ^  ~~~~~~~~\n/tmp/tmpa5s1pugx.swift:35:18: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Int,\
    \ Int), (String, String)\n        if digit == hexDigit {\n                 ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.characters.map\
    \ { String($0) }\n    var hexNum2 = hexNum.map { Int($0, radix: 16) }\n    var\
    \ hexNum3 = hexNum2.map { $0 % 2 != 0 }\n    var hexNum4 = hexNum3.map { $0 %\
    \ 3 != 0 }\n    var hexNum5 = hexNum4.map { $0 % 5 != 0 }\n    var hexNum6 = hexNum5.map\
    \ { $0 % 7 != 0 }\n    var hexNum7 = hexNum6.map { $0 % 11 != 0 }\n    var hexNum8\
    \ = hexNum7.map { $0 % 13 != 0 }\n    var hexNum9 = hexNum8.map { $0 % 17 != 0\
    \ }\n    var hexNum10 = hexNum9.map { $0 % 19 != 0 }\n    var hexNum11 = hexNum10.map\
    \ { $0 % 23 != 0 }\n    var hexNum12 = hexNum11.map { $0 % 29 != 0 }\n    var\
    \ hexNum13 = hexNum12.map { $0 % 31 != 0 }\n    var hexNum14 = hexNum13.map {\
    \ $0 % 37 != 0 }\n    var hexNum15 = hexNum14.map { $0 % 41 != 0 }\n    var hexNum16\
    \ = hexNum15.map { $0 % 43 != 0 }\n    var hexNum17 = hexNum16.map { $0 % 47 !=\
    \ 0 }\n    var hexNum18 = hexNum17.map { $0 % 51 != 0 }\n    var hexNum19 = hexNum18.map\
    \ { $0 % 53 != 0 }\n    var hexNum20 = hexNum19.map { $0 % 59 != 0 }\n    var\
    \ hexNum21 = hexNum20.map { $0 % 61 != 0 }\n    var hexNum22 = hexNum21.map {\
    \ $0 % 67 != 0 }\n    var hexNum23 = hexNum22.map { $0 % 71 != 0 }\n    var hexNum24\
    \ = hexNum23.map { $0 % 73 != 0 }\n    var hexNum25 = hexNum24.map { $0 % 79 !=\
    \ 0 }\n    var hexNum26 = hexNum25.map { $0 % 83 != 0 }\n    var hexNum27 = hexNum26.map\
    \ { $0 % 89 != 0 }\n    var hexNum28 = hexNum27.map { $0 % 93 != 0 }\n    var\
    \ hexNum29 = hexNum28.map { $0 % 97 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcv6o1ink.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexNum = num.characters.map { String($0) }\n  \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpcv6o1ink.swift:26:33: error: value of optional type 'Int?' must be\
    \ unwrapped to a value of type 'Int'\n    var hexNum3 = hexNum2.map { $0 % 2 !=\
    \ 0 }\n                                ^\n/tmp/tmpcv6o1ink.swift:26:33: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    var hexNum3 = hexNum2.map { $0 % 2 != 0 }\n                             \
    \   ^\n                                (  ?? <#default value#>)\n/tmp/tmpcv6o1ink.swift:26:33:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var hexNum3 = hexNum2.map { $0 % 2 != 0 }\n                     \
    \           ^\n                                  !\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for _ in 0..<nums.count\
    \ {\n        let digit = Int(nums[_])\n        if digit == 0 || digit == 1 {\n\
    \            count += 1\n            continue\n        }\n        for prime in\
    \ primes {\n            if digit % prime == 0 {\n                count += 1\n\
    \                break\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpookb4kjg.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpookb4kjg.swift:28:30:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let digit = Int(nums[_])\n                             ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        if c >= '0' && c <= '9' {\n            count += Int(c -\
    \ '0')\n        } else if c >= 'A' && c <= 'F' {\n            count += Int(c -\
    \ 'A') + 10\n        } else if c >= 'a' && c <= 'f' {\n            count += Int(c\
    \ - 'a') + 10\n        } else {\n            return -1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz1nqa0bw.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpz1nqa0bw.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpz1nqa0bw.swift:27:30: error:\
    \ single-quoted string literal found, use '\"'\n            count += Int(c - '0')\n\
    \                             ^~~\n                             \"0\"\n/tmp/tmpz1nqa0bw.swift:28:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'A' && c <= 'F' {\n                       ^~~\n                       \"A\"\n\
    /tmp/tmpz1nqa0bw.swift:28:36: error: single-quoted string literal found, use '\"\
    '\n        } else if c >= 'A' && c <= 'F' {\n                                \
    \   ^~~\n                                   \"F\"\n/tmp/tmpz1nqa0bw.swift:29:30:\
    \ error: single-quoted string literal found, use '\"'\n            count += Int(c\
    \ - 'A') + 10\n                             ^~~\n                            \
    \ \"A\"\n/tmp/tmpz1nqa0bw.swift:30:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c >= 'a' && c <= 'f' {\n                       ^~~\n\
    \                       \"a\"\n/tmp/tmpz1nqa0bw.swift:30:36: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'a' && c <= 'f' {\n \
    \                                  ^~~\n                                   \"\
    f\"\n/tmp/tmpz1nqa0bw.swift:31:30: error: single-quoted string literal found,\
    \ use '\"'\n            count += Int(c - 'a') + 10\n                         \
    \    ^~~\n                             \"a\"\n/tmp/tmpz1nqa0bw.swift:27:28: error:\
    \ binary operator '-' cannot be applied to two 'Character' operands\n        \
    \    count += Int(c - '0')\n                         ~ ^ ~~~\n/tmp/tmpz1nqa0bw.swift:29:28:\
    \ error: binary operator '-' cannot be applied to two 'Character' operands\n \
    \           count += Int(c - 'A') + 10\n                         ~ ^ ~~~\n/tmp/tmpz1nqa0bw.swift:31:28:\
    \ error: binary operator '-' cannot "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        switch char {\n        case \"0\":\n        case \"1\"\
    :\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case\
    \ \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n    \
    \    case \"9\":\n        case \"A\":\n        case \"B\":\n        case \"C\"\
    :\n        case \"D\":\n        case \"E\":\n        case \"F\":\n           \
    \ count += 1\n        default:\n            break\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmprs0m1x8v.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmprs0m1x8v.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:39:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.characters.map\
    \ { String($0) }\n    hexNum = hexNum.filter{ $0.isHexadecimal() }\n    hexNum\
    \ = hexNum.filter{ $0.isUppercase() }\n    hexNum = hexNum.filter{ $0.isNumber()\
    \ }\n    hexNum = hexNum.filter{ $0.characters.count > 1 }\n    hexNum = hexNum.filter{\
    \ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count\
    \ <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count\
    \ }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum\
    \ = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{\
    \ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count\
    \ <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count\
    \ }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum\
    \ = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{\
    \ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count\
    \ <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count\
    \ }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum\
    \ = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{\
    \ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count\
    \ <= hexNum.count }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count\
    \ }\n    hexNum = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum\
    \ = hexNum.filter{ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{\
    \ $0.characters.count <= hexNum.count }\n    hexNum = hexNum.filter{ $\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpimhnx8if.swift:50:29: error: '$' is not an identifier; use backticks\
    \ to escape it\n    hexNum = hexNum.filter{ $\n                            ^\n\
    \                            `$`\n/tmp/tmpimhnx8if.swift:71:63: error: expected\
    \ '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpimhnx8if.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpimhnx8if.swift:24:22: error: 'characters'\
    \ is unavailable: Please use String directly\n    var hexNum = num.characters.map\
    \ { String($0) }\n                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpimhnx8if.swift:25:32: error: value of type 'String'\
    \ has no member 'isHexadecimal'\n    hexNum = hexNum.filter{ $0.isHexadecimal()\
    \ }\n                            ~~ ^~~~~~~~~~~~~\n/tmp/tmpimhnx8if.swift:26:32:\
    \ error: value of type 'String' has no member 'isUppercase'\n    hexNum = hexNum.filter{\
    \ $0.isUppercase() }\n                            ~~ ^~~~~~~~~~~\n/tmp/tmpimhnx8if.swift:27:32:\
    \ error: value of type 'String' has no member 'isNumber'\n    hexNum = hexNum.filter{\
    \ $0.isNumber() }\n                            ~~ ^~~~~~~~\n/tmp/tmpimhnx8if.swift:28:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    hexNum =\
    \ hexNum.filter{ $0.characters.count > 1 }\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpimhnx8if.swift:29:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    hexNum =\
    \ hexNum.filter{ $0.characters.count <= hexNum.count }\n                     \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpimhnx8if.swift:30:32: error: 'characters' "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let hexDigits = digits.map { String($0) }\n    let hexDigitCount = hexDigits.count\n\
    \    let hexDigitPrimes = hexDigits.filter { $0.isPrime }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    let hexDigitPrimePrimes = hexDigitPrimes.filter\
    \ { $0.isPrime && $0.isPrime }\n    let hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.count\n    let\
    \ hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n  \
    \  let hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8wjb2tq6.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8wjb2tq6.swift:27:48:\
    \ error: value of type 'String' has no member 'isPrime'\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0.isPrime }\n                                        \
    \    ~~ ^~~~~~~\n/tmp/tmp8wjb2tq6.swift:31:40: error: cannot find 'hexDigitPrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.count\n\
    \                                       ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8wjb2tq6.swift:32:45:\
    \ error: cannot find 'hexDigitPrimePrimePrimePrimes' in scope\n    let hexDigitPrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimes.count\n                                    \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8wjb2tq6.swift:33:50: error: cannot\
    \ find 'hexDigitPrimePrimePrimePrimePrimes' in scope\n    let hexDigitPrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimes.count\n                               \
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8wjb2tq6.swift:34:55:\
    \ error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimes' in scope\n    let\
    \ hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8wjb2tq6.swift:35:60: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8wjb2tq6.swift:36:65: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrime"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var numString = \"\"\n    var numStringInt: Int = 0\n    var numStringInt2:\
    \ Int = 0\n    var numStringInt3: Int = 0\n    var numStringInt4: Int = 0\n  \
    \  var numStringInt5: Int = 0\n    var numStringInt6: Int = 0\n    var numStringInt7:\
    \ Int = 0\n    var numStringInt8: Int = 0\n    var numStringInt9: Int = 0\n  \
    \  var numStringInt10: Int = 0\n    var numStringInt11: Int = 0\n    var numStringInt12:\
    \ Int = 0\n    var numStringInt13: Int = 0\n    var numStringInt14: Int = 0\n\
    \    var numStringInt15: Int = 0\n    var numStringInt16: Int = 0\n    var numStringInt17:\
    \ Int = 0\n    var numStringInt18: Int = 0\n    var numStringInt19: Int = 0\n\
    \    var numStringInt20: Int = 0\n    var numStringInt21: Int = 0\n    var numStringInt22:\
    \ Int = 0\n    var numStringInt23: Int = 0\n    var numStringInt24: Int = 0\n\
    \    var numStringInt25: Int = 0\n    var numStringInt26: Int = 0\n    var numStringInt27:\
    \ Int = 0\n    var numStringInt28: Int = 0\n    var numStringInt29: Int = 0\n\
    \    var numStringInt30: Int = 0\n    var numStringInt31: Int = 0\n    var numStringInt32:\
    \ Int = 0\n    var numStringInt33: Int = 0\n    var numStringInt34: Int = 0\n\
    \    var numStringInt35: Int = 0\n    var numStringInt36: Int = 0\n    var numStringInt37:\
    \ Int = 0\n    var numStringInt38: Int = 0\n    var numStringInt39: Int = 0\n\
    \    var numStringInt40: Int = 0\n    var numStringInt41: Int = 0\n    var numStringInt42:\
    \ Int = 0\n    var numStringInt43: Int = 0\n    var numStringInt44: Int = 0\n\
    \    var numStringInt45: Int = 0\n    var numStringInt46: Int = 0\n    var numStringInt47:\
    \ Int = 0\n    var numStringInt48: Int = 0\n    var numStringInt49: Int = 0\n\
    \    var numStringInt50: Int = 0\n    var numStringInt51: Int = 0\n    var numStringInt52:\
    \ Int = 0\n    var numStringInt53: Int = 0\n    var numStringInt54: Int = 0\n\
    \    var numStringInt55: Int = 0\n    var numStringInt56: Int = 0\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8rvgfnzu.swift:82:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp8rvgfnzu.swift:24:9: warning: initialization of variable 'nums' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ nums = [Int]()\n    ~~~~^~~~\n    _\n/tmp/tmp8rvgfnzu.swift:25:9: warning: initialization\
    \ of variable 'numString' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var numString = \"\"\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp8rvgfnzu.swift:26:9:\
    \ warning: variable 'numStringInt' was never used; consider replacing with '_'\
    \ or removing it\n    var numStringInt: Int = 0\n        ^~~~~~~~~~~~\n      \
    \  _\n/tmp/tmp8rvgfnzu.swift:27:9: warning: variable 'numStringInt2' was never\
    \ used; consider replacing with '_' or removing it\n    var numStringInt2: Int\
    \ = 0\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp8rvgfnzu.swift:28:9: warning:\
    \ variable 'numStringInt3' was never used; consider replacing with '_' or removing\
    \ it\n    var numStringInt3: Int = 0\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp8rvgfnzu.swift:29:9:\
    \ warning: variable 'numStringInt4' was never used; consider replacing with '_'\
    \ or removing it\n    var numStringInt4: Int = 0\n        ^~~~~~~~~~~~~\n    \
    \    _\n/tmp/tmp8rvgfnzu.swift:30:9: warning: variable 'numStringInt5' was never\
    \ used; consider replacing with '_' or removing it\n    var numStringInt5: Int\
    \ = 0\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp8rvgfnzu.swift:31:9: warning:\
    \ variable 'numStringInt6' was never used; consider replacing with '_' or removing\
    \ it\n    var numStringInt6: Int = 0\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp8rvgfnzu.swift:32:9:\
    \ warning: variable 'numStringInt7' was never used; consider replacing with '_'\
    \ or removing it\n    var numStringInt7: Int = 0\n        ^~~~~~~~~~~~~\n    \
    \    _\n/tmp/tmp8rvgfnzu.swift:33:9: warning: variable 'numStringInt8' was never\
    \ used; consider replacing with '_' or removing it\n    var numStringInt8: Int\
    \ = 0\n        ^~~~~~~~~~~~~\n        _\n/tmp/tmp8rvgfnzu.swift:34:9: warning:\
    \ variable 'numStringInt9' was never used; consider replacing with '_' or removi"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexCount = hex.count\n    var hexDigits = [UInt8](repeating: 0, count:\
    \ hexCount)\n    for i in 0..<hexCount {\n        hexDigits[i] = hex[i]\n    }\n\
    \    var hexDigitCount = hexDigits.count\n    var hexDigitPrimes = [UInt8](repeating:\
    \ 0, count: hexDigitCount)\n    for i in 0..<hexDigitCount {\n        if hexDigits[i]\
    \ == hexDigits[i+1] {\n            hexDigitPrimes[i] = hexDigits[i]\n        }\n\
    \    }\n    var hexDigitPrimeCount = hexDigitPrimes.count\n    var hexDigitPrimePrimes\
    \ = [UInt8](repeating: 0, count: hexDigitPrimeCount)\n    for i in 0..<hexDigitPrimeCount\
    \ {\n        if hexDigitPrimes[i] == hexDigitPrimes[i+1] {\n            hexDigitPrimePrimes[i]\
    \ = hexDigitPrimes[i]\n        }\n    }\n    var hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimes = [UInt8](repeating: 0, count: hexDigitPrimePrimeCount)\n\
    \    for i in 0..<hexDigitPrimePrimeCount {\n        if hexDigitPrimePrimes[i]\
    \ == hexDigitPrimePrimes[i+1] {\n            hexDigitPrimePrimePrimes[i] = hexDigitPrimePrimes[i]\n\
    \        }\n    }\n    var hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimes = [UInt8](repeating: 0, count: hexDigitPrimePrimePrimeCount)\n\
    \    for i in 0..<hexDigitPrimePrimePrimeCount {\n        if hexDigitPrimePrimePrimes[i]\
    \ == hexDigitPrimePrimePrimes[i+1] {\n            hexDigitPrimePrimePrimePrimes[i]\
    \ = hexDigitPrimePrimePrimes[i]\n        }\n    }\n    var hexDigitPrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimes.count\n    var hexDigitPrimePrimePrimePrimePrimes\
    \ = [UInt8](repeating: 0, count: hexDigitPrimePrimePrimePrimePrimeCount)\n   \
    \ for i in 0..<hexDigitPrimePrimePrimePrimePrimeCount {\n        if hexDigitPrimePrimePrimePrimePrimes[i]\
    \ == hexDigitPrimePrimePrimePrimePrimes[i+1] {\n            \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpqw34gfnl.swift:83:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpqw34gfnl.swift:60:57:\
    \ note: to match this opening '{'\n    for i in 0..<hexDigitPrimePrimePrimePrimePrimeCount\
    \ {\n                                                        ^\n/tmp/tmpqw34gfnl.swift:83:63:\
    \ error: expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpqw34gfnl.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpqw34gfnl.swift:28:27: error: no exact matches\
    \ in call to subscript \n        hexDigits[i] = hex[i]\n                     \
    \     ^\n/tmp/tmpqw34gfnl.swift:28:27: note: found candidate with type '(String.UnicodeScalarView.Index)\
    \ -> Unicode.Scalar' (aka '(String.Index) -> Unicode.Scalar')\n        hexDigits[i]\
    \ = hex[i]\n                          ^\n/tmp/tmpqw34gfnl.swift:28:27: note: found\
    \ candidate with type '(Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence'\
    \ (aka '(Range<String.Index>) -> Substring.UnicodeScalarView')\n        hexDigits[i]\
    \ = hex[i]\n                          ^\n/tmp/tmpqw34gfnl.swift:28:27: note: found\
    \ candidate with type '((UnboundedRange_) -> ()) -> String.UnicodeScalarView.SubSequence'\
    \ (aka '((UnboundedRange_) -> ()) -> Substring.UnicodeScalarView')\n        hexDigits[i]\
    \ = hex[i]\n                          ^\n/tmp/tmpqw34gfnl.swift:28:27: error:\
    \ no 'subscript' candidates produce the expected contextual result type 'UInt8'\n\
    \        hexDigits[i] = hex[i]\n                          ^\nSwift.String.UnicodeScalarView:7:23:\
    \ note: 'subscript(_:)' produces 'Unicode.Scalar', not the expected contextual\
    \ result type 'UInt8'\n    @inlinable public subscript(position: String.UnicodeScalarView.Index)\
    \ -> Unicode.Scalar { get }\n                      ^\nSwift.String.UnicodeScalarView:4:12: "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var numAsString = \"\"\
    \n    for char in num {\n        if char >= '0' && char <= '9' {\n           \
    \ numAsString += char\n        }\n    }\n    var numAsInt = Int(numAsString)\n\
    \    var numAsInt2 = numAsInt * numAsInt\n    var numAsInt3 = numAsInt2 * numAsInt\n\
    \    var numAsInt4 = numAsInt3 * numAsInt\n    var numAsInt5 = numAsInt4 * numAsInt\n\
    \    var numAsInt6 = numAsInt5 * numAsInt\n    var numAsInt7 = numAsInt6 * numAsInt\n\
    \    var numAsInt8 = numAsInt7 * numAsInt\n    var numAsInt9 = numAsInt8 * numAsInt\n\
    \    var numAsInt10 = numAsInt9 * numAsInt\n    var numAsInt11 = numAsInt10 *\
    \ numAsInt\n    var numAsInt12 = numAsInt11 * numAsInt\n    var numAsInt13 = numAsInt12\
    \ * numAsInt\n    var numAsInt14 = numAsInt13 * numAsInt\n    var numAsInt15 =\
    \ numAsInt14 * numAsInt\n    var numAsInt16 = numAsInt15 * numAsInt\n    var numAsInt17\
    \ = numAsInt16 * numAsInt\n    var numAsInt18 = numAsInt17 * numAsInt\n    var\
    \ numAsInt19 = numAsInt18 * numAsInt\n    var numAsInt20 = numAsInt19 * numAsInt\n\
    \    var numAsInt21 = numAsInt20 * numAsInt\n    var numAsInt22 = numAsInt21 *\
    \ numAsInt\n    var numAsInt23 = numAsInt22 * numAsInt\n    var numAsInt24 = numAsInt23\
    \ * numAsInt\n    var numAsInt25 = numAsInt24 * numAsInt\n    var numAsInt26 =\
    \ numAsInt25 * numAsInt\n    var numAsInt27 = numAsInt26 * numAsInt\n    var numAsInt28\
    \ = numAsInt27 * numAsInt\n    var numAsInt29 = numAsInt28 * numAsInt\n    var\
    \ numAsInt30 = numAsInt29 * numAsInt\n    var numAsInt31 = numAsInt30 * numAsInt\n\
    \    var numAsInt32 = numAsInt31 * numAsInt\n    var numAsInt33 = numAsInt32 *\
    \ numAsInt\n    var numAsInt34 = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpumtztoiv.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpumtztoiv.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpumtztoiv.swift:63:21: error: expected initial value after '='\n    var\
    \ numAsInt34 = \n                    ^\n/tmp/tmpumtztoiv.swift:27:28: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       numAsString += char\n                           ^\n/tmp/tmpumtztoiv.swift:31:30:\
    \ error: binary operator '*' cannot be applied to two 'Int?' operands\n    var\
    \ numAsInt2 = numAsInt * numAsInt\n                    ~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpumtztoiv.swift:31:30:\
    \ note: overloads for '*' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    var numAsInt2 = numAsInt * numAsInt\n                      \
    \       ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        switch char {\n        case \"0\":\n        case \"1\"\
    :\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case\
    \ \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n    \
    \    case \"9\":\n        case \"A\":\n        case \"B\":\n        case \"C\"\
    :\n        case \"D\":\n        case \"E\":\n        case \"F\":\n           \
    \ count += 1\n        default:\n            break\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmprs0m1x8v.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmprs0m1x8v.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmprs0m1x8v.swift:39:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for char in nums {\n        switch char {\n        case\
    \ \"A\":\n        case \"B\":\n        case \"C\":\n        case \"D\":\n    \
    \    case \"E\":\n        case \"F\":\n            count += 1\n        default:\n\
    \            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpq6nnrww4.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpq6nnrww4.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpq6nnrww4.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpq6nnrww4.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpq6nnrww4.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpq6nnrww4.swift:24:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var nums\
    \ = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpq6nnrww4.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        switch digit {\n      \
    \  case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n\
    \        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"\
    7\":\n        case \"8\":\n        case \"9\":\n        case \"A\":\n        case\
    \ \"B\":\n        case \"C\":\n        case \"D\":\n        case \"E\":\n    \
    \    case \"F\":\n            count += 1\n        default:\n            break\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbxf_a20u.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpbxf_a20u.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpbxf_a20u.swift:40:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var nums_len = nums.count\n    var prime_digits = [Int]()\n    var prime_digits_len\
    \ = prime_digits.count\n    var prime_digits_sum = 0\n    var prime_digits_sum_len\
    \ = prime_digits_sum.count\n    var prime_digits_product = 1\n    var prime_digits_product_len\
    \ = prime_digits_product.count\n    var prime_digits_product_product = 1\n   \
    \ var prime_digits_product_product_len = prime_digits_product_product.count\n\
    \    var prime_digits_product_product_product = 1\n    var prime_digits_product_product_product_len\
    \ = prime_digits_product_product_product.count\n    var prime_digits_product_product_product_len\
    \ = prime_digits_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n    var prime_digits_product_product_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpikp09nqn.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpikp09nqn.swift:29:49:\
    \ error: value of type 'Int' has no member 'count'\n    var prime_digits_sum_len\
    \ = prime_digits_sum.count\n                               ~~~~~~~~~~~~~~~~ ^~~~~\n\
    /tmp/tmpikp09nqn.swift:31:57: error: value of type 'Int' has no member 'count'\n\
    \    var prime_digits_product_len = prime_digits_product.count\n             \
    \                      ~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpikp09nqn.swift:33:73:\
    \ error: value of type 'Int' has no member 'count'\n    var prime_digits_product_product_len\
    \ = prime_digits_product_product.count\n                                     \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpikp09nqn.swift:35:89: error:\
    \ value of type 'Int' has no member 'count'\n    var prime_digits_product_product_product_len\
    \ = prime_digits_product_product_product.count\n                             \
    \                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpikp09nqn.swift:37:60:\
    \ error: use of local variable 'prime_digits_product_product_product_product_len'\
    \ before its declaration\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n                 \
    \                                          ^\n/tmp/tmpikp09nqn.swift:37:9: note:\
    \ 'prime_digits_product_product_product_product_len' declared here\n    var prime_digits_product_product_product_product_len\
    \ = prime_digits_product_product_product_product_len.count\n        ^\n/tmp/tmpikp09nqn.swift:53:9:\
    \ error: type annotation missing in pattern\n    var prime_digits_product_product_\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.uppercased()\n\
    \    var count = 0\n    for char in hex {\n        if char == \"A\" {\n      \
    \      count += 1\n        } else if char == \"B\" {\n            count += 1\n\
    \        } else if char == \"C\" {\n            count += 1\n        } else if\
    \ char == \"D\" {\n            count += 1\n        } else if char == \"E\" {\n\
    \            count += 1\n        } else if char == \"F\" {\n            count\
    \ += 1\n        } else {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpq5zaap4x/tmpq5zaap4x.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8855b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8852aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8852aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8852a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq5zaap4x                        0x000056197ade3474 <unavailable> + 5236

    5    libc.so.6                          0x00002af88579f460 __libc_start_main +
    245

    6    tmpq5zaap4x                        0x000056197ade30f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [Int] =\
    \ []\n    for c in num.unicodeScalars {\n        hexDigits.append(Int(c.value))\n\
    \    }\n    var primeCount = 0\n    for hexDigit in hexDigits {\n        if hexDigit\
    \ == 2 || hexDigit == 3 || hexDigit == 5 || hexDigit == 7 || hexDigit == 11 ||\
    \ hexDigit == 13 {\n            primeCount += 1\n        }\n    }\n    return\
    \ primeCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmpd75qvqao/tmpd75qvqao.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc5a330c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc5a027b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc5a027988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc5a0267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd75qvqao                        0x000055a7f093d824 <unavailable> + 6180

    5    libc.so.6                          0x00002afc5a51c460 __libc_start_main +
    245

    6    tmpd75qvqao                        0x000055a7f093d4a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var count = 0\n    for hex in hex {\n        if hex.value > 0xFF {\n    \
    \        break\n        }\n        count += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp18h8ub3y/tmp18h8ub3y.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0078d26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0078a1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0078a1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0078a1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp18h8ub3y                        0x000055ec0bb48424 <unavailable> + 5156

    5    libc.so.6                          0x00002b0078f12460 __libc_start_main +
    245

    6    tmp18h8ub3y                        0x000055ec0bb480a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    var digit = 0\n    var\
    \ remainder = 0\n    var isPrime = true\n    var isPrime2 = true\n    var isPrime3\
    \ = true\n    var isPrime4 = true\n    var isPrime5 = true\n    var isPrime6 =\
    \ true\n    var isPrime7 = true\n    var isPrime8 = true\n    var isPrime9 = true\n\
    \    var isPrime10 = true\n    var isPrime11 = true\n    var isPrime12 = true\n\
    \    var isPrime13 = true\n    var isPrime14 = true\n    var isPrime15 = true\n\
    \    var isPrime16 = true\n    var isPrime17 = true\n    var isPrime18 = true\n\
    \    var isPrime19 = true\n    var isPrime20 = true\n    var isPrime21 = true\n\
    \    var isPrime22 = true\n    var isPrime23 = true\n    var isPrime24 = true\n\
    \    var isPrime25 = true\n    var isPrime26 = true\n    var isPrime27 = true\n\
    \    var isPrime28 = true\n    var isPrime29 = true\n    var isPrime30 = true\n\
    \    var isPrime31 = true\n    var isPrime32 = true\n    var isPrime33 = true\n\
    \    var isPrime34 = true\n    var isPrime35 = true\n    var isPrime36 = true\n\
    \    var isPrime37 = true\n    var isPrime38 = true\n    var isPrime39 = true\n\
    \    var isPrime40 = true\n    var isPrime41 = true\n    var isPrime42 = true\n\
    \    var isPrime43 = true\n    var isPrime44 = true\n    var isPrime45 = true\n\
    \    var isPrime46 = true\n    var isPrime47 = true\n    var isPrime48 = true\n\
    \    var isPrime49 = true\n    var isPrime50 = true\n    var isPrime51 = true\n\
    \    var isPrime52 = true\n    var isPrime53 = true\n    var isPrime54 = true\n\
    \    var isPrime55 = true\n    var isPrime56 = true\n    var isPrime57 = true\n\
    \    var isPrime58 = true\n    var isPrime59 = true\n    var isPrime60 = true\n\
    \    var isPrime61 = true\n    var isPrime62 = true\n    var isPrime63 = true\n\
    \    var isPrime64 = true\n    var isPrime65 = true\n    var isPrime66 = true\n\
    \    var isPrime67 = true\n    var isPrime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp2wls2smq.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmp2wls2smq.swift:97:9: error:\
    \ type annotation missing in pattern\n    var isPrime\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for char in nums {\n        let digit = Int(char) ?? 0\n\
    \        if digit == 0 || digit == 1 || digit == 2 || digit == 3 || digit == 4\
    \ || digit == 5 || digit == 6 || digit == 7 || digit == 8 || digit == 9 || digit\
    \ == 10 || digit == 11 || digit == 13 || digit == 17 {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpeyr40hjy.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpeyr40hjy.swift:27:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        let digit = Int(char) ?? 0\n                        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { Int($0) }\n    let primes = hexDigits.filter { isPrime($0) }\n    return primes.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcxmoi7is.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpcxmoi7is.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpcxmoi7is.swift:26:37: error: cannot find\
    \ 'isPrime' in scope\n    let primes = hexDigits.filter { isPrime($0) }\n    \
    \                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.unicodeScalars\n\
    \    var hexNumLen = hexNum.count\n    var hexNumLen2 = hexNumLen/2\n    var hexNumLen3\
    \ = hexNumLen2/3\n    var hexNumLen4 = hexNumLen2/4\n    var hexNumLen5 = hexNumLen2/5\n\
    \    var hexNumLen6 = hexNumLen2/6\n    var hexNumLen7 = hexNumLen2/7\n    var\
    \ hexNumLen8 = hexNumLen2/8\n    var hexNumLen9 = hexNumLen2/9\n    var hexNumLen10\
    \ = hexNumLen2/10\n    var hexNumLen11 = hexNumLen2/11\n    var hexNumLen12 =\
    \ hexNumLen2/12\n    var hexNumLen13 = hexNumLen2/13\n    var hexNumLen14 = hexNumLen2/14\n\
    \    var hexNumLen15 = hexNumLen2/15\n    var hexNumLen16 = hexNumLen2/16\n  \
    \  var hexNumLen17 = hexNumLen2/17\n    var hexNumLen18 = hexNumLen2/18\n    var\
    \ hexNumLen19 = hexNumLen2/19\n    var hexNumLen20 = hexNumLen2/20\n    var hexNumLen21\
    \ = hexNumLen2/21\n    var hexNumLen22 = hexNumLen2/22\n    var hexNumLen23 =\
    \ hexNumLen2/23\n    var hexNumLen24 = hexNumLen2/24\n    var hexNumLen25 = hexNumLen2/25\n\
    \    var hexNumLen26 = hexNumLen2/26\n    var hexNumLen27 = hexNumLen2/27\n  \
    \  var hexNumLen28 = hexNumLen2/28\n    var hexNumLen29 = hexNumLen2/29\n    var\
    \ hexNumLen30 = hexNumLen2/30\n    var hexNumLen31 = hexNumLen2/31\n    var hexNumLen32\
    \ = hexNumLen2/32\n    var hexNumLen33 = hexNumLen2/33\n    var hexNumLen34 =\
    \ hexNumLen2/34\n    var hexNumLen35 = hexNumLen2/35\n    var hexNumLen36 = hexNumLen2/36\n\
    \    var hexNumLen37 = hexNumLen2/37\n    var hexNumLen38 = hexNumLen2/38\n  \
    \  var hexNumLen39 = hexNumLen2/39\n    var hexNumLen40 = hexNumLen2/40\n    var\
    \ hexNumLen41 = hexNumLen2/41\n    var hexNumLen42 = hexNumLen2/42\n    var hexNumLen43\
    \ = hexNumLen2/43\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpc0qay6rb.swift:24:9: warning: variable 'hexNum' was never mutated;\
    \ consider changing to 'let' constant\n    var hexNum = num.unicodeScalars\n \
    \   ~~~ ^\n    let\n/tmp/tmpc0qay6rb.swift:25:9: warning: variable 'hexNumLen'\
    \ was never mutated; consider changing to 'let' constant\n    var hexNumLen =\
    \ hexNum.count\n    ~~~ ^\n    let\n/tmp/tmpc0qay6rb.swift:26:9: warning: variable\
    \ 'hexNumLen2' was never mutated; consider changing to 'let' constant\n    var\
    \ hexNumLen2 = hexNumLen/2\n    ~~~ ^\n    let\n/tmp/tmpc0qay6rb.swift:27:9: warning:\
    \ initialization of variable 'hexNumLen3' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var hexNumLen3 = hexNumLen2/3\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpc0qay6rb.swift:28:9: warning: initialization of variable 'hexNumLen4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexNumLen4 = hexNumLen2/4\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpc0qay6rb.swift:29:9:\
    \ warning: initialization of variable 'hexNumLen5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var hexNumLen5 = hexNumLen2/5\n \
    \   ~~~~^~~~~~~~~~\n    _\n/tmp/tmpc0qay6rb.swift:30:9: warning: initialization\
    \ of variable 'hexNumLen6' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexNumLen6 = hexNumLen2/6\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpc0qay6rb.swift:31:9: warning: initialization of variable 'hexNumLen7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexNumLen7 = hexNumLen2/7\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpc0qay6rb.swift:32:9:\
    \ warning: initialization of variable 'hexNumLen8' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var hexNumLen8 = hexNumLen2/8\n \
    \   ~~~~^~~~~~~~~~\n    _\n/tmp/tmpc0qay6rb.swift:33:9: warning: initialization\
    \ of variable 'hexNumLen9' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexNumLen9 = hexNumLen2/9\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpc0qay6rb.swift:34:9: warning: initialization of variable 'hexNumLen10'\
    \ was"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters\n\
    \    var hexCount = hex.count\n    var hexDigits = [String]()\n    var hexDigitCount\
    \ = 0\n    var hexDigitCount2 = 0\n    var hexDigitCount3 = 0\n    var hexDigitCount4\
    \ = 0\n    var hexDigitCount5 = 0\n    var hexDigitCount6 = 0\n    var hexDigitCount7\
    \ = 0\n    var hexDigitCount8 = 0\n    var hexDigitCount9 = 0\n    var hexDigitCount10\
    \ = 0\n    var hexDigitCount11 = 0\n    var hexDigitCount12 = 0\n    var hexDigitCount13\
    \ = 0\n    var hexDigitCount14 = 0\n    var hexDigitCount15 = 0\n    var hexDigitCount16\
    \ = 0\n    var hexDigitCount17 = 0\n    var hexDigitCount18 = 0\n    var hexDigitCount19\
    \ = 0\n    var hexDigitCount20 = 0\n    var hexDigitCount21 = 0\n    var hexDigitCount22\
    \ = 0\n    var hexDigitCount23 = 0\n    var hexDigitCount24 = 0\n    var hexDigitCount25\
    \ = 0\n    var hexDigitCount26 = 0\n    var hexDigitCount27 = 0\n    var hexDigitCount28\
    \ = 0\n    var hexDigitCount29 = 0\n    var hexDigitCount30 = 0\n    var hexDigitCount31\
    \ = 0\n    var hexDigitCount32 = 0\n    var hexDigitCount33 = 0\n    var hexDigitCount34\
    \ = 0\n    var hexDigitCount35 = 0\n    var hexDigitCount36 = 0\n    var hexDigitCount37\
    \ = 0\n    var hexDigitCount38 = 0\n    var hexDigitCount39 = 0\n    var hexDigitCount40\
    \ = 0\n    var hexDigitCount41 = 0\n    var hexDigitCount42 = 0\n    var hexDigitCount43\
    \ = 0\n    var hexDigitCount44 = 0\n    var hexDigitCount45 = 0\n    var hexDigitCount46\
    \ = 0\n    var hexDigitCount47 = 0\n    var hexDigitCount48 = 0\n    var hexDigitCount49\
    \ = 0\n    var hexDigitCount50 = 0\n    var hexDigitCount51 = 0\n    var hexDigitCount52\
    \ = 0\n    var hexDigitCount53 = 0\n    var hexDigitCount54 = 0\n    var hexDigitCount55\
    \ = 0\n    var hexDigitCount56 = 0\n    var hexDigitCount57 = 0\n    var hexDigitCount58\
    \ = 0\n    var hexDigitCount59 = 0\n    var hexDigitCount60 = 0\n    var hexDigitCount61\
    \ = 0\n    var hexDigitCount62 = 0\n    var hexDigitCount63 = 0\n    var hexDigitCount64\
    \ = 0\n    var hexDigitCount65 = 0\n    var hexDigitCount66 = 0\n    var hexDigitCount67\
    \ = 0\n    var hexDigitCount68 = 0\n    var hexDigitCount69 = 0\n    var hexDigitCount70\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfv__5eh9.swift:97:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpfv__5eh9.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfv__5eh9.swift:24:9:\
    \ warning: variable 'hex' was never mutated; consider changing to 'let' constant\n\
    \    var hex = num.characters\n    ~~~ ^\n    let\n/tmp/tmpfv__5eh9.swift:25:9:\
    \ warning: initialization of variable 'hexCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var hexCount = hex.count\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpfv__5eh9.swift:26:9: warning: initialization of variable 'hexDigits'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigits = [String]()\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpfv__5eh9.swift:27:9:\
    \ warning: initialization of variable 'hexDigitCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpfv__5eh9.swift:28:9: warning: initialization\
    \ of variable 'hexDigitCount2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount2 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpfv__5eh9.swift:29:9: warning: initialization of variable 'hexDigitCount3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount3 = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpfv__5eh9.swift:30:9:\
    \ warning: initialization of variable 'hexDigitCount4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount4 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmpfv__5eh9.swift:31:9: warning: initialization\
    \ of variable 'hexDigitCount5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount5 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpfv__5eh9.swift:32:9: warning: initialization of variable 'hexDigitCount6'\
    \ was"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        if char >= '0' && char <= '9' {\n            count +=\
    \ char - '0'\n        } else if char >= 'A' && char <= 'F' {\n            count\
    \ += char - 'A' + 10\n        } else if char >= 'a' && char <= 'f' {\n       \
    \     count += char - 'a' + 10\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpb0_xxikd.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpb0_xxikd.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpb0_xxikd.swift:27:29: error: single-quoted string literal found, use '\"\
    '\n            count += char - '0'\n                            ^~~\n        \
    \                    \"0\"\n/tmp/tmpb0_xxikd.swift:28:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char >= 'A' && char <= 'F'\
    \ {\n                          ^~~\n                          \"A\"\n/tmp/tmpb0_xxikd.swift:28:42:\
    \ error: single-quoted string literal found, use '\"'\n        } else if char\
    \ >= 'A' && char <= 'F' {\n                                         ^~~\n    \
    \                                     \"F\"\n/tmp/tmpb0_xxikd.swift:29:29: error:\
    \ single-quoted string literal found, use '\"'\n            count += char - 'A'\
    \ + 10\n                            ^~~\n                            \"A\"\n/tmp/tmpb0_xxikd.swift:30:27:\
    \ error: single-quoted string literal found, use '\"'\n        } else if char\
    \ >= 'a' && char <= 'f' {\n                          ^~~\n                   \
    \       \"a\"\n/tmp/tmpb0_xxikd.swift:30:42: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char >= 'a' && char <= 'f' {\n          \
    \                               ^~~\n                                        \
    \ \"f\"\n/tmp/tmpb0_xxikd.swift:31:29: error: single-quoted string literal found,\
    \ use '\"'\n            count += char - 'a' + 10\n                           \
    \ ^~~\n                            \"a\"\n/tmp/tmpb0_xxikd.swift:27:19: error:\
    \ binary operator '+=' cannot be applied to operands of type 'Int' and '_'\n \
    \           count += char - '0'\n                  ^\nSwift.SIMD:1:11: note: candidate\
    \ requires that 'Int' conform to 'SIMD' (requirement specified as 'Self' : 'SIMD')\n\
    extension SIMD where Self.Scalar : FloatingPoint {\n    "
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let hexDigits = digits.map { String($0) }\n    let hexDigitCount = hexDigits.count\n\
    \    let hexDigitPrimes = hexDigits.filter { isPrime(hexDigit: $0) }\n    let\
    \ hexDigitPrimeCount = hexDigitPrimes.count\n    return hexDigitPrimeCount + hexDigitCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpo4bii5_d.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpo4bii5_d.swift:27:45:\
    \ error: cannot find 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter\
    \ { isPrime(hexDigit: $0) }\n                                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsLen = nums.count\n    var numsLen2 = numsLen * 2\n    var numsLen3\
    \ = numsLen * 3\n    var numsLen4 = numsLen * 4\n    var numsLen5 = numsLen *\
    \ 5\n    var numsLen6 = numsLen * 6\n    var numsLen7 = numsLen * 7\n    var numsLen8\
    \ = numsLen * 8\n    var numsLen9 = numsLen * 9\n    var numsLen10 = numsLen *\
    \ 10\n    var numsLen11 = numsLen * 11\n    var numsLen12 = numsLen * 12\n   \
    \ var numsLen13 = numsLen * 13\n    var numsLen14 = numsLen * 14\n    var numsLen15\
    \ = numsLen * 15\n    var numsLen16 = numsLen * 16\n    var numsLen17 = numsLen\
    \ * 17\n    var numsLen18 = numsLen * 18\n    var numsLen19 = numsLen * 19\n \
    \   var numsLen20 = numsLen * 20\n    var numsLen21 = numsLen * 21\n    var numsLen22\
    \ = numsLen * 22\n    var numsLen23 = numsLen * 23\n    var numsLen24 = numsLen\
    \ * 24\n    var numsLen25 = numsLen * 25\n    var numsLen26 = numsLen * 26\n \
    \   var numsLen27 = numsLen * 27\n    var numsLen28 = numsLen * 28\n    var numsLen29\
    \ = numsLen * 29\n    var numsLen30 = numsLen * 30\n    var numsLen31 = numsLen\
    \ * 31\n    var numsLen32 = numsLen * 32\n    var numsLen33 = numsLen * 33\n \
    \   var numsLen34 = numsLen * 34\n    var numsLen35 = numsLen * 35\n    var numsLen36\
    \ = numsLen * 36\n    var numsLen37 = numsLen * 37\n    var numsLen38 = numsLen\
    \ * 38\n    var numsLen39 = numsLen * 39\n    var numsLen40 = numsLen * 40\n \
    \   var numsLen41 = numsLen * 41\n    var numsLen42 = numsLen * 42\n    var numsLen43\
    \ = numsLen * 43\n    var numsLen\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp9qej_8t3.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9qej_8t3.swift:68:9:\
    \ error: type annotation missing in pattern\n    var numsLen\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for _ in 0..<nums.count {\n        let digit = nums[_]\
    \ as UInt8\n        if digit == 0xA || digit == 0xB || digit == 0xC || digit ==\
    \ 0xD || digit == 0xE || digit == 0xF {\n            result += digit as Int\n\
    \        } else {\n            result += digit as Int\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp96xs2gfj.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp96xs2gfj.swift:27:26:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let digit = nums[_] as UInt8\n                         ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var hexNum = nums.map { String($0) }\n    var hexNums = hexNum.map { String($0)\
    \ }\n    var hexNumsCount = hexNums.count\n    var hexNumsCount2 = hexNumsCount\
    \ / 2\n    var hexNumsCount3 = hexNumsCount2 / 2\n    var hexNumsCount4 = hexNumsCount3\
    \ / 2\n    var hexNumsCount5 = hexNumsCount4 / 2\n    var hexNumsCount6 = hexNumsCount5\
    \ / 2\n    var hexNumsCount7 = hexNumsCount6 / 2\n    var hexNumsCount8 = hexNumsCount7\
    \ / 2\n    var hexNumsCount9 = hexNumsCount8 / 2\n    var hexNumsCount10 = hexNumsCount9\
    \ / 2\n    var hexNumsCount11 = hexNumsCount10 / 2\n    var hexNumsCount12 = hexNumsCount11\
    \ / 2\n    var hexNumsCount13 = hexNumsCount12 / 2\n    var hexNumsCount14 = hexNumsCount13\
    \ / 2\n    var hexNumsCount15 = hexNumsCount14 / 2\n    var hexNumsCount16 = hexNumsCount15\
    \ / 2\n    var hexNumsCount17 = hexNumsCount16 / 2\n    var hexNumsCount18 = hexNumsCount17\
    \ / 2\n    var hexNumsCount19 = hexNumsCount18 / 2\n    var hexNumsCount20 = hexNumsCount19\
    \ / 2\n    var hexNumsCount21 = hexNumsCount20 / 2\n    var hexNumsCount22 = hexNumsCount21\
    \ / 2\n    var hexNumsCount23 = hexNumsCount22 / 2\n    var hexNumsCount24 = hexNumsCount23\
    \ / 2\n    var hexNumsCount25 = hexNumsCount24 / 2\n    var hexNumsCount26 = hexNumsCount25\
    \ / 2\n    var hexNumsCount27 = hexNumsCount26 / 2\n    var hexNumsCount28 = hexNumsCount27\
    \ / 2\n    var hexNumsCount29 = hexNumsCount28 / 2\n    var hexNumsCount30 = hexNumsCount29\
    \ / 2\n    var hexNumsCount31 = hexNumsCount30 / 2\n    var hexNumsCount32 = hexNumsCount31\
    \ / 2\n    var hexNumsCount33 = hexNumsCount32 / 2\n    var \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpa2n7zefm.swift:60:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpa2n7zefm.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpa2n7zefm.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:25:9:\
    \ warning: variable 'hexNum' was never mutated; consider changing to 'let' constant\n\
    \    var hexNum = nums.map { String($0) }\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:26:9:\
    \ warning: variable 'hexNums' was never mutated; consider changing to 'let' constant\n\
    \    var hexNums = hexNum.map { String($0) }\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:27:9:\
    \ warning: variable 'hexNumsCount' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount = hexNums.count\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:28:9:\
    \ warning: variable 'hexNumsCount2' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount2 = hexNumsCount / 2\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:29:9:\
    \ warning: variable 'hexNumsCount3' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount3 = hexNumsCount2 / 2\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:30:9:\
    \ warning: variable 'hexNumsCount4' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount4 = hexNumsCount3 / 2\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:31:9:\
    \ warning: variable 'hexNumsCount5' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount5 = hexNumsCount4 / 2\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:32:9:\
    \ warning: variable 'hexNumsCount6' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsCount6 = hexNumsCount5 / 2\n    ~~~ ^\n    let\n/tmp/tmpa2n7zefm.swift:33:9:\
    \ warning: variable 'hexNumsCount7' was never mutated; consider changing to 'let'\
    \ constant\n    var hexNumsC"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { String($0) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { isPrime(hexDigit: $0) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    return hexDigitPrimeCount + hexDigitCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp287i24kj.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmp287i24kj.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp287i24kj.swift:27:45: error: cannot find\
    \ 'isPrime' in scope\n    let hexDigitPrimes = hexDigits.filter { isPrime(hexDigit:\
    \ $0) }\n                                            ^~~~~~~\n/tmp/tmp287i24kj.swift:29:31:\
    \ error: cannot convert return expression of type 'String' to return type 'Int'\n\
    \    return hexDigitPrimeCount + hexDigitCount\n           ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var numsDigit = nums.characters\n    var\
    \ numsDigitCount = numsDigit.count\n    var numsDigitCount = numsDigitCount -\
    \ 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit = numsDigit.characters\n    var numsDigitCount = numsDigitCount\
    \ - 1\n    var numsDigit\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpsflhiemm.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsflhiemm.swift:26:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    var numsDigit\
    \ = nums.characters\n                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpsflhiemm.swift:28:9: error: invalid redeclaration\
    \ of 'numsDigitCount'\n    var numsDigitCount = numsDigitCount - 1\n        ^\n\
    /tmp/tmpsflhiemm.swift:27:9: note: 'numsDigitCount' previously declared here\n\
    \    var numsDigitCount = numsDigit.count\n        ^\n/tmp/tmpsflhiemm.swift:29:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    var numsDigit\
    \ = numsDigit.characters\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpsflhiemm.swift:29:9: error: invalid redeclaration\
    \ of 'numsDigit'\n    var numsDigit = numsDigit.characters\n        ^\n/tmp/tmpsflhiemm.swift:26:9:\
    \ note: 'numsDigit' previously declared here\n    var numsDigit = nums.characters\n\
    \        ^\n/tmp/tmpsflhiemm.swift:71:9: error: type annotation missing in pattern\n\
    \    var numsDigit\n        ^\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted) else {\n        return 0\n    }\n    var\
    \ nums: [Int] = []\n    for char in num.unicodeScalars {\n        if char.value\
    \ > 0xFF {\n            return 0\n        }\n        nums.append(char.value)\n\
    \    }\n    let hex = nums.reduce(0) { (sum, value) in\n        sum * 16 + value\n\
    \    }\n    let hexString = String(hex)\n    let hexDigits = hexString.unicodeScalars\n\
    \        .filter({ $0.value > 0xFF })\n        .reduce(0) { (sum, value) in\n\
    \            sum * 16 + value\n    }\n    let primes = hexDigits.filter { $0 %\
    \ 2 == 0 }\n        .filter { $0 % 3 == 0 }\n        .filter { $0 % 5 == 0 }\n\
    \        .filter { $0 % 7 == 0 }\n        .filter { $0 % 11 == 0 }\n        .filter\
    \ { $0 % 13 == 0 }\n        .filter { $0 % 17 == 0 }\n        .filter { $0 % 19\
    \ == 0 }\n        .filter { $0 % 23 == 0 }\n        .filter { $0 % 29 == 0 }\n\
    \        .filter { $0 % 31 == 0 }\n        .filter { $0 % 37 == 0 }\n        .filter\
    \ { $0 % 41 == 0 }\n        .filter { $0 % 43 == 0 }\n        .filter { $0 % 47\
    \ == 0 }\n        .filter { $0 % 53 == 0 }\n        .filter { $0 % 59 == 0 }\n\
    \        .filter { $0 % 61 == 0 }\n        .filter { $0 % 67 == 0 }\n        .filter\
    \ { $0 % 71 == 0 }\n        .filter { $0 % 73 == 0 }\n        .filter { $0 % 79\
    \ == 0 }\n        .filter { $0 % 83 == 0 }\n        .filter { $0 % 89 == 0 }\n\
    \        .filter { $0 % 97 == 0 }\n        .filter { $0 % 101 == 0:}\n       \
    \ .filter { $0 % 103 == 0:}\n        .filter { $0 % 105 == 0:}\n        .filter\
    \ { $0 % 107 == 0:}\n        .filter { $0 % 109 == 0:}\n        .filter { $0 %\
    \ 113 == 0:}\n        .filter { $0 % 117 == 0:}\n        .filter { $0 % 121 ==\
    \ 0:}\n        .filter { $0 % 123 == 0:}\n        .filter { $0 % 127 == 0:}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp4vgx4oph.swift:68:32: error: consecutive statements on a line must\
    \ be separated by ';'\n        .filter { $0 % 101 == 0:}\n                   \
    \            ^\n                               ;\n/tmp/tmp4vgx4oph.swift:68:32:\
    \ error: expected expression\n        .filter { $0 % 101 == 0:}\n            \
    \                   ^\n/tmp/tmp4vgx4oph.swift:69:32: error: consecutive statements\
    \ on a line must be separated by ';'\n        .filter { $0 % 103 == 0:}\n    \
    \                           ^\n                               ;\n/tmp/tmp4vgx4oph.swift:69:32:\
    \ error: expected expression\n        .filter { $0 % 103 == 0:}\n            \
    \                   ^\n/tmp/tmp4vgx4oph.swift:70:32: error: consecutive statements\
    \ on a line must be separated by ';'\n        .filter { $0 % 105 == 0:}\n    \
    \                           ^\n                               ;\n/tmp/tmp4vgx4oph.swift:70:32:\
    \ error: expected expression\n        .filter { $0 % 105 == 0:}\n            \
    \                   ^\n/tmp/tmp4vgx4oph.swift:71:32: error: consecutive statements\
    \ on a line must be separated by ';'\n        .filter { $0 % 107 == 0:}\n    \
    \                           ^\n                               ;\n/tmp/tmp4vgx4oph.swift:71:32:\
    \ error: expected expression\n        .filter { $0 % 107 == 0:}\n            \
    \                   ^\n/tmp/tmp4vgx4oph.swift:72:32: error: consecutive statements\
    \ on a line must be separated by ';'\n        .filter { $0 % 109 == 0:}\n    \
    \                           ^\n                               ;\n/tmp/tmp4vgx4oph.swift:72:32:\
    \ error: expected expression\n        .filter { $0 % 109 == 0:}\n            \
    \                   ^\n/tmp/tmp4vgx4oph.swift:73:32: error: consecutive statements\
    \ on a line must be separated by ';'\n        .filter { $0 % 113 == 0:}\n    \
    \                           ^\n                               ;\n/tmp/tmp4vgx4oph.swift:73:32:\
    \ error: expected expression\n        .filter { $0 % 113 == 0:}\n            \
    \                   ^\n/tmp/tmp4vgx4oph.swift:74:32: error: consecutive statements\
    \ on a line must be separated by ';'\n        .filter { $0 % 117 == 0:}\n     "
  stdout: ''
  timestamp: 1660014378
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters\n\
    \    var hexDigits = [UInt8]()\n    for char in hex {\n        hexDigits.append(UInt8(String(char).unicodeScalars.first!.value\
    \ - 48))\n    }\n    var primes = [UInt8]()\n    var primeCount = 0\n    for digit\
    \ in hexDigits {\n        if digit == 2 {\n            primes.append(digit)\n\
    \            primeCount += 1\n        }\n    }\n    if primeCount > 1 {\n    \
    \    return primeCount\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp804ol74x.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp804ol74x.swift:24:9:\
    \ warning: variable 'hex' was never mutated; consider changing to 'let' constant\n\
    \    var hex = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        switch char {\n        case \"0\": count++\n        case\
    \ \"1\": count++\n        case \"2\": count++\n        case \"3\": count++\n \
    \       case \"4\": count++\n        case \"5\": count++\n        case \"6\":\
    \ count++\n        case \"7\": count++\n        case \"8\": count++\n        case\
    \ \"9\": count++\n        case \"A\": count++\n        case \"B\": count++\n \
    \       case \"C\": count++\n        case \"D\": count++\n        case \"E\":\
    \ count++\n        case \"F\": count++\n        default: break\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3n_h8auq.swift:27:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        case \"0\": count++\n                       ^~\n\
    /tmp/tmp3n_h8auq.swift:28:24: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        case \"1\": count++\n                       ^~\n/tmp/tmp3n_h8auq.swift:29:24:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ \"2\": count++\n                       ^~\n/tmp/tmp3n_h8auq.swift:30:24: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        case \"3\"\
    : count++\n                       ^~\n/tmp/tmp3n_h8auq.swift:31:24: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n        case \"4\": count++\n\
    \                       ^~\n/tmp/tmp3n_h8auq.swift:32:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"5\": count++\n         \
    \              ^~\n/tmp/tmp3n_h8auq.swift:33:24: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n        case \"6\": count++\n              \
    \         ^~\n/tmp/tmp3n_h8auq.swift:34:24: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n        case \"7\": count++\n                 \
    \      ^~\n/tmp/tmp3n_h8auq.swift:35:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        case \"8\": count++\n                       ^~\n\
    /tmp/tmp3n_h8auq.swift:36:24: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        case \"9\": count++\n                       ^~\n/tmp/tmp3n_h8auq.swift:37:24:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ \"A\": count++\n                       ^~\n/tmp/tmp3n_h8auq.swift:38:24: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        case \"B\"\
    : count++\n                       ^~\n/tmp/tmp3n_h8auq.swift:39:24: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n        case \"C\": count++\n\
    \                       ^~\n/tmp/tmp3n_h8auq.swift:40:24: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        case \"D\": count++\n         \
    \              ^~\n/tmp"
  stdout: ''
  timestamp: 1660014334
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.unicodeScalars\n\
    \    var hexDigits = \"\"\n    var count = 0\n    for hex in hex {\n        hexDigits\
    \ += String(hex)\n    }\n    for hexDigit in hexDigits {\n        if hexDigit\
    \ == \"A\" {\n            count += 1\n        } else if hexDigit == \"B\" {\n\
    \            count += 1\n        } else if hexDigit == \"C\" {\n            count\
    \ += 1\n        } else if hexDigit == \"D\" {\n            count += 1\n      \
    \  } else if hexDigit == \"E\" {\n            count += 1\n        } else if hexDigit\
    \ == \"F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp8lc2rupm/tmp8lc2rupm.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afdc6ec6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afdc6bbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afdc6bbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afdc6bbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8lc2rupm                        0x0000561e77bd6624 <unavailable> + 5668

    5    libc.so.6                          0x00002afdc70b2460 __libc_start_main +
    245

    6    tmp8lc2rupm                        0x0000561e77bd62a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var numAsString = \"\"\
    \n    for char in num {\n        if char >= '0' && char <= '9' {\n           \
    \ numAsString += char\n        }\n    }\n    let hexAsString = numAsString.toHexString()\n\
    \    let hexAsArray = hexAsString.characters\n    var primeCount = 0\n    for\
    \ char in hexAsArray {\n        if char == hexAsArray[0] {\n            primeCount\
    \ += 1\n        }\n    }\n    return primeCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpakkuqenu.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpakkuqenu.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpakkuqenu.swift:27:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            numAsString += char\n      \
    \                     ^\n/tmp/tmpakkuqenu.swift:30:35: error: value of type 'String'\
    \ has no member 'toHexString'\n    let hexAsString = numAsString.toHexString()\n\
    \                      ~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    for\
    \ char in num {\n        switch char {\n        case \"0\":\n        case \"1\"\
    :\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case\
    \ \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n    \
    \    case \"9\":\n        case \"A\":\n        case \"B\":\n        case \"C\"\
    :\n        case \"D\":\n        case \"E\":\n        case \"F\":\n        default:\n\
    \            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfd925r_q.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpfd925r_q.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpfd925r_q.swift:39:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.characters.map\
    \ { String($0) }\n    var hexNum2 = hexNum.map { Int($0, radix: 16) }\n    var\
    \ hexNum3 = hexNum2.filter { $0 % 2 == 0 }\n    var hexNum4 = hexNum3.filter {\
    \ $0 % 3 == 0 }\n    var hexNum5 = hexNum4.filter { $0 % 5 == 0 }\n    var hexNum6\
    \ = hexNum5.filter { $0 % 7 == 0 }\n    var hexNum7 = hexNum6.filter { $0 % 11\
    \ == 0 }\n    var hexNum8 = hexNum7.filter { $0 % 13 == 0 }\n    var hexNum9 =\
    \ hexNum8.filter { $0 % 17 == 0 }\n    var hexNum10 = hexNum9.filter { $0 % 19\
    \ == 0 }\n    var hexNum11 = hexNum10.filter { $0 % 23 == 0 }\n    var hexNum12\
    \ = hexNum11.filter { $0 % 29 == 0 }\n    var hexNum13 = hexNum12.filter { $0\
    \ % 31 == 0 }\n    var hexNum14 = hexNum13.filter { $0 % 37 == 0 }\n    var hexNum15\
    \ = hexNum14.filter { $0 % 41 == 0 }\n    var hexNum16 = hexNum15.filter { $0\
    \ % 43 == 0 }\n    var hexNum17 = hexNum16.filter { $0 % 47 == 0 }\n    var hexNum18\
    \ = hexNum17.filter { $0 % 53 == 0 }\n    var hexNum19 = hexNum18.filter { $0\
    \ % 59 == 0 }\n    var hexNum20 = hexNum19.filter { $0 % 61 == 0 }\n    var hexNum21\
    \ = hexNum20.filter { $0 % 67 == 0 }\n    var hexNum22 = hexNum21.filter { $0\
    \ % 71 == 0 }\n    var hexNum23 = hexNum22.filter { $0 % 73 == 0 }\n    var hexNum24\
    \ = hexNum23.filter { $0 % 79 == 0 }\n    var hexNum25 = hexNum24.filter { $0\
    \ % 83 == 0 }\n    var hexNum26 = hexNum25.filter { $0 % 89 == 0 }\n    var hexNum27\
    \ = hexNum26.filter { $0 % 97 == 0 }\n    var hexNum28 = hexNum27.filter { $0\
    \ % 101 == 0 }\n    var hexNum29 = hexNum28.filter { $0 % 103 == 0 }\n    var\
    \ hexNum30 = hex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1ptvy3nd.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hexNum = num.characters.map { String($0) }\n  \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1ptvy3nd.swift:26:36: error: value of optional type 'Int?' must be\
    \ unwrapped to a value of type 'Int'\n    var hexNum3 = hexNum2.filter { $0 %\
    \ 2 == 0 }\n                                   ^\n/tmp/tmp1ptvy3nd.swift:26:36:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    var hexNum3 = hexNum2.filter { $0 % 2 == 0 }\n                  \
    \                 ^\n                                   (  ?? <#default value#>)\n\
    /tmp/tmp1ptvy3nd.swift:26:36: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    var hexNum3 = hexNum2.filter { $0\
    \ % 2 == 0 }\n                                   ^\n                         \
    \            !\n/tmp/tmp1ptvy3nd.swift:53:20: error: cannot find 'hex' in scope\n\
    \    var hexNum30 = hex\n                   ^~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsLen = nums.count\n    var result = 0\n    var primes = Set<Int>()\n\
    \    var primesLen = 0\n    var primesSum = 0\n    var primesSumLen = 0\n    var\
    \ primesSum2 = 0\n    var primesSum2Len = 0\n    var primesSum3 = 0\n    var primesSum3Len\
    \ = 0\n    var primesSum4 = 0\n    var primesSum4Len = 0\n    var primesSum5 =\
    \ 0\n    var primesSum5Len = 0\n    var primesSum6 = 0\n    var primesSum6Len\
    \ = 0\n    var primesSum7 = 0\n    var primesSum7Len = 0\n    var primesSum8 =\
    \ 0\n    var primesSum8Len = 0\n    var primesSum9 = 0\n    var primesSum9Len\
    \ = 0\n    var primesSum10 = 0\n    var primesSum10Len = 0\n    var primesSum11\
    \ = 0\n    var primesSum11Len = 0\n    var primesSum12 = 0\n    var primesSum12Len\
    \ = 0\n    var primesSum13 = 0\n    var primesSum13Len = 0\n    var primesSum14\
    \ = 0\n    var primesSum14Len = 0\n    var primesSum15 = 0\n    var primesSum15Len\
    \ = 0\n    var primesSum16 = 0\n    var primesSum16Len = 0\n    var primesSum17\
    \ = 0\n    var primesSum17Len = 0\n    var primesSum18 = 0\n    var primesSum18Len\
    \ = 0\n    var primesSum19 = 0\n    var primesSum19Len = 0\n    var primesSum20\
    \ = 0\n    var primesSum20Len = 0\n    var primesSum21 = 0\n    var primesSum21Len\
    \ = 0\n    var primesSum22 = 0\n    var primesSum22Len = 0\n    var primesSum23\
    \ = 0\n    var primesSum23Len = 0\n    var primesSum24 = 0\n    var primesSum24Len\
    \ = 0\n    var primesSum25 = 0\n    var primesSum25Len = 0\n    var primesSum26\
    \ = 0\n    var primesSum26Len = 0\n    var primesSum27 = 0\n    var primesSum27Len\
    \ = 0\n    var primesSum28 = 0\n    var primesSum28Len = 0\n    var primesSum29\
    \ = 0\n    var primesSum29Len = 0\n    var primesSum30 = 0\n    var primesSum30Len\
    \ = 0\n    var primesSum31 = 0\n    var primesSum31Len = 0\n    var primesSum32\
    \ = 0\n    var primesSum32Len = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpcui98h5e.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcui98h5e.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpcui98h5e.swift:25:9:\
    \ warning: initialization of variable 'numsLen' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsLen = nums.count\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpcui98h5e.swift:26:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmpcui98h5e.swift:27:9: warning:\
    \ initialization of variable 'primes' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var primes = Set<Int>()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmpcui98h5e.swift:28:9: warning: initialization of variable 'primesLen'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primesLen = 0\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpcui98h5e.swift:29:9:\
    \ warning: initialization of variable 'primesSum' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primesSum = 0\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpcui98h5e.swift:30:9: warning: initialization of variable 'primesSumLen'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primesSumLen = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpcui98h5e.swift:31:9:\
    \ warning: initialization of variable 'primesSum2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var primesSum2 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpcui98h5e.swift:32:9: warning: initialization of variable 'primesSum2Len'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var primesSum2Len = 0\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpcui98h5e.swift:3"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexNum = num.unicodeScalars\n\
    \    var hexNumLen = hexNum.count\n    var hexNumStr = hexNum.map { String($0)\
    \ }\n    var hexNumStrLen = hexNumStr.count\n    var hexNumStrArr = hexNumStr.map\
    \ { String($0) }\n    var hexNumStrArrLen = hexNumStrArr.count\n    var hexNumStrArrArr\
    \ = hexNumStrArr.map { String($0) }\n    var hexNumStrArrArrLen = hexNumStrArrArr.count\n\
    \    var hexNumStrArrArrArrLen = hexNumStrArrArrArr.count\n    var hexNumStrArrArrArrArrLen\
    \ = hexNumStrArrArrArrArr.count\n    var hexNumStrArrArrArrArrArrLen = hexNumStrArrArrArrArrArr.count\n\
    \    var hexNumStrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArr.count\n\
    \    var hexNumStrArrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArrArr.count\n\
    \    var hexNumStrArrArrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArrArrArrArr.count\n\
    \    var hexNumStrArrArrArrArrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArr.count\n\
    \    var hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArr.count\n\
    \    var hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpyk98s1kg.swift:32:33: error: cannot find 'hexNumStrArrArrArr' in\
    \ scope\n    var hexNumStrArrArrArrLen = hexNumStrArrArrArr.count\n          \
    \                      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpyk98s1kg.swift:33:36: error:\
    \ cannot find 'hexNumStrArrArrArrArr' in scope\n    var hexNumStrArrArrArrArrLen\
    \ = hexNumStrArrArrArrArr.count\n                                   ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyk98s1kg.swift:34:39: error: cannot find 'hexNumStrArrArrArrArrArr' in\
    \ scope\n    var hexNumStrArrArrArrArrArrLen = hexNumStrArrArrArrArrArr.count\n\
    \                                      ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyk98s1kg.swift:35:42:\
    \ error: cannot find 'hexNumStrArrArrArrArrArrArr' in scope\n    var hexNumStrArrArrArrArrArrArrLen\
    \ = hexNumStrArrArrArrArrArrArr.count\n                                      \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyk98s1kg.swift:36:45: error: cannot find\
    \ 'hexNumStrArrArrArrArrArrArrArr' in scope\n    var hexNumStrArrArrArrArrArrArrArrLen\
    \ = hexNumStrArrArrArrArrArrArrArr.count\n                                   \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyk98s1kg.swift:37:48: error:\
    \ cannot find 'hexNumStrArrArrArrArrArrArrArrArrArr' in scope\n    var hexNumStrArrArrArrArrArrArrArrArrLen\
    \ = hexNumStrArrArrArrArrArrArrArrArrArr.count\n                             \
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyk98s1kg.swift:38:54:\
    \ error: cannot find 'hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArr' in scope\n\
    \    var hexNumStrArrArrArrArrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArr.count\n\
    \                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyk98s1kg.swift:39:60: error: cannot find 'hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArr'\
    \ in scope\n    var hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrLen = hexNumStrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArrArr.count\n\
    \                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyk98s1k"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexDigits = [UInt8]()\n    var hexDigitsCount\
    \ = nums.count\n    var hexDigitsCount2 = hexDigitsCount\n    var hexDigitsCount3\
    \ = hexDigitsCount2\n    var hexDigitsCount4 = hexDigitsCount3\n    var hexDigitsCount5\
    \ = hexDigitsCount4\n    var hexDigitsCount6 = hexDigitsCount5\n    var hexDigitsCount7\
    \ = hexDigitsCount6\n    var hexDigitsCount8 = hexDigitsCount7\n    var hexDigitsCount9\
    \ = hexDigitsCount8\n    var hexDigitsCount10 = hexDigitsCount9\n    var hexDigitsCount11\
    \ = hexDigitsCount10\n    var hexDigitsCount12 = hexDigitsCount11\n    var hexDigitsCount13\
    \ = hexDigitsCount12\n    var hexDigitsCount14 = hexDigitsCount13\n    var hexDigitsCount15\
    \ = hexDigitsCount14\n    var hexDigitsCount16 = hexDigitsCount15\n    var hexDigitsCount17\
    \ = hexDigitsCount16\n    var hexDigitsCount18 = hexDigitsCount17\n    var hexDigitsCount19\
    \ = hexDigitsCount18\n    var hexDigitsCount20 = hexDigitsCount19\n    var hexDigitsCount21\
    \ = hexDigitsCount20\n    var hexDigitsCount22 = hexDigitsCount21\n    var hexDigitsCount23\
    \ = hexDigitsCount22\n    var hexDigitsCount24 = hexDigitsCount23\n    var hexDigitsCount25\
    \ = hexDigitsCount24\n    var hexDigitsCount26 = hexDigitsCount25\n    var hexDigitsCount27\
    \ = hexDigitsCount26\n    var hexDigitsCount28 = hexDigitsCount27\n    var hexDigitsCount29\
    \ = hexDigitsCount28\n    var hexDigitsCount30 = hexDigitsCount29\n    var hexDigitsCount31\
    \ = hexDigitsCount30\n    var hexDigitsCount32 = hexDigitsCount31\n    var hexDigitsCount33\
    \ = hexDigitsCount32\n    var hexDigitsCount34 = hexDigitsCount33\n    var hexDigitsCount35\
    \ = hexDigitsCount34\n    var hexDigitsCount36 = hexDigitsCount35\n    var hexDigitsCount37\
    \ = hexDigitsCount36\n    var hexDigitsCount38 = hexDigitsCount37\n    var hexDigitsCount39\
    \ = hexDigitsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpizbn_xni.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpizbn_xni.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:25:9:\
    \ warning: initialization of variable 'numsCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsCount = nums.count\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpizbn_xni.swift:26:9: warning: initialization of variable 'hexDigits'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigits = [UInt8]()\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpizbn_xni.swift:27:9:\
    \ warning: variable 'hexDigitsCount' was never mutated; consider changing to 'let'\
    \ constant\n    var hexDigitsCount = nums.count\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:28:9:\
    \ warning: variable 'hexDigitsCount2' was never mutated; consider changing to\
    \ 'let' constant\n    var hexDigitsCount2 = hexDigitsCount\n    ~~~ ^\n    let\n\
    /tmp/tmpizbn_xni.swift:29:9: warning: variable 'hexDigitsCount3' was never mutated;\
    \ consider changing to 'let' constant\n    var hexDigitsCount3 = hexDigitsCount2\n\
    \    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:30:9: warning: variable 'hexDigitsCount4'\
    \ was never mutated; consider changing to 'let' constant\n    var hexDigitsCount4\
    \ = hexDigitsCount3\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:31:9: warning:\
    \ variable 'hexDigitsCount5' was never mutated; consider changing to 'let' constant\n\
    \    var hexDigitsCount5 = hexDigitsCount4\n    ~~~ ^\n    let\n/tmp/tmpizbn_xni.swift:32:9:\
    \ warning: variable 'hexDigitsCount6' was never mutated; consider changing to\
    \ 'let' constant\n    var hexDigitsCount6 = hexDigitsCount5\n    ~~~ ^\n    let\n\
    /tmp/tmpizbn_xni.swift:33:9: warning: variable 'hexDigitsCount7' was never mutated;\
    \ consider changing to 'let' constant\n    var h"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let hex = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics.inverted)\n    let hexDigits = hex.unicodeScalars.map\
    \ { Int($0.value) }\n    let hexDigitCount = hexDigits.count\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0 % 2 == 0 }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimes = hexDigitPrimes.map { Int($0 * 2) }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    let hexDigitPrimes = hexDigitPrimes.map { Int($0\
    \ * 3) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n    let hexDigitPrimes\
    \ = hexDigitPrimes.map { Int($0 * 5) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimes = hexDigitPrimes.map { Int($0 * 7) }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    let hexDigitPrimes = hexDigitPrimes.map { Int($0\
    \ * 11) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n    let hexDigitPrimes\
    \ = hexDigitPrimes.map { Int($0 * 13) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimes = hexDigitPrimes.map { Int($0 * 17) }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    let hexDigitPrimes = hexDigitPrimes.map { Int($0\
    \ * 19) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n    let hexDigitPrimes\
    \ = hexDigitPrimes.map { Int($0 * 23) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimes = hexDigitPrimes.map { Int($0 * 29) }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    let hexDigitPrimes = hexDigitPrimes.map { Int($0\
    \ * 31) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n    let hexDigitPrimes\
    \ = hexDigitPrimes.map { Int($0 * 37) }\n    let hexDigitPrimeCount = hexDigitPrimes.count\n\
    \    let hexDigitPrimes = hexDigitPrimes.map { Int($0 * 41) }\n    let hexDigitPrimeCount\
    \ = hexDigit\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxmxnxcgb.swift:24:42: error: cannot find 'CharacterSet' in scope\n\
    \    let hex = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmpxmxnxcgb.swift:24:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let hex\
    \ = num.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n        \
    \      ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpxmxnxcgb.swift:54:30: error: cannot find\
    \ 'hexDigit' in scope\n    let hexDigitPrimeCount = hexDigit\n               \
    \              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   var numsCount = 0\n    var numsCount2 = 0\n    var numsCount3 = 0\n    var\
    \ numsCount4 = 0\n    var numsCount5 = 0\n    var numsCount6 = 0\n    var numsCount7\
    \ = 0\n    var numsCount8 = 0\n    var numsCount9 = 0\n    var numsCount10 = 0\n\
    \    var numsCount11 = 0\n    var numsCount12 = 0\n    var numsCount13 = 0\n \
    \   var numsCount14 = 0\n    var numsCount15 = 0\n    var numsCount16 = 0\n  \
    \  var numsCount17 = 0\n    var numsCount18 = 0\n    var numsCount19 = 0\n   \
    \ var numsCount20 = 0\n    var numsCount21 = 0\n    var numsCount22 = 0\n    var\
    \ numsCount23 = 0\n    var numsCount24 = 0\n    var numsCount25 = 0\n    var numsCount26\
    \ = 0\n    var numsCount27 = 0\n    var numsCount28 = 0\n    var numsCount29 =\
    \ 0\n    var numsCount30 = 0\n    var numsCount31 = 0\n    var numsCount32 = 0\n\
    \    var numsCount33 = 0\n    var numsCount34 = 0\n    var numsCount35 = 0\n \
    \   var numsCount36 = 0\n    var numsCount37 = 0\n    var numsCount38 = 0\n  \
    \  var numsCount39 = 0\n    var numsCount40 = 0\n    var numsCount41 = 0\n   \
    \ var numsCount42 = 0\n    var numsCount43 = 0\n    var numsCount44 = 0\n    var\
    \ numsCount45 = 0\n    var numsCount46 = 0\n    var numsCount47 = 0\n    var numsCount48\
    \ = 0\n    var numsCount49 = 0\n    var numsCount50 = 0\n    var numsCount51 =\
    \ 0\n    var numsCount52 = 0\n    var numsCount53 = 0\n    var numsCount54 = 0\n\
    \    var numsCount55 = 0\n    var numsCount56 = 0\n    var numsCount57 = 0\n \
    \   var numsCount58 = 0\n    var numsCount59 = 0\n    var numsCount60 = 0\n  \
    \  var numsCount61 = 0\n    var numsCount62 = 0\n    var numsCount63 = 0\n   \
    \ var numsCount64 = 0\n    var numsCount65 = 0\n    var numsCount66 = 0\n    var\
    \ numsCount67 = 0\n    var numsCount68 = 0\n    var numsCount69 = 0\n    var numsCount70\
    \ = 0\n    var numsCount71 = 0\n    var numsCount72 = 0\n    var num\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpmdaif198.swift:97:9: error: type annotation missing in pattern\n\
    \    var num\n        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let hexDigits = digits.map { String($0) }\n    let hexDigitCount = hexDigits.count\n\
    \    let hexDigitPrimes = hexDigits.filter { $0.isPrime }\n    let hexDigitPrimeCount\
    \ = hexDigitPrimes.count\n    let hexDigitPrimePrimes = hexDigitPrimes.filter\
    \ { $0.isPrime && $0.isPrime }\n    let hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.count\n    let\
    \ hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n  \
    \  let hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    let hexDigitPrimePri\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp8wjb2tq6.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8wjb2tq6.swift:27:48:\
    \ error: value of type 'String' has no member 'isPrime'\n    let hexDigitPrimes\
    \ = hexDigits.filter { $0.isPrime }\n                                        \
    \    ~~ ^~~~~~~\n/tmp/tmp8wjb2tq6.swift:31:40: error: cannot find 'hexDigitPrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.count\n\
    \                                       ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8wjb2tq6.swift:32:45:\
    \ error: cannot find 'hexDigitPrimePrimePrimePrimes' in scope\n    let hexDigitPrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimes.count\n                                    \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8wjb2tq6.swift:33:50: error: cannot\
    \ find 'hexDigitPrimePrimePrimePrimePrimes' in scope\n    let hexDigitPrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimes.count\n                               \
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8wjb2tq6.swift:34:55:\
    \ error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimes' in scope\n    let\
    \ hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8wjb2tq6.swift:35:60: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8wjb2tq6.swift:36:65: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    let hexDigitPrimePrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrime"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = num[0]\n    for _ in 0..<num.count {\n        let digit = num[num]\n\
    \        if digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"\
    D\" || digit == \"E\" || digit == \"F\" {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpndx1iy8r.swift:25:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var digit = num[0]\n\
    \                ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpndx1iy8r.swift:27:24: error: no exact matches in call to\
    \ subscript \n        let digit = num[num]\n                       ^\nSwift.String:12:12:\
    \ note: candidate expects value of type 'String.Index' for parameter #1 (got 'String')\n\
    \    public subscript(i: String.Index) -> Character { get }\n           ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'String')\n    public subscript(r: Range<String.Index>) -> Substring {\
    \ get }\n           ^\nSwift.Collection:3:23: note: candidate expects value of\
    \ type '(UnboundedRange_) -> ()' for parameter #1 (got 'String')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = [Int]()\n \
    \   for c in num {\n        if c >= '0' && c <= '9' {\n            nums.append(c\
    \ - '0')\n        } else if c >= 'A' && c <= 'F' {\n            nums.append(c\
    \ - 'A' + 10)\n        } else if c >= 'a' && c <= 'f' {\n            nums.append(c\
    \ - 'a' + 10)\n        } else {\n            return -1\n        }\n    }\n   \
    \ var result = 0\n    for num in nums {\n        if num == 2 {\n            result\
    \ += 1\n        } else if num == 3 {\n            result += 1\n        } else\
    \ if num == 5 {\n            result += 1\n        } else if num == 7 {\n     \
    \       result += 1\n        } else if num == 11 {\n            result += 1\n\
    \        } else if num == 13 {\n            result += 1\n        } else if num\
    \ == 17 {\n            result += 1\n        } else if num == 19 {\n          \
    \  result += 1\n        } else if num == 29 {\n            result += 1\n     \
    \   } else if num == 39 {\n            result += 1\n        } else if num == 49\
    \ {\n            result += 1\n        } else if num == 59 {\n            result\
    \ += 1\n        } else if num == 69 {\n            result += 1\n        } else\
    \ if num == 91 {\n            result += 1\n        } else if num == 99 {\n   \
    \         result += 1\n        } else if num == 109 {\n            result += 1\n\
    \        } else if num == 119 {\n            result += 1\n        } else if num\
    \ == 129 {\n            result += 1\n        } else if num == 139 {\n        \
    \    result += 1\n        } else if num == 159 {\n            result += 1\n  \
    \      } else if num == 169 {\n            result += 1\n        } else if num\
    \ == 179 {\n            result += 1\n        } else if num == 189 {\n        \
    \    result += 1\n        } else if num == 199 {\n            result += 1\n  \
    \      } else if num == 199 {\n            result += 1\n        } else if num\
    \ == 199 {\n            result += 1\n        } else if num == 199 {\n        \
    \    result += 1\n        } else if num == 199 {\n            result += 1\n  \
    \      } else if num == 199 {\n            result += 1\n        } else if num\
    \ == 199 {\n            result += 1\n        } else if num == 199 {\n        \
    \    result += 1\n        } else if num == 199 {\n            result += 1\n  \
    \      } else if num == 199 {\n            result += 1\n        } else if num\
    \ == 199 {\n            result += 1\n        } else if num == 199 {\n        \
    \    result += 1\n        } else if num\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp2k4lawrb.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmp2k4lawrb.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmp2k4lawrb.swift:27:29: error:\
    \ single-quoted string literal found, use '\"'\n            nums.append(c - '0')\n\
    \                            ^~~\n                            \"0\"\n/tmp/tmp2k4lawrb.swift:28:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'A' && c <= 'F' {\n                       ^~~\n                       \"A\"\n\
    /tmp/tmp2k4lawrb.swift:28:36: error: single-quoted string literal found, use '\"\
    '\n        } else if c >= 'A' && c <= 'F' {\n                                \
    \   ^~~\n                                   \"F\"\n/tmp/tmp2k4lawrb.swift:29:29:\
    \ error: single-quoted string literal found, use '\"'\n            nums.append(c\
    \ - 'A' + 10)\n                            ^~~\n                            \"\
    A\"\n/tmp/tmp2k4lawrb.swift:30:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c >= 'a' && c <= 'f' {\n                       ^~~\n\
    \                       \"a\"\n/tmp/tmp2k4lawrb.swift:30:36: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'a' && c <= 'f' {\n \
    \                                  ^~~\n                                   \"\
    f\"\n/tmp/tmp2k4lawrb.swift:31:29: error: single-quoted string literal found,\
    \ use '\"'\n            nums.append(c - 'a' + 10)\n                          \
    \  ^~~\n                            \"a\"\n/tmp/tmp2k4lawrb.swift:108:22: error:\
    \ expected '{' after 'if' condition\n        } else if num\n                 \
    \    ^\n/tmp/tmp2k4lawrb.swift:129:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmp2k4lawrb.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for c\
    \ in num {\n        sum += Int(c) - 48\n    }\n    if sum < 2 {\n        return\
    \ 0\n    }\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    var prime = primes[0]\n\
    \    for prime in primes {\n        if prime * prime > sum {\n            break\n\
    \        }\n    }\n    return prime * prime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpamoa_jp0.swift:26:16: error: no exact matches in call to initializer\
    \ \n        sum += Int(c) - 48\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for index in 0..<nums.count\
    \ {\n        let digit = Int(nums[index])\n        if digit == 0 || digit == 1\
    \ {\n            count += 1\n            continue\n        }\n        for prime\
    \ in primes {\n            if digit % prime == 0 {\n                count += 1\n\
    \                break\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpfrgmyvsw.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfrgmyvsw.swift:28:29:\
    \ error: no exact matches in call to subscript \n        let digit = Int(nums[index])\n\
    \                            ^\nSwift.String:3:12: note: candidate expects value\
    \ of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexDigits = [UInt8](repeating: 0, count:\
    \ numsCount)\n    var hexDigitsCount = numsCount\n    for index in 0..<numsCount\
    \ {\n        let hexDigit = UInt8(nums[index])\n        hexDigits[hexDigitsCount]\
    \ = hexDigit\n        hexDigitsCount += 1\n    }\n    var hexDigitsCount2 = hexDigitsCount\n\
    \    var hexDigitsCount3 = hexDigitsCount\n    var hexDigitsCount4 = hexDigitsCount\n\
    \    var hexDigitsCount5 = hexDigitsCount\n    var hexDigitsCount6 = hexDigitsCount\n\
    \    var hexDigitsCount7 = hexDigitsCount\n    var hexDigitsCount8 = hexDigitsCount\n\
    \    var hexDigitsCount9 = hexDigitsCount\n    var hexDigitsCount10 = hexDigitsCount\n\
    \    var hexDigitsCount11 = hexDigitsCount\n    var hexDigitsCount12 = hexDigitsCount\n\
    \    var hexDigitsCount13 = hexDigitsCount\n    var hexDigitsCount14 = hexDigitsCount\n\
    \    var hexDigitsCount15 = hexDigitsCount\n    var hexDigitsCount16 = hexDigitsCount\n\
    \    var hexDigitsCount17 = hexDigitsCount\n    var hexDigitsCount18 = hexDigitsCount\n\
    \    var hexDigitsCount19 = hexDigitsCount\n    var hexDigitsCount20 = hexDigitsCount\n\
    \    var hexDigitsCount21 = hexDigitsCount\n    var hexDigitsCount22 = hexDigitsCount\n\
    \    var hexDigitsCount23 = hexDigitsCount\n    var hexDigitsCount24 = hexDigitsCount\n\
    \    var hexDigitsCount25 = hexDigitsCount\n    var hexDigitsCount26 = hexDigitsCount\n\
    \    var hexDigitsCount27 = hexDigitsCount\n    var hexDigitsCount28 = hexDigitsCount\n\
    \    var hexDigitsCount29 = hexDigitsCount\n    var hexDigitsCount30 = hexDigitsCount\n\
    \    var hexDigitsCount31 = hexDigitsCount\n    var hexDigitsCount32 = hexDigitsCount\n\
    \    var hexDigitsCount33 = hexDigitsCount\n    var hexDigitsCount34 = hexDigitsCount\n\
    \    var hexDigitsCount35 = hexDigitsCount\n    var hexDigitsCount36 = hexDigitsCount\n\
    \    var hexDigitsCount37 = hexDigitsCount\n    var hexDigitsCount38 = hexDigits\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpa58svvak.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpa58svvak.swift:29:34:\
    \ error: no exact matches in call to subscript \n        let hexDigit = UInt8(nums[index])\n\
    \                                 ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for _ in 0..<nums.count\
    \ {\n        let digit = Int(String(nums[_]).uppercaseHexDigit())\n        if\
    \ digit == 0 {\n            count += 1\n        } else {\n            if primes.contains(digit)\
    \ {\n                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_kj6kf3_.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_kj6kf3_.swift:28:37:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let digit = Int(String(nums[_]).uppercaseHexDigit())\n              \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let nums = num.characters\n\
    \    var sum = 0\n    for n in nums {\n        sum += Int(n) * 16\n    }\n   \
    \ return sum % 10\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpaziochlv.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpaziochlv.swift:27:16:\
    \ error: no exact matches in call to initializer \n        sum += Int(n) * 16\n\
    \               ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n   \
    \        ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float)\n         \
    \  ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n \
    \   public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note:\
    \ candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = \"\"\n\
    \    var count = 0\n    for char in num {\n        hexDigits += char\n    }\n\
    \    for char in hexDigits {\n        if char == \"A\" {\n            count +=\
    \ 2\n        } else if char == \"B\" {\n            count += 1\n        } else\
    \ if char == \"C\" {\n            count += 2\n        } else if char == \"D\"\
    \ {\n            count += 1\n        } else if char == \"E\" {\n            count\
    \ += 2\n        } else if char == \"F\" {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpmg57qwed.swift:27:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        hexDigits += char\n            \
    \         ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    var i = 0\n    for digit in digits {\n        if\
    \ digit == \"A\" {\n            result += 2\n        } else if digit == \"B\"\
    \ {\n            result += 3\n        } else if digit == \"C\" {\n           \
    \ result += 5\n        } else if digit == \"D\" {\n            result += 7\n \
    \       } else if digit == \"E\" {\n            result += 11\n        } else if\
    \ digit == \"F\" {\n            result += 13\n        } else {\n            result\
    \ += digit - 48\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpn3c32x0v.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpn3c32x0v.swift:41:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            result += digit - 48\n                      ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.characters.map\
    \ { String($0) }\n    var hexDigits = hex.map { Int(String($0)) }\n    var primes\
    \ = hexDigits.filter { $0 % 2 == 0 }\n    var primesCount = primes.count\n   \
    \ if primesCount == 0 {\n        return primesCount\n    }\n    var hexDigitCount\
    \ = hexDigits.count\n    var hexDigitPrimes = hexDigits.filter { $0 % 2 == 0 }\n\
    \    var hexDigitPrimesCount = hexDigitPrimes.count\n    var hexDigitPrimePrimes\
    \ = hexDigitPrimes.filter { $0 % 3 == 0 }\n    var hexDigitPrimePrimesCount =\
    \ hexDigitPrimePrimes.count\n    var hexDigitPrimePrimePrimesCount = hexDigitPrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimesCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimesCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmph2rmhmdj.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var hex = num.characters.map { String($0) }\n     \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmph2rmhmdj.swift:26:37: error: value of optional type 'Int?' must be\
    \ unwrapped to a value of type 'Int'\n    var primes = hexDigits.filter { $0 %\
    \ 2 == 0 }\n                                    ^\n/tmp/tmph2rmhmdj.swift:26:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    var primes = hexDigits.filter { $0 % 2 == 0 }\n                 \
    \                   ^\n                                    (  ?? <#default value#>)\n\
    /tmp/tmph2rmhmdj.swift:26:37: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    var primes = hexDigits.filter { $0\
    \ % 2 == 0 }\n                                    ^\n                        \
    \              !\n/tmp/tmph2rmhmdj.swift:32:45: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n    var hexDigitPrimes =\
    \ hexDigits.filter { $0 % 2 == 0 }\n                                         \
    \   ^\n/tmp/tmph2rmhmdj.swift:32:45: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    var hexDigitPrimes = hexDigits.filter\
    \ { $0 % 2 == 0 }\n                                            ^\n           \
    \                                 (  ?? <#default value#>)\n/tmp/tmph2rmhmdj.swift:32:45:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var hexDigitPrimes = hexDigits.filter { $0 % 2 == 0 }\n         \
    \                                   ^\n                                      \
    \        !\n/tmp/tmph2rmhmdj.swift:36:41: error: cannot find 'hexDigitPrimePrimePrimes'\
    \ in scope\n    var hexDigitPrimePrimePrimesCount = hexDigitPrimePrimePrimes.count\n\
    \                                        ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmph2rmhmdj.swift:37:46:\
    \ error: cannot find 'hex"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    for\
    \ char in num.characters {\n        switch char {\n        case 'A':\n       \
    \ case 'B':\n        case 'C':\n        case 'D':\n        case 'E':\n       \
    \ case 'F':\n            result += 1\n        default:\n            break\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp4d1fctep.swift:27:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'A':\n             ^~~\n             \"A\"\n/tmp/tmp4d1fctep.swift:27:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmp4d1fctep.swift:28:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'B':\n   \
    \          ^~~\n             \"B\"\n/tmp/tmp4d1fctep.swift:28:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'B':\n        ^~~~~~~~~\n                  break\n/tmp/tmp4d1fctep.swift:29:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'C':\n   \
    \          ^~~\n             \"C\"\n/tmp/tmp4d1fctep.swift:29:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'C':\n        ^~~~~~~~~\n                  break\n/tmp/tmp4d1fctep.swift:30:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'D':\n   \
    \          ^~~\n             \"D\"\n/tmp/tmp4d1fctep.swift:30:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'D':\n        ^~~~~~~~~\n                  break\n/tmp/tmp4d1fctep.swift:31:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'E':\n   \
    \          ^~~\n             \"E\"\n/tmp/tmp4d1fctep.swift:31:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'E':\n        ^~~~~~~~~\n                  break\n/tmp/tmp4d1fctep.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'F':\n   \
    \          ^~~\n             \"F\"\n/tmp/tmp4d1fctep.swift:25:21: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in num.characters {\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var hexDigits = 0\n    for digit in digits {\n        hexDigits += Int(digit)\
    \ - Int(Int(digit)!)\n    }\n    return hexDigits\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxms4mh8g.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxms4mh8g.swift:27:43:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        hexDigits += Int(digit) - Int(Int(digit)!)\n                        \
    \                  ^\n/tmp/tmpxms4mh8g.swift:27:22: error: no exact matches in\
    \ call to initializer \n        hexDigits += Int(digit) - Int(Int(digit)!)\n \
    \                    ^\n/tmp/tmpxms4mh8g.swift:27:22: note: candidate expects\
    \ value of type 'Float16' for parameter #1 (got 'Character')\n        hexDigits\
    \ += Int(digit) - Int(Int(digit)!)\n                     ^\n/tmp/tmpxms4mh8g.swift:27:22:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \        hexDigits += Int(digit) - Int(Int(digit)!)\n                     ^\n\
    /tmp/tmpxms4mh8g.swift:27:22: note: candidate expects value of type 'Double' for\
    \ parameter #1 (got 'Character')\n        hexDigits += Int(digit) - Int(Int(digit)!)\n\
    \                     ^\n/tmp/tmpxms4mh8g.swift:27:22: note: candidate expects\
    \ value of type 'Float80' for parameter #1 (got 'Character')\n        hexDigits\
    \ += Int(digit) - Int(Int(digit)!)\n                     ^\n/tmp/tmpxms4mh8g.swift:27:22:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n        hexDigits += Int(digit) - Int(Int(digit)!)\n         \
    \            ^\n/tmp/tmpxms4mh8g.swift:27:22: note: candidate expects value of\
    \ type 'Builtin.Word' for parameter #1 (got 'Character')\n        hexDigits +=\
    \ Int(digit) - Int(Int(digit)!)\n                     ^\n"
  stdout: ''
  timestamp: 1660014336
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for num in nums {\n        if nums.contains(where: { $0.isHexadecimal()\
    \ }) {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpii7p3j_l.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpii7p3j_l.swift:27:38:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'isHexadecimal'\n\
    \        if nums.contains(where: { $0.isHexadecimal() }) {\n                 \
    \                 ~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = [Int]()\n\
    \    var count = 0\n    for char in num {\n        guard let digit = Int(String(char).uppercased(),\
    \ radix: 16) else {\n            return count\n        }\n        hexDigits.append(digit)\n\
    \        count += 1\n    }\n    var primes = [Int]()\n    for digit in hexDigits\
    \ {\n        if digit == 2 {\n            primes.append(digit)\n        }\n  \
    \  }\n    return primes.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmpvld7zyx_/tmpvld7zyx_.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01c0489c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01c0180b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01c0180988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01c017f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvld7zyx_                        0x000055b39c7ad7c4 <unavailable> + 6084

    5    libc.so.6                          0x00002b01c0675460 __libc_start_main +
    245

    6    tmpvld7zyx_                        0x000055b39c7ad449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\":\n        case \"1\":\n \
    \       case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"\
    5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case\
    \ \"9\":\n        case \"A\":\n        case \"B\":\n        case \"C\":\n    \
    \    case \"D\":\n        case \"E\":\n        case \"F\":\n            count\
    \ += 1\n        default:\n            break\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_l2vf8_4.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_l2vf8_4.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_l2vf8_4.swift:39:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for index in 0..<nums.count {\n        let digit = nums[index]\n\
    \        switch digit {\n        case \"0\", \"1\", \"2\", \"3\", \"4\", \"5\"\
    , \"6\", \"7\", \"8\", \"9\":\n            result += 1\n        case \"A\", \"\
    B\", \"C\", \"D\", \"E\", \"F\":\n            result += 2\n        default:\n\
    \            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpr6m02p8t.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpr6m02p8t.swift:27:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let digit = nums[index]\n             \
    \       ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpr6m02p8t.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    var i = 0\n    for _ in 0..<nums.count {\n        let\
    \ hex = nums[i]\n        switch hex {\n        case \"0\": \n        case \"1\"\
    : \n        case \"2\": \n        case \"3\": \n        case \"4\": \n       \
    \ case \"5\": \n        case \"6\": \n        case \"7\": \n        case \"8\"\
    : \n        case \"9\": \n        case \"A\": \n        case \"B\": \n       \
    \ case \"C\": \n        case \"D\": \n        case \"E\": \n        case \"F\"\
    : \n        default: \n            break\n        }\n        i += 1\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpo1nvwt1r.swift:30:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\": \n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpo1nvwt1r.swift:31:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\
    \ \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:32:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"2\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:41:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\": \n        ^~~~~~~~~\n                  break\n/tmp/tmpo1nvwt1r.swift:42:9:\
    \ err"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    for digit in num {\n        switch digit {\n        case \"0\"\
    :\n            count = count + 1\n        case \"1\":\n            count = count\
    \ + 1\n        case \"2\":\n            count = count + 1\n        case \"3\"\
    :\n            count = count + 1\n        case \"4\":\n            count = count\
    \ + 1\n        case \"5\":\n            count = count + 1\n        case \"6\"\
    :\n            count = count + 1\n        case \"7\":\n            count = count\
    \ + 1\n        case \"8\":\n            count = count + 1\n        case \"9\"\
    :\n            count = count + 1\n        case \"A\":\n            count = count\
    \ + 1\n        case \"B\":\n            count = count + 1\n        case \"C\"\
    :\n            count = count + 1\n        case \"D\":\n            count = count\
    \ + 1\n        case \"E\":\n            count = count + 1\n        case \"F\"\
    :\n            count = count + 1\n        default:\n            break\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmpt3mg1t46/tmpt3mg1t46.swift:80: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31557d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31554c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31554c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31554c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt3mg1t46                        0x000055a202bf9414 <unavailable> + 5140

    5    libc.so.6                          0x00002b31559be460 __libc_start_main +
    245

    6    tmpt3mg1t46                        0x000055a202bf9099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for char in nums {\n        let digit = Int(char) ?? 0\n\
    \        if digit == 0 || digit == 1 {\n            continue\n        }\n    \
    \    if digit == 2 {\n            count += 2\n            continue\n        }\n\
    \        if digit == 3 {\n            count += 3\n            continue\n     \
    \   }\n        if digit == 5 {\n            count += 5\n            continue\n\
    \        }\n        if digit == 7 {\n            count += 7\n            continue\n\
    \        }\n        if digit == 11 {\n            count += 11\n            continue\n\
    \        }\n        if digit == 13 {\n            count += 13\n            continue\n\
    \        }\n        if digit == 17 {\n            count += 17\n            continue\n\
    \        }\n        if digit == 19 {\n            count += 19\n            continue\n\
    \        }\n        if digit == 29 {\n            count += 29\n            continue\n\
    \        }\n        if digit == 37 {\n            count += 37\n            continue\n\
    \        }\n        if digit == 41 {\n            count += 41\n            continue\n\
    \        }\n        if digit == 43  {\n            count += 43\n            continue\n\
    \        }\n        if digit == 47  {\n            count += 47\n            continue\n\
    \        }\n        if digit == 53  {\n            count += 53\n            continue\n\
    \        }\n        if digit == 59  {\n            count += 59\n            continue\n\
    \        }\n        if digit == 63 {\n            count += 63\n            continue\n\
    \        }\n        if digit == 67  {\n            count += 67\n            continue\n\
    \        }\n        if digit == 73 {\n            count += 73\n            continue\n\
    \        }\n        if digit == 79  {\n            count += 79\n            continue\n\
    \        }\n        if digit == 83  {\n            count += 83\n            continue\n\
    \        }\n        if digit == 89  {\n            count += 89\n            continue\n\
    \        }\n        if digit == 97  {\n            count += 97\n            continue\n\
    \        }\n        if digit == 103 {\n            count += 103\n            continue\n\
    \        }\n        if digit == 109 {\n            count += 109\n            continue\n\
    \        }\n        if digit == 113  {\n            count += 113\n           \
    \ continue\n        }\n        if digit == 117  {\n            count += 117\n\
    \            continue\n        }\n        if digit == 121  {\n            count\
    \ += 121\n            continue\n        }\n        if digit == 127  {\n      \
    \      count += 127\n            continue\n        }\n        if digit == 131\
    \ {\n            count += 131\n            continue\n        }\n        if digit\
    \ == 137  {\n            count += 137\n            continue\n        }\n     \
    \   if digit == 143 {\n            count += 143\n            continue\n      \
    \  }\n        if digit == 149  {\n            \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpaalj1xx6.swift:177:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpaalj1xx6.swift:26:22:\
    \ note: to match this opening '{'\n    for char in nums {\n                  \
    \   ^\n/tmp/tmpaalj1xx6.swift:177:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpaalj1xx6.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpaalj1xx6.swift:24:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    var nums = num.characters\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpaalj1xx6.swift:27:25: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        let digit = Int(char) ?? 0\n   \
    \                     ^\n/tmp/tmpaalj1xx6.swift:160:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics) else { return 0 }\n    guard let hex = num.trimmingCharacters(in:\
    \ CharacterSet.lowercase) else { return 0 }\n    var count = 0\n    for char in\
    \ hex.unicodeScalars {\n        guard let digit = Int(char.value, radix: 16) else\
    \ { return 0 }\n        guard digit != 0 else { return 0 }\n        guard digit\
    \ != 1 && !(digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11\
    \ || digit == 13 || digit == 17 || digit == 19 || digit == 23 || digit == 29 ||\
    \ digit == 31 || digit == 37 || digit == 43 || digit == 51) else { return 0 }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3vr6d0gd.swift:24:48: error: cannot find 'CharacterSet' in scope\n\
    \    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics) else\
    \ { return 0 }\n                                               ^~~~~~~~~~~~\n\
    /tmp/tmp3vr6d0gd.swift:24:25: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \    guard let num = num.trimmingCharacters(in: CharacterSet.alphanumerics) else\
    \ { return 0 }\n                    ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp3vr6d0gd.swift:25:48:\
    \ error: cannot find 'CharacterSet' in scope\n    guard let hex = num.trimmingCharacters(in:\
    \ CharacterSet.lowercase) else { return 0 }\n                                \
    \               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        switch char {\n        case \"A\":\n        case \"B\"\
    :\n        case \"C\":\n        case \"D\":\n        case \"E\":\n        case\
    \ \"F\":\n        case \"0\":\n        case \"1\":\n        case \"2\":\n    \
    \    case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\"\
    :\n        case \"7\":\n        case \"8\":\n        case \"9\":\n        case\
    \ \"a\":\n        case \"b\":\n        case \"c\":\n        case \"d\":\n    \
    \    case \"e\":\n        case \"f\":\n        default:\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp_askdmep.swift:27:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp_askdmep.swift:28:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:29:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"F\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"0\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"1\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"2\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp_askdmep.swift:39:9:\
    \ error: 'case' l"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    var count = 0\n    var digit = 0\n    var isPrime = true\n    var isPrime2\
    \ = true\n    var isPrime3 = true\n    var isPrime4 = true\n    var isPrime5 =\
    \ true\n    var isPrime6 = true\n    var isPrime7 = true\n    var isPrime8 = true\n\
    \    var isPrime9 = true\n    var isPrime10 = true\n    var isPrime11 = true\n\
    \    var isPrime12 = true\n    var isPrime13 = true\n    var isPrime14 = true\n\
    \    var isPrime15 = true\n    var isPrime16 = true\n    var isPrime17 = true\n\
    \    var isPrime18 = true\n    var isPrime19 = true\n    var isPrime20 = true\n\
    \    var isPrime21 = true\n    var isPrime22 = true\n    var isPrime23 = true\n\
    \    var isPrime24 = true\n    var isPrime25 = true\n    var isPrime26 = true\n\
    \    var isPrime27 = true\n    var isPrime28 = true\n    var isPrime29 = true\n\
    \    var isPrime30 = true\n    var isPrime31 = true\n    var isPrime32 = true\n\
    \    var isPrime33 = true\n    var isPrime34 = true\n    var isPrime35 = true\n\
    \    var isPrime36 = true\n    var isPrime37 = true\n    var isPrime38 = true\n\
    \    var isPrime39 = true\n    var isPrime40 = true\n    var isPrime41 = true\n\
    \    var isPrime42 = true\n    var isPrime43 = true\n    var isPrime44 = true\n\
    \    var isPrime45 = true\n    var isPrime46 = true\n    var isPrime47 = true\n\
    \    var isPrime48 = true\n    var isPrime49 = true\n    var isPrime50 = true\n\
    \    var isPrime51 = true\n    var isPrime52 = true\n    var isPrime53 = true\n\
    \    var isPrime54 = true\n    var isPrime55 = true\n    var isPrime56 = true\n\
    \    var isPrime57 = true\n    var isPrime58 = true\n    var isPrime59 = true\n\
    \    var isPrime60 = true\n    var isPrime61 = true\n    var isPrime62 = true\n\
    \    var isPrime63 = true\n    var isPrime64 = true\n    var isPrime65 = true\n\
    \    var isPrime66 = true\n    var isPrime67 = true\n    var isPrime68 = true\n\
    \    var isPrime69 = true\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpsku30a3k.swift:96:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpsku30a3k.swift:24:9: warning: initialization of immutable value 'numAsString'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let numAsString = num.lowercased()\n    ~~~~^~~~~~~~~~~\n    _\n/tmp/tmpsku30a3k.swift:25:9:\
    \ warning: initialization of variable 'count' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmpsku30a3k.swift:26:9: warning: initialization of variable 'digit'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var digit = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpsku30a3k.swift:27:9: warning:\
    \ initialization of variable 'isPrime' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var isPrime = true\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpsku30a3k.swift:28:9: warning: initialization of variable 'isPrime2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime2 = true\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpsku30a3k.swift:29:9:\
    \ warning: initialization of variable 'isPrime3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime3 = true\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpsku30a3k.swift:30:9: warning: initialization of variable 'isPrime4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime4 = true\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpsku30a3k.swift:31:9:\
    \ warning: initialization of variable 'isPrime5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime5 = true\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpsku30a3k.swift:32:9: warning: initialization of variable 'isPrime6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var isPrime6 = true\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpsku30a3k.swift:33:9:\
    \ warning: initialization of variable 'isPrime7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var isPrime7 = true\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpsku30a3k"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  var count = 0\n    for char in num {\n        switch char {\n        case \"\
    A\":\n        case \"B\":\n        case \"C\":\n        case \"D\":\n        case\
    \ \"E\":\n        case \"F\":\n            count += 1\n        default:\n    \
    \        break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpv12ecuqb.swift:28:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"A\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpv12ecuqb.swift:29:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"B\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmpv12ecuqb.swift:30:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"C\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpv12ecuqb.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"D\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpv12ecuqb.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"E\":\n        ^~~~~~~~~\n                  break\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    var hexDigit = 0\n    var hexDigit2 = 0\n    var hexDigit3 =\
    \ 0\n    var hexDigit4 = 0\n    var hexDigit5 = 0\n    var hexDigit6 = 0\n   \
    \ var hexDigit7 = 0\n    var hexDigit8 = 0\n    var hexDigit9 = 0\n    var hexDigit10\
    \ = 0\n    var hexDigit11 = 0\n    var hexDigit12 = 0\n    var hexDigit13 = 0\n\
    \    var hexDigit14 = 0\n    var hexDigit15 = 0\n    var hexDigit16 = 0\n    var\
    \ hexDigit17 = 0\n    var hexDigit18 = 0\n    var hexDigit19 = 0\n    var hexDigit20\
    \ = 0\n    var hexDigit21 = 0\n    var hexDigit22 = 0\n    var hexDigit23 = 0\n\
    \    var hexDigit24 = 0\n    var hexDigit25 = 0\n    var hexDigit26 = 0\n    var\
    \ hexDigit27 = 0\n    var hexDigit28 = 0\n    var hexDigit29 = 0\n    var hexDigit30\
    \ = 0\n    var hexDigit31 = 0\n    var hexDigit32 = 0\n    var hexDigit33 = 0\n\
    \    var hexDigit34 = 0\n    var hexDigit35 = 0\n    var hexDigit36 = 0\n    var\
    \ hexDigit37 = 0\n    var hexDigit38 = 0\n    var hexDigit39 = 0\n    var hexDigit40\
    \ = 0\n    var hexDigit41 = 0\n    var hexDigit42 = 0\n    var hexDigit43 = 0\n\
    \    var hexDigit44 = 0\n    var hexDigit45 = 0\n    var hexDigit46 = 0\n    var\
    \ hexDigit47 = 0\n    var hexDigit48 = 0\n    var hexDigit49 = 0\n    var hexDigit50\
    \ = 0\n    var hexDigit51 = 0\n    var hexDigit52 = 0\n    var hexDigit53 = 0\n\
    \    var hexDigit54 = 0\n    var hexDigit55 = 0\n    var hexDigit56 = 0\n    var\
    \ hexDigit57 = 0\n    var hexDigit58 = 0\n    var hexDigit59 = 0\n    var hexDigit60\
    \ = 0\n    var hexDigit61 = 0\n    var hexDigit62 = 0\n    var hexDigit63 = 0\n\
    \    var hexDigit64 = 0\n    var hexDigit65 = 0\n    var hexDigit66 = 0\n    var\
    \ hexDigit67 = 0\n    var hexDigit68 = 0\n    var hexDigit69 = 0\n    var hexDigit70\
    \ = 0\n    var hexDigit71 = 0\n    var hexDigit72 = 0\n    var hexDigit73 = 0\n\
    \    var hexDigit74 = 0\n    var hexDigit75 = 0\n    var hexDigit76 = 0\n    var\
    \ hexDigit77 = 0\n    var hexDigit78 = 0\n    var hexDigit79 = 0\n    var hexDigit80\
    \ = 0\n    var hexDigit81 = 0\n    var hexDigit82 = 0\n    var hexDigit83 = 0\n\
    \    var hexDigit84 = 0\n    var hex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp6ajrbwli.swift:110:9: error: type annotation missing in pattern\n\
    \    var hex\n        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for _ in 0..<nums.count {\n        if nums[_] == \"A\"\
    \ {\n            count += 1\n        } else if nums[_] == \"B\" {\n          \
    \  count += 1\n        } else if nums[_] == \"C\" {\n            count += 1\n\
    \        } else if nums[_] == \"D\" {\n            count += 1\n        } else\
    \ if nums[_] == \"E\" {\n            count += 1\n        } else if nums[_] ==\
    \ \"F\" {\n            count += 1\n        } else {\n            count += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3oic645d.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3oic645d.swift:27:17:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        if nums[_] == \"A\" {\n                ^\n/tmp/tmp3oic645d.swift:29:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"B\" {\n                       ^\n/tmp/tmp3oic645d.swift:31:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"C\" {\n                       ^\n/tmp/tmp3oic645d.swift:33:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"D\" {\n                       ^\n/tmp/tmp3oic645d.swift:35:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"E\" {\n                       ^\n/tmp/tmp3oic645d.swift:37:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        } else if nums[_] == \"F\" {\n                       ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"A\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"B\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"C\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"D\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"E\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"F\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"0\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"1\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"2\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmphh_x7o1i.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmphh_x7o1i.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmphh_x7o1i.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmphh_x7o1i.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmphh_x7o1i.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphh_x7o1i.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmphh_x7o1i.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmphh_x7o1i.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014013
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for _ in 0..<nums.count {\n        let digit = Int(nums[_],\
    \ radix: 16)\n        if digit == 11 || digit == 13 {\n            result += 2\n\
    \        } else if digit == 10 {\n            result += 3\n        } else if digit\
    \ == 9 {\n            result += 5\n        } else if digit == 8 {\n          \
    \  result += 7\n        } else if digit == 7 {\n            result += 11\n   \
    \     } else if digit == 6 {\n            result += 13\n        } else if digit\
    \ == 5 {\n            result += 17\n        } else if digit == 4 {\n         \
    \   result += 19\n        } else if digit == 3 {\n            result += 23\n \
    \       } else if digit == 2 {\n            result += 29\n        } else if digit\
    \ == 1 {\n            result += 31\n        } else {\n            result += 33\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmptpetokqy.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptpetokqy.swift:27:30:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        let digit = Int(nums[_], radix: 16)\n                             ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        if char >= '0' && char <= '9' {\n            count +=\
    \ Int(char) - 48\n        } else if char >= 'A' && char <= 'F' {\n           \
    \ count += Int(char) - 55\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpus0pydzm.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpus0pydzm.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpus0pydzm.swift:28:27: error: single-quoted string literal found, use '\"\
    '\n        } else if char >= 'A' && char <= 'F' {\n                          ^~~\n\
    \                          \"A\"\n/tmp/tmpus0pydzm.swift:28:42: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char >= 'A' && char <= 'F'\
    \ {\n                                         ^~~\n                          \
    \               \"F\"\n/tmp/tmpus0pydzm.swift:27:22: error: no exact matches in\
    \ call to initializer \n            count += Int(char) - 48\n                \
    \     ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects\
    \ value of type 'Float80' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_\
    \ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects\
    \ value of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public\
    \ init(_ _v: Builtin.Word)\n           ^\n/tmp/tmpus0pydzm.swift:29:22: error:\
    \ no exact matches in call to initializer \n            count += Int(char) - 55\n\
    \                     ^\nSwift.Int:7:12: note: candidate expects value of type\
    \ 'Float16' for parameter #1 (got 'Character')\n    pu"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    for index in 0..<nums.count {\n        let digit = Int(nums[index])\n\
    \        if digit < '0' || digit > '9' {\n            return -1\n        }\n \
    \       result *= 16\n        result += digit\n    }\n    if result < 2 {\n  \
    \      return -1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpds2hdqut.swift:28:20: error: single-quoted string literal found,\
    \ use '\"'\n        if digit < '0' || digit > '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpds2hdqut.swift:28:35: error: single-quoted\
    \ string literal found, use '\"'\n        if digit < '0' || digit > '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpds2hdqut.swift:24:20: error: 'characters' is unavailable: Please use String\
    \ directly\n    var nums = num.characters\n                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpds2hdqut.swift:27:29: error: no exact\
    \ matches in call to subscript \n        let digit = Int(nums[index])\n      \
    \                      ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: Exception
  stderr: 'tmp05k8eu7x/tmp05k8eu7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b1946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b1946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b19457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05k8eu7x                        0x00005602520ce264 <unavailable> + 4708

    5    libc.so.6                          0x00002b19b1e3b460 __libc_start_main +
    245

    6    tmp05k8eu7x                        0x00005602520cdee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var result = 0\n    var count = 0\n    for index in 0..<nums.count {\n  \
    \      let char = nums[index]\n        switch char {\n        case \"0\": // 0\n\
    \        case \"1\": // 1\n        case \"2\": // 2\n        case \"3\": // 3\n\
    \        case \"4\": // 4\n        case \"5\": // 5\n        case \"6\": // 6\n\
    \        case \"7\": // 7\n        case \"8\": // 8\n        case \"9\": // 9\n\
    \        case \"A\": // A\n        case \"B\": // B\n        case \"C\": // C\n\
    \        case \"D\": // D\n        case \"E\": // E\n        case \"F\": // F\n\
    \        default:\n            break\n        }\n        count += 1\n    }\n \
    \   for index in 0..<count {\n        let char = nums[index]\n        switch char\
    \ {\n        case \"2\": // 2\n        case \"3\": // 3\n        case \"5\": //\
    \ 5\n        case \"7\": // 7\n        case \"B\": // B\n        case \"D\": //\
    \ D\n        default:\n            break\n        }\n        result += 1\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp70cf3u0b.swift:30:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"0\": // 0\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp70cf3u0b.swift:31:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"1\":\
    \ // 1\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"2\": // 2\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"3\": // 3\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"4\": // 4\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"5\": // 5\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"6\": // 6\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:37:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"7\": // 7\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:38:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"8\": // 8\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:39:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"9\": // 9\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:40:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"A\": // A\n        ^~~~~~~~~\n                  break\n/tmp/tmp70cf3u0b.swift:41:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"B\": // B\n        ^~~~~~~~~\n        "
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    let numAsArray = numAsString.characters\n    let numAsArray2 = numAsArray.filter({$0\
    \ != \"A\" && $0 != \"B\" && $0 != \"C\" && $0 != \"D\" && $0 != \"E\" && $0 !=\
    \ \"F\"})\n    let numAsArray3 = numAsArray2.filter({$0 != \"0\"})\n    let numAsArray4\
    \ = numAsArray3.filter({$0 != \"1\"})\n    let numAsArray5 = numAsArray4.filter({$0\
    \ != \"2\"})\n    let numAsArray6 = numAsArray5.filter({$0 != \"3\"})\n    let\
    \ numAsArray7 = numAsArray6.filter({$0 != \"4\"})\n    let numAsArray8 = numAsArray7.filter({$0\
    \ != \"5\"})\n    let numAsArray9 = numAsArray8.filter({$0 != \"6\"})\n    let\
    \ numAsArray10 = numAsArray9.filter({$0 != \"7\"})\n    let numAsArray11 = numAsArray10.filter({$0\
    \ != \"8\"})\n    let numAsArray12 = numAsArray11.filter({$0 != \"9\"})\n    let\
    \ numAsArray13 = numAsArray12.filter({$0 != \"A\"})\n    let numAsArray14 = numAsArray13.filter({$0\
    \ != \"B\"})\n    let numAsArray15 = numAsArray14.filter({$0 != \"C\"})\n    let\
    \ numAsArray16 = numAsArray15.filter({$0 != \"D\"})\n    let numAsArray17 = numAsArray16.filter({$0\
    \ != \"E\"})\n    let numAsArray18 = numAsArray17.filter({$0 != \"F\"})\n    let\
    \ numAsArray19 = numAsArray18.filter({$0 != \"a\"})\n    let numAsArray20 = numAsArray19.filter({$0\
    \ != \"b\"})\n    let numAsArray21 = numAsArray20.filter({$0 != \"c\"})\n    let\
    \ numAsArray22 = numAsArray21.filter({$0 != \"d\"})\n    let numAsArray23 = numAsArray22.filter({$0\
    \ != \"e\"})\n    let numAsArray24 = numAsArray23.filter({$0 != \"f\"})\n    let\
    \ numAsArray25 = numAsArray24.filter({$0 != \"0\"})\n    let numAsArray26 = numAsArray25.filter({$0\
    \ != \"1\"})\n    let numAsArray27 = numAsArray26.filter({$0 != \"2\"})\n    let\
    \ numAsArray28 = numAsArray27.filter({\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpzm_2dibu.swift:56:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpzm_2dibu.swift:52:43:\
    \ note: to match this opening '('\n    let numAsArray28 = numAsArray27.filter({\n\
    \                                          ^\n/tmp/tmpzm_2dibu.swift:73:63: error:\
    \ expected '}' at end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpzm_2dibu.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpzm_2dibu.swift:25:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let numAsArray = numAsString.characters\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpzm_2dibu.swift:52:44: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    let\
    \ numAsArray28 = numAsArray27.filter({\n                                     \
    \      ^\n                                            _ in \n/tmp/tmpzm_2dibu.swift:52:44:\
    \ error: cannot convert value of type '()' to closure result type 'Bool'\n   \
    \ let numAsArray28 = numAsArray27.filter({\n                                 \
    \          ^\n/tmp/tmpzm_2dibu.swift:56:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var numsDigits = nums.map { UInt8(String($0))\
    \ }\n    var numsPrimes = numsDigits.filter { $0 % 2 == 0 }\n    var numsPrimesCount\
    \ = numsPrimes.count\n    var numsPrimesDigits = numsPrimes.map { UInt8(String($0))\
    \ }\n    var numsPrimesPrimes = numsPrimesDigits.filter { $0 % 2 == 0 }\n    var\
    \ numsPrimesPrimesCount = numsPrimesPrimes.count\n    var numsPrimesPrimesDigits\
    \ = numsPrimesPrimes.map { UInt8(String($0)) }\n    var numsPrimesPrimesPrimes\
    \ = numsPrimesPrimesDigits.filter { $0 % 2 == 0 }\n    var numsPrimesPrimesPrimesCount\
    \ = numsPrimesPrimesPrimes.count\n    var numsPrimesPrimesPrimesDigits = numsPrimesPrimesPrimes.map\
    \ { UInt8(String($0)) }\n    var numsPrimesPrimesPrimesPrimes = numsPrimesPrimesPrimesDigits.filter\
    \ { $0 % 2 == 0 }\n    var numsPrimesPrimesPrimesPrimesCount = numsPrimesPrimesPrimesPrimes.count\n\
    \    var numsPrimesPrimesPrimesPrimesDigits = numsPrimesPrimesPrimesPrimes.map\
    \ { UInt8(String($0)) }\n    var numsPrimesPrimesPrimesPrimesPrimes = numsPrimesPrimesPrimesPrimesDigits.filter\
    \ { $0 % 2 == 0 }\n    var numsPrimesPrimesPrimesPrimesCount = numsPrimesPrimesPrimesPrimesPrimes.count\n\
    \    var numsPrimesPrimesPrimesPrimesDigits = numsPrimesPrimesPrimesPrimesPrimes.map\
    \ { UInt8(String($0)) }\n    var numsPrimesPrimesPrimesPrimesPrimesPrimes = numsPrimesPrimesPrimesPrimesPrimesDigits.filter\
    \ { $0 % 2 == 0 }\n    var numsPrimesPrimesPrimesPrimesPrimesCount = numsPrimesPrimesPrimesPrimesPrimesPrimes.count\n\
    \    var numsPrimesPrimesPrimesPrimesPrimesDigits = numsPrimesPrimesPrimesPrimesPrimesPrimes.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpx585lkwm.swift:44:92: error: expected member name following '.'\n\
    \    var numsPrimesPrimesPrimesPrimesPrimesDigits = numsPrimesPrimesPrimesPrimesPrimesPrimes.\n\
    \                                                                            \
    \               ^\n/tmp/tmpx585lkwm.swift:24:20: error: 'characters' is unavailable:\
    \ Please use String directly\n    var nums = num.characters\n                \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpx585lkwm.swift:27:42:\
    \ error: value of optional type 'UInt8?' must be unwrapped to a value of type\
    \ 'UInt8'\n    var numsPrimes = numsDigits.filter { $0 % 2 == 0 }\n          \
    \                               ^\n/tmp/tmpx585lkwm.swift:27:42: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ var numsPrimes = numsDigits.filter { $0 % 2 == 0 }\n                       \
    \                  ^\n                                         (  ?? <#default\
    \ value#>)\n/tmp/tmpx585lkwm.swift:27:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    var numsPrimes = numsDigits.filter\
    \ { $0 % 2 == 0 }\n                                         ^\n              \
    \                             !\n/tmp/tmpx585lkwm.swift:42:52: error: use of local\
    \ variable 'numsPrimesPrimesPrimesPrimesPrimesDigits' before its declaration\n\
    \    var numsPrimesPrimesPrimesPrimesPrimesPrimes = numsPrimesPrimesPrimesPrimesPrimesDigits.filter\
    \ { $0 % 2 == 0 }\n                                                   ^\n/tmp/tmpx585lkwm.swift:44:9:\
    \ note: 'numsPrimesPrimesPrimesPrimesPrimesDigits' declared here\n    var numsPrimesPrimesPrimesPrimesPrimesDigits\
    \ = numsPrimesPrimesPrimesPrimesPrimesPrimes.\n        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased(),\
    \ num.isEmpty else {\n        return 0\n    }\n    var count = 0\n    for c in\
    \ num {\n        guard let digit = Int(c, radix: 16) else {\n            return\
    \ 0\n        }\n        if digit == 0 || digit == 1 {\n            continue\n\
    \        }\n        for d in 2...digit {\n            if digit % d == 0 {\n  \
    \              count += 1\n                break\n            }\n        }\n \
    \   }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz8aez6d9.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased(),\
    \ num.isEmpty else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmpz8aez6d9.swift:29:27:\
    \ error: initializer 'init(_:radix:)' requires that 'Character' conform to 'StringProtocol'\n\
    \        guard let digit = Int(c, radix: 16) else {\n                        \
    \  ^\nSwift.FixedWidthInteger:2:23: note: where 'S' = 'Character'\n    @inlinable\
    \ public init?<S>(_ text: S, radix: Int = 10) where S : StringProtocol\n     \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ char in num {\n        if char >= '0' && char <= '9' {\n            count +=\
    \ Int(char) - Int(Int(char))\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpgane1rg7.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmpgane1rg7.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmpgane1rg7.swift:27:22: error: no exact matches in call to initializer \n\
    \            count += Int(char) - Int(Int(char))\n                     ^\n/tmp/tmpgane1rg7.swift:27:22:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \            count += Int(char) - Int(Int(char))\n                     ^\n/tmp/tmpgane1rg7.swift:27:22:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \            count += Int(char) - Int(Int(char))\n                     ^\n/tmp/tmpgane1rg7.swift:27:22:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \            count += Int(char) - Int(Int(char))\n                     ^\n/tmp/tmpgane1rg7.swift:27:22:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \            count += Int(char) - Int(Int(char))\n                     ^\n/tmp/tmpgane1rg7.swift:27:22:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n            count += Int(char) - Int(Int(char))\n            \
    \         ^\n/tmp/tmpgane1rg7.swift:27:22: note: candidate expects value of type\
    \ 'Builtin.Word' for parameter #1 (got 'Character')\n            count += Int(char)\
    \ - Int(Int(char))\n                     ^\n/tmp/tmpgane1rg7.swift:27:38: error:\
    \ no exact matches in call to initializer \n            count += Int(char) - Int(Int(char))\n\
    \                                     ^\n/tmp/tmpgane1rg7.swift:27:38: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n       \
    \     count += Int(char) - Int(Int(char))\n                                  \
    \   ^\n/tmp/tmpgane1rg7.swift:27:38: note: candidate expects valu"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit\
    \ == \"F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpxfqn6bhi.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxfqn6bhi.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014333
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var sum = 0\n    for char\
    \ in num.characters {\n        switch char {\n        case \"A\":\n          \
    \  sum += 2\n        case \"B\":\n            sum += 3\n        case \"C\":\n\
    \            sum += 5\n        case \"D\":\n            sum += 7\n        case\
    \ \"E\":\n            sum += 11\n        case \"F\":\n            sum += 13\n\
    \        default:\n            sum += char.unicodeScalars.count\n        }\n \
    \   }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp0ztqup45.swift:25:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in num.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [Int] =\
    \ []\n    var hexNum: Int = 0\n    var hexChar: Character\n    var hexString:\
    \ String\n    var hexStringLen: Int\n    var hexStringIndex: Int\n    var hexStringIndex2:\
    \ Int\n    var hexStringIndex3: Int\n    var hexStringIndex4: Int\n    var hexStringIndex5:\
    \ Int\n    var hexStringIndex6: Int\n    var hexStringIndex7: Int\n    var hexStringIndex8:\
    \ Int\n    var hexStringIndex9: Int\n    var hexStringIndex10: Int\n    var hexStringIndex11:\
    \ Int\n    var hexStringIndex12: Int\n    var hexStringIndex13: Int\n    var hexStringIndex14:\
    \ Int\n    var hexStringIndex15: Int\n    var hexStringIndex16: Int\n    var hexStringIndex17:\
    \ Int\n    var hexStringIndex18: Int\n    var hexStringIndex19: Int\n    var hexStringIndex20:\
    \ Int\n    var hexStringIndex21: Int\n    var hexStringIndex22: Int\n    var hexStringIndex23:\
    \ Int\n    var hexStringIndex24: Int\n    var hexStringIndex25: Int\n    var hexStringIndex26:\
    \ Int\n    var hexStringIndex27: Int\n    var hexStringIndex28: Int\n    var hexStringIndex29:\
    \ Int\n    var hexStringIndex30: Int\n    var hexStringIndex31: Int\n    var hexStringIndex32:\
    \ Int\n    var hexStringIndex33: Int\n    var hexStringIndex34: Int\n    var hexStringIndex35:\
    \ Int\n    var hexStringIndex36: Int\n    var hexStringIndex37: Int\n    var hexStringIndex38:\
    \ Int\n    var hexStringIndex39: Int\n    var hexStringIndex40: Int\n    var hexStringIndex41:\
    \ Int\n    var hexStringIndex42: Int\n    var hexStringIndex43: Int\n    var hexStringIndex44:\
    \ Int\n    var hexStringIndex45: Int\n    var hexStringIndex46: Int\n    var hexStringIndex47:\
    \ Int\n    var hexStringIndex48: Int\n    var hexStringIndex49: Int\n    var hexStringIndex50:\
    \ Int\n    var hexStringIndex51: Int\n    var hexStringIndex52: Int\n    var hexStringIndex53:\
    \ Int\n    var hexStringIndex54: Int\n    var hexStringIndex55: Int\n    var hexStringIndex56:\
    \ Int\n    var hexStringIndex57: Int\n    var hexStringIndex58: Int\n    var hexStringIndex59:\
    \ Int\n    var hexStringIndex60: Int\n    var hexStringIndex61\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpvis9vber.swift:89:9: error: type annotation missing in pattern\n\
    \    var hexStringIndex61\n        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.uppercaseCharacterSet())\n\
    \    var hexDigits = hex.componentsSeparatedByString(\"0123456789ABCDEF\")\n \
    \   var hexDigitCount = hexDigits.count\n    var hexDigitPrimes = hexDigits.filter({$0\
    \ % 2 == 0})\n    var hexDigitPrimeCount = hexDigitPrimes.count\n    var hexDigitPrimePrimes\
    \ = hexDigitPrimes.filter({$0 % 3 == 0})\n    var hexDigitPrimePrimeCount = hexDigitPrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimes = hexDigitPrimePrimes.filter({$0 % 5 == 0})\n\
    \    var hexDigitPrimePrimePrimeCount = hexDigitPrimePrimePrimes.count\n    var\
    \ hexDigitPrimePrimePrimePrimes = hexDigitPrimePrimePrimes.filter({$0 % 7 == 0})\n\
    \    var hexDigitPrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimes.filter({$0\
    \ % 11 == 0})\n    var hexDigitPrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimes.filter({$0\
    \ % 13 == 0})\n    var hexDigitPrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter({$0\
    \ % 17 == 0})\n    var hexDigitPrimePrimePrimePrimePrimePrimePrimeCount = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter({$0\
    \ % 19 == 0})\n    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp3ti8vcr9.swift:24:51: error: cannot find 'NSCharacterSet' in scope\n\
    \    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.uppercaseCharacterSet())\n\
    \                                                  ^~~~~~~~~~~~~~\n/tmp/tmp3ti8vcr9.swift:24:19:\
    \ error: value of type 'String' has no member 'stringByTrimmingCharactersInSet'\n\
    \    var hex = num.stringByTrimmingCharactersInSet(NSCharacterSet.uppercaseCharacterSet())\n\
    \              ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ti8vcr9.swift:39:51:\
    \ error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimes' in scope\n\
    \    var hexDigitPrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimes.filter({$0\
    \ % 17 == 0})\n                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3ti8vcr9.swift:40:60: error: use of local variable 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ before its declaration\n    var hexDigitPrimePrimePrimePrimePrimePrimePrimeCount\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes.count\n                \
    \                                           ^\n/tmp/tmp3ti8vcr9.swift:41:9: note:\
    \ 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes' declared here\n    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes\
    \ = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter({$0 % 19 ==\
    \ 0})\n        ^\n/tmp/tmp3ti8vcr9.swift:41:61: error: cannot find 'hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes'\
    \ in scope\n    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimes = hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimes.filter({$0\
    \ % 19 == 0})\n                                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3ti8vcr9.swift:42:70: error: cannot find 'hexDigitPrimePrimePrime' in\
    \ scope\n    var hexDigitPrimePrimePrimePrimePrimePrimePrimePrimePrimeCount =\
    \ hexDigitPrimePrimePrime\n                                                  \
    \                   ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        if c >= '0' && c <= '9' {\n            count += Int(c -\
    \ '0')\n        } else if c >= 'A' && c <= 'F' {\n            count += Int(c -\
    \ 'A') + 10\n        } else if c >= 'a' && c <= 'f' {\n            count += Int(c\
    \ - 'a') + 10\n        } else {\n            return -1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz1nqa0bw.swift:26:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c >= '0' && c <= '9' {\n                ^~~\n         \
    \       \"0\"\n/tmp/tmpz1nqa0bw.swift:26:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c >= '0' && c <= '9' {\n                       \
    \     ^~~\n                            \"9\"\n/tmp/tmpz1nqa0bw.swift:27:30: error:\
    \ single-quoted string literal found, use '\"'\n            count += Int(c - '0')\n\
    \                             ^~~\n                             \"0\"\n/tmp/tmpz1nqa0bw.swift:28:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c >=\
    \ 'A' && c <= 'F' {\n                       ^~~\n                       \"A\"\n\
    /tmp/tmpz1nqa0bw.swift:28:36: error: single-quoted string literal found, use '\"\
    '\n        } else if c >= 'A' && c <= 'F' {\n                                \
    \   ^~~\n                                   \"F\"\n/tmp/tmpz1nqa0bw.swift:29:30:\
    \ error: single-quoted string literal found, use '\"'\n            count += Int(c\
    \ - 'A') + 10\n                             ^~~\n                            \
    \ \"A\"\n/tmp/tmpz1nqa0bw.swift:30:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c >= 'a' && c <= 'f' {\n                       ^~~\n\
    \                       \"a\"\n/tmp/tmpz1nqa0bw.swift:30:36: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c >= 'a' && c <= 'f' {\n \
    \                                  ^~~\n                                   \"\
    f\"\n/tmp/tmpz1nqa0bw.swift:31:30: error: single-quoted string literal found,\
    \ use '\"'\n            count += Int(c - 'a') + 10\n                         \
    \    ^~~\n                             \"a\"\n/tmp/tmpz1nqa0bw.swift:27:28: error:\
    \ binary operator '-' cannot be applied to two 'Character' operands\n        \
    \    count += Int(c - '0')\n                         ~ ^ ~~~\n/tmp/tmpz1nqa0bw.swift:29:28:\
    \ error: binary operator '-' cannot be applied to two 'Character' operands\n \
    \           count += Int(c - 'A') + 10\n                         ~ ^ ~~~\n/tmp/tmpz1nqa0bw.swift:31:28:\
    \ error: binary operator '-' cannot "
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for i in 0..<digits.count {\n        let digit\
    \ = Int(digits[i])\n        if digit == 0 || digit == 1 {\n            continue\n\
    \        }\n        if digit == 2 {\n            result += 2\n            continue\n\
    \        }\n        if digit == 3 {\n            result += 3\n            continue\n\
    \        }\n        if digit == 5 {\n            result += 5\n            continue\n\
    \        }\n        if digit == 7 {\n            result += 7\n            continue\n\
    \        }\n        if digit == 11 {\n            result += 11\n            continue\n\
    \        }\n        if digit == 13 {\n            result += 13\n            continue\n\
    \        }\n        if digit == 17 {\n            result += 17\n            continue\n\
    \        }\n        if digit == 19 {\n            result += 19\n            continue\n\
    \        }\n        if digit == 29 {\n            result += 29\n            continue\n\
    \        }\n        if digit == 37 {\n            result += 37\n            continue\n\
    \        }\n        if digit == 41 {\n            result += 41\n            continue\n\
    \        }\n        if digit == 431 {\n            result += 431\n           \
    \ continue\n        }\n        if digit == 479 {\n            result += 479\n\
    \            continue\n        }\n        if digit == 537 {\n            result\
    \ += 537\n            continue\n        }\n        if digit == 591 {\n       \
    \     result += 591\n            continue\n        }\n        if digit == 637\
    \ {\n            result += 637\n            continue\n        }\n        if digit\
    \ == 679 {\n            result += 679\n            continue\n        }\n     \
    \   if digit == 729 {\n            result += 729\n            continue\n     \
    \   }\n        if digit == 767 {\n            result += 767\n            continue\n\
    \        }\n        if digit == 811 {\n            result += 811\n           \
    \ continue\n        }\n        if digit == 837 {\n            result += 837\n\
    \            continue\n        }\n        if digit == 893 {\n            result\
    \ += 893\n            continue\n        }\n        if digit == 967 {\n       \
    \     result += 967\n            continue\n        }\n        if digit == 1023\
    \ {\n            result += 1023\n            continue\n        }\n        if digit\
    \ == 1059 {\n            result += 1059\n            continue\n        }\n   \
    \     if digit == 1091 {\n            result += 1091\n            continue\n \
    \       }\n        if digit == 1137 {\n            result += 1137\n          \
    \  continue\n        }\n        if digit == 1171 {\n            result += 1171\n\
    \            continue\n        }\n        if digit == 1213 {\n            result\
    \ += 1213\n            continue\n        }\n        if digit == 1249 {\n     \
    \       result += 1249\n            continue\n        }\n        if digit == 1277\
    \ {\n            result += 1277\n            continue\n        }\n        if digit\
    \ == 1311 {\n            result += 1311\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpa5ct6fsn.swift:177:63: error: expected '}' at end of brace statement\n\
    assert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)\n           \
    \                                                   ^\n/tmp/tmpa5ct6fsn.swift:26:31:\
    \ note: to match this opening '{'\n    for i in 0..<digits.count {\n         \
    \                     ^\n/tmp/tmpa5ct6fsn.swift:177:63: error: expected '}' at\
    \ end of brace statement\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)\n                                                              ^\n/tmp/tmpa5ct6fsn.swift:23:34:\
    \ note: to match this opening '{'\nfunc hex_key(num: String) -> Int {\n      \
    \                           ^\n/tmp/tmpa5ct6fsn.swift:25:22: error: 'characters'\
    \ is unavailable: Please use String directly\n    var digits = num.characters\n\
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpa5ct6fsn.swift:27:31: error: no exact matches in call to subscript\
    \ \n        let digit = Int(digits[i])\n                              ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmpa5ct6fsn.swift:160:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    let primes = primes()\n    var count = 0\n    for digit in digits {\n   \
    \     if primes.contains(digit) {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpbbgx_xnt.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbbgx_xnt.swift:25:18:\
    \ error: use of local variable 'primes' before its declaration\n    let primes\
    \ = primes()\n                 ^\n/tmp/tmpbbgx_xnt.swift:25:9: note: 'primes'\
    \ declared here\n    let primes = primes()\n        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let numAsString = num.lowercased()\n\
    \    var numAsInt: Int = 0\n    var numAsChar: Character?\n    var numAsIntArray:\
    \ [Int] = []\n    var numAsIntArrayIndex = 0\n    var numAsIntArrayIndex2 = 0\n\
    \    var numAsIntArrayIndex3 = 0\n    var numAsIntArrayIndex4 = 0\n    var numAsIntArrayIndex5\
    \ = 0\n    var numAsIntArrayIndex6 = 0\n    var numAsIntArrayIndex7 = 0\n    var\
    \ numAsIntArrayIndex8 = 0\n    var numAsIntArrayIndex9 = 0\n    var numAsIntArrayIndex10\
    \ = 0\n    var numAsIntArrayIndex11 = 0\n    var numAsIntArrayIndex12 = 0\n  \
    \  var numAsIntArrayIndex13 = 0\n    var numAsIntArrayIndex14 = 0\n    var numAsIntArrayIndex15\
    \ = 0\n    var numAsIntArrayIndex16 = 0\n    var numAsIntArrayIndex17 = 0\n  \
    \  var numAsIntArrayIndex18 = 0\n    var numAsIntArrayIndex19 = 0\n    var numAsIntArrayIndex20\
    \ = 0\n    var numAsIntArrayIndex21 = 0\n    var numAsIntArrayIndex22 = 0\n  \
    \  var numAsIntArrayIndex23 = 0\n    var numAsIntArrayIndex24 = 0\n    var numAsIntArrayIndex25\
    \ = 0\n    var numAsIntArrayIndex26 = 0\n    var numAsIntArrayIndex27 = 0\n  \
    \  var numAsIntArrayIndex28 = 0\n    var numAsIntArrayIndex29 = 0\n    var numAsIntArrayIndex30\
    \ = 0\n    var numAsIntArrayIndex31 = 0\n    var numAsIntArrayIndex32 = 0\n  \
    \  var numAsIntArrayIndex33 = 0\n    var numAsIntArrayIndex34 = 0\n    var numAsIntArrayIndex35\
    \ = 0\n    var numAsIntArrayIndex36 = 0\n    var numAsIntArrayIndex37 = 0\n  \
    \  var numAsIntArrayIndex38 = 0\n    var numAsIntArrayIndex39 = 0\n    var numAsIntArrayIndex40\
    \ = 0\n    var numAsIntArrayIndex41 = 0\n    var numAsIntArrayIndex42 = 0\n  \
    \  var numAsIntArrayIndex43 = 0\n    var numAsIntArrayIndex44 = 0\n    var numAsIntArrayIndex45\
    \ = 0\n    var numAsIntArrayIndex46 = 0\n    var numAsIntArrayIndex47 = 0\n  \
    \  var numAsIntArrayIndex48 = 0\n    var numAsIntArrayIndex49 = 0\n    var numAsIntArrayIndex50\
    \ = 0\n    var numAsIntArrayIndex51 = 0\n    var numAsIntArrayIndex52 = 0\n  \
    \  var numAsIntArrayIndex53 = 0\n    var num\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpy85gkrow.swift:81:9: error: type annotation missing in pattern\n\
    \    var num\n        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var primes = Array<Int>()\n    var prime = Int(2)\n    var count = 0\n  \
    \  for char in nums {\n        let digit = Int(char) - Int(97)\n        if digit\
    \ < 0 || digit > 9 {\n            return -1\n        }\n        if prime % digit\
    \ == 0 {\n            primes.append(prime)\n            prime = Int(prime) + 1\n\
    \        }\n    }\n    for prime in primes {\n        if prime % 2 == 0 {\n  \
    \          count = count + 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpibzdn0t1.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpibzdn0t1.swift:29:21:\
    \ error: no exact matches in call to initializer \n        let digit = Int(char)\
    \ - Int(97)\n                    ^\nSwift.Int:7:12: note: candidate expects value\
    \ of type 'Float16' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float16)\n           ^\nSwift.Int:10:12: note: candidate expects value of type\
    \ 'Float' for parameter #1 (got 'Character')\n    public init(_ source: Float)\n\
    \           ^\nSwift.Int:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Double)\n    \
    \       ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float80)\n       \
    \    ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    // Your code here\n  \
    \  var numArray: [Int] = []\n    for char in num {\n        let charInt = Int(char)\n\
    \        if charInt >= 48 && charInt <= 57 {\n            numArray.append(charInt\
    \ - 48)\n        }\n    }\n    var count = 0\n    for index in 0..<numArray.count\
    \ {\n        let index = numArray[index]\n        if index == 2 || index == 3\
    \ || index == 5 || index == 7 || index == 11 || index == 13 {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpk2tcaf_l.swift:27:23: error: no exact matches in call to initializer\
    \ \n        let charInt = Int(char)\n                      ^\nSwift.Int:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init?(_ description: String)\n                      ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [Int] =\
    \ []\n    for c in num {\n        guard let digit = Int(c, radix: 16) else {\n\
    \            return -1\n        }\n        hexDigits.append(digit)\n    }\n  \
    \  var primeCount = 0\n    for digit in hexDigits {\n        if digit % 2 == 0\
    \ {\n            primeCount += 1\n        }\n    }\n    return primeCount\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp29907hm8.swift:26:27: error: initializer 'init(_:radix:)' requires\
    \ that 'Character' conform to 'StringProtocol'\n        guard let digit = Int(c,\
    \ radix: 16) else {\n                          ^\nSwift.FixedWidthInteger:2:23:\
    \ note: where 'S' = 'Character'\n    @inlinable public init?<S>(_ text: S, radix:\
    \ Int = 10) where S : StringProtocol\n                      ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let hex = nums[index]\
    \ as String\n        if hex.lowercased() == \"a\" {\n            count += 1\n\
    \        } else if hex.lowercased() == \"b\" {\n            count += 1\n     \
    \   } else if hex.lowercased() == \"c\" {\n            count += 1\n        } else\
    \ if hex.lowercased() == \"d\" {\n            count += 1\n        } else if hex.lowercased()\
    \ == \"e\" {\n            count += 1\n        } else if hex.lowercased() == \"\
    f\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp75h89_9d.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp75h89_9d.swift:27:31:\
    \ error: cannot convert value of type 'Character' to type 'String' in coercion\n\
    \        let hex = nums[index] as String\n                  ~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var numsLen = nums.count\n    var numsLen2\
    \ = numsLen / 2\n    var numsLen3 = numsLen / 3\n    var numsLen4 = numsLen /\
    \ 4\n    var numsLen5 = numsLen / 5\n    var numsLen6 = numsLen / 6\n    var numsLen7\
    \ = numsLen / 7\n    var numsLen8 = numsLen / 8\n    var numsLen9 = numsLen /\
    \ 9\n    var numsLen10 = numsLen / 10\n    var numsLen11 = numsLen / 11\n    var\
    \ numsLen12 = numsLen / 12\n    var numsLen13 = numsLen / 13\n    var numsLen14\
    \ = numsLen / 14\n    var numsLen15 = numsLen / 15\n    var numsLen16 = numsLen\
    \ / 16\n    var numsLen17 = numsLen / 17\n    var numsLen18 = numsLen / 18\n \
    \   var numsLen19 = numsLen / 19\n    var numsLen20 = numsLen / 20\n    var numsLen21\
    \ = numsLen / 21\n    var numsLen22 = numsLen / 22\n    var numsLen23 = numsLen\
    \ / 23\n    var numsLen24 = numsLen / 24\n    var numsLen25 = numsLen / 25\n \
    \   var numsLen26 = numsLen / 26\n    var numsLen27 = numsLen / 27\n    var numsLen28\
    \ = numsLen / 28\n    var numsLen29 = numsLen / 29\n    var numsLen30 = numsLen\
    \ / 30\n    var numsLen31 = numsLen / 31\n    var numsLen32 = numsLen / 32\n \
    \   var numsLen33 = numsLen / 33\n    var numsLen34 = numsLen / 34\n    var numsLen35\
    \ = numsLen / 35\n    var numsLen36 = numsLen / 36\n    var numsLen37 = numsLen\
    \ / 37\n    var numsLen38 = numsLen / 38\n    var numsLen39 = numsLen / 39\n \
    \   var numsLen40 = numsLen / 40\n    var numsLen41 = numsLen / 41\n    var numsLen42\
    \ = numsLen / 42\n    var numsLen43 = num\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpz9_hddxm.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpz9_hddxm.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpz9_hddxm.swift:25:9:\
    \ warning: initialization of variable 'numsCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsCount = nums.count\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpz9_hddxm.swift:26:9: warning: variable 'numsLen' was never mutated;\
    \ consider changing to 'let' constant\n    var numsLen = nums.count\n    ~~~ ^\n\
    \    let\n/tmp/tmpz9_hddxm.swift:27:9: warning: initialization of variable 'numsLen2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var numsLen2 = numsLen / 2\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpz9_hddxm.swift:28:9:\
    \ warning: initialization of variable 'numsLen3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsLen3 = numsLen / 3\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpz9_hddxm.swift:29:9: warning: initialization of variable 'numsLen4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var numsLen4 = numsLen / 4\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpz9_hddxm.swift:30:9:\
    \ warning: initialization of variable 'numsLen5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsLen5 = numsLen / 5\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpz9_hddxm.swift:31:9: warning: initialization of variable 'numsLen6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var numsLen6 = numsLen / 6\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpz9_hddxm.swift:32:9:\
    \ warning: initialization of variable 'numsLen7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsLen7 = numsLen / 7\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpz9_hddxm.swift:33:9:"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    let digits = num.characters\n\
    \    var count = 0\n    for digit in digits {\n        if digit == \"A\" || digit\
    \ == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"\
    F\" {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpdxnnxpa1.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var numAsString = \"\"\
    \n    for char in num {\n        if char >= '0' && char <= '9' {\n           \
    \ numAsString += char\n        }\n    }\n    var numAsInt: Int = 0\n    var isPrime:\
    \ Bool = false\n    var prime: Int = 0\n    var primes: Int = 0\n    var isPrime2:\
    \ Bool = false\n    var prime2: Int = 0\n    var primes2: Int = 0\n    var isPrime3:\
    \ Bool = false\n    var prime3: Int = 0\n    var primes3: Int = 0\n    var isPrime4:\
    \ Bool = false\n    var prime4: Int = 0\n    var primes4: Int = 0\n    var isPrime5:\
    \ Bool = false\n    var prime5: Int = 0\n    var primes5: Int = 0\n    var isPrime6:\
    \ Bool = false\n    var prime6: Int = 0\n    var primes6: Int = 0\n    var isPrime7:\
    \ Bool = false\n    var prime7: Int = 0\n    var primes7: Int = 0\n    var isPrime8:\
    \ Bool = false\n    var prime8: Int = 0\n    var primes8: Int = 0\n    var isPrime9:\
    \ Bool = false\n    var prime9: Int = 0\n    var primes9: Int = 0\n    var isPrime10:\
    \ Bool = false\n    var prime10: Int = 0\n    var primes10: Int = 0\n    var isPrime11:\
    \ Bool = false\n    var prime11: Int = 0\n    var primes11: Int = 0\n    var isPrime12:\
    \ Bool = false\n    var prime12: Int = 0\n    var primes12: Int = 0\n    var isPrime13:\
    \ Bool = false\n    var prime13: Int = 0\n    var primes13: Int = 0\n    var isPrime14:\
    \ Bool = false\n    var prime14: Int = 0\n    var primes14: Int = 0\n    var isPrime15:\
    \ Bool = false\n    var prime15: Int = 0\n    var primes15: Int = 0\n    var isPrime16:\
    \ Bool = false\n    var prime16: Int = 0\n    var primes16: Int = 0\n    var isPrime17:\
    \ Bool = false\n    var prime17: Int = 0\n    var primes17: Int = 0\n    var isPrime18:\
    \ Bool = false\n    var prime18: Int = 0\n    var primes18: Int = 0\n    var isPrime19:\
    \ Bool = false\n    var prime19: Int = 0\n    var primes19: Int = 0\n    var isPrime20:\
    \ Bool = false\n    var prime20: Int = 0\n    var primes20: Int = 0\n    var isPrime21:\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\n\
    assert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\n\
    assert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmppsgms14t.swift:26:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char >= '0' && char <= '9' {\n                   ^~~\n\
    \                   \"0\"\n/tmp/tmppsgms14t.swift:26:35: error: single-quoted\
    \ string literal found, use '\"'\n        if char >= '0' && char <= '9' {\n  \
    \                                ^~~\n                                  \"9\"\n\
    /tmp/tmppsgms14t.swift:91:19: error: expected type\n    var isPrime21: \n    \
    \              ^\n                   <#type#>\n/tmp/tmppsgms14t.swift:27:28: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            numAsString += char\n                           ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    guard let num = num.lowercased()\
    \ else {\n        return 0\n    }\n    var count = 0\n    var prime = 0\n    var\
    \ prime2 = 0\n    var prime3 = 0\n    var prime4 = 0\n    var prime5 = 0\n   \
    \ var prime6 = 0\n    var prime7 = 0\n    var prime8 = 0\n    var prime9 = 0\n\
    \    var prime10 = 0\n    var prime11 = 0\n    var prime12 = 0\n    var prime13\
    \ = 0\n    var prime14 = 0\n    var prime15 = 0\n    var prime16 = 0\n    var\
    \ prime17 = 0\n    var prime18 = 0\n    var prime19 = 0\n    var prime20 = 0\n\
    \    var prime21 = 0\n    var prime22 = 0\n    var prime23 = 0\n    var prime24\
    \ = 0\n    var prime25 = 0\n    var prime26 = 0\n    var prime27 = 0\n    var\
    \ prime28 = 0\n    var prime29 = 0\n    var prime30 = 0\n    var prime31 = 0\n\
    \    var prime32 = 0\n    var prime33 = 0\n    var prime34 = 0\n    var prime35\
    \ = 0\n    var prime36 = 0\n    var prime37 = 0\n    var prime38 = 0\n    var\
    \ prime39 = 0\n    var prime40 = 0\n    var prime41 = 0\n    var prime42 = 0\n\
    \    var prime43 = 0\n    var prime44 = 0\n    var prime45 = 0\n    var prime46\
    \ = 0\n    var prime47 = 0\n    var prime48 = 0\n    var prime49 = 0\n    var\
    \ prime50 = 0\n    var prime51 = 0\n    var prime52 = 0\n    var prime53 = 0\n\
    \    var prime54 = 0\n    var prime55 = 0\n    var prime56 = 0\n    var prime57\
    \ = 0\n    var prime58 = 0\n    var prime59 = 0\n    var prime60 = 0\n    var\
    \ prime61 = 0\n    var prime62 = 0\n    var prime63 = 0\n    var prime64 = 0\n\
    \    var prime65 = 0\n    var prime66 = 0\n    var prime67 = 0\n    var prime68\
    \ = 0\n    var prime69 = 0\n    var prime70 = 0\n    var prime71 = 0\n    var\
    \ prime72 = 0\n    var prime73 = 0\n    var prime74 = 0\n    var prime75 = 0\n\
    \    var prime76 = 0\n    var prime77 = 0\n    var prime78 = 0\n    var prime79\
    \ = 0\n    var prime80 = 0\n    var prime81 = 0\n    var prime82 = 0\n    var\
    \ prime83 = 0\n    var prime84 = 0\n    var prime85 = 0\n    var prime86 = 0\n\
    \    var prime87 = 0\n    var prime88 = 0\n    var prime89 = 0\n    var prime90\
    \ = 0\n    var prime91 = 0\n    var prime92 = 0\n    var prime93 = 0\n    var\
    \ prime94 = 0\n    var prime95 = 0\n    var prime96 = 0\n    var prime97 = 0\n\
    \    var prime98 = 0\n    var prime99 = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp83qpl283.swift:24:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let num = num.lowercased()\
    \ else {\n          ^         ~~~~~~~~~~~~~~~~\n/tmp/tmp83qpl283.swift:24:15:\
    \ warning: value 'num' was defined but never used; consider replacing with boolean\
    \ test\n    guard let num = num.lowercased() else {\n          ~~~~^~~~~~\n  \
    \                                   != nil\n/tmp/tmp83qpl283.swift:27:9: warning:\
    \ initialization of variable 'count' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmp83qpl283.swift:28:9:\
    \ warning: initialization of variable 'prime' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime = 0\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmp83qpl283.swift:29:9: warning: initialization of variable 'prime2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime2 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:30:9: warning:\
    \ initialization of variable 'prime3' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var prime3 = 0\n    ~~~~^~~~~~\n    _\n\
    /tmp/tmp83qpl283.swift:31:9: warning: initialization of variable 'prime4' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ prime4 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:32:9: warning: initialization\
    \ of variable 'prime5' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var prime5 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:33:9:\
    \ warning: initialization of variable 'prime6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime6 = 0\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp83qpl283.swift:34:9: warning: initialization of variable 'prime7'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime7 = 0\n    ~~~~^~~~~~\n    _\n/tmp/tmp83qpl283.swift:35:9: warning:\
    \ initialization of variable 'prime8' was never used; consider replacing with\
    \ assignment to '_' or removi"
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var nums_len = nums.count\n    var nums_hex = [Int]()\n    var nums_hex_len\
    \ = nums_hex.count\n    var nums_hex_len2 = nums_hex_len * 2\n    var nums_hex_len3\
    \ = nums_hex_len * 3\n    var nums_hex_len4 = nums_hex_len * 4\n    var nums_hex_len5\
    \ = nums_hex_len * 5\n    var nums_hex_len6 = nums_hex_len * 6\n    var nums_hex_len7\
    \ = nums_hex_len * 7\n    var nums_hex_len8 = nums_hex_len * 8\n    var nums_hex_len9\
    \ = nums_hex_len * 9\n    var nums_hex_len10 = nums_hex_len * 10\n    var nums_hex_len11\
    \ = nums_hex_len * 11\n    var nums_hex_len12 = nums_hex_len * 12\n    var nums_hex_len13\
    \ = nums_hex_len * 13\n    var nums_hex_len14 = nums_hex_len * 14\n    var nums_hex_len15\
    \ = nums_hex_len * 15\n    var nums_hex_len16 = nums_hex_len * 16\n    var nums_hex_len17\
    \ = nums_hex_len * 17\n    var nums_hex_len18 = nums_hex_len * 18\n    var nums_hex_len19\
    \ = nums_hex_len * 19\n    var nums_hex_len20 = nums_hex_len * 20\n    var nums_hex_len21\
    \ = nums_hex_len * 21\n    var nums_hex_len22 = nums_hex_len * 22\n    var nums_hex_len23\
    \ = nums_hex_len * 23\n    var nums_hex_len24 = nums_hex_len * 24\n    var nums_hex_len25\
    \ = nums_hex_len * 25\n    var nums_hex_len26 = nums_hex_len * 26\n    var nums_hex_len27\
    \ = nums_hex_len * 27\n    var nums_hex_len28 = nums_hex_len * 28\n    var nums_hex_len29\
    \ = nums_hex_len * 29\n    var nums_hex_len30 = nums_hex_len * 30\n    var nums_hex_len31\
    \ = nums_hex_len * 31\n    var nums_hex_len32 = nums_hex_len * 32\n    var nums_hex_len33\
    \ = nums_hex_len * 33\n    var nums_hex_len34 = nums_hex_len * 34\n    var nums_hex_len35\
    \ = nums_hex_len * 35\n    var nums_hex_len36 = nums_hex_len * 36\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpmcxk2kly.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmcxk2kly.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmpmcxk2kly.swift:25:9:\
    \ warning: initialization of variable 'nums_len' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums_len = nums.count\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmpmcxk2kly.swift:26:9: warning: variable 'nums_hex' was never mutated;\
    \ consider changing to 'let' constant\n    var nums_hex = [Int]()\n    ~~~ ^\n\
    \    let\n/tmp/tmpmcxk2kly.swift:27:9: warning: variable 'nums_hex_len' was never\
    \ mutated; consider changing to 'let' constant\n    var nums_hex_len = nums_hex.count\n\
    \    ~~~ ^\n    let\n/tmp/tmpmcxk2kly.swift:28:9: warning: initialization of variable\
    \ 'nums_hex_len2' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var nums_hex_len2 = nums_hex_len * 2\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpmcxk2kly.swift:29:9: warning: initialization of variable 'nums_hex_len3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums_hex_len3 = nums_hex_len * 3\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpmcxk2kly.swift:30:9:\
    \ warning: initialization of variable 'nums_hex_len4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var nums_hex_len4 = nums_hex_len\
    \ * 4\n    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpmcxk2kly.swift:31:9: warning: initialization\
    \ of variable 'nums_hex_len5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var nums_hex_len5 = nums_hex_len * 5\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpmcxk2kly.swift:32:9: warning: initialization of variable 'nums_hex_len6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var nums_hex_len6 = nums_he"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    for index in 0..<nums.count {\n        let char = nums[index]\n\
    \        if char == \"A\" || char == \"B\" || char == \"C\" || char == \"D\" ||\
    \ char == \"E\" || char == \"F\" {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp63w5wa39.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp63w5wa39.swift:27:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = nums[index]\n              \
    \     ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp63w5wa39.swift:24:9: warning: variable 'nums' was never\
    \ mutated; consider changing to 'let' constant\n    var nums = num.characters\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [Int] =\
    \ []\n    var primeCount = 0\n    var prime: Int = 0\n    var digit: Int = 0\n\
    \    var digitString: String = \"\"\n    var digitStringLen: Int = 0\n    var\
    \ digitStringLen2: Int = 0\n    var digitStringLen3: Int = 0\n    var digitStringLen4:\
    \ Int = 0\n    var digitStringLen5: Int = 0\n    var digitStringLen6: Int = 0\n\
    \    var digitStringLen7: Int = 0\n    var digitStringLen8: Int = 0\n    var digitStringLen9:\
    \ Int = 0\n    var digitStringLen10: Int = 0\n    var digitStringLen11: Int =\
    \ 0\n    var digitStringLen12: Int = 0\n    var digitStringLen13: Int = 0\n  \
    \  var digitStringLen14: Int = 0\n    var digitStringLen15: Int = 0\n    var digitStringLen16:\
    \ Int = 0\n    var digitStringLen17: Int = 0\n    var digitStringLen18: Int =\
    \ 0\n    var digitStringLen19: Int = 0\n    var digitStringLen20: Int = 0\n  \
    \  var digitStringLen21: Int = 0\n    var digitStringLen22: Int = 0\n    var digitStringLen23:\
    \ Int = 0\n    var digitStringLen24: Int = 0\n    var digitStringLen25: Int =\
    \ 0\n    var digitStringLen26: Int = 0\n    var digitStringLen27: Int = 0\n  \
    \  var digitStringLen28: Int = 0\n    var digitStringLen29: Int = 0\n    var digitStringLen30:\
    \ Int = 0\n    var digitStringLen31: Int = 0\n    var digitStringLen32: Int =\
    \ 0\n    var digitStringLen33: Int = 0\n    var digitStringLen34: Int = 0\n  \
    \  var digitStringLen35: Int = 0\n    var digitStringLen36: Int = 0\n    var digitStringLen37:\
    \ Int = 0\n    var digitStringLen38: Int = 0\n    var digitStringLen39: Int =\
    \ 0\n    var digitStringLen40: Int = 0\n    var digitStringLen41: Int = 0\n  \
    \  var digitStringLen42: Int = 0\n    var digitStringLen43: Int = 0\n    var digitStringLen44:\
    \ Int = 0\n    var digitStringLen45: Int = 0\n    var digitStringLen46: Int =\
    \ 0\n    var digitStringLen47: Int = 0\n    var digitStringLen48: Int = 0\n  \
    \  var digitStringLen49: Int = 0\n    var digitStringLen50: Int = 0\n    var digitStringLen51:\
    \ Int = 0\n    var digitStringLen52: Int = 0\n    var digitStringLen53: Int =\
    \ 0\n    var digitStringLen54: Int = 0\n    var \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\"\
    ) == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\"\
    ) == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp1dfxj7s8.swift:83:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp1dfxj7s8.swift:24:9: warning: variable 'hexDigits' was never used;\
    \ consider replacing with '_' or removing it\n    var hexDigits: [Int] = []\n\
    \        ^~~~~~~~~\n        _\n/tmp/tmp1dfxj7s8.swift:25:9: warning: initialization\
    \ of variable 'primeCount' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var primeCount = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp1dfxj7s8.swift:26:9:\
    \ warning: variable 'prime' was never used; consider replacing with '_' or removing\
    \ it\n    var prime: Int = 0\n        ^~~~~\n        _\n/tmp/tmp1dfxj7s8.swift:27:9:\
    \ warning: variable 'digit' was never used; consider replacing with '_' or removing\
    \ it\n    var digit: Int = 0\n        ^~~~~\n        _\n/tmp/tmp1dfxj7s8.swift:28:9:\
    \ warning: variable 'digitString' was never used; consider replacing with '_'\
    \ or removing it\n    var digitString: String = \"\"\n        ^~~~~~~~~~~\n  \
    \      _\n/tmp/tmp1dfxj7s8.swift:29:9: warning: variable 'digitStringLen' was\
    \ never used; consider replacing with '_' or removing it\n    var digitStringLen:\
    \ Int = 0\n        ^~~~~~~~~~~~~~\n        _\n/tmp/tmp1dfxj7s8.swift:30:9: warning:\
    \ variable 'digitStringLen2' was never used; consider replacing with '_' or removing\
    \ it\n    var digitStringLen2: Int = 0\n        ^~~~~~~~~~~~~~~\n        _\n/tmp/tmp1dfxj7s8.swift:31:9:\
    \ warning: variable 'digitStringLen3' was never used; consider replacing with\
    \ '_' or removing it\n    var digitStringLen3: Int = 0\n        ^~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmp1dfxj7s8.swift:32:9: warning: variable 'digitStringLen4' was\
    \ never used; consider replacing with '_' or removing it\n    var digitStringLen4:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~\n        _\n/tmp/tmp1dfxj7s8.swift:33:9: warning:\
    \ variable 'digitStringLen5' was never used; consider replacing with '_' or removing\
    \ it\n    var digitStringLen5: Int = 0\n        ^~~~~~~~~~~~~~~\n        _\n/tmp/tmp1dfxj7s8.swift:34:9:\
    \ warning: variable 'digitStringLen6' was never used; consider replacing with\
    \ '_' or removing it\n    var digitStringLe"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var count = 0\n    var prime = 0\n    var prime2 = 2\n    var prime3 = 3\n\
    \    var prime5 = 5\n    var prime7 = 7\n    var prime11 = 1\n    var prime13\
    \ = 3\n    var prime17 = 7\n    var prime19 = 7\n    var prime23 = 3\n    var\
    \ prime29 = 3\n    var prime31 = 5\n    var prime37 = 7\n    var prime41 = 7\n\
    \    var prime43 = 11\n    var prime47 = 13\n    var prime51 = 17\n    var prime59\
    \ = 19\n    var prime63 = 23\n    var prime67 = 29\n    var prime71 = 31\n   \
    \ var prime73 = 37\n    var prime79 = 41\n    var prime83 = 43\n    var prime89\
    \ = 47\n    var prime93 = 51\n    var prime97 = 59\n    var prime101 = 63\n  \
    \  var prime103 = 67\n    var prime107 = 71\n    var prime109 = 73\n    var prime113\
    \ = 79\n    var prime127 = 83\n    var prime131 = 89\n    var prime137 = 93\n\
    \    var prime143 = 97\n    var prime147 = 101\n    var prime151 = 103\n    var\
    \ prime157 = 107\n    var prime163 = 113\n    var prime167 = 127\n    var prime173\
    \ = 131\n    var prime177 = 137\n    var prime181 = 143\n    var prime183 = 147\n\
    \    var prime187 = 151\n    var prime191 = 157\n    var prime193 = 163\n    var\
    \ prime197 = 167\n    var prime201 = 181\n    var prime203 = 183\n    var prime207\
    \ = 187\n    var prime211 = 191\n    var prime213 = 193\n    var prime217 = 197\n\
    \    var prime221 = 201\n    var prime223 = 203\n    var prime227 = 207\n    var\
    \ prime229 = 211\n    var prime233 = 213\n    var prime237 = 217\n    var prime241\
    \ = 221\n    var prime243 = 223\n    var prime247 = 227\n    var prime251 = 229\n\
    \    var prime253 = 233\n    var prime257 = 247\n    var prime261 = 251\n    var\
    \ prime263 = 253\n    var prime267 = 257\n    var prime271 = 263\n    var prime273\
    \ = 267\n    var prime277 = 271\n    var prime281 = 273\n    var prime283 = 277\n\
    \    var prime287 = 281\n    var prime289 = 283\n    var prime293 = 287\n    var\
    \ prime297 = 289\n    var prime301 = 293\n    var prime303 = 297\n    var prime307\
    \ = 301\n    var prime311 = 3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpu6a72xzw.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu6a72xzw.swift:24:9:\
    \ warning: initialization of variable 'nums' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var nums = num.characters\n    ~~~~^~~~\n\
    \    _\n/tmp/tmpu6a72xzw.swift:25:9: warning: initialization of variable 'count'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var count = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpu6a72xzw.swift:26:9: warning:\
    \ initialization of variable 'prime' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var prime = 0\n    ~~~~^~~~~\n    _\n/tmp/tmpu6a72xzw.swift:27:9:\
    \ warning: initialization of variable 'prime2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime2 = 2\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmpu6a72xzw.swift:28:9: warning: initialization of variable 'prime3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var prime3 = 3\n    ~~~~^~~~~~\n    _\n/tmp/tmpu6a72xzw.swift:29:9: warning:\
    \ initialization of variable 'prime5' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var prime5 = 5\n    ~~~~^~~~~~\n    _\n\
    /tmp/tmpu6a72xzw.swift:30:9: warning: initialization of variable 'prime7' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ prime7 = 7\n    ~~~~^~~~~~\n    _\n/tmp/tmpu6a72xzw.swift:31:9: warning: initialization\
    \ of variable 'prime11' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var prime11 = 1\n    ~~~~^~~~~~~\n    _\n/tmp/tmpu6a72xzw.swift:32:9:\
    \ warning: initialization of variable 'prime13' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var prime13 = 3\n    ~~~~^~~~~~~\n\
    \    _\n/tmp/tmpu6a72xzw.swift:33:9: warning: initialization of variable 'prime17'\
    \ wa"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums: [Int] = []\n\
    \    for c in num.unicodeScalars {\n        if c.value > 0xFF {\n            return\
    \ -1\n        }\n        nums.append(Int(c.value))\n    }\n    var primes: [Int]\
    \ = []\n    for n in nums {\n        if n % 2 == 0 {\n            primes.append(n)\n\
    \        }\n    }\n    var result: Int = 0\n    for p in primes {\n        if\
    \ p > 1 {\n            for q in primes {\n                if q > p {\n       \
    \             if p % q == 0 {\n                        result = p\n          \
    \              break\n                    }\n                }\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmpri4mdowi/tmpri4mdowi.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33a1981c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33a1678b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33a1678988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33a16777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpri4mdowi                        0x00005647eb4468c4 <unavailable> + 6340

    5    libc.so.6                          0x00002b33a1b6d460 __libc_start_main +
    245

    6    tmpri4mdowi                        0x00005647eb446549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            result = result + 2\n        } else if digit == \"B\" {\n   \
    \         result = result + 3\n        } else if digit == \"C\" {\n          \
    \  result = result + 5\n        } else if digit == \"D\" {\n            result\
    \ = result + 7\n        } else if digit == \"E\" {\n            result = result\
    \ + 11\n        } else if digit == \"F\" {\n            result = result + 13\n\
    \        } else {\n            result = result + digit.unicodeScalars.count\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num:\
    \ \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num:\
    \ \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpqibabf1i.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqibabf1i.swift:25:9:\
    \ warning: variable 'digits' was never mutated; consider changing to 'let' constant\n\
    \    var digits = num.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: -4
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    for\
    \ c in num {\n        switch c {\n        case \"0\", \"1\", \"2\", \"3\", \"\
    4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"\
    F\":\n            count += 1\n        default:\n            break\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num:\
    \ \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"\
    ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"\
    123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: Exception
  stderr: 'tmphu5lm__f/tmphu5lm__f.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afee184fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afee1546b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afee1546988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afee15457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphu5lm__f                        0x0000565077d1f414 <unavailable> + 5140

    5    libc.so.6                          0x00002afee1a3b460 __libc_start_main +
    245

    6    tmphu5lm__f                        0x0000565077d1f099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014014
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var result = 0\n    var\
    \ digits = num.characters\n    for digit in digits {\n        if digit == \"A\"\
    \ {\n            result += 2\n        } else if digit == \"B\" {\n           \
    \ result += 3\n        } else if digit == \"C\" {\n            result += 5\n \
    \       } else if digit == \"D\" {\n            result += 7\n        } else if\
    \ digit == \"E\" {\n            result += 11\n        } else if digit == \"F\"\
    \ {\n            result += 13\n        } else {\n            result += digit -\
    \ \"0\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\n\
    assert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\n\
    assert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\"\
    ) == 12)"
  status: SyntaxError
  stderr: "/tmp/tmplzmwlxrn.swift:25:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var digits = num.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmplzmwlxrn.swift:40:20:\
    \ error: binary operator '+=' cannot be applied to operands of type 'Int' and\
    \ '_'\n            result += digit - \"0\"\n                   ^\nSwift.SIMD:1:11:\
    \ note: candidate requires that 'Int' conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FloatingPoint {\n  \
    \        ^\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var nums = num.characters\n\
    \    var numsCount = nums.count\n    var hexDigits = [String]()\n    var hexDigitCount\
    \ = 0\n    var hexDigitCount2 = 0\n    var hexDigitCount3 = 0\n    var hexDigitCount4\
    \ = 0\n    var hexDigitCount5 = 0\n    var hexDigitCount6 = 0\n    var hexDigitCount7\
    \ = 0\n    var hexDigitCount8 = 0\n    var hexDigitCount9 = 0\n    var hexDigitCount10\
    \ = 0\n    var hexDigitCount11 = 0\n    var hexDigitCount12 = 0\n    var hexDigitCount13\
    \ = 0\n    var hexDigitCount14 = 0\n    var hexDigitCount15 = 0\n    var hexDigitCount16\
    \ = 0\n    var hexDigitCount17 = 0\n    var hexDigitCount18 = 0\n    var hexDigitCount19\
    \ = 0\n    var hexDigitCount20 = 0\n    var hexDigitCount21 = 0\n    var hexDigitCount22\
    \ = 0\n    var hexDigitCount23 = 0\n    var hexDigitCount24 = 0\n    var hexDigitCount25\
    \ = 0\n    var hexDigitCount26 = 0\n    var hexDigitCount27 = 0\n    var hexDigitCount28\
    \ = 0\n    var hexDigitCount29 = 0\n    var hexDigitCount30 = 0\n    var hexDigitCount31\
    \ = 0\n    var hexDigitCount32 = 0\n    var hexDigitCount33 = 0\n    var hexDigitCount34\
    \ = 0\n    var hexDigitCount35 = 0\n    var hexDigitCount36 = 0\n    var hexDigitCount37\
    \ = 0\n    var hexDigitCount38 = 0\n    var hexDigitCount39 = 0\n    var hexDigitCount40\
    \ = 0\n    var hexDigitCount41 = 0\n    var hexDigitCount42 = 0\n    var hexDigitCount43\
    \ = 0\n    var hexDigitCount44 = 0\n    var hexDigitCount45 = 0\n    var hexDigitCount46\
    \ = 0\n    var hexDigitCount47 = 0\n    var hexDigitCount48 = 0\n    var hexDigitCount49\
    \ = 0\n    var hexDigitCount50 = 0\n    var hexDigitCount51 = 0\n    var hexDigitCount52\
    \ = 0\n    var hexDigitCount53 = 0\n    var hexDigitCount54 = 0\n    var hexDigitCount55\
    \ = 0\n    var hexDigitCount56 = 0\n    var hexDigitCount57 = 0\n    var hexDigitCount58\
    \ = 0\n    var hexDigitCount59 = 0\n    var hexDigitCount60 = 0\n    var hexDigitCount61\
    \ = 0\n    var hexDigitCount62 = 0\n    var hexDigitCount63 = 0\n    var hexDigitCount64\
    \ = 0\n    var hexDigitCount65 = 0\n    var hexDigitCount66 = 0\n    var hexDigitCount67\
    \ = 0\n    var hexDigitCount68 = 0\n    var hexDigitCount69 = 0\n    var hexDigitCount70\
    \ = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp2c8vox5e.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var nums = num.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2c8vox5e.swift:24:9:\
    \ warning: variable 'nums' was never mutated; consider changing to 'let' constant\n\
    \    var nums = num.characters\n    ~~~ ^\n    let\n/tmp/tmp2c8vox5e.swift:25:9:\
    \ warning: initialization of variable 'numsCount' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var numsCount = nums.count\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmp2c8vox5e.swift:26:9: warning: initialization of variable 'hexDigits'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigits = [String]()\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmp2c8vox5e.swift:27:9:\
    \ warning: initialization of variable 'hexDigitCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp2c8vox5e.swift:28:9: warning: initialization\
    \ of variable 'hexDigitCount2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount2 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp2c8vox5e.swift:29:9: warning: initialization of variable 'hexDigitCount3'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var hexDigitCount3 = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp2c8vox5e.swift:30:9:\
    \ warning: initialization of variable 'hexDigitCount4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var hexDigitCount4 = 0\n\
    \    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp2c8vox5e.swift:31:9: warning: initialization\
    \ of variable 'hexDigitCount5' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var hexDigitCount5 = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp2c8vox5e.swift:32:9: warning: initialization of variable 'hexDigitCount6'\
    \ was never used; consider replacing with assignment to '_' or remov"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits = [String]()\n\
    \    for char in num {\n        hexDigits.append(String(char).uppercase)\n   \
    \ }\n    var primeDigits = [String]()\n    var primeCount = 0\n    var primeFound\
    \ = false\n    for char in hexDigits {\n        if char == \"A\" {\n         \
    \   primeDigits.append(\"B\")\n        } else if char == \"B\" {\n           \
    \ primeDigits.append(\"C\")\n        } else if char == \"C\" {\n            primeDigits.append(\"\
    D\")\n        } else if char == \"D\" {\n            primeDigits.append(\"E\"\
    )\n        } else if char == \"E\" {\n            primeDigits.append(\"F\")\n\
    \        } else {\n            primeDigits.append(char)\n        }\n    }\n  \
    \  for char in primeDigits {\n        if char == \"B\" {\n            primeCount\
    \ += 1\n        } else if char == \"C\" {\n            primeCount += 1\n     \
    \   } else if char == \"D\" {\n            primeCount += 1\n        } else if\
    \ char == \"E\" {\n            primeCount += 1\n        } else if char == \"F\"\
    \ {\n            primeCount += 1\n        } else {\n            primeCount +=\
    \ 1\n        }\n    }\n    if primeCount > 1 {\n        return primeCount\n  \
    \  }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\"\
    ) == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\"\
    ) == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmp34ih4zyo.swift:26:39: error: value of type 'String' has no member\
    \ 'uppercase'\n        hexDigits.append(String(char).uppercase)\n            \
    \             ~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var hexDigits: [Int] =\
    \ []\n    for c in num.unicodeScalars {\n        hexDigits.append(Int(c.value))\n\
    \    }\n    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n\
    \    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n \
    \   hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n  \
    \  hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n   \
    \ hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n\
    \    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n \
    \   hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n  \
    \  hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n   \
    \ hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n\
    \    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n \
    \   hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n  \
    \  hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n   \
    \ hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n\
    \    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n \
    \   hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n  \
    \  hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n   \
    \ hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n\
    \    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n \
    \   hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n  \
    \  hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n   \
    \ hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n\
    \    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n \
    \   hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n  \
    \  hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n   \
    \ hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n    hexDigits.append(0)\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") ==\
    \ 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\")\
    \ == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\"\
    ) == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: '/tmp/tmpodnkuk7e.swift:110:1: error: missing return in global function
    expected to return ''Int''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014335
- exit_code: 1
  program: "\n/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(num: \"AB\")\n/// 1\n\
    /// >>> hex_key(num: \"1077E\")\n/// 2\n/// >>> hex_key(num: \"ABED1A33\")\n///\
    \ 4\n/// >>> hex_key(num: \"123456789ABCDEF0\")\n/// 6\n/// >>> hex_key(num: \"\
    2020\")\n/// 2\nfunc hex_key(num: String) -> Int {\n    var count = 0\n    var\
    \ digit = 0\n    var hexDigit = 0\n    var isPrime = true\n    var isHexDigit\
    \ = true\n    var isHexDigitUpper = true\n    var isHexDigitLowerUpper = true\n\
    \    var isHexDigitUpperLowerUpper = true\n    var isHexDigitLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerLowerUpperLowerUpper = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpper = true\n\
    \    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper = true\n\
    \    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num:\
    \ \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num:\
    \ \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num:\
    \ \"112233445566778899AABBCCDDEEFF00\") == 12)"
  status: SyntaxError
  stderr: "/tmp/tmpv3ixlj7s.swift:40:9: error: invalid redeclaration of 'isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper'\n\
    \    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n        ^\n/tmp/tmpv3ixlj7s.swift:39:9: note: 'isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper'\
    \ previously declared here\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\
    \ = true\n        ^\n/tmp/tmpv3ixlj7s.swift:47:9: error: type annotation missing\
    \ in pattern\n    var isHexDigitUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpperLowerUpper\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014335
