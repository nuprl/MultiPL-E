language: swift
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxSum && q.max() < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwdmh4tkt.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpwdmh4tkt.swift:20:35:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return q.count == maxSum && q.max() < maxWeight\n                       \
    \           ^\n/tmp/tmpwdmh4tkt.swift:20:35: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return q.count == maxSum\
    \ && q.max() < maxWeight\n                                  ^\n              \
    \                          ?? <#default value#>\n/tmp/tmpwdmh4tkt.swift:20:35:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return q.count == maxSum && q.max() < maxWeight\n               \
    \                   ^\n                                       !\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let q = q.sorted else { return false }\n    let\
    \ maxWeight = w * q.reduce(0) { $0 + $1 }\n    return q == q.filter { ($0 % maxWeight)\
    \ == 0  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkm226mww.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '() -> [Int]'\n    guard let q = q.sorted else\
    \ { return false }\n          ^       ~~~~~~~~\n/tmp/tmpkm226mww.swift:19:25:\
    \ error: function 'q' was used as a property; add () to call it\n    let maxWeight\
    \ = w * q.reduce(0) { $0 + $1 }\n                        ^\n                 \
    \        ()\n/tmp/tmpkm226mww.swift:20:19: error: no exact matches in call to\
    \ instance method 'filter'\n    return q == q.filter { ($0 % maxWeight) == 0 \
    \ }\n                  ^\n/tmp/tmpkm226mww.swift:20:19: note: found candidate\
    \ with type '((Int) throws -> Bool) throws -> [Int]'\n    return q == q.filter\
    \ { ($0 % maxWeight) == 0  }\n                  ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumIndex2\
    \ = 0\n    for i := 0; i < len(q); i++ {\n        var sum = 0\n        for j :=\
    \ 0; j < len(q); j++ {\n            sum += q[j]\n        }\n        if sum > maxSum\
    \ {\n            maxSum = sum\n            maxSumIndex = i\n        }\n    }\n\
    \    for i := 0; i < len(q); i++ {\n        var sum = 0\n        for j := 0; j\
    \ < len(q); j++ {\n            sum += q[j]\n        }\n        if sum > maxSum\
    \ {\n            maxSum = sum\n            maxSumIndex2 = i\n        }\n    }\n\
    \    return maxSumIndex == maxSumIndex2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn3gs6tia.swift:21:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpn3gs6tia.swift:21:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpn3gs6tia.swift:21:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpn3gs6tia.swift:23:16:\
    \ error: expected type\n        for j := 0; j < len(q); j++ {\n              \
    \ ^\n                <#type#>\n/tmp/tmpn3gs6tia.swift:23:16: error: expected 'in'\
    \ after for-each pattern\n        for j := 0; j < len(q); j++ {\n            \
    \   ^\n/tmp/tmpn3gs6tia.swift:23:16: error: expected Sequence expression for for-each\
    \ loop\n        for j := 0; j < len(q); j++ {\n               ^\n/tmp/tmpn3gs6tia.swift:31:12:\
    \ error: expected type\n    for i := 0; i < len(q); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmpn3gs6tia.swift:31:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpn3gs6tia.swift:31:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(q);\
    \ i++ {\n           ^\n/tmp/tmpn3gs6tia.swift:33:16: error: expected type\n  \
    \      for j := 0; j < len(q); j++ {\n               ^\n                <#type#>\n\
    /tmp/tmpn3gs6tia.swift:33:16: error: expected 'in' after for-each pattern\n  \
    \      for j := 0; j < len(q); j++ {\n               ^\n/tmp/tmpn3gs6tia.swift:33:16:\
    \ error: expected Sequence expression for for-each loop\n        for j := 0; j\
    \ < len(q); j++ {\n               ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else {\n        return false\n\
    \    }\n    var maxWeight = w\n    var maxSum = w.reduce(0, +)\n    for element\
    \ in q {\n        if element > maxWeight {\n            return false\n       \
    \ }\n        maxWeight -= element\n        maxSum += element\n    }\n    return\
    \ maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy878gzpn.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else {\n                     ~ ^~~~~\n\
    /tmp/tmpy878gzpn.swift:22:20: error: value of type 'Int' has no member 'reduce'\n\
    \    var maxSum = w.reduce(0, +)\n                 ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        max = max(max,\
    \ x)\n    }\n    if w == max {\n        return true\n    }\n    if w < max {\n\
    \        return false\n    }\n    var sum = 0\n    for x in q {\n        sum +=\
    \ x\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwb3omk6b.swift:20:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    let maxSum = maxWeight + w\n    return q.count == maxSum && q.sorted()\
    \ == q.sorted(.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmy_jb_de.swift:21:56: error: missing argument label 'by:' in call\n\
    \    return q.count == maxSum && q.sorted() == q.sorted(.reversed())\n       \
    \                                                ^\n                         \
    \                              by: \n/tmp/tmpmy_jb_de.swift:21:57: error: type\
    \ '(Int, Int) throws -> Bool' has no member 'reversed'\n    return q.count ==\
    \ maxSum && q.sorted() == q.sorted(.reversed())\n                            \
    \                           ~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = 0\n    for i := 0;\
    \ i < len(q); i++ {\n        maxWeight -= q[i]\n        maxSum += q[i]\n     \
    \   if maxWeight < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4qipz9zx.swift:20:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp4qipz9zx.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp4qipz9zx.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else {\n        return false\n\
    \    }\n    var maxWeight = w\n    var maxSum = w\n    for element in q {\n  \
    \      maxWeight -= element\n        maxSum += element\n    }\n    return maxWeight\
    \ <= 0 && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwe9g_gxi.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else {\n                     ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else { return false }\n    var\
    \ maxSum = w\n    for element in q {\n        maxSum -= element\n        if maxSum\
    \ < 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdk0hne2a.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else { return false }\n              \
    \       ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ = maxSum * element + element\n    }\n    return maxSum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp3olesg7a/tmp3olesg7a.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cbf02fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cbed26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cbed26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cbed257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3olesg7a                        0x0000560aa47b246f <unavailable> + 5231

    5    libc.so.6                          0x00002b1cbf21b460 __libc_start_main +
    245

    6    tmp3olesg7a                        0x0000560aa47b20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.map({ $0 + $1 }).reduce(0,\
    \ +)\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0rhroc3c.swift:19:24: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let maxSum\
    \ = q.map({ $0 + $1 }).reduce(0, +)\n                       ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.reduce(0, +)\n\
    \    for i in  q.indices {\n        if maxWeight < q[i] {\n            maxWeight\
    \ = q[i]\n        }\n        if maxSum < maxWeight {\n            maxSum = maxWeight\n\
    \        }\n    }\n    return maxSum == maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp427my_fl/tmp427my_fl.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc80fddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc80cd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc80cd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc80cd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp427my_fl                        0x000055b43dd6160b <unavailable> + 5643

    5    libc.so.6                          0x00002abc811c9460 __libc_start_main +
    245

    6    tmp427my_fl                        0x000055b43dd611b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    return q == reverse(q.prefix(q.count)).prefix(q.count) && first\
    \ + last <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpj_d7mn39.swift:21:17: error: cannot find 'reverse' in scope\n \
    \   return q == reverse(q.prefix(q.count)).prefix(q.count) && first + last <=\
    \ w\n                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    for element in q {\n        maxSum -= element\n        if maxSum <\
    \ 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmps0f299uo/tmps0f299uo.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5f7e96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5f7b8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5f7b8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5f7b8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0f299uo                        0x0000562633beb4bf <unavailable> + 5311

    5    libc.so.6                          0x00002ba5f8082460 __libc_start_main +
    245

    6    tmps0f299uo                        0x0000562633beb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == 1 && maxSum == maxWeight && q[0] == maxWeight\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvyj_9faa.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfElements = q.map({\
    \ $0 + $1 }).reduce(0, +)\n    return sumOfElements <= maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpp2uzy3a_.swift:19:31: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let sumOfElements\
    \ = q.map({ $0 + $1 }).reduce(0, +)\n                              ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else { return\
    \ false }\n    guard q.count == 1 || q.max() == w else { return false }\n    guard\
    \ let first = q.first else { return false }\n    guard let last = q.last else\
    \ { return false }\n    guard first == last else { return false }\n    guard q.palindromic\
    \ else { return false }\n    guard q.sum() <= w else { return false }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkwmg0uqi.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpkwmg0uqi.swift:18:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpkwmg0uqi.swift:18:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpkwmg0uqi.swift:23:13: error: value of type '[Int]' has\
    \ no member 'palindromic'\n    guard q.palindromic else { return false }\n   \
    \       ~ ^~~~~~~~~~~\n/tmp/tmpkwmg0uqi.swift:24:13: error: value of type '[Int]'\
    \ has no member 'sum'\n    guard q.sum() <= w else { return false }\n        \
    \  ~ ^~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    var maxSum = w\n    var\
    \ maxSumIndex = 0\n    var maxSumElement = q[0]\n    for index in 0..<q.count\
    \ {\n        if maxSum < q[index] {\n            maxSum = q[index]\n         \
    \   maxSumIndex = index\n            maxSumElement = q[index]\n        }\n   \
    \ }\n    return maxSum == w && maxSumIndex == 0 && maxSumElement == q[0]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpye_maqrk/tmpye_maqrk.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33ffb23c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33ff81ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33ff81a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33ff8197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpye_maqrk                        0x000056173809b5fb <unavailable> + 5627

    5    libc.so.6                          0x00002b33ffd0f460 __libc_start_main +
    245

    6    tmpye_maqrk                        0x000056173809b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    var maxSumIndex = 0\n    var maxSumElement = q[0]\n    for index in\
    \ 1..<q.count {\n        let element = q[index]\n        if element > maxSumElement\
    \ {\n            maxSumElement = element\n            maxSumIndex = index\n  \
    \      }\n        maxSum = maxSum + element\n    }\n    if maxSum == w {\n   \
    \     return true\n    }\n    if maxSum < w {\n        return false\n    }\n \
    \   if maxSum == w {\n        return true\n    }\n    if maxSum == w {\n     \
    \   return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkll2nwki/tmpkll2nwki.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99ff361c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99ff058b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99ff058988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99ff0577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkll2nwki                        0x000055788588f53f <unavailable> + 5439

    5    libc.so.6                          0x00002b99ff54d460 __libc_start_main +
    245

    6    tmpkll2nwki                        0x000055788588f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    \n\
    \    var maxSum = w\n    for element in q {\n        maxSum = maxSum * element\
    \ + element\n    }\n    \n    if maxSum > w {\n        return false\n    }\n \
    \   \n    if maxSum == w {\n        return true\n    }\n    \n    return will_it_fly(q,\
    \ maxSum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp78hvz_yo.swift:35:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q, maxSum)\n                      ^\n         \
    \              q: w: \n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        if x > max {\n\
    \            max = x\n        }\n    }\n    if max > w {\n        return false\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    if sum\
    \ < w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpaia_d7iy/tmpaia_d7iy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82a2618c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82a230fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82a230f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82a230e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaia_d7iy                        0x000055e0e0c7246f <unavailable> + 5231

    5    libc.so.6                          0x00002b82a2804460 __libc_start_main +
    245

    6    tmpaia_d7iy                        0x000055e0e0c720d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let q = q.sorted() else {\n        return false\n\
    \    }\n    let maxWeight = w * q.reduce(0) { $0 + $1 }\n    return q == q.reversed().sorted()\
    \ && maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqsskpzgg.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.reduce(0, +)\n\
    \    return maxWeight <= maxSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5js8ikvn/tmp5js8ikvn.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56652ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5664ff6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5664ff6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5664ff57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5js8ikvn                        0x000055b5be2e637f <unavailable> + 4991

    5    libc.so.6                          0x00002b56654eb460 __libc_start_main +
    245

    6    tmp5js8ikvn                        0x000055b5be2e5fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = w\n    for x in q\
    \ {\n        if x > maxWeight {\n            maxWeight = x\n        }\n      \
    \  maxSum += x\n    }\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpmfkas0ml/tmpmfkas0ml.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b796885fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7968556b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7968556988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79685557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmfkas0ml                        0x000055b7bce4c46f <unavailable> + 5231

    5    libc.so.6                          0x00002b7968a4b460 __libc_start_main +
    245

    6    tmpmfkas0ml                        0x000055b7bce4c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var max\
    \ = 0\n    var sum = 0\n    for x in q {\n        sum += x\n        if sum > max\
    \ { max = sum }\n    }\n    return sum == max && q == q.sort()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8ib0hyvu.swift:25:26: error: cannot convert value of type '[Int]'\
    \ to expected argument type '()'\n    return sum == max && q == q.sort()\n   \
    \                      ^\n/tmp/tmp8ib0hyvu.swift:25:33: error: cannot use mutating\
    \ member on immutable value: 'q' is a 'let' constant\n    return sum == max &&\
    \ q == q.sort()\n                              ~ ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for index in 1..<q.count {\n        let element = q[index]\n   \
    \     if element > maxSumElement {\n            maxSumElement = element\n    \
    \        maxSumIndex = index\n        }\n        maxSum = maxSum * element + maxSum\n\
    \    }\n    return maxSum < w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0xmqiwxe/tmp0xmqiwxe.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb0eb00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb0e7f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb0e7f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb0e7f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0xmqiwxe                        0x000055d2890b353f <unavailable> + 5439

    5    libc.so.6                          0x00002aeb0ecec460 __libc_start_main +
    245

    6    tmp0xmqiwxe                        0x000055d2890b31a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return false\n \
    \   }\n    if q.count == 1 {\n        return true\n    }\n    if w == 1 {\n  \
    \      return true\n    }\n    if w == 2 {\n        return q[0] == q[q.count -\
    \ 1]\n    }\n    if w == 3 {\n        return q[0] == q[q.count - 1] && q[1] ==\
    \ q[q.count - 2] && q[2] == q[q.count - 3]\n    }\n    if w == 4 {\n        return\
    \ q[0] == q[q.count - 1] && q[1] == q[q.count - 2] && q[2] == q[q.count - 3] &&\
    \ q[3] == q[q.count - 4]\n    }\n    if w == 5 {\n        return q[0] == q[q.count\
    \ - 1] && q[1] == q[q.count - 2] && q[2] == q[q.count - 3] && q[3] == q[q.count\
    \ - 4] && q[4] == q[q.count - 5]\n    }\n    if w == 6 {\n        return q[0]\
    \ == q[q.count - 1] && q[1] == q[q.count - 2] && q[2] == q[q.count - 3] && q[3]\
    \ == q[q.count - 4] && q[4] == q[q.count - 5] && q[5] == q[q.count - 6]\n    }\n\
    \    if w == 7 {\n        return q[0] == q[q.count - 1] && q[1] == q[q.count -\
    \ 2] && q[2] == q[q.count - 3] && q[3] == q[q.count - 4] && q[4] == q[q.count\
    \ - 5] && q[5] == q[q.count - 6] && q[6] == q[q.count - 7]\n    }\n    if w ==\
    \ 8 {\n        return q[0] == q[q.count - 1] && q[1] == q[q.count - 2] && q[2]\
    \ == q[q.count - 3] && q[3] == q[q.count - 4] && q[4] == q[q.count - 5] && q[5]\
    \ == q[q.count - 6] && q[6] == q[q.count - 7] && q[7] == q[q.count - 8]\n    }\n\
    \    if w == 9 {\n        return q[0] == q[q.count - 1] && q[1] == q[q.count -\
    \ 2] && q[2] == q[q.count - 3] && q[3] == q[q.count - 4] && q[4] == q[q.count\
    \ - 5] && q[5] == q[q.count - 6] && q[6] == q[q.count - 7] && q[7] == q[q.count\
    \ - 8] && q[8] == q[q.count \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwdm4yxow.swift:50:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpwdm4yxow.swift:49:233: note: to match this opening '['\n        return\
    \ q[0] == q[q.count - 1] && q[1] == q[q.count - 2] && q[2] == q[q.count - 3] &&\
    \ q[3] == q[q.count - 4] && q[4] == q[q.count - 5] && q[5] == q[q.count - 6] &&\
    \ q[6] == q[q.count - 7] && q[7] == q[q.count - 8] && q[8] == q[q.count \n   \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \ ^\n/tmp/tmpwdm4yxow.swift:70:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpwdm4yxow.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpwdm4yxow.swift:53:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == w\n    }\n    if w ==\
    \ 2 {\n        return q[0] == w && q[1] == w\n    }\n    if w == 3 {\n       \
    \ return q[0] == w && q[1] == w && q[2] == w\n    }\n    if w == 4 {\n       \
    \ return q[0] == w && q[1] == w && q[2] == w && q[3] == w\n    }\n    if w ==\
    \ 5 {\n        return q[0] == w && q[1] == w && q[2] == w && q[3] == w && q[4]\
    \ == w\n    }\n    if w == 6 {\n        return q[0] == w && q[1] == w && q[2]\
    \ == w && q[3] == w && q[4] == w && q[5] == w\n    }\n    if w == 7 {\n      \
    \  return q[0] == w && q[1] == w && q[2] == w && q[3] == w && q[4] == w && q[5]\
    \ == w && q[6] == w\n    }\n    if w == 8 {\n        return q[0] == w && q[1]\
    \ == w && q[2] == w && q[3] == w && q[4] == w && q[5] == w && q[6] == w && q[7]\
    \ == w\n    }\n    if w == 9 {\n        return q[0] == w && q[1] == w && q[2]\
    \ == w && q[3] == w && q[4] == w && q[5] == w && q[6] == w && q[7] == w && q[8]\
    \ == w\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpfbn4s2a1/tmpfbn4s2a1.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c802c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c7ffb7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c7ffb7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c7ffb67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfbn4s2a1                        0x000055fd0d8e03af <unavailable> + 5039

    5    libc.so.6                          0x00002b2c804ac460 __libc_start_main +
    245

    6    tmpfbn4s2a1                        0x000055fd0d8e0019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ q = q.sorted else { return false }\n    return q == q.suffix(from: q.count -\
    \ 1) && q.prefix(from: q.count).reduce(0) { $0 + $1 } <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpav_bsdox.swift:19:11: error: initializer for conditional binding\
    \ must have Optional type, not '() -> [Int]'\n    guard let q = q.sorted else\
    \ { return false }\n          ^       ~~~~~~~~\n/tmp/tmpav_bsdox.swift:20:12:\
    \ error: cannot convert value of type '() -> [Int]' to expected argument type\
    \ 'ArraySlice<Int>'\n    return q == q.suffix(from: q.count - 1) && q.prefix(from:\
    \ q.count).reduce(0) { $0 + $1 } <= w\n           ^\n/tmp/tmpav_bsdox.swift:20:17:\
    \ error: function 'q' was used as a property; add () to call it\n    return q\
    \ == q.suffix(from: q.count - 1) && q.prefix(from: q.count).reduce(0) { $0 + $1\
    \ } <= w\n                ^\n                 ()\n/tmp/tmpav_bsdox.swift:20:32:\
    \ error: function 'q' was used as a property; add () to call it\n    return q\
    \ == q.suffix(from: q.count - 1) && q.prefix(from: q.count).reduce(0) { $0 + $1\
    \ } <= w\n                               ^\n                                ()\n\
    /tmp/tmpav_bsdox.swift:20:56: error: extraneous argument label 'from:' in call\n\
    \    return q == q.suffix(from: q.count - 1) && q.prefix(from: q.count).reduce(0)\
    \ { $0 + $1 } <= w\n                                                       ^~~~~~~\n\
    \                                                        \n/tmp/tmpav_bsdox.swift:20:48:\
    \ error: function 'q' was used as a property; add () to call it\n    return q\
    \ == q.suffix(from: q.count - 1) && q.prefix(from: q.count).reduce(0) { $0 + $1\
    \ } <= w\n                                               ^\n                 \
    \                               ()\n/tmp/tmpav_bsdox.swift:20:63: error: function\
    \ 'q' was used as a property; add () to call it\n    return q == q.suffix(from:\
    \ q.count - 1) && q.prefix(from: q.count).reduce(0) { $0 + $1 } <= w\n       \
    \                                                       ^\n                  \
    \                                             ()\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        max = max(max,\
    \ x)\n    }\n    if max <= w {\n        return true\n    }\n    if max > w {\n\
    \        return false\n    }\n    var sum = 0\n    for x in q {\n        sum +=\
    \ x\n    }\n    if sum < w {\n        return false\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplth8_bhf.swift:20:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    var maxSum = Int.max\n    for\
    \ element in q {\n        maxSum = maxSum + element\n    }\n    return maxSum\
    \ < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard first == last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard first == last else { return false }\n    guard let first = q.first\
    \ else { return false }\n    guard let last = q.last else { return false }\n \
    \   guard first == last else { return false }\n    guard let first = q.first else\
    \ { return false }\n    guard let last = q.last else { return false }\n    guard\
    \ first == last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard first\
    \ == last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard first == last\
    \ else { return false }\n    guard let first = q.first else { return false }\n\
    \    guard let last = q.last else { return false }\n    guard first == last else\
    \ { return false }\n    guard let first = q.first else { return false }\n    guard\
    \ let last = q.last else { return false }\n    guard first == last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard first == last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard first == last else { return false }\n\
    \    guard let first = q.first else { return false }\n    guard let last = q.last\
    \ else { return false }\n    guard first == last else { return false }\n    guard\
    \ let first = q.first else { return false }\n    guard let last = q.last else\
    \ { return false }\n    guard first == last else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard first == last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard first == last else { return false }\n    guard let first = q.first\
    \ else { return false }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpz7k32pwc.swift:61:15: warning: value 'first' was defined but never\
    \ used; consider replacing with boolean test\n    guard let first = q.first else\
    \ { return false }\n          ~~~~^~~~~~~~\n                              != nil\n\
    /tmp/tmpz7k32pwc.swift:62:1: error: missing return in global function expected\
    \ to return 'Bool'\n}\n^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var max\
    \ = 0\n    for x in q {\n        max = max > x ? max : x\n    }\n    return max\
    \ == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpdokhrbcz/tmpdokhrbcz.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5255a07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52556feb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52556fe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52556fd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdokhrbcz                        0x0000559440d364bf <unavailable> + 5311

    5    libc.so.6                          0x00002b5255bf3460 __libc_start_main +
    245

    6    tmpdokhrbcz                        0x0000559440d36129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.maxElement()\n\
    \    return maxWeight == 0 || maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvm7a13o9.swift:19:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxSum = q.maxElement()\n                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for i := 0; i\
    \ < len(q); i++ {\n        sum += q[i]\n        if sum > maxWeight {\n       \
    \     maxWeight = sum\n        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk4zktvvd.swift:20:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpk4zktvvd.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpk4zktvvd.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumValue\
    \ = 0\n    for index in 0..<q.count {\n        let value = q[index]\n        if\
    \ value > maxSumValue {\n            maxSumValue = value\n            maxSumIndex\
    \ = index\n        }\n    }\n    if maxSumValue > w {\n        return false\n\
    \    }\n    if maxSumValue == w {\n        return true\n    }\n    if maxSumValue\
    \ > w {\n        return false\n    }\n    if maxSumValue == w {\n        return\
    \ true\n    }\n    if maxSumValue > w {\n        return false\n    }\n    if maxSumValue\
    \ == w {\n        return true\n    }\n    if maxSumValue > w {\n        return\
    \ false\n    }\n    if maxSumValue == w {\n        return true\n    }\n    if\
    \ maxSumValue > w {\n        return false\n    }\n    if maxSumValue == w {\n\
    \        return true\n    }\n    if maxSumValue > w {\n        return false\n\
    \    }\n    if maxSumValue == w {\n        return true\n    }\n    if maxSumValue\
    \ > w {\n        return false\n    }\n    if maxSumValue == w {\n        return\
    \ true\n    }\n    if maxSumValue > w {\n        return false\n    }\n    if maxSumValue\
    \ == w {\n        return true\n    }\n    if maxSumValue > w {\n        return\
    \ false\n    }\n    if maxSumValue == w {\n        return true\n    }\n    if\
    \ maxSumValue > w {\n        return false\n    }\n    if maxSumValue == w {\n\
    \        return true\n    }\n    if maxSumValue > w {\n        return false\n\
    \    }\n    if maxSumValue == w {\n        return true\n    }\n    if maxSumValue\
    \ > w {\n        return false\n    }\n    if maxSumValue == w {\n        return\
    \ true\n    }\n    if maxSumValue > w {\n        return false\n    }\n    if maxSumValue\
    \ == w {\n        return true\n    }\n    if maxSumValue > w {\n        return\
    \ false\n    }\n    if maxSumValue == w {\n        return true\n    }\n    if\
    \ maxSumValue > w {\n        return false\n    }\n    if maxSumValue == w {\n\
    \        return true\n    }\n    if maxSumValue > w {\n        return false\n\
    \    }\n    if maxSumValue == w {\n        return true\n    }\n    if maxSumValue\
    \ > w {\n        return false\n    }\n    if maxSumValue == w {\n        return\
    \ true\n    }\n    if maxSumValue > w {\n        return false\n    }\n    if maxSumValue\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyqvh8jj3.swift:133:19: error: expected '{' after 'if' condition\n\
    \    if maxSumValue \n                  ^\n/tmp/tmpyqvh8jj3.swift:133:8: error:\
    \ type 'Int' cannot be used as a boolean; test for '!= 0' instead\n    if maxSumValue\
    \ \n       ^\n       (           != 0)\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplwpl0szo.swift:81:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmplwpl0szo.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmplwpl0szo.swift:60:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmplwpl0szo.swift:64:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmplwpl0szo.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:21:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:22:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:23:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:24:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:25:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    var sum = 0\n    for x in q {\n\
    \        sum += x\n    }\n    if sum > maxWeight {\n        return false\n   \
    \ }\n    if sum == maxWeight {\n        return true\n    }\n    if sum < maxWeight\
    \ {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpptyp3x85/tmpptyp3x85.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a5e91ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a5e611b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a5e611988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a5e6107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpptyp3x85                        0x0000561e7c22946f <unavailable> + 5231

    5    libc.so.6                          0x00002b1a5eb06460 __libc_start_main +
    245

    6    tmpptyp3x85                        0x0000561e7c2290d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    \n\
    \    // The first element of the list is the maximum of the first and last elements.\n\
    \    let maxFirst = q[0]\n    let maxLast = q[q.count - 1]\n    \n    // The sum\
    \ of the elements of the list is the maximum of the first and last elements.\n\
    \    let maxSum = maxFirst + maxLast\n    \n    // If the sum of the elements\
    \ is less than or equal to the maximum possible weight, then the list will fly.\n\
    \    return maxSum < w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9b_74h16/tmp9b_74h16.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03404f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03401ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03401ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03401eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9b_74h16                        0x0000561699eee46b <unavailable> + 5227

    5    libc.so.6                          0x00002b03406e1460 __libc_start_main +
    245

    6    tmp9b_74h16                        0x0000561699eee019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let maxSum = maxWeight + maxWeight\n\
    \    return q.count == 0 || (q.count == 1 && q[0] == q[q.count-1]) && maxSum <\
    \ maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp03euncdq/tmp03euncdq.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab68d030c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab68cd27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab68cd27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab68cd267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp03euncdq                        0x000055fbdb8753af <unavailable> + 5039

    5    libc.so.6                          0x00002ab68d21c460 __libc_start_main +
    245

    6    tmp03euncdq                        0x000055fbdb875019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i := 0; i < len(q); i++ {\n \
    \       maxSum = maxSum * 10 + q[i]\n    }\n    return maxSum <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmposcqfvbh.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmposcqfvbh.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmposcqfvbh.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfWeights = q.map({\
    \ $0 * $0 }).reduce(0, +)\n    return maxWeight <= sumOfWeights\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpe29xobnf/tmpe29xobnf.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08cede3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08ceadab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08ceada988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08cead97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe29xobnf                        0x000055bc36a7941f <unavailable> + 5151

    5    libc.so.6                          0x00002b08cefcf460 __libc_start_main +
    245

    6    tmpe29xobnf                        0x000055bc36a79089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    var maxSumIndex = 0\n    for i in 0..<q.count {\n        let sum =\
    \ q[i] + maxSum\n        if sum > maxSum { maxSum = sum; maxSumIndex = i }\n \
    \   }\n    return maxSum == w && maxSumIndex < q.count - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7iy9m_i2/tmp7iy9m_i2.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b506f06bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b506ed62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b506ed62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b506ed617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7iy9m_i2                        0x000055faa5f0653f <unavailable> + 5439

    5    libc.so.6                          0x00002b506f257460 __libc_start_main +
    245

    6    tmp7iy9m_i2                        0x000055faa5f061a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = w\n    for element\
    \ in q {\n        maxWeight -= element\n        maxSum += element\n        if\
    \ maxWeight < 0 {\n            return false\n        }\n    }\n    return maxSum\
    \ < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmplabe99wr/tmplabe99wr.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6c7e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6c7b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6c7b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6c7b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplabe99wr                        0x000056305da9546f <unavailable> + 5231

    5    libc.so.6                          0x00002ae6c8084460 __libc_start_main +
    245

    6    tmplabe99wr                        0x000056305da950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.reduce(0, +)\n\
    \    for i in\n        stride(from: q.count - 1, through: 0, by: -1) {\n     \
    \       let sum = q[i] + q[i - 1]\n            if sum > maxSum {\n           \
    \     maxSum = sum\n                maxWeight = w\n            }\n        }\n\
    \    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8285e1cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8285b13561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8285b13286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8285b1313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8285b12bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8285912e83 <unavailable> + 188035

    6    tmppfu_rm00                        0x0000555726838d0d <unavailable> + 7437

    7    tmppfu_rm00                        0x00005557268385da <unavailable> + 5594

    8    libc.so.6                          0x00002b8286008460 __libc_start_main +
    245

    9    tmppfu_rm00                        0x00005557268382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let mid = q.mid(at: 0) else { return false }\n    guard let\
    \ mid2 = q.mid(at: 1) else { return false }\n    guard let mid3 = q.mid(at: 2)\
    \ else { return false }\n    guard let mid4 = q.mid(at: 3) else { return false\
    \ }\n    guard let mid5 = q.mid(at: 4) else { return false }\n    guard let mid6\
    \ = q.mid(at: 5) else { return false }\n    guard let mid7 = q.mid(at: 6) else\
    \ { return false }\n    guard let mid8 = q.mid(at: 7) else { return false }\n\
    \    guard let mid9 = q.mid(at: 8) else { return false }\n    guard let mid10\
    \ = q.mid(at: 9) else { return false }\n    guard let mid11 = q.mid(at: 10) else\
    \ { return false }\n    guard let mid12 = q.mid(at: 11) else { return false }\n\
    \    guard let mid13 = q.mid(at: 12) else { return false }\n    guard let mid14\
    \ = q.mid(at: 13) else { return false }\n    guard let mid15 = q.mid(at: 14) else\
    \ { return false }\n    guard let mid16 = q.mid(at: 15) else { return false }\n\
    \    guard let mid17 = q.mid(at: 16) else { return false }\n    guard let mid18\
    \ = q.mid(at: 17) else { return false }\n    guard let mid19 = q.mid(at: 18) else\
    \ { return false }\n    guard let mid20 = q.mid(at: 19) else { return false }\n\
    \    guard let mid21 = q.mid(at: 20) else { return false }\n    guard let mid22\
    \ = q.mid(at: 21) else { return false }\n    guard let mid23 = q.mid(at: 22) else\
    \ { return false }\n    guard let mid24 = q.mid(at: 23) else { return false }\n\
    \    guard let mid25 = q.mid(at: 24) else { return false }\n    guard let mid26\
    \ = q.mid(at: 25) else { return false }\n    guard let mid27 = q.mid(at: 26) else\
    \ { return false }\n    gu\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptr8cxyy4.swift:21:23: error: value of type '[Int]' has no member\
    \ 'mid'\n    guard let mid = q.mid(at: 0) else { return false }\n            \
    \        ~ ^~~\n/tmp/tmptr8cxyy4.swift:22:24: error: value of type '[Int]' has\
    \ no member 'mid'\n    guard let mid2 = q.mid(at: 1) else { return false }\n \
    \                    ~ ^~~\n/tmp/tmptr8cxyy4.swift:23:24: error: value of type\
    \ '[Int]' has no member 'mid'\n    guard let mid3 = q.mid(at: 2) else { return\
    \ false }\n                     ~ ^~~\n/tmp/tmptr8cxyy4.swift:24:24: error: value\
    \ of type '[Int]' has no member 'mid'\n    guard let mid4 = q.mid(at: 3) else\
    \ { return false }\n                     ~ ^~~\n/tmp/tmptr8cxyy4.swift:25:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid5 = q.mid(at:\
    \ 4) else { return false }\n                     ~ ^~~\n/tmp/tmptr8cxyy4.swift:26:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid6 = q.mid(at:\
    \ 5) else { return false }\n                     ~ ^~~\n/tmp/tmptr8cxyy4.swift:27:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid7 = q.mid(at:\
    \ 6) else { return false }\n                     ~ ^~~\n/tmp/tmptr8cxyy4.swift:28:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid8 = q.mid(at:\
    \ 7) else { return false }\n                     ~ ^~~\n/tmp/tmptr8cxyy4.swift:29:24:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid9 = q.mid(at:\
    \ 8) else { return false }\n                     ~ ^~~\n/tmp/tmptr8cxyy4.swift:30:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid10 = q.mid(at:\
    \ 9) else { return false }\n                      ~ ^~~\n/tmp/tmptr8cxyy4.swift:31:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid11 = q.mid(at:\
    \ 10) else { return false }\n                      ~ ^~~\n/tmp/tmptr8cxyy4.swift:32:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid12 = q.mid(at:\
    \ 11) else { return false }\n                      ~ ^~~\n/tmp/tmptr8cxyy4.swift:33:25:\
    \ error: value of type '[Int]' has no member 'mid'\n    guard let mid13"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count && q.count == q.max() else {\
    \ return false }\n    var max = 0\n    for x in q {\n        max += x\n    }\n\
    \    return max == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjcasi9f4.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == q.max() else { return false\
    \ }\n                     ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxSum && q.max() < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwdmh4tkt.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpwdmh4tkt.swift:20:35:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return q.count == maxSum && q.max() < maxWeight\n                       \
    \           ^\n/tmp/tmpwdmh4tkt.swift:20:35: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return q.count == maxSum\
    \ && q.max() < maxWeight\n                                  ^\n              \
    \                          ?? <#default value#>\n/tmp/tmpwdmh4tkt.swift:20:35:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return q.count == maxSum && q.max() < maxWeight\n               \
    \                   ^\n                                       !\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa95330ym/tmpa95330ym.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2d1852c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2d1549b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2d1549988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2d15487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa95330ym                        0x000055a78333746f <unavailable> + 5231

    5    libc.so.6                          0x00002ad2d1a3e460 __libc_start_main +
    245

    6    tmpa95330ym                        0x000055a7833370d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = 0\n    for element\
    \ in q {\n        maxWeight -= element\n        maxSum += element\n        if\
    \ maxWeight < 0 {\n            return false\n        }\n    }\n    return maxSum\
    \ < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp4hdxxtu_/tmp4hdxxtu_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53d80ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53d7dc3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53d7dc3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53d7dc27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4hdxxtu_                        0x0000556ef2b3046f <unavailable> + 5231

    5    libc.so.6                          0x00002b53d82b8460 __libc_start_main +
    245

    6    tmp4hdxxtu_                        0x0000556ef2b300d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    for v in q {\n        maxSum -= v\n    }\n    return maxSum < 0\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp12sx03_0/tmp12sx03_0.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fae6dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fae3d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fae3d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fae3d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp12sx03_0                        0x000056169b0cf4bf <unavailable> + 5311

    5    libc.so.6                          0x00002b5fae8c6460 __libc_start_main +
    245

    6    tmp12sx03_0                        0x000056169b0cf129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for index in 1..<q.count {\n        let element = q[index]\n   \
    \     let sumElement = element + maxSumElement\n        if sumElement > maxSum\
    \ {\n            maxSum = sumElement\n            maxSumIndex = index\n      \
    \      maxSumElement = element\n        }\n    }\n    return maxSum == w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpb8yb_7aw/tmpb8yb_7aw.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6e2390c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6e2087b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6e2087988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6e20867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8yb_7aw                        0x00005624e481a5fb <unavailable> + 5627

    5    libc.so.6                          0x00002ae6e257c460 __libc_start_main +
    245

    6    tmpb8yb_7aw                        0x00005624e481a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        max = max(max,\
    \ x)\n    }\n    if max > w {\n        return false\n    }\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyp9yj874.swift:20:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for element in\
    \ q {\n        sum += element\n        if sum > maxWeight {\n            maxWeight\
    \ = sum\n        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpllb5sj_9/tmpllb5sj_9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b734cf9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b734cc93b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b734cc93988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b734cc927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllb5sj_9                        0x000055e06baf952b <unavailable> + 5419

    5    libc.so.6                          0x00002b734d188460 __libc_start_main +
    245

    6    tmpllb5sj_9                        0x000055e06baf90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb0thsbge.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return false\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return true\n    }\n    if w == 2 {\n\
    \        return q[0] == q[q.count - 1]\n    }\n    if w == 3 {\n        return\
    \ q[0] == q[1] && q[1] == q[q.count - 1]\n    }\n    if w == 4 {\n        return\
    \ q[0] == q[1] && q[1] == q[2] && q[2] == q[q.count - 1]\n    }\n    if w == 5\
    \ {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[q.count\
    \ - 1]\n    }\n    if w == 6 {\n        return q[0] == q[1] && q[1] == q[2] &&\
    \ q[2] == q[3] && q[3] == q[4] && q[4] == q[q.count - 1]\n    }\n    if w == 7\
    \ {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4]\
    \ && q[4] == q[5] && q[5] == q[q.count - 1]\n    }\n    if w == 8 {\n        return\
    \ q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\
    \ && q[5] == q[6] && q[6] == q[q.count - 1]\n    }\n    if w == 9 {\n        return\
    \ q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\
    \ && q[5] == q[6] && q[6] == q[7] && q[7] == q[q.count - 1]\n    }\n    if w ==\
    \ 10 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] ==\
    \ q[4] && q[4] == q[5] && q[5] == q[6] && q[6] == q[7] && q[7] == q[8] && q[8]\
    \ == q[q.count - 1]\n    }\n    if w == 11 {\n        return q[0] == q[1] && q[1]\
    \ == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5] == q[6] && q[6]\
    \ == q[7] && q[7] == q[8] && q[8] == q[9] && q[9] == q[q.count - 1]\n    }\n \
    \   if w == 12 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3]\
    \ && q[3] == q[4] && q[4] == q[5\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsoo198af.swift:62:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpsoo198af.swift:61:89: note: to match this opening '['\n        return\
    \ q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5\n\
    \                                                                            \
    \            ^\n/tmp/tmpsoo198af.swift:82:42: error: expected '}' at end of brace\
    \ statement\nassert(will_it_fly(q: [5], w: 5) == true)\n                     \
    \                    ^\n/tmp/tmpsoo198af.swift:17:44: note: to match this opening\
    \ '{'\nfunc will_it_fly(q: [Int], w: Int) -> Bool {\n                        \
    \                   ^\n/tmp/tmpsoo198af.swift:65:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    return q == q.reversed\n        && q.count == w\n        && q.first\
    \ == last\n        && q.last == first\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0dg_xkey.swift:21:19: error: function produces expected type '[Int]';\
    \ did you mean to call it with '()'?\n    return q == q.reversed\n           \
    \     ~~^~~~~~~~\n                          ()\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else { return\
    \ false }\n    let s = q.sum()\n    return s == w && s == q.max() - w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3g6tyh1r.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmp3g6tyh1r.swift:18:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmp3g6tyh1r.swift:18:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmp3g6tyh1r.swift:19:15: error: value of type '[Int]' has\
    \ no member 'sum'\n    let s = q.sum()\n            ~ ^~~\n/tmp/tmp3g6tyh1r.swift:20:29:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return s == w && s == q.max() - w\n                            ^\n/tmp/tmp3g6tyh1r.swift:20:29:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return s == w && s == q.max() - w\n                            ^\n\
    \                          (       ?? <#default value#>)\n/tmp/tmp3g6tyh1r.swift:20:29:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return s == w && s == q.max() - w\n                            ^\n\
    \                                 !\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    var\
    \ maxWeight = w\n    var maxSum = q[0]\n    for i := 1; i < q.count; i++ {\n \
    \       if q[i] > maxSum {\n            maxSum = q[i]\n        }\n        if maxWeight\
    \ > q[i] {\n            maxWeight = q[i]\n        }\n    }\n    return maxSum\
    \ == w && maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwo7wdorj.swift:23:12: error: expected type\n    for i := 1; i <\
    \ q.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpwo7wdorj.swift:23:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < q.count; i++\
    \ {\n           ^\n/tmp/tmpwo7wdorj.swift:23:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < q.count; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    \n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyjr0ubnh/tmpyjr0ubnh.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3b183fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3b1536b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3b1536988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3b15357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyjr0ubnh                        0x00005589b19cd3bb <unavailable> + 5051

    5    libc.so.6                          0x00002ac3b1a2b460 __libc_start_main +
    245

    6    tmpyjr0ubnh                        0x00005589b19ccf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let sum = q.reduce(0) { $0 + $1 }\n    guard sum <= w else\
    \ { return false }\n    guard let middle = q.count / 2 else { return false }\n\
    \    guard let leftSum = q[..middle].reduce(0) { $0 + $1 }\n    guard leftSum\
    \ <= w else { return false }\n    guard let rightSum = q[middle..].reduce(0) {\
    \ $0 + $1 }\n    guard rightSum <= w else { return false }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpualwmml1.swift:21:33: error: expected 'else' after 'guard' condition\n\
    \    guard let sum = q.reduce(0) { $0 + $1 }\n                               \
    \ ^\n                                else \n/tmp/tmpualwmml1.swift:21:35: error:\
    \ anonymous closure argument not contained in a closure\n    guard let sum = q.reduce(0)\
    \ { $0 + $1 }\n                                  ^\n/tmp/tmpualwmml1.swift:21:40:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ sum = q.reduce(0) { $0 + $1 }\n                                       ^\n/tmp/tmpualwmml1.swift:24:47:\
    \ error: expected 'else' after 'guard' condition\n    guard let leftSum = q[..middle].reduce(0)\
    \ { $0 + $1 }\n                                              ^\n             \
    \                                 else \n/tmp/tmpualwmml1.swift:24:49: error:\
    \ anonymous closure argument not contained in a closure\n    guard let leftSum\
    \ = q[..middle].reduce(0) { $0 + $1 }\n                                      \
    \          ^\n/tmp/tmpualwmml1.swift:24:54: error: anonymous closure argument\
    \ not contained in a closure\n    guard let leftSum = q[..middle].reduce(0) {\
    \ $0 + $1 }\n                                                     ^\n/tmp/tmpualwmml1.swift:26:48:\
    \ error: expected 'else' after 'guard' condition\n    guard let rightSum = q[middle..].reduce(0)\
    \ { $0 + $1 }\n                                               ^\n            \
    \                                   else \n/tmp/tmpualwmml1.swift:26:50: error:\
    \ anonymous closure argument not contained in a closure\n    guard let rightSum\
    \ = q[middle..].reduce(0) { $0 + $1 }\n                                      \
    \           ^\n/tmp/tmpualwmml1.swift:26:55: error: anonymous closure argument\
    \ not contained in a closure\n    guard let rightSum = q[middle..].reduce(0) {\
    \ $0 + $1 }\n                                                      ^\n/tmp/tmpualwmml1.swift:21:31:\
    \ error: missing argument for parameter #2 in call\n    guard let sum = q.reduce(0)\
    \ { $0 + $1 }\n                              ^\n                             \
    \ , <#(Int?, Int) throws -> Int?#>\nSwift.S"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    let reversed = q.reversed()\n    return q.count\
    \ == reversed.count && w == reversed.sum()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsbk73bq5.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpsbk73bq5.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpsbk73bq5.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpsbk73bq5.swift:22:55:\
    \ error: value of type 'ReversedCollection<[Int]>' has no member 'sum'\n    return\
    \ q.count == reversed.count && w == reversed.sum()\n                         \
    \                    ~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q[0]\n    for element\
    \ in q {\n        if element > maxWeight {\n            maxWeight = element\n\
    \            maxSum = element\n        }\n    }\n    if maxWeight <= w {\n   \
    \     return true\n    }\n    if maxWeight > w {\n        return false\n    }\n\
    \    if maxSum < w {\n        return false\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp_sl5qm_s/tmp_sl5qm_s.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4e064dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4e0344b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4e0344988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4e03437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_sl5qm_s                        0x00005648cc64c57b <unavailable> + 5499

    5    libc.so.6                          0x00002ba4e0839460 __libc_start_main +
    245

    6    tmp_sl5qm_s                        0x00005648cc64c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ a = q.first else { return false }\n    guard let b = q.last else { return false\
    \ }\n    return a == b && will_it_fly(q: q.dropFirst(), w: w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpehvnfenk.swift:21:39: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return a == b && will_it_fly(q: q.dropFirst(),\
    \ w: w)\n                                      ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp4n4vhuzn/tmp4n4vhuzn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3b3e86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3b3b7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3b3b7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3b3b7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4n4vhuzn                        0x000056110da3752b <unavailable> + 5419

    5    libc.so.6                          0x00002ad3b4072460 __libc_start_main +
    245

    6    tmp4n4vhuzn                        0x000056110da370d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var maxSum\
    \ = w\n    for element in q {\n        maxSum -= element\n        if maxSum <\
    \ 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmps0f299uo/tmps0f299uo.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5f7e96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5f7b8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5f7b8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5f7b8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0f299uo                        0x0000562633beb4bf <unavailable> + 5311

    5    libc.so.6                          0x00002ba5f8082460 __libc_start_main +
    245

    6    tmps0f299uo                        0x0000562633beb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa95330ym/tmpa95330ym.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2d1852c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2d1549b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2d1549988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2d15487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa95330ym                        0x000055a78333746f <unavailable> + 5231

    5    libc.so.6                          0x00002ad2d1a3e460 __libc_start_main +
    245

    6    tmpa95330ym                        0x000055a7833370d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    var sum = 0\n    for element in q {\n       \
    \ sum += element\n    }\n    return sum == w && is_balanced(q) && is_palindromic(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbx0qajva.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpbx0qajva.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpbx0qajva.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpbx0qajva.swift:25:24:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                       ^~~~~~~~~~~\n/tmp/tmpbx0qajva.swift:25:42:\
    \ error: cannot find 'is_palindromic' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                                         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return is_balanced(q) && is_palindromic(q)\
    \ && q.sum() <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9rq9esrf.swift:19:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && is_palindromic(q) && q.sum() <= maxWeight\n    \
    \       ^~~~~~~~~~~\n/tmp/tmp9rq9esrf.swift:19:30: error: cannot find 'is_palindromic'\
    \ in scope\n    return is_balanced(q) && is_palindromic(q) && q.sum() <= maxWeight\n\
    \                             ^~~~~~~~~~~~~~\n/tmp/tmp9rq9esrf.swift:19:53: error:\
    \ value of type '[Int]' has no member 'sum'\n    return is_balanced(q) && is_palindromic(q)\
    \ && q.sum() <= maxWeight\n                                                  ~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for i := 1; i < len(q); i++ {\n        var currentSum = q[i] + maxSumElement\n\
    \        if currentSum > maxSum {\n            maxSum = currentSum\n         \
    \   maxSumIndex = i\n            maxSumElement = q[i]\n        }\n    }\n    return\
    \ maxSum == w && maxSumIndex == 0 && maxSumElement == q[0]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe5jba4pm.swift:21:12: error: expected type\n    for i := 1; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpe5jba4pm.swift:21:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpe5jba4pm.swift:21:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == q[1]\n    }\n    if w\
    \ == 2 {\n        return q[0] == q[1] && q[0] == q[2]\n    }\n    if w == 3 {\n\
    \        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0]\
    \ == q[4]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[0] == q[2]\
    \ && q[0] == q[3] && q[0] == q[4] && q[0] == q[5]\n    }\n    if w == 6 {\n  \
    \      return q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] &&\
    \ q[0] == q[5] && q[0] == q[6]\n    }\n    if w == 7 {\n        return q[0] ==\
    \ q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0]\
    \ == q[6] && q[0] == q[7]\n    }\n    if w == 8 {\n        return q[0] == q[1]\
    \ && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0] == q[6]\
    \ && q[0] == q[7] && q[0] == q[8]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0]\
    \ == q[6] && q[0] == q[7] && q[0] == q[8] && q[0] == q[9]\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0p0iji81/tmp0p0iji81.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8dbb1c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8dbaebfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8dbaebf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8dbaebe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0p0iji81                        0x00005559c22b93af <unavailable> + 5039

    5    libc.so.6                          0x00002b8dbb3b4460 __libc_start_main +
    245

    6    tmp0p0iji81                        0x00005559c22b9019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ = maxSum * element + element\n    }\n    return maxSum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp3olesg7a/tmp3olesg7a.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cbf02fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cbed26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cbed26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cbed257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3olesg7a                        0x0000560aa47b246f <unavailable> + 5231

    5    libc.so.6                          0x00002b1cbf21b460 __libc_start_main +
    245

    6    tmp3olesg7a                        0x0000560aa47b20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    let maxWeight = w - first - last\n    return maxWeight <= q.count\
    \ && maxWeight == (q.count - q.first! - q.last!)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpf_mzbhuy/tmpf_mzbhuy.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad19e855c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad19e54cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad19e54c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad19e54b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf_mzbhuy                        0x000056169a11951f <unavailable> + 5407

    5    libc.so.6                          0x00002ad19ea41460 __libc_start_main +
    245

    6    tmpf_mzbhuy                        0x000056169a119189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = w\n    for element\
    \ in q {\n        if element > maxWeight {\n            maxWeight = element\n\
    \        }\n        if element + maxWeight > maxSum {\n            maxSum = element\
    \ + maxWeight\n        }\n    }\n    return maxSum == w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpxjazlz1i/tmpxjazlz1i.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22ff2d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22fefc8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22fefc8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22fefc77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxjazlz1i                        0x00005610db44946f <unavailable> + 5231

    5    libc.so.6                          0x00002b22ff4bd460 __libc_start_main +
    245

    6    tmpxjazlz1i                        0x00005610db4490d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp4n4vhuzn/tmp4n4vhuzn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3b3e86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3b3b7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3b3b7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3b3b7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4n4vhuzn                        0x000056110da3752b <unavailable> + 5419

    5    libc.so.6                          0x00002ad3b4072460 __libc_start_main +
    245

    6    tmp4n4vhuzn                        0x000056110da370d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else { return\
    \ false }\n    let sum = q.sum()\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwavkj986.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmpwavkj986.swift:18:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmpwavkj986.swift:18:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmpwavkj986.swift:19:17: error: value of type '[Int]' has\
    \ no member 'sum'\n    let sum = q.sum()\n              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    let maxPalindromic\
    \ = q.palindromic\n    let maxPalindromicSum = maxPalindromic.sum\n    return\
    \ maxWeight <= maxPalindromicSum && maxPalindromic.count == q.count && maxPalindromic.count\
    \ == q.count && maxPalindromic.count == q.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgbb7ngzh.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpgbb7ngzh.swift:20:28:\
    \ error: value of type '[Int]' has no member 'palindromic'\n    let maxPalindromic\
    \ = q.palindromic\n                         ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == q[1]\n    }\n    if w\
    \ == 2 {\n        return q[0] == q[1] && q[1] == q[2]\n    }\n    if w == 3 {\n\
    \        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3]\
    \ == q[4]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[1] == q[2]\
    \ && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\n    }\n    if w == 6 {\n  \
    \      return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] &&\
    \ q[4] == q[5] && q[5] == q[6]\n    }\n    if w == 7 {\n        return q[0] ==\
    \ q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7]\n    }\n    if w == 8 {\n        return q[0] == q[1]\
    \ && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5] == q[6]\
    \ && q[6] == q[7] && q[7] == q[8]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7] && q[7] == q[8] && q[8] == q[9]\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5qt_6pof/tmp5qt_6pof.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b672e34dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b672e044b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b672e044988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b672e0437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5qt_6pof                        0x000055f407ba63af <unavailable> + 5039

    5    libc.so.6                          0x00002b672e539460 __libc_start_main +
    245

    6    tmp5qt_6pof                        0x000055f407ba6019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpu5g73x23/tmpu5g73x23.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cb081cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cb0513b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cb0513988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cb05127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu5g73x23                        0x0000563f30d7f3bb <unavailable> + 5051

    5    libc.so.6                          0x00002b1cb0a08460 __libc_start_main +
    245

    6    tmpu5g73x23                        0x0000563f30d7ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let q = q.sorted() else { return false }\n    let\
    \ maxWeight = w * q.reduce(0) { $0 + $1 }\n    return q == q.reversed().sorted()\
    \ && q.sum() <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6ok0b6rc.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else { return\
    \ false }\n          ^       ~~~~~~~~~~\n/tmp/tmp6ok0b6rc.swift:20:44: error:\
    \ value of type '[Int]' has no member 'sum'\n    return q == q.reversed().sorted()\
    \ && q.sum() <= maxWeight\n                                         ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ maxWeight <= maxSum && q.count == q.countPalindrome()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpeeph6o8i.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpeeph6o8i.swift:20:48:\
    \ error: value of type '[Int]' has no member 'countPalindrome'\n    return maxWeight\
    \ <= maxSum && q.count == q.countPalindrome()\n                              \
    \               ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpk1pwrz71/tmpk1pwrz71.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08a97ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08a94e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08a94e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08a94e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk1pwrz71                        0x0000556ef37483bb <unavailable> + 5051

    5    libc.so.6                          0x00002b08a99d7460 __libc_start_main +
    245

    6    tmpk1pwrz71                        0x0000556ef3747f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first,\n        let last = q.last,\n      \
    \  let first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n        let last =\
    \ q.last,\n        let first = q.first,\n        let last = q.last,\n        let\
    \ first = q.first,\n        let last = q.last,\n        let first = q.first,\n\
    \        let last = q.last,\n        let first = q.first,\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpftfe15n8.swift:99:29: error: expected expression in conditional\n\
    \        let first = q.first,\n                            ^\n/tmp/tmpftfe15n8.swift:19:15:\
    \ warning: value 'first' was defined but never used; consider replacing with boolean\
    \ test\n    guard let first = q.first else { return false }\n          ~~~~^~~~~~~~\n\
    \                              != nil\n/tmp/tmpftfe15n8.swift:20:15: warning:\
    \ value 'last' was defined but never used; consider replacing with boolean test\n\
    \    guard let last = q.last else { return false }\n          ~~~~^~~~~~~\n  \
    \                          != nil\n/tmp/tmpftfe15n8.swift:21:15: warning: immutable\
    \ value 'first' was never used; consider replacing with '_' or removing it\n \
    \   guard let first = q.first,\n          ~~~~^~~~~\n          _\n/tmp/tmpftfe15n8.swift:22:13:\
    \ warning: immutable value 'last' was never used; consider replacing with '_'\
    \ or removing it\n        let last = q.last,\n        ~~~~^~~~\n        _\n/tmp/tmpftfe15n8.swift:23:13:\
    \ warning: immutable value 'first' was never used; consider replacing with '_'\
    \ or removing it\n        let first = q.first,\n        ~~~~^~~~~\n        _\n\
    /tmp/tmpftfe15n8.swift:24:13: warning: immutable value 'last' was never used;\
    \ consider replacing with '_' or removing it\n        let last = q.last,\n   \
    \     ~~~~^~~~\n        _\n/tmp/tmpftfe15n8.swift:25:13: warning: immutable value\
    \ 'first' was never used; consider replacing with '_' or removing it\n       \
    \ let first = q.first,\n        ~~~~^~~~~\n        _\n/tmp/tmpftfe15n8.swift:26:13:\
    \ warning: immutable value 'last' was never used; consider replacing with '_'\
    \ or removing it\n        let last = q.last,\n        ~~~~^~~~\n        _\n/tmp/tmpftfe15n8.swift:27:13:\
    \ warning: immutable value 'first' was never used; consider replacing with '_'\
    \ or removing it\n        let first = q.first,\n        ~~~~^~~~~\n        _\n\
    /tmp/tmpftfe15n8.swift:28:13: warning: immutable value 'last' was never used;\
    \ consider replacing with '_' or removing it\n        let last = q.last,\n   \
    \     ~~~~^~~~\n        _\n/tmp/tmpftfe15n8.swift:29:13: warning: im"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa95330ym/tmpa95330ym.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2d1852c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2d1549b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2d1549988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2d15487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa95330ym                        0x000055a78333746f <unavailable> + 5231

    5    libc.so.6                          0x00002ad2d1a3e460 __libc_start_main +
    245

    6    tmpa95330ym                        0x000055a7833370d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    var sum = 0\n    for element in q {\n       \
    \ sum += element\n    }\n    return sum == w && is_balanced(q)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbm45qjak.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpbm45qjak.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpbm45qjak.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpbm45qjak.swift:25:24:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_balanced(q)\n\
    \                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.reduce(0) { $0 +\
    \ $1 < maxWeight }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl3jmcxyf.swift:19:14: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n    return q.reduce(0) { $0 + $1 < maxWeight }\n  \
    \           ^\n           (                                   != 0)\n/tmp/tmpl3jmcxyf.swift:19:34:\
    \ error: cannot convert value of type 'Bool' to closure result type 'Int'\n  \
    \  return q.reduce(0) { $0 + $1 < maxWeight }\n                         ~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.maxElement()\n\
    \    return maxSum < maxWeight && isPalindromic(q, maxWeight)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpub5l_u5g.swift:19:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxSum = q.maxElement()\n                 ~ ^~~~~~~~~~\n\
    /tmp/tmpub5l_u5g.swift:20:34: error: cannot find 'isPalindromic' in scope\n  \
    \  return maxSum < maxWeight && isPalindromic(q, maxWeight)\n                \
    \                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.reduce(0, +)\n\
    \    for i in\n        stride(from: 0, to: q.count, by: 1) {\n            let\
    \ weight = q[i]\n            let sum = maxSum - weight\n            if sum > maxWeight\
    \ {\n                maxWeight = sum\n                maxSum = weight\n      \
    \      }\n        }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpqc9ix72c/tmpqc9ix72c.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b005ea1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b005e711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b005e711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b005e7107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqc9ix72c                        0x00005638937ed6eb <unavailable> + 5867

    5    libc.so.6                          0x00002b005ec06460 __libc_start_main +
    245

    6    tmpqc9ix72c                        0x00005638937ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        max = max(max,\
    \ x)\n    }\n    if max <= w {\n        return true\n    }\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmu_m_03e.swift:20:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else {\n        return false\n\
    \    }\n    \n    let maxWeight = w.reduce(0, combine: +)\n    \n    return q.reduce(0,\
    \ combine: >) <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxdfhgnob.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else {\n                     ~ ^~~~~\n\
    /tmp/tmpxdfhgnob.swift:22:23: error: value of type 'Int' has no member 'reduce'\n\
    \    let maxWeight = w.reduce(0, combine: +)\n                    ~ ^~~~~~\n/tmp/tmpxdfhgnob.swift:24:20:\
    \ error: extraneous argument label 'combine:' in call\n    return q.reduce(0,\
    \ combine: >) <= maxWeight\n                   ^   ~~~~~~~~~\n               \
    \        \n/tmp/tmpxdfhgnob.swift:24:21: error: type 'Int' cannot be used as a\
    \ boolean; test for '!= 0' instead\n    return q.reduce(0, combine: >) <= maxWeight\n\
    \                    ^\n                    ( != 0)\n/tmp/tmpxdfhgnob.swift:24:33:\
    \ error: binary operator '>' cannot be applied to operands of type 'Bool' and\
    \ 'Int'\n    return q.reduce(0, combine: >) <= maxWeight\n                   \
    \             ^\nSwift.BinaryInteger:1:11: note: candidate requires that 'Bool'\
    \ conform to 'BinaryInteger' (requirement specified as 'Self' : 'BinaryInteger')\n\
    extension BinaryInteger {\n          ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count && q.count == q.max() else {\
    \ return false }\n    var sum = 0\n    for i in 0 ..< q.count {\n        sum +=\
    \ q[i]\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu16ecogp.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count && q.count == q.max() else { return false\
    \ }\n                     ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.fold(0, +)\n  \
    \  return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju_dc75n.swift:19:20: error: value of type '[Int]' has no member\
    \ 'fold'\n    let maxSum = q.fold(0, +)\n                 ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let sum = q.reduce(0, +) else { return false }\n    return\
    \ sum == w && first == last\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp60mt69ff.swift:21:11: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n    guard let sum = q.reduce(0, +) else\
    \ { return false }\n          ^         ~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.fold(0, +)\n  \
    \  return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju_dc75n.swift:19:20: error: value of type '[Int]' has no member\
    \ 'fold'\n    let maxSum = q.fold(0, +)\n                 ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplwpl0szo.swift:81:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmplwpl0szo.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmplwpl0szo.swift:60:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmplwpl0szo.swift:64:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmplwpl0szo.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:21:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:22:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:23:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:24:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:25:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    if q.count == 1 {\n        return true\n    }\n    if w == 1 {\n   \
    \     return true\n    }\n    if w == q.last {\n        return true\n    }\n \
    \   if w == q[0] {\n        return true\n    }\n    if w == q[q.count - 1] {\n\
    \        return true\n    }\n    if w == q[q.count - 2] + q[q.count - 1] {\n \
    \       return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp36eupyle/tmp36eupyle.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0b1f3dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0b1c34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0b1c34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0b1c337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp36eupyle                        0x000056175d45e44f <unavailable> + 5199

    5    libc.so.6                          0x00002ba0b2129460 __libc_start_main +
    245

    6    tmp36eupyle                        0x000056175d45e0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.map({ $0 + $1 }).reduce(0,\
    \ +)\n    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0rhroc3c.swift:19:24: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let maxSum\
    \ = q.map({ $0 + $1 }).reduce(0, +)\n                       ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var balanced = true\n    var sum\
    \ = 0\n    for x in q {\n        sum += x\n        if sum > maxWeight {\n    \
    \        balanced = false\n            break\n        }\n    }\n    if balanced\
    \ {\n        for x in q {\n            if x != q[q.index(of: x)!] {\n        \
    \        balanced = false\n                break\n            }\n        }\n \
    \   }\n    return balanced && sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpz95bfh_a/tmpz95bfh_a.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a27ad0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a277c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a277c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a277c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz95bfh_a                        0x0000564613eec68b <unavailable> + 5771

    5    libc.so.6                          0x00002b3a27cbc460 __libc_start_main +
    245

    6    tmpz95bfh_a                        0x0000564613eec239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        maxSum -= x\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpirrn1sfq/tmpirrn1sfq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b39381f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3937ee7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3937ee7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3937ee67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpirrn1sfq                        0x00005625d880646f <unavailable> + 5231

    5    libc.so.6                          0x00002b39383dc460 __libc_start_main +
    245

    6    tmpirrn1sfq                        0x00005625d88060d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = 0\n    var isPalindromic = false\n    for i := 0; i < len(q); i++ {\n    \
    \    if q[i] > maxSum {\n            maxSum = q[i]\n            maxSumIndex =\
    \ i\n            maxSumElement = q[i]\n        }\n    }\n    if maxSum == w {\n\
    \        isPalindromic = true\n    }\n    for i := 0; i < len(q); i++ {\n    \
    \    if q[i] > maxSum {\n            maxSum = q[i]\n            maxSumIndex =\
    \ i\n            maxSumElement = q[i]\n        }\n    }\n    if maxSum == w {\n\
    \        isPalindromic = true\n    }\n    if maxSum < w {\n        isPalindromic\
    \ = false\n    }\n    if maxSum == w {\n        isPalindromic = true\n    }\n\
    \    if maxSum < w {\n        isPalindromic = false\n    }\n    if maxSum == w\
    \ {\n        isPalindromic = true\n    }\n    if maxSum < w {\n        isPalindromic\
    \ = false\n    }\n    if maxSum == w {\n        isPalindromic = true\n    }\n\
    \    if maxSum < w {\n        isPalindromic = false\n    }\n    if maxSum == w\
    \ {\n        isPalindromic = true\n    }\n    if maxSum < w {\n        isPalindromic\
    \ = false\n    }\n    if maxSum == w {\n        isPalindromic = true\n    }\n\
    \    if maxSum < w {\n        isPalindromic = false\n    }\n    if maxSum == w\
    \ {\n        isPalindromic = true\n    }\n    if maxSum < w {\n        isPalindromic\
    \ = false\n    }\n    if maxSum == w {\n        isPalindromic = true\n    }\n\
    \    if maxSum < w {\n        isPalindromic = false\n    }\n    if maxSum == w\
    \ {\n        isPalindromic = true\n    }\n    if maxSum < w {\n        isPalindromic\
    \ = false\n    }\n    if maxSum == w {\n        isPalindromic = true\n    }\n\
    \    if maxSum < w {\n        isPalindromic = false\n    }\n    if maxSum == w\
    \ {\n        isPalindromic = true\n    }\n    if maxSum < w {\n        isPalindromic\
    \ = false\n    }\n    if maxSum == w {\n        isPalindromic = true\n    }\n\
    \    if maxSum < w {\n        isPalindromic = false\n    }\n    if maxSum == \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0xj2cfeb.swift:22:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp0xj2cfeb.swift:22:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp0xj2cfeb.swift:22:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmp0xj2cfeb.swift:32:12:\
    \ error: expected type\n    for i := 0; i < len(q); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmp0xj2cfeb.swift:32:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmp0xj2cfeb.swift:32:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(q);\
    \ i++ {\n           ^\n/tmp/tmp0xj2cfeb.swift:112:1: error: expected expression\
    \ after operator\n}\n^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w\n    let maxSum = q.sum\n    guard maxSum < maxWeight else { return false\
    \ }\n    let maxSumPalindromic = maxSum - maxWeight + 1\n    guard maxSumPalindromic\
    \ >= 0 else { return false }\n    let maxSumPalindromicHalf = maxSumPalindromic\
    \ / 2\n    guard maxSumPalindromicHalf < maxWeight else { return false }\n   \
    \ let maxSumPalindromicHalfPalindromic = maxSumPalindromicHalf + 1\n    guard\
    \ maxSumPalindromicHalfPalindromic >= 0 else { return false }\n    let maxSumPalindromicHalfPalindromicHalf\
    \ = maxSumPalindromicHalfPalindromic - 1\n    guard maxSumPalindromicHalfPalindromicHalf\
    \ >= 0 else { return false }\n    let maxSumPalindromicHalfPalindromicHalfPalindromic\
    \ = maxSumPalindromicHalfPalindromicHalf + 1\n    guard maxSumPalindromicHalfPalindromicHalfPalindromic\
    \ >= 0 else { return false }\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalf\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromic - 1\n    guard maxSumPalindromicHalfPalindromicHalfPalindromicHalf\
    \ >= 0 else { return false }\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic - 1\n    guard\
    \ maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf >= 0 else\
    \ { return false }\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf + 1\n \
    \   guard maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalfPalindromic\
    \ >= 0 else { return false }\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalfPalindromic\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqj69rpck.swift:20:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpqj69rpck.swift:34:74:\
    \ error: use of local variable 'maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic'\
    \ before its declaration\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic - 1\n     \
    \                                                                    ^\n/tmp/tmpqj69rpck.swift:34:9:\
    \ note: 'maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic' declared\
    \ here\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromic - 1\n     \
    \   ^\n/tmp/tmpqj69rpck.swift:35:11: error: use of local variable 'maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf'\
    \ before its declaration\n    guard maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf\
    \ >= 0 else { return false }\n          ^\n/tmp/tmpqj69rpck.swift:36:9: note:\
    \ 'maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf' declared\
    \ here\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf + 1\n \
    \       ^\n/tmp/tmpqj69rpck.swift:36:78: error: use of local variable 'maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf'\
    \ before its declaration\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf + 1\n \
    \                                                                            ^\n\
    /tmp/tmpqj69rpck.swift:36:9: note: 'maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf'\
    \ declared here\n    let maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf\
    \ = maxSumPalindromicHalfPalindromicHalfPalindromicHalfPalindromicHalf + 1\n \
    \       ^\n/tmp/tmpqj69rpck.swift:37:11: error: use of local variable 'maxSumPalindromicHalfPalindromicHalfPali"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.maxElement()\n\
    \    return q.count == 1 && maxSum == w && maxWeight <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps2zyqcm2.swift:19:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxSum = q.maxElement()\n                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.reduce(0, +)\n\
    \    for i in\n        stride(from: q.count - 1, through: 0, by: -1) {\n     \
    \       let weight = q[i]\n            let sum = maxSum - weight\n           \
    \ if sum > maxWeight {\n                maxWeight = sum\n                maxSum\
    \ = weight\n            }\n        }\n    return maxSum < maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpz0wsbrbf/tmpz0wsbrbf.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ca407dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ca3d74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ca3d74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ca3d737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz0wsbrbf                        0x000055e0a78c670b <unavailable> + 5899

    5    libc.so.6                          0x00002b4ca4269460 __libc_start_main +
    245

    6    tmpz0wsbrbf                        0x000055e0a78c62b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let middle = q.first + q.last else { return false }\n   \
    \ guard middle == w else { return false }\n    guard let middle2 = q.first + q.last\
    \ + 1 else {\n        return false\n    }\n    guard middle2 == w else { return\
    \ false }\n    guard let middle3 = q.first + q.last + 2 else {\n        return\
    \ false\n    }\n    guard middle3 == w else { return false }\n    guard let middle4\
    \ = q.first + q.last + 3 else {\n        return false\n    }\n    guard middle4\
    \ == w else { return false }\n    guard let middle5 = q.first + q.last + 4 else\
    \ {\n        return false\n    }\n    guard middle5 == w else { return false }\n\
    \    guard let middle6 = q.first + q.last + 5 else {\n        return false\n \
    \   }\n    guard middle6 == w else { return false }\n    guard let middle7 = q.first\
    \ + q.last + 6 else {\n        return false\n    }\n    guard middle7 == w else\
    \ { return false }\n    guard let middle8 = q.first + q.last + 7 else {\n    \
    \    return false\n    }\n    guard middle8 == w else { return false }\n    guard\
    \ let middle9 = q.first + q.last + 8 else {\n        return false\n    }\n   \
    \ guard middle9 == w else { return false }\n    guard let middle10 = q.first +\
    \ q.last + 9 else {\n        return false\n    }\n    guard middle10 == w else\
    \ { return false }\n    guard let middle11 = q.first + q.last + 10 else {\n  \
    \      return false\n    }\n    guard middle11 == w else { return false }\n  \
    \  guard let middle12 = q.first + q.last + 11 else {\n        return false\n \
    \   }\n    guard middle12 == w else { return false }\n    guard let middle13 =\
    \ q.first + q.last + 12 else {\n        return false\n    }\n    guard middle13\
    \ == w else { return false }\n    guard let middle14 = q.first + q.last + 13 else\
    \ {\n        return false\n    }\n    guard middle14 == w else { return false\
    \ }\n    guard let middle15 = q.first + q.last + 14 else {\n        return false\n\
    \    }\n    guard middle15 == w else { return false }\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpox67k4us.swift:21:32: error: binary operator '+' cannot be applied\
    \ to two 'Int?' operands\n    guard let middle = q.first + q.last else { return\
    \ false }\n                       ~~~~~~~ ^ ~~~~~~\n/tmp/tmpox67k4us.swift:21:32:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard let middle = q.first + q.last else { return false }\n\
    \                               ^\n/tmp/tmpox67k4us.swift:23:33: error: binary\
    \ operator '+' cannot be applied to two 'Int?' operands\n    guard let middle2\
    \ = q.first + q.last + 1 else {\n                        ~~~~~~~ ^ ~~~~~~\n/tmp/tmpox67k4us.swift:23:33:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard let middle2 = q.first + q.last + 1 else {\n          \
    \                      ^\n/tmp/tmpox67k4us.swift:27:33: error: binary operator\
    \ '+' cannot be applied to two 'Int?' operands\n    guard let middle3 = q.first\
    \ + q.last + 2 else {\n                        ~~~~~~~ ^ ~~~~~~\n/tmp/tmpox67k4us.swift:27:33:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard let middle3 = q.first + q.last + 2 else {\n          \
    \                      ^\n/tmp/tmpox67k4us.swift:31:33: error: binary operator\
    \ '+' cannot be applied to two 'Int?' operands\n    guard let middle4 = q.first\
    \ + q.last + 3 else {\n                        ~~~~~~~ ^ ~~~~~~\n/tmp/tmpox67k4us.swift:31:33:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard let middle4 = q.first + q.last + 3 else {\n          \
    \                      ^\n/tmp/tmpox67k4us.swift:35:33: error: binary operator\
    \ '+' cannot be applied to two 'Int?' operands\n    guard let middle5 = q.first\
    \ + q.last + 4 else {\n                        ~~~~~~~ ^ ~~~~~~\n/tmp/tmpox67k4us.swift:35:33:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard let middle5 = q.first + q.last + 4 else {\n          \
    \                      ^\n/tmp/tmpox67k4us.swift:39:33: error: binary operator\
    \ '+"
  stdout: ''
  timestamp: 1660014558
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.isEmpty {\n        return true\n    }\n    if q.first\
    \ == q.last {\n        return true\n    }\n    if w == 0 {\n        return false\n\
    \    }\n    let maxWeight = w * q.last\n    let maxSum = q.last * q.last\n   \
    \ for element in q {\n        if element > maxWeight {\n            return false\n\
    \        }\n    }\n    if maxSum < w {\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpebgzlf5j.swift:27:27: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    let maxWeight = w * q.last\n    \
    \                      ^\n/tmp/tmpebgzlf5j.swift:27:27: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    let maxWeight\
    \ = w * q.last\n                          ^\n                        (      ??\
    \ <#default value#>)\n/tmp/tmpebgzlf5j.swift:27:27: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n    let maxWeight =\
    \ w * q.last\n                          ^\n                              !\n/tmp/tmpebgzlf5j.swift:28:25:\
    \ error: binary operator '*' cannot be applied to two 'Int?' operands\n    let\
    \ maxSum = q.last * q.last\n                 ~~~~~~ ^ ~~~~~~\n/tmp/tmpebgzlf5j.swift:28:25:\
    \ note: overloads for '*' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    let maxSum = q.last * q.last\n                        ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        max = max(max,\
    \ x)\n    }\n    if max > w {\n        return false\n    }\n    var sum = 0\n\
    \    for x in q {\n        sum += x\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyp9yj874.swift:20:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let maxSum = maxWeight + w\n\
    \    return q == reverse(q.prefix(q.count)) && q.sum() <= maxSum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzrzybm0k.swift:20:17: error: cannot find 'reverse' in scope\n \
    \   return q == reverse(q.prefix(q.count)) && q.sum() <= maxSum\n            \
    \    ^~~~~~~\n/tmp/tmpzrzybm0k.swift:20:49: error: value of type '[Int]' has no\
    \ member 'sum'\n    return q == reverse(q.prefix(q.count)) && q.sum() <= maxSum\n\
    \                                              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb0thsbge.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplwpl0szo.swift:81:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmplwpl0szo.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmplwpl0szo.swift:60:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmplwpl0szo.swift:64:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmplwpl0szo.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:21:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:22:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:23:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:24:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:25:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    var sum = 0\n    var i = 0\n    for element in\
    \ q {\n        sum += element\n        i += 1\n    }\n    return sum == w && is_palindromic(q)\
    \ && i <= q.max() / 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpofp2fcab.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpofp2fcab.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpofp2fcab.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpofp2fcab.swift:27:24:\
    \ error: cannot find 'is_palindromic' in scope\n    return sum == w && is_palindromic(q)\
    \ && i <= q.max() / 2\n                       ^~~~~~~~~~~~~~\n/tmp/tmpofp2fcab.swift:27:52:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return sum == w && is_palindromic(q) && i <= q.max() / 2\n              \
    \                                     ^\n/tmp/tmpofp2fcab.swift:27:52: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return sum == w && is_palindromic(q) && i <= q.max() / 2\n                 \
    \                                  ^\n                                       \
    \          (       ?? <#default value#>)\n/tmp/tmpofp2fcab.swift:27:52: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    return sum == w && is_palindromic(q) && i <= q.max() / 2\n              \
    \                                     ^\n                                    \
    \                    !\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = w.reduce(0, combine:\
    \ +)\n    return q.count == 0 && maxSum == maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfqsvp6ix.swift:19:20: error: value of type 'Int' has no member\
    \ 'reduce'\n    let maxSum = w.reduce(0, combine: +)\n                 ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for x in q {\n\
    \        sum += x\n        if sum > maxWeight {\n            maxWeight = sum\n\
    \        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpia3_pfqx/tmpia3_pfqx.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b013b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b010acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b010ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b010ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpia3_pfqx                        0x000055cdd491752b <unavailable> + 5419

    5    libc.so.6                          0x00002b1b015a1460 __libc_start_main +
    245

    6    tmpia3_pfqx                        0x000055cdd49170d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i := 0; i < len(q); i++ {\n \
    \       maxSum = maxSum * 10 + q[i]\n    }\n    return maxSum == w && is_balanced(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp00f4kin_.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp00f4kin_.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp00f4kin_.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmp00f4kin_.swift:22:27:\
    \ error: cannot find 'is_balanced' in scope\n    return maxSum == w && is_balanced(q)\n\
    \                          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let firstReversed = q.reversed().first else { return false\
    \ }\n    guard let lastReversed = q.reversed().last else { return false }\n  \
    \  guard first == lastReversed else { return false }\n    guard q.count == w-first\
    \ else { return false }\n    guard q.count == w-firstReversed else { return false\
    \ }\n    guard q.count == w-lastReversed else { return false }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp_g7tt00r/tmp_g7tt00r.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3f3cfcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3f39f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3f39f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3f39f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_g7tt00r                        0x00005595f0d235ff <unavailable> + 5631

    5    libc.so.6                          0x00002af3f3ee8460 __libc_start_main +
    245

    6    tmp_g7tt00r                        0x00005595f0d23269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else { return\
    \ false }\n    guard q.count == 1 || q.max() == w else { return false }\n    guard\
    \ let first = q.first else { return false }\n    guard let last = q.last else\
    \ { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n        let last = q.last,\n        let first =\
    \ q.first,\n        let last = q.last,\n        let first = q.first,\n       \
    \ let last = q.last,\n        let first = q.first,\n        let last = q.last,\n\
    \        let first = q.first,\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk76zdhbv.swift:96:29: error: expected expression in conditional\n\
    \        let first = q.first,\n                            ^\n/tmp/tmpk76zdhbv.swift:18:42:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n      \
    \                                   ^\n/tmp/tmpk76zdhbv.swift:18:42: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n         \
    \                                ^\n                                         \
    \      ?? <#default value#>\n/tmp/tmpk76zdhbv.swift:18:42: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    guard\
    \ q.count > 0 && w > 0 && w <= q.max() else { return false }\n               \
    \                          ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == q[0]\n    }\n    if w == 0 {\n      \
    \  return false\n    }\n    if w == 1 {\n        return q[0] == q[0]\n    }\n\
    \    if w == 2 {\n        return q[0] == q[1] && q[1] == q[0]\n    }\n    if w\
    \ == 3 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[0]\n    }\n\
    \    if w == 4 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3]\
    \ && q[3] == q[0]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[1]\
    \ == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[0]\n    }\n    if w ==\
    \ 6 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] ==\
    \ q[4] && q[4] == q[5] && q[5] == q[0]\n    }\n    if w == 7 {\n        return\
    \ q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\
    \ && q[5] == q[6] && q[6] == q[0]\n    }\n    if w == 8 {\n        return q[0]\
    \ == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7] && q[7] == q[0]\n    }\n    if w == 9 {\n        return\
    \ q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\
    \ && q[5] == q[6] && q[6] == q[7] && q[7] == q[8] && q[8] == q[0]\n    }\n   \
    \ return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpwxnxc1d7/tmpwxnxc1d7.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0edc264c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0edbf5bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0edbf5b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0edbf5a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxnxc1d7                        0x00005577131083af <unavailable> + 5039

    5    libc.so.6                          0x00002b0edc450460 __libc_start_main +
    245

    6    tmpwxnxc1d7                        0x0000557713108019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    \n\
    \    let maxWeight = w\n    \n    var maxSum = q[0]\n    for element in q {\n\
    \        maxSum = maxSum + element\n    }\n    \n    for element in q {\n    \
    \    if maxSum > maxWeight {\n            return false\n        }\n        maxSum\
    \ = maxSum - element\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpo4qi8xiy/tmpo4qi8xiy.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5322724c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b532241bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b532241b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b532241a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4qi8xiy                        0x000056481d69c51f <unavailable> + 5407

    5    libc.so.6                          0x00002b5322910460 __libc_start_main +
    245

    6    tmpo4qi8xiy                        0x000056481d69c189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = 0\n    var isBalanced = true\n\n    for i := 0; i < len(q); i++ {\n      \
    \  var currentSum = q[i]\n        for j := 0; j < i; j++ {\n            currentSum\
    \ += q[j]\n        }\n        if currentSum > maxSum {\n            maxSum = currentSum\n\
    \            maxSumIndex = i\n            maxSumElement = q[i]\n        }\n  \
    \  }\n\n    if maxSum > w {\n        isBalanced = false\n    }\n\n    if maxSum\
    \ == w {\n        return true\n    }\n\n    if maxSum < w {\n        for i :=\
    \ 0; i < len(q); i++ {\n            if q[i] != maxSumElement {\n             \
    \   isBalanced = false\n                break\n            }\n        }\n    }\n\
    \n    return isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo2l2aao0.swift:23:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpo2l2aao0.swift:23:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpo2l2aao0.swift:23:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpo2l2aao0.swift:25:16:\
    \ error: expected type\n        for j := 0; j < i; j++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpo2l2aao0.swift:25:16: error: expected 'in' after\
    \ for-each pattern\n        for j := 0; j < i; j++ {\n               ^\n/tmp/tmpo2l2aao0.swift:25:16:\
    \ error: expected Sequence expression for for-each loop\n        for j := 0; j\
    \ < i; j++ {\n               ^\n/tmp/tmpo2l2aao0.swift:44:16: error: expected\
    \ type\n        for i := 0; i < len(q); i++ {\n               ^\n            \
    \    <#type#>\n/tmp/tmpo2l2aao0.swift:44:16: error: expected 'in' after for-each\
    \ pattern\n        for i := 0; i < len(q); i++ {\n               ^\n/tmp/tmpo2l2aao0.swift:44:16:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < len(q); i++ {\n               ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    let maxSum = q.maxElement()\n    return maxSum < maxWeight\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphphkw2tx.swift:20:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    let maxSum = q.maxElement()\n                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for x in q {\n        if x > max {\n\
    \            max = x\n        }\n    }\n    if max > w {\n        return false\n\
    \    }\n    var sum = 0\n    for x in q {\n        sum += x\n    }\n    if sum\
    \ < w {\n        return false\n    }\n    if sum == w {\n        return true\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpl2j0pag5/tmpl2j0pag5.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b948324fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9482f46b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9482f46988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9482f457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2j0pag5                        0x000055f6aba0d46f <unavailable> + 5231

    5    libc.so.6                          0x00002b948343b460 __libc_start_main +
    245

    6    tmpl2j0pag5                        0x000055f6aba0d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb0thsbge.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    \n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyjr0ubnh/tmpyjr0ubnh.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3b183fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3b1536b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3b1536988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3b15357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyjr0ubnh                        0x00005589b19cd3bb <unavailable> + 5051

    5    libc.so.6                          0x00002ac3b1a2b460 __libc_start_main +
    245

    6    tmpyjr0ubnh                        0x00005589b19ccf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = 0\n    for element\
    \ in q {\n        maxWeight -= element\n        maxSum += element\n    }\n   \
    \ return maxWeight <= 0 && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp2nwarg7y/tmp2nwarg7y.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6085d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6082ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6082cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6082cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2nwarg7y                        0x000055c42a86446f <unavailable> + 5231

    5    libc.so.6                          0x00002ba6087c1460 __libc_start_main +
    245

    6    tmp2nwarg7y                        0x000055c42a8640d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.isEmpty {\n        return true\n    }\n    if q.first\
    \ == q.last {\n        return true\n    }\n    if w == 0 {\n        return false\n\
    \    }\n    if w > q.last {\n        return false\n    }\n    if w == q.last {\n\
    \        return true\n    }\n    if w == q.first {\n        return false\n   \
    \ }\n    let left = q.first - 1\n    let right = q.last + 1\n    let mid = left\
    \ + (right - left) / 2\n    if will_it_fly(q: q.suffix(from: mid), w: w - mid)\
    \ {\n        return true\n    }\n    if will_it_fly(q: q.prefix(to: mid), w: w\
    \ - mid) {\n        return true\n    }\n    if will_it_fly(q: q.suffix(from: mid),\
    \ w: w) {\n        return true\n    }\n    if will_it_fly(q: q.prefix(to: mid),\
    \ w: w) {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpni0rahg4.swift:27:14: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if w > q.last {\n             ^\n\
    /tmp/tmpni0rahg4.swift:27:14: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    if w > q.last {\n             ^\n   \
    \               ?? <#default value#>\n/tmp/tmpni0rahg4.swift:27:14: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if w\
    \ > q.last {\n             ^\n                 !\n/tmp/tmpni0rahg4.swift:36:18:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let left = q.first - 1\n                 ^\n/tmp/tmpni0rahg4.swift:36:18:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let left = q.first - 1\n                 ^\n               (    \
    \   ?? <#default value#>)\n/tmp/tmpni0rahg4.swift:36:18: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    let left =\
    \ q.first - 1\n                 ^\n                      !\n/tmp/tmpni0rahg4.swift:37:19:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let right = q.last + 1\n                  ^\n/tmp/tmpni0rahg4.swift:37:19:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let right = q.last + 1\n                  ^\n                (  \
    \    ?? <#default value#>)\n/tmp/tmpni0rahg4.swift:37:19: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    let right =\
    \ q.last + 1\n                  ^\n                      !\n/tmp/tmpni0rahg4.swift:39:25:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    if will_it_fly(q: q.suffix(from: mid), w: w - mid) {\n        \
    \                ^\n/tmp/tmpni0rahg4.swift:42:25: error: cannot convert value\
    \ of type 'ArraySlice<Int>' to expected argument type '[Int]'\n    if will_it_fly(q:\
    \ q.prefix(to: mid), w: w - mid) {\n                        ^\n/tmp/tmpni0rahg4.swift:42:31:\
    \ error: extraneo"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb0thsbge.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb0thsbge.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    var max = 0\n    for x in q {\n    \
    \    sum += x\n        if sum > max {\n            max = sum\n        }\n    }\n\
    \    return sum <= w && sum == max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmppr2lz7zb/tmppr2lz7zb.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5957426c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b595711db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b595711d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b595711c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppr2lz7zb                        0x00005567d922e52b <unavailable> + 5419

    5    libc.so.6                          0x00002b5957612460 __libc_start_main +
    245

    6    tmppr2lz7zb                        0x00005567d922e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.fold(0, +)\n  \
    \  return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju_dc75n.swift:19:20: error: value of type '[Int]' has no member\
    \ 'fold'\n    let maxSum = q.fold(0, +)\n                 ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfElements = q.map\
    \ { $0.1 }.reduce(0, +)\n    return sumOfElements <= maxWeight\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu65py1ci.swift:19:36: error: value of type 'Int' has no member\
    \ '1'\n    let sumOfElements = q.map { $0.1 }.reduce(0, +)\n                 \
    \               ~~ ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    var sum = 0\n    var max = 0\n    for element\
    \ in q {\n        sum += element\n        if sum > max {\n            max = sum\n\
    \        }\n    }\n    return sum == max && q == q.sorted().reverse()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpel13li5g.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpel13li5g.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpel13li5g.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpel13li5g.swift:29:26:\
    \ error: cannot convert value of type '[Int]' to expected argument type '()'\n\
    \    return sum == max && q == q.sorted().reverse()\n                        \
    \ ^\n/tmp/tmpel13li5g.swift:29:42: error: cannot use mutating member on immutable\
    \ value: function call returns immutable value\n    return sum == max && q ==\
    \ q.sorted().reverse()\n                              ~~~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w * w\n    var sum = 0\n    for element in q {\n        sum += element\n \
    \   }\n    return sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa9jd8r7l/tmpa9jd8r7l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3bafcac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3bacc1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3bacc1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3bacc07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa9jd8r7l                        0x000056201bb894bf <unavailable> + 5311

    5    libc.so.6                          0x00002ba3bb1b6460 __libc_start_main +
    245

    6    tmpa9jd8r7l                        0x000056201bb89129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    var sum = 0\n    for element\
    \ in q {\n        sum += element\n    }\n    return sum <= maxWeight\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5toa_fdr/tmp5toa_fdr.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba41413ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba413e35b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba413e35988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba413e347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5toa_fdr                        0x000055ae1701452b <unavailable> + 5419

    5    libc.so.6                          0x00002ba41432a460 __libc_start_main +
    245

    6    tmp5toa_fdr                        0x000055ae170140d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    for v in q {\n        max = max(max,\
    \ v)\n    }\n    if max <= w {\n        return true\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc3_c4qe5.swift:20:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, v)\n              ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == maxWeight && maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb0thsbge.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    let sum: Int = q.fold(0, +)\n    return sum <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps5iyv8ul.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmps5iyv8ul.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmps5iyv8ul.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmps5iyv8ul.swift:21:22:\
    \ error: value of type '[Int]' has no member 'fold'\n    let sum: Int = q.fold(0,\
    \ +)\n                   ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for index in 1..<q.count {\n        let element = q[index]\n   \
    \     let sum = element + maxSumElement\n        if sum > maxSum {\n         \
    \   maxSum = sum\n            maxSumIndex = index\n            maxSumElement =\
    \ element\n        }\n    }\n    return maxSum == w && maxSumIndex == q.count\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpooowbtgf/tmpooowbtgf.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75f15d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75f12ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75f12cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75f12cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpooowbtgf                        0x000056075278a53f <unavailable> + 5439

    5    libc.so.6                          0x00002b75f17c1460 __libc_start_main +
    245

    6    tmpooowbtgf                        0x000056075278a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i : Int in q {\n        maxSum\
    \ -= i\n    }\n    return maxSum < 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpp5gk77ta/tmpp5gk77ta.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad73566c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad7325db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad7325d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad7325c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp5gk77ta                        0x00005591136ad46f <unavailable> + 5231

    5    libc.so.6                          0x00002aad73752460 __libc_start_main +
    245

    6    tmpp5gk77ta                        0x00005591136ad0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.fold(0, +)\n  \
    \  return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju_dc75n.swift:19:20: error: value of type '[Int]' has no member\
    \ 'fold'\n    let maxSum = q.fold(0, +)\n                 ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for element in\
    \ q {\n        sum += element\n        if sum > maxWeight {\n            maxWeight\
    \ = sum\n        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpllb5sj_9/tmpllb5sj_9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b734cf9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b734cc93b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b734cc93988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b734cc927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllb5sj_9                        0x000055e06baf952b <unavailable> + 5419

    5    libc.so.6                          0x00002b734d188460 __libc_start_main +
    245

    6    tmpllb5sj_9                        0x000055e06baf90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let firstReversed = q.reversed().first else { return false\
    \ }\n    guard let lastReversed = q.reversed().last else { return false }\n  \
    \  guard let firstSum = q.reduce(0, +) else {\n        return false\n    }\n \
    \   guard let lastSum = q.reduce(0, +) else {\n        return false\n    }\n \
    \   guard firstSum + lastSum <= w else {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpw9mty_iw.swift:23:11: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n    guard let firstSum = q.reduce(0, +)\
    \ else {\n          ^              ~~~~~~~~~~~~~~\n/tmp/tmpw9mty_iw.swift:26:11:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \    guard let lastSum = q.reduce(0, +) else {\n          ^             ~~~~~~~~~~~~~~\n\
    /tmp/tmpw9mty_iw.swift:19:15: warning: value 'first' was defined but never used;\
    \ consider replacing with boolean test\n    guard let first = q.first else { return\
    \ false }\n          ~~~~^~~~~~~~\n                              != nil\n/tmp/tmpw9mty_iw.swift:20:15:\
    \ warning: value 'last' was defined but never used; consider replacing with boolean\
    \ test\n    guard let last = q.last else { return false }\n          ~~~~^~~~~~~\n\
    \                            != nil\n/tmp/tmpw9mty_iw.swift:21:15: warning: value\
    \ 'firstReversed' was defined but never used; consider replacing with boolean\
    \ test\n    guard let firstReversed = q.reversed().first else { return false }\n\
    \          ~~~~^~~~~~~~~~~~~~~~\n                                            \
    \     != nil\n/tmp/tmpw9mty_iw.swift:22:15: warning: value 'lastReversed' was\
    \ defined but never used; consider replacing with boolean test\n    guard let\
    \ lastReversed = q.reversed().last else { return false }\n          ~~~~^~~~~~~~~~~~~~~\n\
    \                                               != nil\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    let maxWeight = w * w\n    return q.count == maxWeight && q.sorted()\
    \ == q.sorted().reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpygnvwuwp.swift:22:38: error: cannot convert value of type '[Int]'\
    \ to expected argument type '()'\n    return q.count == maxWeight && q.sorted()\
    \ == q.sorted().reverse()\n                                     ^\n/tmp/tmpygnvwuwp.swift:22:61:\
    \ error: cannot use mutating member on immutable value: function call returns\
    \ immutable value\n    return q.count == maxWeight && q.sorted() == q.sorted().reverse()\n\
    \                                                 ~~~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    return\
    \ q.count == 1 && maxSum == maxWeight && q[0] == maxWeight\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvyj_9faa.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    var max = 0\n    for x in q {\n    \
    \    sum += x\n        if sum > max {\n            max = sum\n        }\n    }\n\
    \    return sum <= w && sum == max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmppr2lz7zb/tmppr2lz7zb.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5957426c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b595711db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b595711d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b595711c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppr2lz7zb                        0x00005567d922e52b <unavailable> + 5419

    5    libc.so.6                          0x00002b5957612460 __libc_start_main +
    245

    6    tmppr2lz7zb                        0x00005567d922e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    guard let first = q.first else {\n        return\
    \ false\n    }\n    guard let last = q.last else {\n        return false\n   \
    \ }\n    return q == reverse(q.prefix(q.count - 1)) && q.isPalindromic && q.sum()\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu82bhfzg.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpu82bhfzg.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpu82bhfzg.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpu82bhfzg.swift:27:17:\
    \ error: cannot find 'reverse' in scope\n    return q == reverse(q.prefix(q.count\
    \ - 1)) && q.isPalindromic && q.sum() <= w\n                ^~~~~~~\n/tmp/tmpu82bhfzg.swift:27:53:\
    \ error: value of type '[Int]' has no member 'isPalindromic'\n    return q ==\
    \ reverse(q.prefix(q.count - 1)) && q.isPalindromic && q.sum() <= w\n        \
    \                                          ~ ^~~~~~~~~~~~~\n/tmp/tmpu82bhfzg.swift:27:72:\
    \ error: value of type '[Int]' has no member 'sum'\n    return q == reverse(q.prefix(q.count\
    \ - 1)) && q.isPalindromic && q.sum() <= w\n                                 \
    \                                    ~ ^~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    let sumOfWeights = q.map {\
    \ $0 * $0 }.reduce(0, +)\n    return maxWeight <= sumOfWeights\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpb77o8pw_/tmpb77o8pw_.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9279b84c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b927987bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b927987b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b927987a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb77o8pw_                        0x00005608096ca41f <unavailable> + 5151

    5    libc.so.6                          0x00002b9279d70460 __libc_start_main +
    245

    6    tmpb77o8pw_                        0x00005608096ca089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for v in q {\n        maxSum -= v\n\
    \        if maxSum < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum == 0 || maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmps_9zb1df/tmps_9zb1df.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f2adbac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f2aab1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f2aab1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f2aab07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_9zb1df                        0x0000557fabc4b46f <unavailable> + 5231

    5    libc.so.6                          0x00002b4f2afa6460 __libc_start_main +
    245

    6    tmps_9zb1df                        0x0000557fabc4b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == q[1]\n    }\n    if w\
    \ == 2 {\n        return q[0] == q[1] && q[0] == q[2]\n    }\n    if w == 3 {\n\
    \        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0]\
    \ == q[4]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[0] == q[2]\
    \ && q[0] == q[3] && q[0] == q[4] && q[0] == q[5]\n    }\n    if w == 6 {\n  \
    \      return q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] &&\
    \ q[0] == q[5] && q[0] == q[6]\n    }\n    if w == 7 {\n        return q[0] ==\
    \ q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0]\
    \ == q[6] && q[0] == q[7]\n    }\n    if w == 8 {\n        return q[0] == q[1]\
    \ && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0] == q[6]\
    \ && q[0] == q[7] && q[0] == q[8]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0]\
    \ == q[6] && q[0] == q[7] && q[0] == q[8] && q[0] == q[9]\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0p0iji81/tmp0p0iji81.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8dbb1c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8dbaebfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8dbaebf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8dbaebe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0p0iji81                        0x00005559c22b93af <unavailable> + 5039

    5    libc.so.6                          0x00002b8dbb3b4460 __libc_start_main +
    245

    6    tmp0p0iji81                        0x00005559c22b9019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.reduce(0, +)\n\
    \    return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0k2iovq6/tmp0k2iovq6.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d78696c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d7838db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d7838d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d7838c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0k2iovq6                        0x0000563043a8a43b <unavailable> + 5179

    5    libc.so.6                          0x00002b7d78882460 __libc_start_main +
    245

    6    tmp0k2iovq6                        0x0000563043a89fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement the function\n    return false\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpp3_je458/tmpp3_je458.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0598f5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0598c52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0598c52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0598c517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp3_je458                        0x00005623a6cfd2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b0599147460 __libc_start_main +
    245

    6    tmpp3_je458                        0x00005623a6cfcf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.count == 0 && maxWeight\
    \ <= 0 || maxWeight == q.sum * w && q.count == q.count && q.max() == q.min() &&\
    \ q.max() == q.max() && q.max() == q.min()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6y67nvht.swift:19:61: error: value of type '[Int]' has no member\
    \ 'sum'\n    return q.count == 0 && maxWeight <= 0 || maxWeight == q.sum * w &&\
    \ q.count == q.count && q.max() == q.min() && q.max() == q.max() && q.max() ==\
    \ q.min()\n                                                          ~ ^~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    if q.count < 2 {\n  \
    \      return true\n    }\n    var maxSum = w\n    for element in q {\n      \
    \  maxSum = maxSum - element\n    }\n    if maxSum < 0 {\n        return false\n\
    \    }\n    var sum = 0\n    for element in q {\n        sum = sum + element\n\
    \    }\n    return sum <= maxSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpg_9c_d_x/tmpg_9c_d_x.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac850c47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac85093eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac85093e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac85093d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg_9c_d_x                        0x0000560c657784bf <unavailable> + 5311

    5    libc.so.6                          0x00002ac850e33460 __libc_start_main +
    245

    6    tmpg_9c_d_x                        0x0000560c65778129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = q.reduce(0, +)\n\
    \    for i : Int in q.indices {\n        if maxWeight > q[i] {\n            maxWeight\
    \ = q[i]\n            maxSum = q[i]\n        }\n    }\n    return maxSum < maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpvjwtpca2/tmpvjwtpca2.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2997ba6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b299789db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b299789d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b299789c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvjwtpca2                        0x00005612058cc54f <unavailable> + 5455

    5    libc.so.6                          0x00002b2997d92460 __libc_start_main +
    245

    6    tmpvjwtpca2                        0x00005612058cc1b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if q.count > w {\n    \
    \    return false\n    }\n    if q.reduce(0, +) == w {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpk2q8d8k5/tmpk2q8d8k5.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc96dedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc96ae4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc96ae4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc96ae37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk2q8d8k5                        0x000055897e4b842f <unavailable> + 5167

    5    libc.so.6                          0x00002acc96fd9460 __libc_start_main +
    245

    6    tmpk2q8d8k5                        0x000055897e4b8099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    let maxWeight = w * q[q.count\
    \ - 1]\n    return q.reduce(0, +) <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpq8p3jt5a/tmpq8p3jt5a.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ecb32fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ecb026b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ecb026988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ecb0257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq8p3jt5a                        0x000055ce20feb4eb <unavailable> + 5355

    5    libc.so.6                          0x00002b5ecb51b460 __libc_start_main +
    245

    6    tmpq8p3jt5a                        0x000055ce20feb099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    var sum = 0\n    for x in q {\n    \
    \    sum += x\n        if sum > max {\n            max = sum\n        }\n    }\n\
    \    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmprnsmfqth/tmprnsmfqth.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a77beec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a778e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a778e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a778e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprnsmfqth                        0x0000556abba3f52b <unavailable> + 5419

    5    libc.so.6                          0x00002b4a77dda460 __libc_start_main +
    245

    6    tmprnsmfqth                        0x0000556abba3f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    guard let first = q.first else {\n        return false\n    }\n    guard\
    \ let last = q.last else {\n        return false\n    }\n    let maxWeight = w\
    \ - first - last\n    return q.isPalindromic && q.sum < maxWeight\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6aes4p9h.swift:28:14: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    return q.isPalindromic && q.sum < maxWeight\n         \
    \  ~ ^~~~~~~~~~~~~\n/tmp/tmp6aes4p9h.swift:28:33: error: value of type '[Int]'\
    \ has no member 'sum'\n    return q.isPalindromic && q.sum < maxWeight\n     \
    \                         ~ ^~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w\n    return q.count == 0 && maxWeight\
    \ == 0 || maxWeight == q.sum * maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpr17pp0o_.swift:19:61: error: value of type '[Int]' has no member\
    \ 'sum'\n    return q.count == 0 && maxWeight == 0 || maxWeight == q.sum * maxWeight\n\
    \                                                          ~ ^~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else { return\
    \ false }\n    let s = q.sum()\n    return s == w || (s == w && q.palindrome())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3xkfd0m2.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else { return false }\n                                         ^\n\
    /tmp/tmp3xkfd0m2.swift:18:42: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max()\
    \ else { return false }\n                                         ^\n        \
    \                                       ?? <#default value#>\n/tmp/tmp3xkfd0m2.swift:18:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else { return false }\n\
    \                                         ^\n                                \
    \              !\n/tmp/tmp3xkfd0m2.swift:19:15: error: value of type '[Int]' has\
    \ no member 'sum'\n    let s = q.sum()\n            ~ ^~~\n/tmp/tmp3xkfd0m2.swift:20:35:\
    \ error: value of type '[Int]' has no member 'palindrome'\n    return s == w ||\
    \ (s == w && q.palindrome())\n                                ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let q = q.sorted() else {\n        return false\n\
    \    }\n    let maxWeight = w * q.reduce(0) { (max, next) in\n        return max\
    \ > next ? max : next\n    }\n    return q == q.dropLast().reverse() && maxWeight\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5u6_ztl7.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let q = q.sorted() else {\n\
    \          ^       ~~~~~~~~~~\n/tmp/tmp5u6_ztl7.swift:24:12: error: cannot convert\
    \ value of type '[Int]' to expected argument type '()'\n    return q == q.dropLast().reverse()\
    \ && maxWeight <= w\n           ^\n/tmp/tmp5u6_ztl7.swift:24:30: error: cannot\
    \ use mutating member on immutable value: function call returns immutable value\n\
    \    return q == q.dropLast().reverse() && maxWeight <= w\n                ~~~~~~~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    var sum\
    \ = 0\n    for x in q {\n        sum += x\n    }\n    return sum <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpxapu6j1m/tmpxapu6j1m.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acbc8960c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbc8657b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acbc8657988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acbc86567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxapu6j1m                        0x00005558738c14bf <unavailable> + 5311

    5    libc.so.6                          0x00002acbc8b4c460 __libc_start_main +
    245

    6    tmpxapu6j1m                        0x00005558738c1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var sum = 0\n    for x in q {\n\
    \        sum += x\n        if sum > maxWeight {\n            maxWeight = sum\n\
    \        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpia3_pfqx/tmpia3_pfqx.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b013b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b010acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b010ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b010ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpia3_pfqx                        0x000055cdd491752b <unavailable> + 5419

    5    libc.so.6                          0x00002b1b015a1460 __libc_start_main +
    245

    6    tmpia3_pfqx                        0x000055cdd49170d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var maxSumIndex = 0\n    var maxSumElement\
    \ = q[0]\n    for index in 1..<q.count {\n        let element = q[index]\n   \
    \     let sum = element + maxSumElement\n        if sum > maxSum {\n         \
    \   maxSum = sum\n            maxSumIndex = index\n            maxSumElement =\
    \ element\n        }\n    }\n    return maxSum == w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptc8y_zhv/tmptc8y_zhv.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c37ac3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c377bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c377ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c377b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptc8y_zhv                        0x000055af0267b5fb <unavailable> + 5627

    5    libc.so.6                          0x00002b9c37caf460 __libc_start_main +
    245

    6    tmptc8y_zhv                        0x000055af0267b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = w\n    for i := 0;\
    \ i < len(q); i++ {\n        maxWeight -= q[i]\n        maxSum += q[i]\n     \
    \   if maxWeight < 0 {\n            return false\n        }\n    }\n    return\
    \ maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqnxb35rm.swift:20:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpqnxb35rm.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpqnxb35rm.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ -= element\n        if maxSum < 0 {\n            return false\n        }\n \
    \   }\n    return maxSum == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa95330ym/tmpa95330ym.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2d1852c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2d1549b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2d1549988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2d15487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa95330ym                        0x000055a78333746f <unavailable> + 5231

    5    libc.so.6                          0x00002ad2d1a3e460 __libc_start_main +
    245

    6    tmpa95330ym                        0x000055a7833370d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var balanced = true\n    for element\
    \ in q {\n        if element > maxWeight {\n            maxWeight = element\n\
    \        }\n        if element != maxWeight {\n            balanced = false\n\
    \        }\n    }\n    return balanced && maxWeight <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpr22twy8k/tmpr22twy8k.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b306d898c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b306d58fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b306d58f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b306d58e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr22twy8k                        0x00005643b14dc46f <unavailable> + 5231

    5    libc.so.6                          0x00002b306da84460 __libc_start_main +
    245

    6    tmpr22twy8k                        0x00005643b14dc0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.fold(0, +)\n  \
    \  return maxSum < maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju_dc75n.swift:19:20: error: value of type '[Int]' has no member\
    \ 'fold'\n    let maxSum = q.fold(0, +)\n                 ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n    if sum < w {\n        return false\n    }\n    var max = 0\n    for x\
    \ in q {\n        if x > max {\n            max = x\n        }\n    }\n    if\
    \ sum == max {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpluchgzr1/tmpluchgzr1.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b001f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9affee7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9affee7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9affee67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpluchgzr1                        0x0000560b9362346f <unavailable> + 5231

    5    libc.so.6                          0x00002b9b003dc460 __libc_start_main +
    245

    6    tmpluchgzr1                        0x0000560b936230d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    guard let first = q.first else {\n        return\
    \ true\n    }\n    guard let last = q.last else {\n        return true\n    }\n\
    \    let middle = q.index(q.startIndex, offsetBy: q.count / 2)\n    let leftSum\
    \ = q[middle]\n    let rightSum = q[q.index(q.startIndex, offsetBy: q.count -\
    \ middle - 1)]\n    return leftSum + rightSum <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpayftptgn.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpayftptgn.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpayftptgn.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    if q.count == 1 {\n        return true\n    }\n    if w == 1 {\n   \
    \     return true\n    }\n    if w == 2 {\n        return q[0] == q[1]\n    }\n\
    \    if w == 3 {\n        return q[0] == q[1] && q[0] == q[2]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3]\n    }\n\
    \    if w == 5 {\n        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3]\
    \ && q[0] == q[4]\n    }\n    if w == 6 {\n        return q[0] == q[1] && q[0]\
    \ == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5]\n    }\n    if w ==\
    \ 7 {\n        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] ==\
    \ q[4] && q[0] == q[5] && q[0] == q[6]\n    }\n    if w == 8 {\n        return\
    \ q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5]\
    \ && q[0] == q[6] && q[0] == q[7]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0]\
    \ == q[6] && q[0] == q[7] && q[0] == q[8]\n    }\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp3o6eqdk2/tmp3o6eqdk2.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4cc803dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4cc7d34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4cc7d34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4cc7d337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3o6eqdk2                        0x00005634218283af <unavailable> + 5039

    5    libc.so.6                          0x00002b4cc8229460 __libc_start_main +
    245

    6    tmp3o6eqdk2                        0x0000563421828019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014556
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for x in q {\n        if x > maxSum\
    \ {\n            maxSum = x\n        }\n    }\n    if maxSum == w {\n        return\
    \ true\n    }\n    if maxSum > w {\n        return false\n    }\n    var sum =\
    \ 0\n    for x in q {\n        sum += x\n    }\n    return sum <= maxSum\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptvdfpcsv/tmptvdfpcsv.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1000f89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1000c80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1000c80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1000c7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptvdfpcsv                        0x00005564b924e52b <unavailable> + 5419

    5    libc.so.6                          0x00002b1001175460 __libc_start_main +
    245

    6    tmptvdfpcsv                        0x00005564b924e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == q[1]\n    }\n    if w\
    \ == 2 {\n        return q[0] == q[1] && q[1] == q[2]\n    }\n    if w == 3 {\n\
    \        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3]\
    \ == q[4]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[1] == q[2]\
    \ && q[2] == q[3] && q[3] == q[4] && q[4] == q[5]\n    }\n    if w == 6 {\n  \
    \      return q[0] == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] &&\
    \ q[4] == q[5] && q[5] == q[6]\n    }\n    if w == 7 {\n        return q[0] ==\
    \ q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7]\n    }\n    if w == 8 {\n        return q[0] == q[1]\
    \ && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5] == q[6]\
    \ && q[6] == q[7] && q[7] == q[8]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[1] == q[2] && q[2] == q[3] && q[3] == q[4] && q[4] == q[5] && q[5]\
    \ == q[6] && q[6] == q[7] && q[7] == q[8] && q[8] == q[9]\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5qt_6pof/tmp5qt_6pof.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b672e34dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b672e044b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b672e044988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b672e0437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5qt_6pof                        0x000055f407ba63af <unavailable> + 5039

    5    libc.so.6                          0x00002b672e539460 __libc_start_main +
    245

    6    tmp5qt_6pof                        0x000055f407ba6019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    if w == 0 {\n        return\
    \ false\n    }\n    if w == 1 {\n        return q[0] == q[1]\n    }\n    if w\
    \ == 2 {\n        return q[0] == q[1] && q[0] == q[2]\n    }\n    if w == 3 {\n\
    \        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3]\n    }\n    if w\
    \ == 4 {\n        return q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0]\
    \ == q[4]\n    }\n    if w == 5 {\n        return q[0] == q[1] && q[0] == q[2]\
    \ && q[0] == q[3] && q[0] == q[4] && q[0] == q[5]\n    }\n    if w == 6 {\n  \
    \      return q[0] == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] &&\
    \ q[0] == q[5] && q[0] == q[6]\n    }\n    if w == 7 {\n        return q[0] ==\
    \ q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0]\
    \ == q[6] && q[0] == q[7]\n    }\n    if w == 8 {\n        return q[0] == q[1]\
    \ && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0] == q[6]\
    \ && q[0] == q[7] && q[0] == q[8]\n    }\n    if w == 9 {\n        return q[0]\
    \ == q[1] && q[0] == q[2] && q[0] == q[3] && q[0] == q[4] && q[0] == q[5] && q[0]\
    \ == q[6] && q[0] == q[7] && q[0] == q[8] && q[0] == q[9]\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0p0iji81/tmp0p0iji81.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8dbb1c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8dbaebfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8dbaebf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8dbaebe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0p0iji81                        0x00005559c22b93af <unavailable> + 5039

    5    libc.so.6                          0x00002b8dbb3b4460 __libc_start_main +
    245

    6    tmp0p0iji81                        0x00005559c22b9019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014554
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first,\n        let last = q.last,\n      \
    \  first == last else { return false }\n    guard let first = q.first,\n     \
    \   let last = q.last,\n        first == last else { return false }\n    guard\
    \ let first = q.first,\n        let last = q.last,\n        first == last else\
    \ { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return false }\n   \
    \ guard let first = q.first,\n        let last = q.last,\n        first == last\
    \ else { return false }\n    guard let first = q.first,\n        let last = q.last,\n\
    \        first == last else { return false }\n    guard let first = q.first,\n\
    \        let last = q.last,\n        first == last else { return \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjs884m1g.swift:101:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmpjs884m1g.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmpjs884m1g.swift:80:30: error: non-void function should return\
    \ a value\n        first == last else { return \n                            \
    \ ^\n/tmp/tmpjs884m1g.swift:84:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmpjs884m1g.swift:19:15: warning: value 'first' was\
    \ defined but never used; consider replacing with boolean test\n    guard let\
    \ first = q.first else { return false }\n          ~~~~^~~~~~~~\n            \
    \                  != nil\n/tmp/tmpjs884m1g.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let maxSum = q.sum\n    let maxSumOfElements\
    \ = q.sumOfElements\n    return maxWeight <= maxSum && maxSumOfElements <= maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxuap3ull.swift:19:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n/tmp/tmpxuap3ull.swift:20:30:\
    \ error: value of type '[Int]' has no member 'sumOfElements'\n    let maxSumOfElements\
    \ = q.sumOfElements\n                           ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var maxSum = 0\n    for element\
    \ in q {\n        maxWeight -= element\n        maxSum += element\n        if\
    \ maxWeight < 0 {\n            return false\n        }\n    }\n    return maxSum\
    \ == 0 || maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpjabt2q1a/tmpjabt2q1a.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fcca46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fcc73db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fcc73d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fcc73c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjabt2q1a                        0x0000563513ab146f <unavailable> + 5231

    5    libc.so.6                          0x00002b5fccc32460 __libc_start_main +
    245

    6    tmpjabt2q1a                        0x0000563513ab10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014556
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplwpl0szo.swift:81:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmplwpl0szo.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmplwpl0szo.swift:60:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmplwpl0szo.swift:64:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmplwpl0szo.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:21:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:22:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:23:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:24:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:25:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    guard let\
    \ first = q.first else { return false }\n    guard let last = q.last else { return\
    \ false }\n    guard let first = q.first else { return false }\n    guard let\
    \ last = q.last else { return false }\n    guard let first = q.first else { return\
    \ false }\n    guard let last = q.last else { return false }\n    guard let first\
    \ = q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return false }\n    guard let first =\
    \ q.first else { return false }\n    guard let last = q.last else { return false\
    \ }\n    guard let first = q.first else { return false }\n    guard let last =\
    \ q.last else { return false }\n    guard let first = q.first else { return false\
    \ }\n    guard let last = q.last else { return \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplwpl0szo.swift:81:42: error: expected '}' at end of brace statement\n\
    assert(will_it_fly(q: [5], w: 5) == true)\n                                  \
    \       ^\n/tmp/tmplwpl0szo.swift:17:44: note: to match this opening '{'\nfunc\
    \ will_it_fly(q: [Int], w: Int) -> Bool {\n                                  \
    \         ^\n/tmp/tmplwpl0szo.swift:60:36: error: non-void function should return\
    \ a value\n    guard let last = q.last else { return \n                      \
    \             ^\n/tmp/tmplwpl0szo.swift:64:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n/tmp/tmplwpl0szo.swift:19:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:20:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:21:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:22:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:23:15: warning: value 'first'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let first = q.first else { return false }\n          ~~~~^~~~~~~~\n        \
    \                      != nil\n/tmp/tmplwpl0szo.swift:24:15: warning: value 'last'\
    \ was defined but never used; consider replacing with boolean test\n    guard\
    \ let last = q.last else { return false }\n          ~~~~^~~~~~~\n           \
    \                 != nil\n/tmp/tmplwpl0szo.swift:25:15: warning: value 'f"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count == 1 {\n        return q[0] == w\n    }\n    let maxWeight = w\n   \
    \ var maxSum = q[0]\n    for element in q {\n        if element > maxSum {\n \
    \           maxSum = element\n        }\n    }\n    if maxSum > maxWeight {\n\
    \        return false\n    }\n    let maxSumOfElements = maxSum\n    var maxSumOfElementsIndex\
    \ = 0\n    var maxSumOfElementsWeight = maxSum\n    for element in q {\n     \
    \   if element > maxSumOfElementsWeight {\n            maxSumOfElementsWeight\
    \ = element\n            maxSumOfElementsIndex = q.index(of: element)!\n     \
    \   }\n    }\n    if maxSumOfElementsWeight == maxWeight {\n        return true\n\
    \    }\n    if maxSumOfElementsWeight > maxWeight {\n        return false\n  \
    \  }\n    let maxSumOfElementsWeight = maxSum\n    var maxSumOfElementsIndex =\
    \ 0\n    var maxSumOfElementsWeight = maxSum\n    for element in q {\n       \
    \ if element > maxSumOfElementsWeight {\n            maxSumOfElementsWeight =\
    \ element\n            maxSumOfElementsIndex = q.index(of: element)!\n       \
    \ }\n    }\n    if maxSumOfElementsWeight == maxWeight {\n        return true\n\
    \    }\n    if maxSumOfElementsWeight > maxWeight {\n        return false\n  \
    \  }\n    let maxSumOfElementsWeight = maxSum\n    var maxSumOfElementsIndex =\
    \ 0\n    var maxSumOfElementsWeight = maxSum\n    for element in q {\n       \
    \ if element > maxSumOfElementsWeight {\n            maxSumOfElementsWeight =\
    \ element\n            maxSumOfElementsIndex = q.index(of: element)!\n       \
    \ }\n    }\n    if maxSumOfElementsWeight == maxWeight {\n        return true\n\
    \    }\n    if maxSumOfElementsWeight > maxWeight {\n        return false\n  \
    \  }\n    let maxSumOfElementsWeight = maxSum\n    var maxSumOfElementsIndex =\
    \ 0\n    var maxSumOfElementsWeight = maxSum\n    for element in q {\n       \
    \ if element > maxSumOfElementsWeight {\n            maxSumOfElementsWeight =\
    \ element\n            maxSumOfElementsIndex = q.index(of: element)!\n       \
    \ }\n    }\n    if maxSumOfElementsWeight == maxWeight {\n        return true\n\
    \    }\n    if maxSumOfElementsWeight > maxWeight {\n        return false\n  \
    \  }\n    let maxSumOfElementsWeight = maxSum\n    var maxSumOfElements\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdt9hs_p6.swift:40:39: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n            maxSumOfElementsIndex = q.index(of: element)!\n\
    \                                      ^\n/tmp/tmpdt9hs_p6.swift:40:39: note:\
    \ use 'firstIndex(of:)' instead\n            maxSumOfElementsIndex = q.index(of:\
    \ element)!\n                                      ^~~~~\n                   \
    \                   firstIndex\n/tmp/tmpdt9hs_p6.swift:49:9: error: invalid redeclaration\
    \ of 'maxSumOfElementsWeight'\n    let maxSumOfElementsWeight = maxSum\n     \
    \   ^\n/tmp/tmpdt9hs_p6.swift:36:9: note: 'maxSumOfElementsWeight' previously\
    \ declared here\n    var maxSumOfElementsWeight = maxSum\n        ^\n/tmp/tmpdt9hs_p6.swift:50:9:\
    \ error: invalid redeclaration of 'maxSumOfElementsIndex'\n    var maxSumOfElementsIndex\
    \ = 0\n        ^\n/tmp/tmpdt9hs_p6.swift:35:9: note: 'maxSumOfElementsIndex' previously\
    \ declared here\n    var maxSumOfElementsIndex = 0\n        ^\n/tmp/tmpdt9hs_p6.swift:51:9:\
    \ error: invalid redeclaration of 'maxSumOfElementsWeight'\n    var maxSumOfElementsWeight\
    \ = maxSum\n        ^\n/tmp/tmpdt9hs_p6.swift:36:9: note: 'maxSumOfElementsWeight'\
    \ previously declared here\n    var maxSumOfElementsWeight = maxSum\n        ^\n\
    /tmp/tmpdt9hs_p6.swift:64:9: error: invalid redeclaration of 'maxSumOfElementsWeight'\n\
    \    let maxSumOfElementsWeight = maxSum\n        ^\n/tmp/tmpdt9hs_p6.swift:36:9:\
    \ note: 'maxSumOfElementsWeight' previously declared here\n    var maxSumOfElementsWeight\
    \ = maxSum\n        ^\n/tmp/tmpdt9hs_p6.swift:65:9: error: invalid redeclaration\
    \ of 'maxSumOfElementsIndex'\n    var maxSumOfElementsIndex = 0\n        ^\n/tmp/tmpdt9hs_p6.swift:35:9:\
    \ note: 'maxSumOfElementsIndex' previously declared here\n    var maxSumOfElementsIndex\
    \ = 0\n        ^\n/tmp/tmpdt9hs_p6.swift:66:9: error: invalid redeclaration of\
    \ 'maxSumOfElementsWeight'\n    var maxSumOfElementsWeight = maxSum\n        ^\n\
    /tmp/tmpdt9hs_p6.swift:36:9: note: 'maxSumOfElementsWeight' previously declared\
    \ here\n    var maxSumOfElementsWeight = maxSum\n        ^\n/tmp/tmpdt9hs_p6.swift:79:9:\
    \ error: inv"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    var\
    \ maxWeight = w\n    var maxSum = q[0]\n    for i := 1; i < q.count; i++ {\n \
    \       maxWeight = maxWeight - q[i]\n        maxSum = maxSum + q[i]\n       \
    \ if maxWeight < 0 {\n            return false\n        }\n    }\n    if maxSum\
    \ > w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph77cqb__.swift:23:12: error: expected type\n    for i := 1; i <\
    \ q.count; i++ {\n           ^\n            <#type#>\n/tmp/tmph77cqb__.swift:23:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < q.count; i++\
    \ {\n           ^\n/tmp/tmph77cqb__.swift:23:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < q.count; i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement the function here.\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpe8mc5gfu/tmpe8mc5gfu.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc14ef7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc14beeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc14bee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc14bed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe8mc5gfu                        0x000055bc33ba92ff <unavailable> + 4863

    5    libc.so.6                          0x00002afc150e3460 __libc_start_main +
    245

    6    tmpe8mc5gfu                        0x000055bc33ba8f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014556
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = 0\n    var maxIndex = 0\n    var sum = 0\n\
    \    for i := 0; i < len(q); i++ {\n        sum += q[i]\n        if sum > max\
    \ {\n            max = sum\n            maxIndex = i\n        }\n    }\n    if\
    \ sum < w {\n        return false\n    }\n    if sum == w {\n        return true\n\
    \    }\n    if sum > w {\n        return false\n    }\n    if sum == 0 {\n   \
    \     return true\n    }\n    if maxIndex == 0 {\n        return false\n    }\n\
    \    return will_it_fly(q[maxIndex...], w)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyawd8ako.swift:21:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpyawd8ako.swift:21:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpyawd8ako.swift:21:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpyawd8ako.swift:43:23:\
    \ error: missing argument labels 'q:w:' in call\n    return will_it_fly(q[maxIndex...],\
    \ w)\n                      ^\n                       q:              w: \n/tmp/tmpyawd8ako.swift:43:25:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    return will_it_fly(q[maxIndex...], w)\n                       \
    \ ^\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    var maxSum = w\n    for\
    \ element in q {\n        maxSum = maxSum - element\n    }\n    return maxSum\
    \ == 0 || maxSum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp4_t1_3lq/tmp4_t1_3lq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43de61fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43de316b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43de316988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43de3157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4_t1_3lq                        0x0000561403bd046f <unavailable> + 5231

    5    libc.so.6                          0x00002b43de80b460 __libc_start_main +
    245

    6    tmp4_t1_3lq                        0x0000561403bd00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014556
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n \
    \       return false\n    }\n    var sum = 0\n    for x in q {\n        sum +=\
    \ x\n    }\n    return sum == w && is_balanced(q) && is_palindromic(q)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvbh5tst1.swift:18:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.count > 0 && w > 0 && w <=\
    \ q.max() else {\n                                         ^\n/tmp/tmpvbh5tst1.swift:18:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard q.count > 0 && w > 0 && w <= q.max() else {\n             \
    \                            ^\n                                             \
    \  ?? <#default value#>\n/tmp/tmpvbh5tst1.swift:18:42: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard q.count\
    \ > 0 && w > 0 && w <= q.max() else {\n                                      \
    \   ^\n                                              !\n/tmp/tmpvbh5tst1.swift:25:24:\
    \ error: cannot find 'is_balanced' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                       ^~~~~~~~~~~\n/tmp/tmpvbh5tst1.swift:25:42:\
    \ error: cannot find 'is_palindromic' in scope\n    return sum == w && is_balanced(q)\
    \ && is_palindromic(q)\n                                         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for i := 0; i < len(q); i++ {\n \
    \       maxSum = maxSum * 10 + q[i]\n    }\n    return maxSum <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmposcqfvbh.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmposcqfvbh.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmposcqfvbh.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else { return false }\n    let maxWeight\
    \ = w\n    let maxSum = q.sum\n    return q.count == maxWeight && maxSum < maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmbypsgwy.swift:20:20: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxSum = q.sum\n                 ~ ^~~\n"
  stdout: ''
  timestamp: 1660014555
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    for element in q {\n        maxSum\
    \ = maxSum * element + element\n    }\n    return maxSum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp3olesg7a/tmp3olesg7a.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cbf02fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cbed26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cbed26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cbed257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3olesg7a                        0x0000560aa47b246f <unavailable> + 5231

    5    libc.so.6                          0x00002b1cbf21b460 __libc_start_main +
    245

    6    tmp3olesg7a                        0x0000560aa47b20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: -4
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpj4czbip3/tmpj4czbip3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba64e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba61d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba61d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba61d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4czbip3                        0x000055cc63c442ff <unavailable> + 4863

    5    libc.so.6                          0x00002acba66cd460 __libc_start_main +
    245

    6    tmpj4czbip3                        0x000055cc63c43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014553
- exit_code: 1
  program: "\n/// Write a function that returns True if the object q will fly, and\
    \ False otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return true\n    }\n    var\
    \ max = 0\n    for x in q {\n        max = max(max, x)\n    }\n    if w == max\
    \ {\n        return true\n    }\n    if w < max {\n        return false\n    }\n\
    \    var i = 0\n    var j = 0\n    var sum = 0\n    while i < q.count {\n    \
    \    sum += q[i]\n        i += 1\n    }\n    if sum < w {\n        return false\n\
    \    }\n    while j < q.count {\n        sum += q[j]\n        j += 1\n    }\n\
    \    if sum > w {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpv1lb0hf8.swift:23:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, x)\n              ^\n"
  stdout: ''
  timestamp: 1660014555
