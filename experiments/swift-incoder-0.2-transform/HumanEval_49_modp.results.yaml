language: swift
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxvtpkc6g.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxvtpkc6g.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpxvtpkc6g.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpxvtpkc6g.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpxvtpkc6g.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpxvtpkc6g.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p >\
    \ p {\n        return modp(n, p - p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n        return\
    \ p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n    if n == 4 {\n\
    \        return p + 3\n    }\n    if n == 5 {\n        return p + 4\n    }\n \
    \   if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n        return\
    \ p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n    if n == 9 {\n\
    \        return p + 8\n    }\n    if n == 10 {\n        return p + 9\n    }\n\
    \    if n == 11 {\n        return p + 10\n    }\n    if n == 12 {\n        return\
    \ p + 11\n    }\n    if n == 13 {\n        return p + 12\n    }\n    if n == 14\
    \ {\n        return p + 13\n    }\n    if n == 15 {\n        return p + 14\n \
    \   }\n    if n == 16 {\n        return p + 15\n    }\n    if n == 17 {\n    \
    \    return p + 16\n    }\n    if n == 18 {\n        return p + 17\n    }\n  \
    \  if n == 19 {\n        return p + 18\n    }\n    if n == 20 {\n        return\
    \ p + 19\n    }\n    if n == 21 {\n        return p + 20\n    }\n    if n == 22\
    \ {\n        return p + 21\n    }\n    if n == 23 {\n        return p + 22\n \
    \   }\n    if n == 24 {\n        return p + 23\n    }\n    if n == 25 {\n    \
    \    return p + 24\n    }\n    if n == 26 {\n        return p + 25\n    }\n  \
    \  if n == 27 {\n        return p + 26\n    }\n    if n == 28 {\n        return\
    \ p + 27\n    }\n    if n == 29 {\n        return p + 28\n    }\n    if n == 30\
    \ {\n        return p + 29\n    }\n    if n == 31 {\n        return p + 30\n \
    \   }\n    if n == 32 {\n        return p + 31\n    }\n    if n == 33 {\n    \
    \    return p + 32\n    }\n    if n == 34 {\n        return p + 33\n    }\n  \
    \  if n == 35 {\n        return p + 34\n    }\n    if n == 36 {\n        return\
    \ p + 35\n    }\n    if n == 37 {\n        return p + 36\n    }\n    if n == 38\
    \ {\n        return p + 37\n    }\n    if n == 39 {\n        return p + 38\n \
    \   }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpl80i_j6r.swift:143:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmpl80i_j6r.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpl80i_j6r.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 1)\n    \
    \               ^\n                    n: p: \n/tmp/tmpl80i_j6r.swift:21:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - p)\n    \
    \               ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptlzzr4fo.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmptlzzr4fo.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmptlzzr4fo.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmptlzzr4fo.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n > p {\n\
    \        return modp(n, p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppwytpltp.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmppwytpltp.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - p, p)\n\t}\n\t\
    if p > p {\n\t\treturn modp(n, p - 1)\n\t}\n\tq := modp(n - p, p)\n\tif q == p\
    \ {\n\t\treturn n\n\t}\n\treturn q\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmo8roq_5.swift:35:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := modp(n - p, p)\n         ^\n         ;\n/tmp/tmpmo8roq_5.swift:35:4:\
    \ error: expected expression\n        q := modp(n - p, p)\n          ^\n/tmp/tmpmo8roq_5.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpmo8roq_5.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 1\")\n \
    \               ^~~~~\n/tmp/tmpmo8roq_5.swift:30:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(n - p, p)\n                    \
    \       ^\n                            n:     p: \n/tmp/tmpmo8roq_5.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - 1)\n                           ^\n                            n: p: \n/tmp/tmpmo8roq_5.swift:35:2:\
    \ error: cannot find 'q' in scope\n        q := modp(n - p, p)\n        ^\n/tmp/tmpmo8roq_5.swift:36:5:\
    \ error: cannot find 'q' in scope\n        if q == p {\n           ^\n/tmp/tmpmo8roq_5.swift:39:9:\
    \ error: cannot find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp expects n >=\
    \ 0\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp expects p >= 1\")\n\t}\n\tif n ==\
    \ 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjya7fz4s.swift:200:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpjya7fz4s.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpjya7fz4s.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp expects n >= 0\")\n         \
    \       ^~~~~\n/tmp/tmpjya7fz4s.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp expects p >= 1\")\n                ^~~~~\n/tmp/tmpjya7fz4s.swift:182:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj32itbvo/tmpj32itbvo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cc8e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc8b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc8b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc8b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj32itbvo                        0x000055679410d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6cc9040460 __libc_start_main +
    245

    6    tmpj32itbvo                        0x000055679410cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n / p, p)\n    }\n    if p >\
    \ p {\n        return modp(n / p, p)\n    }\n    return n % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk13w9np7.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpk13w9np7.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpk13w9np7.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / p, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n <= p:\n\t\treturn n\n\tcase n >= p - 1:\n\t\treturn p - 1 + modp(n\
    \ - p, p)\n\tdefault:\n\t\treturn modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwovwmx8r.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpwovwmx8r.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpwovwmx8r.swift:20:22:\
    \ error: missing argument labels 'n:p:' in call\n                return p - 1\
    \ + modp(n - p, p)\n                                   ^\n                   \
    \                 n:     p: \n/tmp/tmpwovwmx8r.swift:22:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n >= p {\n\t\treturn modp(n - p, p)\n\t}\n\treturn\
    \ modp((p - 1) * (n - p), p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxa7ghs1o.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpxa7ghs1o.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpxa7ghs1o.swift:28:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpxa7ghs1o.swift:30:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((p - 1) *\
    \ (n - p), p)\n                   ^\n                    n:                 p:\
    \ \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv46e953w.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive n\")\n                ^~~~~\n/tmp/tmpv46e953w.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ p\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p % p)\n    }\n    if p >\
    \ p {\n        return modp(n, p % p)\n    }\n    return n - (n % p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnqdo6tlh.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpnqdo6tlh.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n/tmp/tmpnqdo6tlh.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((p\
    \ - n) % p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeettots2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpeettots2.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((p - n) % p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p+1 {\n\t\treturn n\n\t\
    }\n\tif n == p+2 {\n\t\treturn n\n\t}\n\tif n == p+3 {\n\t\treturn n\n\t}\n\t\
    if n == p+4 {\n\t\treturn n\n\t}\n\tif n == p+5 {\n\t\treturn n\n\t}\n\tif n ==\
    \ p+6 {\n\t\treturn n\n\t}\n\tif n == p+7 {\n\t\treturn n\n\t}\n\tif n == p+8\
    \ {\n\t\treturn n\n\t}\n\tif n == p+9 {\n\t\treturn n\n\t}\n\tif n == p+10 {\n\
    \t\treturn n\n\t}\n\tif n == p+11 {\n\t\treturn n\n\t}\n\tif n == p+12 {\n\t\t\
    return n\n\t}\n\tif n == p+13 {\n\t\treturn n\n\t}\n\tif n == p+14 {\n\t\treturn\
    \ n\n\t}\n\tif n == p+15 {\n\t\treturn n\n\t}\n\tif n == p+16 {\n\t\treturn n\n\
    \t}\n\tif n == p+17 {\n\t\treturn n\n\t}\n\tif n == p+18 {\n\t\treturn n\n\t}\n\
    \tif n == p+19 {\n\t\treturn n\n\t}\n\tif n == p+20 {\n\t\treturn n\n\t}\n\tif\
    \ n == p+21 {\n\t\treturn n\n\t}\n\tif n == p+22 {\n\t\treturn n\n\t}\n\tif n\
    \ == p+23 {\n\t\treturn n\n\t}\n\tif n == p+24 {\n\t\treturn n\n\t}\n\tif n ==\
    \ p+25 {\n\t\treturn n\n\t}\n\tif n == p+26 {\n\t\treturn n\n\t}\n\tif n == p+27\
    \ {\n\t\treturn n\n\t}\n\tif n == p+28 {\n\t\treturn n\n\t}\n\tif n == p+29 {\n\
    \t\treturn n\n\t}\n\tif n == p+30 {\n\t\treturn n\n\t}\n\tif n == p+31 {\n\t\t\
    return n\n\t}\n\tif n == p+32 {\n\t\treturn n\n\t}\n\tif n == p+33 {\n\t\treturn\
    \ n\n\t}\n\tif n == p+34 {\n\t\treturn n\n\t}\n\tif n == p+35 {\n\t\treturn n\n\
    \t}\n\tif n == p+36 {\n\t\treturn n\n\t}\n\tif n == p+37 {\n\t\treturn n\n\t}\n\
    \tif n == p+38 {\n\t\treturn n\n\t}\n\tif n == p+39 {\n\t\treturn n\n\t}\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpm8w0qj3l.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpm8w0qj3l.swift:18:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 2:\n\t\treturn 0\n\tcase p < n:\n\t\treturn p - 1\n\tdefault:\n\
    \t\treturn p - (p - 1) * ((p - 1) * (p - 2) * (p - 3) * (p - 4) * (p - 5) * (p\
    \ - 6) * (p - 7) * (p - 8) * (p - 9) * (p - 10) * (p - 11) * (p - 12) * (p - 13)\
    \ * (p - 14) * (p - 15) * (p - 16) * (p - 17) * (p - 18) * (p - 19) * (p - 20)\
    \ * (p - 21) * (p - 22) * (p - 23) * (p - 24) * (p - 25) * (p - 26) * (p - 27)\
    \ * (p - 28) * (p - 29) * (p - 30) * (p - 31) * (p - 32) * (p - 33) * (p - 34)\
    \ * (p - 35) * (p - 36) * (p - 37) * (p - 38) * (p - 39) * (p - 40) * (p - 41)\
    \ * (p - 42) * (p - 43) * (p - 44) * (p - 45) * (p - 46) * (p - 47) * (p - 48)\
    \ * (p - 49) * (p - 50) * (p - 51) * (p - 52) * (p - 53) * (p - 54) * (p - 55)\
    \ * (p - 56) * (p - 57) * (p - 58) * (p - 59) * (p - 60) * (p - 61) * (p - 62)\
    \ * (p - 63) * (p - 64) * (p - 65) * (p - 66) * (p - 67) * (p - 68) * (p - 69)\
    \ * (p - 70) * (p - 71) * (p - 72) * (p - 73) * (p - 74) * (p - 75) * (p - 76)\
    \ * (p - 77) * (p - 78) * (p - 79) * (p - 80) * (p - 81) * (p - 82) * (p - 83)\
    \ * (p - 84) * (p - 85) * (p - 86) * (p - 87) * (p - 88) * (p - 89) * (p - 90)\
    \ * (p - 91) * (p - 92) * (p - 93) * (p - 94) * (p - 95) * (p - 96) * (p - 97)\
    \ * (p - 98) * (p - 99) * (p - 100) * (p - 101) * (p - 102) * (p - 103) * (p -\
    \ 104) * (p - 105) * (p - 106) * (p - 107) * (p - 108) * (p - 109) * (p-110) *\
    \ (p - 111) * (p - 112) * (p - 113) * (p - 114) * (p - 115) * (p - 116) * (p -\
    \ 117) * (p - 118) * (p - 119) * (p - 120) * (p - 121) * (p - 122) * (p - 123)\
    \ * (p - 124) * (p - 125) * (p - 126) * (p - 127) * (p - 128) * (p - 129) * (p\
    \ - 130) * (p - 131) * (p - 132) * (p - 133) * (p - 134) * (p - 135) * (p - 136)\
    \ * (p - 137) * (p - 138) * (p - 139) * (p - 140) * (p - 141) * (p - 142) * (p\
    \ - 143) * (p - 144) * (p - 145) * (p - 146) * (p - 147) * (p - 148) * (p - 149)\
    \ * (\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsypful7w.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpsypful7w.swift:23:1: error: expected\
    \ expression in list of expressions\n}\n^\n/tmp/tmpsypful7w.swift:44:31: error:\
    \ expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n   \
    \                           ^\n/tmp/tmpsypful7w.swift:13:34: note: to match this\
    \ opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                          \
    \       ^\n/tmp/tmpsypful7w.swift:16:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp(abs(n), p)\n                          \
    \ ^\n                            n:      p: \n/tmp/tmpsypful7w.swift:22:10: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n                return\
    \ p - (p - 1) * ((p - 1) * (p - 2) * (p - 3) * (p - 4) * (p - 5) * (p - 6) * (p\
    \ - 7) * (p - 8) * (p - 9) * (p - 10) * (p - 11) * (p - 12) * (p - 13) * (p -\
    \ 14) * (p - 15) * (p - 16) * (p - 17) * (p - 18) * (p - 19) * (p - 20) * (p -\
    \ 21) * (p - 22) * (p - 23) * (p - 24) * (p - 25) * (p - 26) * (p - 27) * (p -\
    \ 28) * (p - 29) * (p - 30) * (p - 31) * (p - 32) * (p - 33) * (p - 34) * (p -\
    \ 35) * (p - 36) * (p - 37) * (p - 38) * (p - 39) * (p - 40) * (p - 41) * (p -\
    \ 42) * (p - 43) * (p - 44) * (p - 45) * (p - 46) * (p - 47) * (p - 48) * (p -\
    \ 49) * (p - 50) * (p - 51) * (p - 52) * (p - 53) * (p - 54) * (p - 55) * (p -\
    \ 56) * (p - 57) * (p - 58) * (p - 59) * (p - 60) * (p - 61) * (p - 62) * (p -\
    \ 63) * (p - 64) * (p - 65) * (p - 66) * (p - 67) * (p - 68) * (p - 69) * (p -\
    \ 70) * (p - 71) * (p - 72) * (p - 73) * (p - 74) * (p - 75) * (p - 76) * (p -\
    \ 77) * (p - 78) * (p - 79) * (p - 80) * (p - 81) * (p - 82) * (p - 83) * (p -\
    \ 84) * (p - 85) * (p - 86) * (p - 87) * (p - 88) * (p - 89) * (p - 90) * (p -\
    \ 91) * (p - 92) * (p - 93) * (p - 94) * (p - 95) * (p - 96) * (p - 97) * (p -\
    \ 98) * (p - 99) * (p - 100) * (p - 101) * (p - 102) * (p - 103) * (p - 104) *\
    \ (p - 105) * (p - 106) * (p - 107) * (p - 108) * ("
  stdout: ''
  timestamp: 1660014971
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgd_87t1s.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpgd_87t1s.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpgd_87t1s.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpgd_87t1s.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpgd_87t1s.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n - 1, p)\n    }\n    if p >\
    \ p {\n        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n        return\
    \ p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n    if n == 4 {\n\
    \        return p + 3\n    }\n    if n == 5 {\n        return p + 4\n    }\n \
    \   if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n        return\
    \ p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n    if n == 9 {\n\
    \        return p + 8\n    }\n    if n == 10 {\n        return p + 9\n    }\n\
    \    if n == 11 {\n        return p + 10\n    }\n    if n == 12 {\n        return\
    \ p + 11\n    }\n    if n == 13 {\n        return p + 12\n    }\n    if n == 14\
    \ {\n        return p + 13\n    }\n    if n == 15 {\n        return p + 14\n \
    \   }\n    if n == 16 {\n        return p + 15\n    }\n    if n == 17 {\n    \
    \    return p + 16\n    }\n    if n == 18 {\n        return p + 17\n    }\n  \
    \  if n == 19 {\n        return p + 18\n    }\n    if n == 20 {\n        return\
    \ p + 19\n    }\n    if n == 21 {\n        return p + 20\n    }\n    if n == 22\
    \ {\n        return p + 21\n    }\n    if n == 23 {\n        return p + 22\n \
    \   }\n    if n == 24 {\n        return p + 23\n    }\n    if n == 25 {\n    \
    \    return p + 24\n    }\n    if n == 26 {\n        return p + 25\n    }\n  \
    \  if n == 27 {\n        return p + 26\n    }\n    if n == 28 {\n        return\
    \ p + 27\n    }\n    if n == 29 {\n        return p + 28\n    }\n    if n == 30\
    \ {\n        return p + 29\n    }\n    if n == 31 {\n        return p + 30\n \
    \   }\n    if n == 32 {\n        return p + 31\n    }\n    if n == 33 {\n    \
    \    return p + 32\n    }\n    if n == 34 {\n        return p + 33\n    }\n  \
    \  if n == 35 {\n        return p + 34\n    }\n    if n == 36 {\n        return\
    \ p + 35\n    }\n    if n == 37 {\n        return p + 36\n    }\n    if n == 38\
    \ {\n        return p + 37\n    }\n    if n == 39 {\n        return p + 38\n \
    \   }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2ud44hzp.swift:143:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp2ud44hzp.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmp2ud44hzp.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmp2ud44hzp.swift:21:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p - 1)\n\
    \                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tif p == 2 {\n\t\treturn n + 1\n\t}\n\tif p == 3 {\n\t\treturn n *\
    \ n\n\t}\n\tif p == 4 {\n\t\treturn n * n + n\n\t}\n\tif p == 5 {\n\t\treturn\
    \ n * n + n + 1\n\t}\n\tif p == 6 {\n\t\treturn n * n + n * n\n\t}\n\tif p ==\
    \ 7 {\n\t\treturn n * n + n * n + n\n\t}\n\tif p == 8 {\n\t\treturn n * n + n\
    \ * n + n * n\n\t}\n\tif p == 9 {\n\t\treturn n * n + n * n + n * n + n\n\t}\n\
    \tif p == 10 {\n\t\treturn n * n + n * n + n * n + n * n\n\t}\n\tif p == 11 {\n\
    \t\treturn n * n + n * n + n * n + n * n + n\n\t}\n\tif p == 12 {\n\t\treturn\
    \ n * n + n * n + n * n + n * n + n * n\n\t}\n\tif p == 13 {\n\t\treturn n * n\
    \ + n * n + n * n + n * n + n * n + n\n\t}\n\tif p == 14 {\n\t\treturn n * n +\
    \ n * n + n * n + n * n + n * n + n * n\n\t}\n\tif p == 15 {\n\t\treturn n * n\
    \ + n * n + n * n + n * n + n * n + n * n + n * n\n\t}\n\tif p == 16 {\n\t\treturn\
    \ n * n + n * n + n * n + n * n + n * n + n * n + n * n + n\n\t}\n\tif p == 17\
    \ {\n\t\treturn n * n + n * n + n * n + n * n + n * n + n * n + n * n + n * n\n\
    \t}\n\tif p == 18 {\n\t\treturn n * n + n * n + n * n + n * n + n * n + n * n\
    \ + n * n + n * n\n\t}\n\tif p == 19 {\n\t\treturn n * n + n * n + n * n + n *\
    \ n + n * n + n * n + n * n + n * n + n\n\t}\n\tif p == 20 {\n\t\treturn n * n\
    \ + n * n + n * n + n * n + n * n + n * n + n * n + n * n + n * n\n\t}\n\tif p\
    \ == 21 {\n\t\treturn n * n + n * n + n * n + n * n + n * n + n * n + n * n +\
    \ n * n + n * n + n\n\t}\n\tif p == 22 {\n\t\treturn n * n + n * n + n * n + n\
    \ * n + n * n + n * n + n * n + n * n + n * n + n\n\t}\n\tif p == 23 {\n\t\treturn\
    \ n * n + n * n + n * n + n * n + n * n + n * n + n * n + n * n + n * n + n\n\t\
    }\n\tif p == 24 {\n\t\treturn n * n + n * n + n * n + n * n + n * n + n * n +\
    \ n * n + n * n + n * n + n * n + n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdhwx4k0t.swift:115:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdhwx4k0t.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpdhwx4k0t.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmpdhwx4k0t.swift:18:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmpdhwx4k0t.swift:97:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: n must be\
    \ positive\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p must be positive\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7fx3ifpa.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: n must be positive\")\n                ^~~~~\n/tmp/tmp7fx3ifpa.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p must be\
    \ positive\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n > p {\n\
    \        return modp(n, p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppwytpltp.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmppwytpltp.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp39qgcyw.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpp39qgcyw.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tcase p < n:\n\
    \t\treturn modp(n - p, p)\n\tdefault:\n\t\treturn modp(n - p, p)\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj2226w2y.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpj2226w2y.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpj2226w2y.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpj2226w2y.swift:24:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - p, p)\n                           ^\n       \
    \                     n:     p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n & (p - 1)) == 0) ? n : n -\
    \ p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp334x_hfy/tmp334x_hfy.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44f3ac9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44f37c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44f37c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44f37bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp334x_hfy                        0x000055964d2d923d <unavailable> + 4669

    5    libc.so.6                          0x00002b44f3cb5460 __libc_start_main +
    245

    6    tmp334x_hfy                        0x000055964d2d8e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp requires p <= p\")\n\t}\n\t\
    x := n\n\ty := p\n\tfor {\n\t\tif y % 2 == 0 {\n\t\t\tx /= 2\n\t\t\ty /= 2\n\t\
    \t} else {\n\t\t\tx /= 2\n\t\t\ty = (y - 1) / 2\n\t\t}\n\t\tif x == 0 {\n\t\t\t\
    return y\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4ey_sdq3.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp4ey_sdq3.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp4ey_sdq3.swift:34:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp4ey_sdq3.swift:34:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp4ey_sdq3.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp requires positive n\")\n                ^~~~~\n\
    /tmp/tmp4ey_sdq3.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires positive p\")\n                ^~~~~\n/tmp/tmp4ey_sdq3.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ <= p\")\n                ^~~~~\n/tmp/tmp4ey_sdq3.swift:32:2: error: cannot find\
    \ 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\t\
    case n == p:\n\t\treturn 1\n\tcase n >= p:\n\t\treturn n - p\n\t}\n\treturn 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqgvuvxo2.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 1\n    }\n    if p == 1 {\n        return n\n    }\n    if p ==\
    \ 2 {\n        return modp(n / 2, p)\n    }\n    if p == 3 {\n        return modp(n\
    \ / 3, p)\n    }\n    if p == 4 {\n        return modp(n / 4, p)\n    }\n    if\
    \ p == 5 {\n        return modp(n / 5, p)\n    }\n    if p == 6 {\n        return\
    \ modp(n / 6, p)\n    }\n    if p == 7 {\n        return modp(n / 7, p)\n    }\n\
    \    if p == 8 {\n        return modp(n / 8, p)\n    }\n    if p == 9 {\n    \
    \    return modp(n / 9, p)\n    }\n    if p == 10 {\n        return modp(n / 10,\
    \ p)\n    }\n    if p == 11 {\n        return modp(n / 11, p)\n    }\n    if p\
    \ == 12 {\n        return modp(n / 12, p)\n    }\n    if p == 13 {\n        return\
    \ modp(n / 13, p)\n    }\n    if p == 14 {\n        return modp(n / 14, p)\n \
    \   }\n    if p == 15 {\n        return modp(n / 15, p)\n    }\n    if p == 16\
    \ {\n        return modp(n / 16, p)\n    }\n    if p == 17 {\n        return modp(n\
    \ / 17, p)\n    }\n    if p == 18 {\n        return modp(n / 18, p)\n    }\n \
    \   if p == 19 {\n        return modp(n / 19, p)\n    }\n    if p == 20 {\n  \
    \      return modp(n / 20, p)\n    }\n    if p == 21 {\n        return modp(n\
    \ / 21, p)\n    }\n    if p == 22 {\n        return modp(n / 22, p)\n    }\n \
    \   if p == 23 {\n        return modp(n / 23, p)\n    }\n    if p == 24 {\n  \
    \      return modp(n / 24, p)\n    }\n    if p == 25 {\n        return modp(n\
    \ / 25, p)\n    }\n    if p == 26 {\n        return modp(n / 26, p)\n    }\n \
    \   if p == 27 {\n        return modp(n / 27, p)\n    }\n    if p == 28 {\n  \
    \      return modp(n / 28, p)\n    }\n    if p == 29 {\n        return modp(n\
    \ / 29, p)\n    }\n    if p == 30 {\n        return modp(n / 30, p)\n    }\n \
    \   if p == 31 {\n        return modp(n / 31, p)\n    }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp29qim2bg.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp29qim2bg.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp29qim2bg.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmp29qim2bg.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / 3, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmp29qim2bg.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n / 4, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:36:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / 5, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 9, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 10, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmp29qim2bg.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 11, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmp29qim2bg.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 12, p)\n\
    \                   ^\n                    n:    "
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif y >\
    \ z {\n\t\t\tx -= z\n\t\t\ty -= z\n\t\t} else {\n\t\t\tx -= y\n\t\t\ty = 0\n\t\
    \t}\n\t\tif x == 0 {\n\t\t\treturn z\n\t\t}\n\t\tz *= y\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpg2_t2t52.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpg2_t2t52.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpg2_t2t52.swift:32:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpg2_t2t52.swift:32:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpg2_t2t52.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp called with negative n\")\n                ^~~~~\n\
    /tmp/tmpg2_t2t52.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp called with p < 1\")\n                ^~~~~\n/tmp/tmpg2_t2t52.swift:29:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn ((n - p) % (p - 1))\
    \ + 1\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_ig0matu.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp_ig0matu.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(abs(n), -p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn\
    \ modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpurhgkbyg.swift:17:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpurhgkbyg.swift:19:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpurhgkbyg.swift:21:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(abs(n),\
    \ -p)\n                           ^\n                            n:      p: \n\
    /tmp/tmpurhgkbyg.swift:25:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - p, p)\n                           ^\n       \
    \                     n:     p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n        return\
    \ modp(n - p, p)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n\
    \    if p < p {\n        return modp(n, p)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n  \
    \  if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n  \
    \  if p < p {\n        return modp(n, p)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n  \
    \  if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n  \
    \  if p < p {\n        return modp(n, p)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n  \
    \  if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n  \
    \  if p < p {\n        return modp(n, p)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n  \
    \  if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n  \
    \  if p < p {\n        return modp(n, p)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n  \
    \  if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n        return\
    \ modp(n, p)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n  \
    \  if p < p {\n        return modp(n, p)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p)\n    }\n  \
    \  if p < p {\n        return modp(n, p - 1)\n    }\n    if p \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphhxn394c.swift:128:9: error: expected '{' after 'if' condition\n\
    \    if p \n        ^\n/tmp/tmphhxn394c.swift:15:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(-n, p)\n                   ^\n         \
    \           n:  p: \n/tmp/tmphhxn394c.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmphhxn394c.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmphhxn394c.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmphhxn394c.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmphhxn394c.swift:33:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmphhxn394c.swift:36:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmphhxn394c.swift:39:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmphhxn394c.swift:42:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmphhxn394c.swift:45:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmphhxn394c.swift:48:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmphhxn394c.swift:51:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmphhxn394c.swift:54:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n - 1, p)\n    }\n    if p < p {\n\
    \        return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n\
    \    if p < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n      \
    \  return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n\
    \    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n\
    \        return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n\
    \    if p < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n      \
    \  return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n\
    \    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n\
    \        return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n\
    \    if p < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n      \
    \  return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n\
    \    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n    if p < p {\n\
    \        return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 1, p)\n    }\n    if p < p {\n        return modp(n - 1, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 1, \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpquo38o_r.swift:127:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpquo38o_r.swift:148:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpquo38o_r.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpquo38o_r.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - 1, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpquo38o_r.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:30:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpquo38o_r.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \      "
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return modp(n - 1, p)\n\t}\n\tif p < p {\n\t\treturn modp(n - 1, p)\n\t}\n\tif\
    \ p < p {\n\t\treturn modp(n - 1, p)\n\t}\n\treturn modp(n - 1, p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp17xv5qe3.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - 1, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmp17xv5qe3.swift:27:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n - 1, p)\n\
    \                           ^\n                            n:     p: \n/tmp/tmp17xv5qe3.swift:30:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp17xv5qe3.swift:32:13: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n - 1, p)\n                   ^\n                    n: \
    \    p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tswitch {\n\tcase p < 0:\n\t\treturn 0\n\tcase p < n:\n\t\treturn p % n\n\tdefault:\n\
    \t\treturn n % p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0jmar49r.swift:18:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp0jmar49r.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmp0jmar49r.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    if p % 2 == 0 {\n        return modp(n\
    \ / 2, p)\n    }\n    return modp(n / 2, p) + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwj513s2e.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpwj513s2e.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmpwj513s2e.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpwj513s2e.swift:32:16: error: missing argument\
    \ labels 'n:p:' in call\n    return modp(n / 2, p) + 1\n               ^\n   \
    \             n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn ((n % p) + p) % p\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp76lz891x.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp76lz891x.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n & (p - 1)) == 0) ? n : n -\
    \ p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp334x_hfy/tmp334x_hfy.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44f3ac9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44f37c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44f37c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44f37bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp334x_hfy                        0x000055964d2d923d <unavailable> + 4669

    5    libc.so.6                          0x00002b44f3cb5460 __libc_start_main +
    245

    6    tmp334x_hfy                        0x000055964d2d8e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbkmf0uyq.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpbkmf0uyq.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpbkmf0uyq.swift:18:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ number\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive modulus\")\n\
    \t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7csk8yy3.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive number\")\n                ^~~~~\n\
    /tmp/tmp7csk8yy3.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires positive modulus\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n - 1, p)\n    }\n    if p >\
    \ p {\n        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpruvwbn58.swift:201:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpruvwbn58.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpruvwbn58.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpruvwbn58.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpruvwbn58.swift:21:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 1)\n    \
    \               ^\n                    n: p: \n/tmp/tmpruvwbn58.swift:183:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == 2 {\n        return p + 1\n    }\n    if n == 3 {\n        return\
    \ p + 2\n    }\n    if n == 4 {\n        return p + 3\n    }\n    if n == 5 {\n\
    \        return p + 4\n    }\n    if n == 6 {\n        return p + 5\n    }\n \
    \   if n == 7 {\n        return p + 6\n    }\n    if n == 8 {\n        return\
    \ p + 7\n    }\n    if n == 9 {\n        return p + 8\n    }\n    if n == 10 {\n\
    \        return p + 9\n    }\n    if n == 11 {\n        return p + 10\n    }\n\
    \    if n == 12 {\n        return p + 11\n    }\n    if n == 13 {\n        return\
    \ p + 12\n    }\n    if n == 14 {\n        return p + 13\n    }\n    if n == 15\
    \ {\n        return p + 14\n    }\n    if n == 16 {\n        return p + 15\n \
    \   }\n    if n == 17 {\n        return p + 16\n    }\n    if n == 18 {\n    \
    \    return p + 17\n    }\n    if n == 19 {\n        return p + 18\n    }\n  \
    \  if n == 20 {\n        return p + 19\n    }\n    if n == 21 {\n        return\
    \ p + 20\n    }\n    if n == 22 {\n        return p + 21\n    }\n    if n == 23\
    \ {\n        return p + 22\n    }\n    if n == 24 {\n        return p + 23\n \
    \   }\n    if n == 25 {\n        return p + 24\n    }\n    if n == 26 {\n    \
    \    return p + 25\n    }\n    if n == 27 {\n        return p + 26\n    }\n  \
    \  if n == 28 {\n        return p + 27\n    }\n    if n == 29 {\n        return\
    \ p + 28\n    }\n    if n == 30 {\n        return p + 29\n    }\n    if n == 31\
    \ {\n        return p + 30\n    }\n    if n == 32 {\n        return p + 31\n \
    \   }\n    if n == 33 {\n        return p + 32\n    }\n    if n == 34 {\n    \
    \    return p + 33\n    }\n    if n == 35 {\n        return p + 34\n    }\n  \
    \  if n == 36 {\n        return p + 35\n    }\n    if n == 37 {\n        return\
    \ p + 36\n    }\n    if n == 38 {\n        return p + 37\n    }\n    if n == 39\
    \ {\n        return p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_g9ep_tr.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp_g9ep_tr.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp_g9ep_tr.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp_g9ep_tr.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp_g9ep_tr.swift:148:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp requires p > p\")\n\t}\n\tr\
    \ := n % p\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpudd1tauf.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmpudd1tauf.swift:32:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmpudd1tauf.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ n\")\n                ^~~~~\n/tmp/tmpudd1tauf.swift:18:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive p\")\n    \
    \            ^~~~~\n/tmp/tmpudd1tauf.swift:30:3: error: cannot find 'panic' in\
    \ scope\n                panic(\"modp requires p > p\")\n                ^~~~~\n\
    /tmp/tmpudd1tauf.swift:32:2: error: cannot find 'r' in scope\n        r := n %\
    \ p\n        ^\n/tmp/tmpudd1tauf.swift:33:5: error: cannot find 'r' in scope\n\
    \        if r == 0 {\n           ^\n/tmp/tmpudd1tauf.swift:36:9: error: cannot\
    \ find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\"\
    )\n\t}\n\tq := p\n\tr := 1\n\tfor i := 0; i < n; i++ {\n\t\tq *= p\n\t\tr += q\n\
    \t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjie3nycd.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpjie3nycd.swift:32:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpjie3nycd.swift:34:9:\
    \ error: expected type\n        for i := 0; i < n; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpjie3nycd.swift:34:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 0; i < n; i++ {\n               ^\n/tmp/tmpjie3nycd.swift:34:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < n; i++ {\n               ^\n/tmp/tmpjie3nycd.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpjie3nycd.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 1\")\n              \
    \  ^~~~~\n/tmp/tmpjie3nycd.swift:30:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp called with p > p\")\n                ^~~~~\n/tmp/tmpjie3nycd.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p\n        ^\n/tmp/tmpjie3nycd.swift:38:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn ((n % p) + p) % p\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp66czvmjc.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp66czvmjc.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, p)\n    }\n    if p < p {\n        return modp(n-1, p)\n\
    \    }\n    if p < p {\n        return modp(n-1, p)\n    }\n    if p < p {\n \
    \       return modp(n-1, \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprrw7qu7v.swift:127:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmprrw7qu7v.swift:148:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmprrw7qu7v.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmprrw7qu7v.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:33:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:36:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:39:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:42:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:45:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:48:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:51:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p: \n/tmp/tmprrw7qu7v.swift:54:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n-1, p)\n                   ^\n \
    \                   n:   p:"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n & (p - 1)) == 0) ? n : ((n\
    \ & (p - 1)) + p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp1ooyl8qm/tmp1ooyl8qm.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b020b5f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b020b2efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b020b2ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b020b2ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ooyl8qm                        0x000055c5a2d0623d <unavailable> + 4669

    5    libc.so.6                          0x00002b020b7e4460 __libc_start_main +
    245

    6    tmp1ooyl8qm                        0x000055c5a2d05e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014470
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj32itbvo/tmpj32itbvo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cc8e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cc8b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cc8b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cc8b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj32itbvo                        0x000055679410d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6cc9040460 __libc_start_main +
    245

    6    tmpj32itbvo                        0x000055679410cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n, p - 1)\n    }\n    if p < p {\n\
    \        return modp(n, p - 2)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 3)\n    }\n    if p < p {\n        return modp(n, p - 4)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 5)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 6)\n    }\n    if p < p {\n        return modp(n, p - 7)\n    }\n\
    \    if p < p {\n        return modp(n, p - 8)\n    }\n    if p < p {\n      \
    \  return modp(n, p - 9)\n    }\n    if p < p {\n        return modp(n, p - 10)\n\
    \    }\n    if p < p {\n        return modp(n, p - 11)\n    }\n    if p < p {\n\
    \        return modp(n, p - 12)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 13)\n    }\n    if p < p {\n        return modp(n, p - 14)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 15)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 16)\n    }\n    if p < p {\n        return modp(n, p - 17)\n   \
    \ }\n    if p < p {\n        return modp(n, p - 18)\n    }\n    if p < p {\n \
    \       return modp(n, p - 19)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 20)\n    }\n    if p < p {\n        return modp(n, p - 21)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 22)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 23)\n    }\n    if p < p {\n        return modp(n, p - 24)\n   \
    \ }\n    if p < p {\n        return modp(n, p - 25)\n    }\n    if p < p {\n \
    \       return modp(n, p - 26)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 27)\n    }\n    if p < p {\n        return modp(n, p - 28)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 29)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 30)\n    }\n    if p < p {\n        return modp(n, p - 31)\n   \
    \ }\n    if p < p {\n        return modp(n, p - 32)\n    }\n    if p < p {\n \
    \       return modp(n, p - 33)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 34)\n    }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgeqe16jr.swift:125:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmpgeqe16jr.swift:24:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 2)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 3)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 4)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:36:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 5)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:39:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 6)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:42:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 7)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:45:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 8)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:48:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 9)\n            \
    \       ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:51:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 10)\n           \
    \        ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:54:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 11)\n           \
    \        ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:57:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 12)\n           \
    \        ^\n                    n: p: \n/tmp/tmpgeqe16jr.swift:60:20: error: missing\
    \ argument labels 'n:p:' in call\n        return mo"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 0 {\n\t\treturn\
    \ 0\n\t}\n\tif p > n {\n\t\tp = n\n\t}\n\tx := powMod(n, p, p)\n\tif x == 1 {\n\
    \t\treturn 0\n\t}\n\treturn x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsiw8gl7n.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := powMod(n, p, p)\n         ^\n         ;\n\
    /tmp/tmpsiw8gl7n.swift:29:4: error: expected expression\n        x := powMod(n,\
    \ p, p)\n          ^\n/tmp/tmpsiw8gl7n.swift:15:3: error: cannot assign to value:\
    \ 'n' is a 'let' constant\n                n = -n\n                ^\n/tmp/tmpsiw8gl7n.swift:18:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpsiw8gl7n.swift:27:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = n\n                ^\n/tmp/tmpsiw8gl7n.swift:29:2:\
    \ error: cannot find 'x' in scope\n        x := powMod(n, p, p)\n        ^\n/tmp/tmpsiw8gl7n.swift:30:5:\
    \ error: cannot find 'x' in scope\n        if x == 1 {\n           ^\n/tmp/tmpsiw8gl7n.swift:33:9:\
    \ error: cannot find 'x' in scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt47f3385.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpt47f3385.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpt47f3385.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmpt47f3385.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyvwzfoo0.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyvwzfoo0.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 2 {\n\t\tpanic(\"modp: p must be >= 2\")\n\t}\n\tif n == 0 {\n\
    \t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif p < p {\n\t\treturn modp(n, p - 1)\n\t}\n\tif p > p {\n\t\treturn\
    \ modp(n, p - 2)\n\t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q, p) * p + r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp39eqe5ij.swift:35:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp39eqe5ij.swift:35:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp39eqe5ij.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp39eqe5ij.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p must be >= 2\")\n   \
    \             ^~~~~\n/tmp/tmp39eqe5ij.swift:30:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(n, p - 1)\n                    \
    \       ^\n                            n: p: \n/tmp/tmp39eqe5ij.swift:33:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n, p - 2)\n\
    \                           ^\n                            n: p: \n/tmp/tmp39eqe5ij.swift:35:2:\
    \ error: cannot find 'q' in scope\n        q := n / p\n        ^\n/tmp/tmp39eqe5ij.swift:37:14:\
    \ error: cannot find 'q' in scope\n        return modp(q, p) * p + r\n       \
    \             ^\n/tmp/tmp39eqe5ij.swift:37:26: error: cannot find 'r' in scope\n\
    \        return modp(q, p) * p + r\n                                ^\n/tmp/tmp39eqe5ij.swift:37:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * p\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tx := n\n\tfor x != 0 {\n\t\t\
    x = x % p\n\t\tif x == 0 {\n\t\t\treturn x\n\t\t}\n\t}\n\treturn 1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphu42ra26.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmphu42ra26.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmphu42ra26.swift:33:8:\
    \ error: expected 'in' after for-each pattern\n        for x != 0 {\n        \
    \      ^\n/tmp/tmphu42ra26.swift:33:8: error: unary operator cannot be separated\
    \ from its operand\n        for x != 0 {\n              ^ ~\n                \n\
    /tmp/tmphu42ra26.swift:15:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmphu42ra26.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmphu42ra26.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmphu42ra26.swift:32:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmphu42ra26.swift:33:8:\
    \ error: '!=' is not a prefix unary operator\n        for x != 0 {\n         \
    \     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(abs(n), -p) + p\n    }\n    if\
    \ n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return p\n    }\n\
    \    if n == p {\n        return n\n    }\n    if n == -p+1 {\n        return\
    \ -p\n    }\n    if n == -p-1 {\n        return p\n    }\n    if n == -p+2 {\n\
    \        return -p-1\n    }\n    if n == -p+3 {\n        return -p-2\n    }\n\
    \    if n == -p+4 {\n        return -p-3\n    }\n    if n == -p+5 {\n        return\
    \ -p-4\n    }\n    if n == -p+6 {\n        return -p-5\n    }\n    if n == -p+7\
    \ {\n        return -p-6\n    }\n    if n == -p+8 {\n        return -p-7\n   \
    \ }\n    if n == -p+9 {\n        return -p-8\n    }\n    if n == -p+10 {\n   \
    \     return -p-9\n    }\n    if n == -p+11 {\n        return -p-10\n    }\n \
    \   if n == -p+12 {\n        return -p-11\n    }\n    if n == -p+13 {\n      \
    \  return -p-12\n    }\n    if n == -p+14 {\n        return -p-13\n    }\n   \
    \ if n == -p+15 {\n        return -p-14\n    }\n    if n == -p+16 {\n        return\
    \ -p-15\n    }\n    if n == -p+17 {\n        return -p-16\n    }\n    if n ==\
    \ -p+18 {\n        return -p-17\n    }\n    if n == -p+19 {\n        return -p-18\n\
    \    }\n    if n == -p+20 {\n        return -p-19\n    }\n    if n == -p+21 {\n\
    \        return -p-20\n    }\n    if n == -p+22 {\n        return -p-21\n    }\n\
    \    if n == -p+23 {\n        return -p-22\n    }\n    if n == -p+24 {\n     \
    \   return -p-23\n    }\n    if n == -p+25 {\n        return -p-24\n    }\n  \
    \  if n == -p+26 {\n        return -p-25\n    }\n    if n == -p+27 {\n       \
    \ return -p-26\n    }\n    if n == -p+28 {\n        return -p-27\n    }\n    if\
    \ n == -p+29 {\n        return -p-28\n    }\n    if n == -p+30 {\n        return\
    \ -p-29\n    }\n    if n == -p+31 {\n        return -p-30\n    }\n    if n ==\
    \ -p+32 {\n        return -p-31\n    }\n    if n == -p+33 {\n        return -p-32\n\
    \    }\n    if n == -p+34 {\n        return -p-\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyte8j5c6.swift:154:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpyte8j5c6.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpyte8j5c6.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpyte8j5c6.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), -p) + p\n      \
    \             ^\n                    n:      p: \n/tmp/tmpyte8j5c6.swift:132:18:\
    \ error: '-' is not a postfix unary operator\n        return -p-\n           \
    \      ^\n/tmp/tmpyte8j5c6.swift:136:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 1\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa51zq45e.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpa51zq45e.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpa51zq45e.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpa51zq45e.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpa51zq45e.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpa51zq45e.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcp2i4jjk.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcp2i4jjk.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 2 {\n\t\tpanic(\"modp called with p < 2\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn 0\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tif n == p-2 {\n\t\treturn 0\n\t}\n\tif n == p-3\
    \ {\n\t\treturn 2\n\t}\n\tif n == p-4 {\n\t\treturn 3\n\t}\n\tif n == p-5 {\n\t\
    \treturn 4\n\t}\n\tif n == p-6 {\n\t\treturn 5\n\t}\n\tif n == p-7 {\n\t\treturn\
    \ 6\n\t}\n\tif n == p-8 {\n\t\treturn 7\n\t}\n\tif n == p-9 {\n\t\treturn 8\n\t\
    }\n\tif n == p-10 {\n\t\treturn 9\n\t}\n\tif n == p-11 {\n\t\treturn 10\n\t}\n\
    \tif n == p-12 {\n\t\treturn 11\n\t}\n\tif n == p-13 {\n\t\treturn 12\n\t}\n\t\
    if n == p-14 {\n\t\treturn 13\n\t}\n\tif n == p-15 {\n\t\treturn 14\n\t}\n\tif\
    \ n == p-16 {\n\t\treturn 15\n\t}\n\tif n == p-17 {\n\t\treturn 16\n\t}\n\tif\
    \ n == p-18 {\n\t\treturn 17\n\t}\n\tif n == p-19 {\n\t\treturn 18\n\t}\n\tif\
    \ n == p-20 {\n\t\treturn 19\n\t}\n\tif n == p-21 {\n\t\treturn 20\n\t}\n\tif\
    \ n == p-22 {\n\t\treturn 21\n\t}\n\tif n == p-23 {\n\t\treturn 22\n\t}\n\tif\
    \ n == p-24 {\n\t\treturn 23\n\t}\n\tif n == p-25 {\n\t\treturn 24\n\t}\n\tif\
    \ n == p-26 {\n\t\treturn 25\n\t}\n\tif n == p-27 {\n\t\treturn 26\n\t}\n\tif\
    \ n == p-28 {\n\t\treturn 27\n\t}\n\tif n == p-29 {\n\t\treturn 28\n\t}\n\tif\
    \ n == p-30 {\n\t\treturn 29\n\t}\n\tif n == p-31 {\n\t\treturn 30\n\t}\n\tif\
    \ n == p-32 {\n\t\treturn 31\n\t}\n\tif n == p-33 {\n\t\treturn 32\n\t}\n\tif\
    \ n == p-34 {\n\t\treturn 33\n\t}\n\tif n == p-35 {\n\t\treturn 34\n\t}\n\tif\
    \ n == p-36 {\n\t\treturn 35\n\t}\n\tif n == p-37 {\n\t\treturn 36\n\t}\n\tif\
    \ n == p-38 {\n\t\treturn 37\n\t}\n\tif n == p-39 {\n\t\treturn 38\n\t}\n\tif\
    \ n == p-40 {\n\t\treturn 39\n\t}\n\tif n == p-41 {\n\t\treturn 40\n\t}\n\tif\
    \ n == p-42 {\n\t\treturn 41\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgp81qzer.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpgp81qzer.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 2\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase n <= p:\n\t\treturn n\n\tcase\
    \ p < 1:\n\t\treturn 1\n\tdefault:\n\t\tn -= p\n\t\tn /= p\n\t\treturn n\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpho73u9qe.swift:18:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpho73u9qe.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpho73u9qe.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmpho73u9qe.swift:26:5:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n -= p\n                ~ ^\n/tmp/tmpho73u9qe.swift:27:5: error:\
    \ left side of mutating operator isn't mutable: 'n' is a 'let' constant\n    \
    \            n /= p\n                ~ ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn 1\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif y %\
    \ 2 == 0 {\n\t\t\tx /= 2\n\t\t\ty /= 2\n\t\t\tz /= 2\n\t\t} else {\n\t\t\tbreak\n\
    \t\t}\n\t}\n\tswitch {\n\tcase x == y:\n\t\treturn z\n\tcase x == z:\n\t\treturn\
    \ y\n\tcase y == z:\n\t\treturn x\n\tdefault:\n\t\treturn z\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu_300w0c.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpu_300w0c.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpu_300w0c.swift:32:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpu_300w0c.swift:32:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpu_300w0c.swift:41:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpu_300w0c.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpu_300w0c.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 1\")\n \
    \               ^~~~~\n/tmp/tmpu_300w0c.swift:29:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n/tmp/tmpu_300w0c.swift:43:10: error: cannot\
    \ find 'z' in scope\n                return z\n                       ^\n/tmp/tmpu_300w0c.swift:45:10:\
    \ error: cannot find 'y' in scope\n                return y\n                \
    \       ^\n/tmp/tmpu_300w0c.swift:47:10: error: cannot find 'x' in scope\n   \
    \             return x\n                       ^\n/tmp/tmpu_300w0c.swift:49:10:\
    \ error: cannot find 'z' in scope\n                return z\n                \
    \       ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tp = p\n\t}\n\tif n == 0 {\n\
    \t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj1gxey4d.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpj1gxey4d.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpj1gxey4d.swift:22:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = p\n                ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(n, abs(p))\n\tcase p == 0:\n\t\treturn n\n\tdefault:\n\t\tswitch {\n\
    \t\tcase n >= p:\n\t\t\treturn modp(n / p, p)\n\t\tcase n <= -p:\n\t\t\treturn\
    \ modp(-n / p, p)\n\t\tdefault:\n\t\t\treturn modp((n+p-1)/p, p)\n\t\t}\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcg3tltyz.swift:17:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcg3tltyz.swift:25:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmpcg3tltyz.swift:19:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp(abs(n), p)\n                          \
    \ ^\n                            n:      p: \n/tmp/tmpcg3tltyz.swift:21:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n, abs(p))\n\
    \                           ^\n                            n: p: \n/tmp/tmpcg3tltyz.swift:27:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(n / p, p)\n                                   ^\n                     \
    \               n:     p: \n/tmp/tmpcg3tltyz.swift:29:15: error: missing argument\
    \ labels 'n:p:' in call\n                        return modp(-n / p, p)\n    \
    \                               ^\n                                    n:    \
    \  p: \n/tmp/tmpcg3tltyz.swift:31:15: error: missing argument labels 'n:p:' in\
    \ call\n                        return modp((n+p-1)/p, p)\n                  \
    \                 ^\n                                    n:         p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n - 1, p)\n    }\n    if p < p {\n\
    \        return modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return\
    \ modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n -\
    \ 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p -\
    \ 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p - 1), p)\n \
    \   }\n    if p < p {\n        return modp((n - 1) * (p - 1), p)\n    }\n    if\
    \ p < p {\n        return modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n\
    \        return modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return\
    \ modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n -\
    \ 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p -\
    \ 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p - 1), p)\n \
    \   }\n    if p < p {\n        return modp((n - 1) * (p - 1), p)\n    }\n    if\
    \ p < p {\n        return modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n\
    \        return modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return\
    \ modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n -\
    \ 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p -\
    \ 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p - 1), p)\n \
    \   }\n    if p < p {\n        return modp((n - 1) * (p - 1), p)\n    }\n    if\
    \ p < p {\n        return modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n\
    \        return modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return\
    \ modp((n - 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n -\
    \ 1) * (p - 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p -\
    \ 1), p)\n    }\n    if p < p {\n        return modp((n - 1) * (p - 1), p)\n \
    \   }\n    if p < p {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpklutd_4u.swift:126:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpklutd_4u.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpklutd_4u.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - 1, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpklutd_4u.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp((n - 1) * (p - 1), p)\n\
    \                   ^\n                    n:                 p: \n/tmp/tmpklutd_4u.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((n - 1) *\
    \ (p - 1), p)\n                   ^\n                    n:                 p:\
    \ \n/tmp/tmpklutd_4u.swift:33:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp((n - 1) * (p - 1), p)\n                   ^\n           \
    \         n:                 p: \n/tmp/tmpklutd_4u.swift:36:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp((n - 1) * (p - 1), p)\n\
    \                   ^\n                    n:                 p: \n/tmp/tmpklutd_4u.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((n - 1) *\
    \ (p - 1), p)\n                   ^\n                    n:                 p:\
    \ \n/tmp/tmpklutd_4u.swift:42:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp((n - 1) * (p - 1), p)\n                   ^\n           \
    \         n:                 p: \n/tmp/tmpklutd_4u.swift:45:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp((n - 1) * (p - 1), p)\n\
    \                   ^\n                    n:                 p: \n/tmp/tmpklutd_4u.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((n - 1) *\
    \ (p - 1), p)\n                   ^\n                    n:                 p:\
    \ \n/tmp/tmpklutd_4u.swift:51:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp((n - 1) * (p - 1), p)\n                   ^\n           \
    \         n: "
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p > p {\n       \
    \ return modp(n, p - 2)\n    }\n    if n == 0 {\n        return 1\n    }\n   \
    \ if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp90bsaauw.swift:203:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp90bsaauw.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp90bsaauw.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp90bsaauw.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 2)\n            \
    \       ^\n                    n: p: \n/tmp/tmp90bsaauw.swift:185:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tq := p\n\tr := 1\n\tfor i := 0; i < n; i++ {\n\t\tq /= p\n\
    \t\tr *= q\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu93pjb6n.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpu93pjb6n.swift:29:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpu93pjb6n.swift:31:9:\
    \ error: expected type\n        for i := 0; i < n; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpu93pjb6n.swift:31:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 0; i < n; i++ {\n               ^\n/tmp/tmpu93pjb6n.swift:31:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < n; i++ {\n               ^\n/tmp/tmpu93pjb6n.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive n\")\n    \
    \            ^~~~~\n/tmp/tmpu93pjb6n.swift:18:3: error: cannot find 'panic' in\
    \ scope\n                panic(\"modp requires positive p\")\n               \
    \ ^~~~~\n/tmp/tmpu93pjb6n.swift:29:2: error: cannot find 'q' in scope\n      \
    \  q := p\n        ^\n/tmp/tmpu93pjb6n.swift:35:9: error: cannot find 'r' in scope\n\
    \        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp39qgcyw.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpp39qgcyw.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n, p)\n    }\n    if p < p {\n   \
    \     return modp(n - p, p)\n    }\n    if p < p {\n        return modp(n, p -\
    \ p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq32ok8l3.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n, p)\n                   ^\n                    n:\
    \ p: \n/tmp/tmpq32ok8l3.swift:27:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpq32ok8l3.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - p)\n                   ^\n      \
    \              n: p: \n/tmp/tmpq32ok8l3.swift:32:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n / p, p)\n    }\n    if p >\
    \ p {\n        return modp(n / p, p)\n    }\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpl4cynvgc.swift:179:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmpl4cynvgc.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpl4cynvgc.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpl4cynvgc.swift:21:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n < p {\n\t\t\
    return modp(n - p, p)\n\t}\n\treturn modp((p - 1) * (n - p), p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpny1gz77q.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmpny1gz77q.swift:26:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((p - 1) * (n - p),\
    \ p)\n                   ^\n                    n:                 p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tlet mut r = 1\n\tlet mut m = p\n\twhile n > 0 {\n\t\tif n % 2 == 0 {\n\t\t\
    \tr *= m\n\t\t}\n\t\tn /= 2\n\t\tm *= p\n\t}\n\treturn r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0mz1ono7.swift:17:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut r =\
    \ 1\n                ^\n/tmp/tmp0mz1ono7.swift:17:10: note: join the identifiers\
    \ together\n        let mut r = 1\n            ~~~~^\n            mutr\n/tmp/tmp0mz1ono7.swift:17:10:\
    \ note: join the identifiers together with camel-case\n        let mut r = 1\n\
    \            ~~~~^\n            mutR\n/tmp/tmp0mz1ono7.swift:18:10: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut m = p\n                ^\n/tmp/tmp0mz1ono7.swift:18:10:\
    \ note: join the identifiers together\n        let mut m = p\n            ~~~~^\n\
    \            mutm\n/tmp/tmp0mz1ono7.swift:18:10: note: join the identifiers together\
    \ with camel-case\n        let mut m = p\n            ~~~~^\n            mutM\n\
    /tmp/tmp0mz1ono7.swift:18:6: error: invalid redeclaration of 'mut'\n        let\
    \ mut m = p\n            ^\n/tmp/tmp0mz1ono7.swift:17:6: note: 'mut' previously\
    \ declared here\n        let mut r = 1\n            ^\n/tmp/tmp0mz1ono7.swift:21:4:\
    \ error: cannot find 'r' in scope\n                        r *= m\n          \
    \              ^\n/tmp/tmp0mz1ono7.swift:21:9: error: cannot find 'm' in scope\n\
    \                        r *= m\n                             ^\n/tmp/tmp0mz1ono7.swift:23:5:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n /= 2\n                ~ ^\n/tmp/tmp0mz1ono7.swift:24:3: error:\
    \ cannot find 'm' in scope\n                m *= p\n                ^\n/tmp/tmp0mz1ono7.swift:26:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n - abs(n), p)\n    }\n    if\
    \ n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n\
    \    if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n\
    \    }\n    if n == 2 {\n        return p + 1\n    }\n    if n == 3 {\n      \
    \  return p + 2\n    }\n    if n == 4 {\n        return p + 3\n    }\n    if n\
    \ == 5 {\n        return p + 4\n    }\n    if n == 6 {\n        return p + 5\n\
    \    }\n    if n == 7 {\n        return p + 6\n    }\n    if n == 8 {\n      \
    \  return p + 7\n    }\n    if n == 9 {\n        return p + 8\n    }\n    if n\
    \ == 10 {\n        return p + 9\n    }\n    if n == 11 {\n        return p + 10\n\
    \    }\n    if n == 12 {\n        return p + 11\n    }\n    if n == 13 {\n   \
    \     return p + 12\n    }\n    if n == 14 {\n        return p + 13\n    }\n \
    \   if n == 15 {\n        return p + 14\n    }\n    if n == 16 {\n        return\
    \ p + 15\n    }\n    if n == 17 {\n        return p + 16\n    }\n    if n == 18\
    \ {\n        return p + 17\n    }\n    if n == 19 {\n        return p + 18\n \
    \   }\n    if n == 20 {\n        return p + 19\n    }\n    if n == 21 {\n    \
    \    return p + 20\n    }\n    if n == 22 {\n        return p + 21\n    }\n  \
    \  if n == 23 {\n        return p + 22\n    }\n    if n == 24 {\n        return\
    \ p + 23\n    }\n    if n == 25 {\n        return p + 24\n    }\n    if n == 26\
    \ {\n        return p + 25\n    }\n    if n == 27 {\n        return p + 26\n \
    \   }\n    if n == 28 {\n        return p + 27\n    }\n    if n == 29 {\n    \
    \    return p + 28\n    }\n    if n == 30 {\n        return p + 29\n    }\n  \
    \  if n == 31 {\n        return p + 30\n    }\n    if n == 32 {\n        return\
    \ p + 31\n    }\n    if n == 33 {\n        return p + 32\n    }\n    if n == 34\
    \ {\n        return p + 33\n    }\n    if n == 35 {\n        return p + 34\n \
    \   }\n    if n == 36 {\n        return p + 35\n    }\n    if n == 37 {\n    \
    \    return p + 36\n    }\n    if n == 38 {\n        return p + 37\n    }\n  \
    \  if n == 39 {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpet_ixs8f.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpet_ixs8f.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpet_ixs8f.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpet_ixs8f.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - abs(n), p)\n       \
    \            ^\n                    n:          p: \n/tmp/tmpet_ixs8f.swift:148:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p < 2 {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tif p > p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3q_dkbhv.swift:190:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp3q_dkbhv.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp3q_dkbhv.swift:172:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if p == 0 {\n        return 0\n    }\n    if n >= p {\n        return n -\
    \ p\n    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpneb8tmjk/tmpneb8tmjk.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b970e7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b970e4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b970e4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b970e4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpneb8tmjk                        0x000055910c5c52cd <unavailable> + 4813

    5    libc.so.6                          0x00002b970e9a8460 __libc_start_main +
    245

    6    tmpneb8tmjk                        0x000055910c5c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p must be positive\")\n\t}\n\tif p > p {\n\t\tpanic(\"\
    p must be smaller than p\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9c1dmyyh.swift:200:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp9c1dmyyh.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp9c1dmyyh.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmp9c1dmyyh.swift:16:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmp9c1dmyyh.swift:19:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"p must be positive\")\n\
    \                ^~~~~\n/tmp/tmp9c1dmyyh.swift:22:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p must be smaller than p\")\n            \
    \    ^~~~~\n/tmp/tmp9c1dmyyh.swift:182:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p > p {\n\
    \        return modp(n, p)\n    }\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpczpm5p3j.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpczpm5p3j.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpczpm5p3j.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpczpm5p3j.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpczpm5p3j.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpczpm5p3j.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmpczpm5p3j.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p > p {\n\
    \        return modp(n, p)\n    }\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5_pdp9ec.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp5_pdp9ec.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp5_pdp9ec.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmp5_pdp9ec.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp5_pdp9ec.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmp5_pdp9ec.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmp5_pdp9ec.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcp2i4jjk.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcp2i4jjk.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcp2i4jjk.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcp2i4jjk.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxvtpkc6g.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxvtpkc6g.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpxvtpkc6g.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpxvtpkc6g.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpxvtpkc6g.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpxvtpkc6g.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxvtpkc6g.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxvtpkc6g.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpxvtpkc6g.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpxvtpkc6g.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpxvtpkc6g.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpxvtpkc6g.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((n\
    \ - p) + p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa6ei0vfm.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpa6ei0vfm.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((n - p) + p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n == 0\
    \ {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpws5cp6xc.swift:183:4: error: expected expression, var, or let in\
    \ 'if' condition\n        if \n          ^\n/tmp/tmpws5cp6xc.swift:15:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = -n\n  \
    \              ^\n/tmp/tmpws5cp6xc.swift:16:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = -p\n                ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n > p {\n\
    \        return modp(n, p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppwytpltp.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmppwytpltp.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(n, abs(p))\n\tcase p == 0:\n\t\treturn 0\n\
    \tdefault:\n\t\treturn n & (p - 1)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpci24y4a2.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpci24y4a2.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpci24y4a2.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ abs(p))\n                           ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((n\
    \ - p) + p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa6ei0vfm.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpa6ei0vfm.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((n - p) + p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpo9p3uru5.swift:200:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpo9p3uru5.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpo9p3uru5.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpo9p3uru5.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 1\")\n              \
    \  ^~~~~\n/tmp/tmpo9p3uru5.swift:182:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n, p - 2)\n    }\n    if p < p {\n\
    \        return modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 2)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 2)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p - 2)\n    }\n\
    \    if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n      \
    \  return modp(n, p - 2)\n    }\n    if p < p {\n        return modp(n, p - 1)\n\
    \    }\n    if p < p {\n        return modp(n, p - 2)\n    }\n    if p < p {\n\
    \        return modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 2)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 2)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p - 2)\n    }\n\
    \    if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n      \
    \  return modp(n, p - 2)\n    }\n    if p < p {\n        return modp(n, p - 1)\n\
    \    }\n    if p < p {\n        return modp(n, p - 2)\n    }\n    if p < p {\n\
    \        return modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 2)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n    if\
    \ p < p {\n        return modp(n, p - 2)\n    }\n    if p < p {\n        return\
    \ modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n, p - 2)\n    }\n\
    \    if p < p {\n        return modp(n, p - 1)\n    }\n    if p < p {\n      \
    \  return modp(n, p - 2)\n    }\n    if p < p {\n        return modp(n, p - 1)\n\
    \    }\n    if p < p {\n        return modp(n, p - 2)\n    }\n    if p < p {\n\
    \        return modp(n, p - 1)\n    }\n    if p < p {\n        return modp(n,\
    \ p - 2)\n    }\n    if p < p {\n        return modp(n, p - 1)\n    }\n    if\
    \ p < p {\n        return modp(n, p - \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp56muwik7.swift:127:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp56muwik7.swift:148:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp56muwik7.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp56muwik7.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 2)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 2)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:33:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:36:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 2)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:39:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:42:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 2)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:45:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:48:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 2)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:51:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp56muwik7.swift:54:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 2)\n                   ^\n\
    \                    n: p: \n/tmp/t"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n & (p - 1), p)\n    }\n    if\
    \ p > p {\n        return modp((n >> 1) & (p - 1), p)\n    }\n    return n & (p\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp09k4_7kh.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp09k4_7kh.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n & (p - 1), p)\n                   ^\n\
    \                    n:           p: \n/tmp/tmp09k4_7kh.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp((n >> 1) & (p - 1), p)\n\
    \                   ^\n                    n:                  p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tx := n % p\n\tif x == 0 {\n\t\treturn p\n\t}\n\treturn p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcrcf_fvk.swift:26:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n % p\n         ^\n         ;\n/tmp/tmpcrcf_fvk.swift:26:4:\
    \ error: expected expression\n        x := n % p\n          ^\n/tmp/tmpcrcf_fvk.swift:26:2:\
    \ error: cannot find 'x' in scope\n        x := n % p\n        ^\n/tmp/tmpcrcf_fvk.swift:27:5:\
    \ error: cannot find 'x' in scope\n        if x == 0 {\n           ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t}\n\tn %= p\n\t\
    if n == 0 {\n\t\treturn 1\n\t}\n\treturn p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpx8zbnqav.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpx8zbnqav.swift:18:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpx8zbnqav.swift:23:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n & (p - 1)) == 0) ? n : ((n\
    \ & (p - 1)) + p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp1ooyl8qm/tmp1ooyl8qm.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b020b5f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b020b2efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b020b2ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b020b2ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ooyl8qm                        0x000055c5a2d0623d <unavailable> + 4669

    5    libc.so.6                          0x00002b020b7e4460 __libc_start_main +
    245

    6    tmp1ooyl8qm                        0x000055c5a2d05e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3ghfgaed.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp3ghfgaed.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp3ghfgaed.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp3ghfgaed.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmp3ghfgaed.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmp3ghfgaed.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp39qgcyw.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpp39qgcyw.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p-2 {\n\t\
    \treturn 2\n\t}\n\tif n == p-3 {\n\t\treturn 3\n\t}\n\tif n == p-4 {\n\t\treturn\
    \ 4\n\t}\n\tif n == p-5 {\n\t\treturn 5\n\t}\n\tif n == p-6 {\n\t\treturn 6\n\t\
    }\n\tif n == p-7 {\n\t\treturn 7\n\t}\n\tif n == p-8 {\n\t\treturn 8\n\t}\n\t\
    if n == p-9 {\n\t\treturn 9\n\t}\n\tif n == p-10 {\n\t\treturn 10\n\t}\n\tif n\
    \ == p-11 {\n\t\treturn 11\n\t}\n\tif n == p-12 {\n\t\treturn 12\n\t}\n\tif n\
    \ == p-13 {\n\t\treturn 13\n\t}\n\tif n == p-14 {\n\t\treturn 14\n\t}\n\tif n\
    \ == p-15 {\n\t\treturn 15\n\t}\n\tif n == p-16 {\n\t\treturn 16\n\t}\n\tif n\
    \ == p-17 {\n\t\treturn 17\n\t}\n\tif n == p-18 {\n\t\treturn 18\n\t}\n\tif n\
    \ == p-19 {\n\t\treturn 19\n\t}\n\tif n == p-20 {\n\t\treturn 20\n\t}\n\tif n\
    \ == p-21 {\n\t\treturn 21\n\t}\n\tif n == p-22 {\n\t\treturn 22\n\t}\n\tif n\
    \ == p-23 {\n\t\treturn 23\n\t}\n\tif n == p-24 {\n\t\treturn 24\n\t}\n\tif n\
    \ == p-25 {\n\t\treturn 25\n\t}\n\tif n == p-26 {\n\t\treturn 26\n\t}\n\tif n\
    \ == p-27 {\n\t\treturn 27\n\t}\n\tif n == p-28 {\n\t\treturn 28\n\t}\n\tif n\
    \ == p-29 {\n\t\treturn 29\n\t}\n\tif n == p-30 {\n\t\treturn 30\n\t}\n\tif n\
    \ == p-31 {\n\t\treturn 31\n\t}\n\tif n == p-32 {\n\t\treturn 32\n\t}\n\tif n\
    \ == p-33 {\n\t\treturn 33\n\t}\n\tif n == p-34 {\n\t\treturn 34\n\t}\n\tif n\
    \ == p-35 {\n\t\treturn 35\n\t}\n\tif n == p-36 {\n\t\treturn 36\n\t}\n\tif n\
    \ == p-37 {\n\t\treturn 37\n\t}\n\tif n == p-38 {\n\t\treturn 38\n\t}\n\tif n\
    \ == p-39 {\n\t\treturn 39\n\t}\n\tif n == p-40 {\n\t\treturn 40\n\t}\n\tif n\
    \ == p-41 {\n\t\treturn 41\n\t}\n\tif n == p-42 {\n\t\treturn 42\n\t}\n\tif n\
    \ == p-43 {\n\t\treturn 43\n\t}\n\tif n == p-44 {\n\t\treturn 44\n\t}\n\tif n\
    \ == p-45 {\n\t\treturn 45\n\t}\n\tif n == p-46\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcd26of84.swift:155:14: error: expected '{' after 'if' condition\n\
    \        if n == p-46\n                    ^\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p ==\
    \ 1 {\n\t\treturn n\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > n {\n\t\t\
    return 0\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(n - 1, p) % p\n\tcase\
    \ n <= p:\n\t\treturn n\n\tcase n >= p:\n\t\treturn modp((n - p) % p, p)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvnp0gjwl.swift:26:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvnp0gjwl.swift:28:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p) % p\n\
    \                           ^\n                            n:     p: \n/tmp/tmpvnp0gjwl.swift:32:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp((n\
    \ - p) % p, p)\n                           ^\n                            n: \
    \          p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp((n\
    \ - p) + p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptwfo9wyo.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmptwfo9wyo.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((n - p) + p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 2, p)\n\
    \    }\n    if p < p {\n        return modp(n - 3, p)\n    }\n    if p < p {\n\
    \        return modp(n - 4, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 5, p)\n    }\n    if p < p {\n        return modp(n - 6, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 7, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 8, p)\n    }\n    if p < p {\n        return modp(n - 9, p)\n    }\n\
    \    if p < p {\n        return modp(n - 10, p)\n    }\n    if p < p {\n     \
    \   return modp(n - 11, p)\n    }\n    if p < p {\n        return modp(n - 12,\
    \ p)\n    }\n    if p < p {\n        return modp(n - 13, p)\n    }\n    if p <\
    \ p {\n        return modp(n - 14, p)\n    }\n    if p < p {\n        return modp(n\
    \ - 15, p)\n    }\n    if p < p {\n        return modp(n - 16, p)\n    }\n   \
    \ if p < p {\n        return modp(n - 17, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 18, p)\n    }\n    if p < p {\n        return modp(n - 19, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 20, p)\n    }\n    if p < p {\n \
    \       return modp(n - 21, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 22, p)\n    }\n    if p < p {\n        return modp(n - 23, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 24, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 25, p)\n    }\n    if p < p {\n        return modp(n - 26, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 27, p)\n    }\n    if p < p {\n \
    \       return modp(n - 28, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 29, p)\n    }\n    if p < p {\n        return modp(n - 30, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 31, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 32, p)\n    }\n    if p < p {\n        return modp(n - 33, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 34, p)\n    }\n    if p < p {\n \
    \       return modp(n - 35, p)\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxb62c1dr.swift:146:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxb62c1dr.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpxb62c1dr.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpxb62c1dr.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:24:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - 2, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 3, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 4, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 5, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 9, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 10, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmpxb62c1dr.swift:51:20:\
    \ erro"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: n must be\
    \ positive\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p must be positive\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less than\
    \ p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t}\n\t\
    if p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\t\t\
    panic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p\
    \ must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less\
    \ than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less\
    \ than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less\
    \ than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p must be less than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less\
    \ than p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p must be less than p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p must be \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyk42imom.swift:99:9: error: unterminated string literal\n     \
    \           panic(\"modp: p must be \n                      ^\n/tmp/tmpyk42imom.swift:121:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmpyk42imom.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmpyk42imom.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: n must be positive\")\n                ^~~~~\n\
    /tmp/tmpyk42imom.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp: p must be positive\")\n                ^~~~~\n/tmp/tmpyk42imom.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p must be\
    \ less than p\")\n                ^~~~~\n/tmp/tmpyk42imom.swift:33:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p must be less than p\"\
    )\n                ^~~~~\n/tmp/tmpyk42imom.swift:36:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p must be less than p\")\n         \
    \       ^~~~~\n/tmp/tmpyk42imom.swift:39:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p must be less than p\")\n                ^~~~~\n\
    /tmp/tmpyk42imom.swift:42:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp: p must be less than p\")\n                ^~~~~\n/tmp/tmpyk42imom.swift:45:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p must be\
    \ less than p\")\n                ^~~~~\n/tmp/tmpyk42imom.swift:48:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p must be less than p\"\
    )\n                ^~~~~\n/tmp/tmpyk42imom.swift:51:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p must be less than p\")\n         \
    \       ^~~~~\n/tmp/tmpyk42imom.swift:54:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p must be less than p\")\n                ^~~~~\n\
    /tmp/tmpyk42imom.swift:57:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp: p must be less than "
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 1\n    }\n    if p == 1 {\n        return n\n    }\n    if p ==\
    \ 2 {\n        return modp(n / 2, p)\n    }\n    if p == 3 {\n        return modp(n\
    \ / 3, p)\n    }\n    if p == 4 {\n        return modp(n / 4, p)\n    }\n    if\
    \ p == 5 {\n        return modp(n / 5, p)\n    }\n    if p == 6 {\n        return\
    \ modp(n / 6, p)\n    }\n    if p == 7 {\n        return modp(n / 7, p)\n    }\n\
    \    if p == 8 {\n        return modp(n / 8, p)\n    }\n    if p == 9 {\n    \
    \    return modp(n / 9, p)\n    }\n    if p == 10 {\n        return modp(n / 10,\
    \ p)\n    }\n    if p == 11 {\n        return modp(n / 11, p)\n    }\n    if p\
    \ == 12 {\n        return modp(n / 12, p)\n    }\n    if p == 13 {\n        return\
    \ modp(n / 13, p)\n    }\n    if p == 14 {\n        return modp(n / 14, p)\n \
    \   }\n    if p == 15 {\n        return modp(n / 15, p)\n    }\n    if p == 16\
    \ {\n        return modp(n / 16, p)\n    }\n    if p == 17 {\n        return modp(n\
    \ / 17, p)\n    }\n    if p == 18 {\n        return modp(n / 18, p)\n    }\n \
    \   if p == 19 {\n        return modp(n / 19, p)\n    }\n    if p == 20 {\n  \
    \      return modp(n / 20, p)\n    }\n    if p == 21 {\n        return modp(n\
    \ / 21, p)\n    }\n    if p == 22 {\n        return modp(n / 22, p)\n    }\n \
    \   if p == 23 {\n        return modp(n / 23, p)\n    }\n    if p == 24 {\n  \
    \      return modp(n / 24, p)\n    }\n    if p == 25 {\n        return modp(n\
    \ / 25, p)\n    }\n    if p == 26 {\n        return modp(n / 26, p)\n    }\n \
    \   if p == 27 {\n        return modp(n / 27, p)\n    }\n    if p == 28 {\n  \
    \      return modp(n / 28, p)\n    }\n    if p == 29 {\n        return modp(n\
    \ / 29, p)\n    }\n    if p == 30 {\n        return modp(n / 30, p)\n    }\n \
    \   if p == 31 {\n        return modp(n / 31, p)\n    }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp29qim2bg.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp29qim2bg.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp29qim2bg.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmp29qim2bg.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / 3, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmp29qim2bg.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n / 4, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:36:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / 5, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 9, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp29qim2bg.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 10, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmp29qim2bg.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 11, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmp29qim2bg.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / 12, p)\n\
    \                   ^\n                    n:    "
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ argument\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive argument\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if n == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp requires positive\
    \ argument\")\n\t}\n\tx := n\n\ty := p\n\tt := 1\n\tfor {\n\t\tif y > 1 {\n\t\t\
    \ty >>= 1\n\t\t\tx >>= 1\n\t\t}\n\t\tif x == 0 {\n\t\t\treturn t\n\t\t}\n\t\t\
    if x & y == 0 {\n\t\t\treturn x\n\t\t}\n\t\tt *= y\n\t\tx >>= 1\n\t\ty >>= 1\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxdtihac0.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpxdtihac0.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpxdtihac0.swift:35:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpxdtihac0.swift:35:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpxdtihac0.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp requires positive argument\")\n                ^~~~~\n\
    /tmp/tmpxdtihac0.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires positive argument\")\n                ^~~~~\n/tmp/tmpxdtihac0.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ argument\")\n                ^~~~~\n/tmp/tmpxdtihac0.swift:32:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcp2i4jjk.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpcp2i4jjk.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\
    \t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\
    \t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p\
    \ < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\t\
    return 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t\
    }\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p <\
    \ p {\n\t\treturn 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\t\
    return 0\n\t}\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t\
    }\n\tif p < p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tif p <\
    \ p {\n\t\treturn 1\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9wkoakj2.swift:189:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp9wkoakj2.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp9wkoakj2.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmp9wkoakj2.swift:16:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmp9wkoakj2.swift:171:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p % p)\n    }\n    if p >\
    \ p {\n        return modp(n, p - 1)\n    }\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwh847upv.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpwh847upv.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n/tmp/tmpwh847upv.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n - 1, p)\n    }\n    if p >\
    \ p {\n        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpruvwbn58.swift:201:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpruvwbn58.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpruvwbn58.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpruvwbn58.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpruvwbn58.swift:21:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 1)\n    \
    \               ^\n                    n: p: \n/tmp/tmpruvwbn58.swift:183:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ argument\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive argument\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p\
    \ {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp43dub2sp.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive argument\")\n                ^~~~~\n\
    /tmp/tmp43dub2sp.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires positive argument\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p+1 {\n        return\
    \ p\n    }\n    if n == p+2 {\n        return p+1\n    }\n    if n == p+3 {\n\
    \        return p+2\n    }\n    if n == p+4 {\n        return p+3\n    }\n   \
    \ if n == p+5 {\n        return p+4\n    }\n    if n == p+6 {\n        return\
    \ p+5\n    }\n    if n == p+7 {\n        return p+6\n    }\n    if n == p+8 {\n\
    \        return p+7\n    }\n    if n == p+9 {\n        return p+8\n    }\n   \
    \ if n == p+10 {\n        return p+9\n    }\n    if n == p+11 {\n        return\
    \ p+10\n    }\n    if n == p+12 {\n        return p+11\n    }\n    if n == p+13\
    \ {\n        return p+12\n    }\n    if n == p+14 {\n        return p+13\n   \
    \ }\n    if n == p+15 {\n        return p+14\n    }\n    if n == p+16 {\n    \
    \    return p+15\n    }\n    if n == p+17 {\n        return p+16\n    }\n    if\
    \ n == p+18 {\n        return p+17\n    }\n    if n == p+19 {\n        return\
    \ p+18\n    }\n    if n == p+20 {\n        return p+19\n    }\n    if n == p+21\
    \ {\n        return p+20\n    }\n    if n == p+22 {\n        return p+21\n   \
    \ }\n    if n == p+23 {\n        return p+22\n    }\n    if n == p+24 {\n    \
    \    return p+23\n    }\n    if n == p+25 {\n        return p+24\n    }\n    if\
    \ n == p+26 {\n        return p+25\n    }\n    if n == p+27 {\n        return\
    \ p+26\n    }\n    if n == p+28 {\n        return p+27\n    }\n    if n == p+29\
    \ {\n        return p+28\n    }\n    if n == p+30 {\n        return p+29\n   \
    \ }\n    if n == p+31 {\n        return p+30\n    }\n    if n == p+32 {\n    \
    \    return p+31\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9r0oug9m.swift:151:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp9r0oug9m.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp9r0oug9m.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp9r0oug9m.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp9r0oug9m.swift:133:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires n\
    \ >= 0\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires p >= 1\")\n\t}\n\tif n\
    \ == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp requires p <= p\")\n\t}\n\t\
    n %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == 2\
    \ {\n\t\treturn p\n\t}\n\tif n == 3 {\n\t\treturn p + 1\n\t}\n\tif n == 4 {\n\t\
    \treturn p + 2\n\t}\n\tif n == 5 {\n\t\treturn p + 3\n\t}\n\tif n == 6 {\n\t\t\
    return p + 4\n\t}\n\tif n == 7 {\n\t\treturn p + 5\n\t}\n\tif n == 8 {\n\t\treturn\
    \ p + 6\n\t}\n\tif n == 9 {\n\t\treturn p + 7\n\t}\n\tif n == 10 {\n\t\treturn\
    \ p + 8\n\t}\n\tif n == 11 {\n\t\treturn p + 9\n\t}\n\tif n == 12 {\n\t\treturn\
    \ p + 10\n\t}\n\tif n == 13 {\n\t\treturn p + 11\n\t}\n\tif n == 14 {\n\t\treturn\
    \ p + 12\n\t}\n\tif n == 15 {\n\t\treturn p + 13\n\t}\n\tif n == 16 {\n\t\treturn\
    \ p + 14\n\t}\n\tif n == 17 {\n\t\treturn p + 15\n\t}\n\tif n == 18 {\n\t\treturn\
    \ p + 16\n\t}\n\tif n == 19 {\n\t\treturn p + 17\n\t}\n\tif n == 20 {\n\t\treturn\
    \ p + 18\n\t}\n\tif n == 21 {\n\t\treturn p + 19\n\t}\n\tif n == 22 {\n\t\treturn\
    \ p + 20\n\t}\n\tif n == 23 {\n\t\treturn p + 21\n\t}\n\tif n == 24 {\n\t\treturn\
    \ p + 22\n\t}\n\tif n == 25 {\n\t\treturn p + 23\n\t}\n\tif n == 26 {\n\t\treturn\
    \ p + 24\n\t}\n\tif n == 27 {\n\t\treturn p + 25\n\t}\n\tif n == 28 {\n\t\treturn\
    \ p + 26\n\t}\n\tif n == 29 {\n\t\treturn p + 27\n\t}\n\tif n == 30 {\n\t\treturn\
    \ p + 28\n\t}\n\tif n == 31 {\n\t\treturn p + 29\n\t}\n\tif n == 32 {\n\t\treturn\
    \ p + 30\n\t}\n\tif n == 33 {\n\t\treturn p + 31\n\t}\n\tif n == 34 {\n\t\treturn\
    \ p + 32\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzv30h3ah.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires n >= 0\")\n                ^~~~~\n/tmp/tmpzv30h3ah.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ >= 1\")\n                ^~~~~\n/tmp/tmpzv30h3ah.swift:30:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires p <= p\")\n        \
    \        ^~~~~\n/tmp/tmpzv30h3ah.swift:32:4: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ number\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive modulus\")\n\
    \t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tr :=\
    \ n % p\n\tif r == 0 {\n\t\treturn p\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgwqm3i6y.swift:26:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmpgwqm3i6y.swift:26:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmpgwqm3i6y.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ number\")\n                ^~~~~\n/tmp/tmpgwqm3i6y.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp requires positive modulus\"\
    )\n                ^~~~~\n/tmp/tmpgwqm3i6y.swift:26:2: error: cannot find 'r'\
    \ in scope\n        r := n % p\n        ^\n/tmp/tmpgwqm3i6y.swift:27:5: error:\
    \ cannot find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpgwqm3i6y.swift:30:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n / p, p)\n    }\n    if p >\
    \ p {\n        return modp(p / n, p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpuce863bb.swift:179:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmpuce863bb.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpuce863bb.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpuce863bb.swift:21:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(p / n, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv46e953w.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive n\")\n                ^~~~~\n/tmp/tmpv46e953w.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ p\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp called with p > p\"\
    )\n\t}\n\tr := 1\n\tfor i := n - 1; i >= 0; i-- {\n\t\tr *= p\n\t\tr += n\n\t\
    }\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqin7ml16.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmpqin7ml16.swift:32:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmpqin7ml16.swift:33:9:\
    \ error: expected type\n        for i := n - 1; i >= 0; i-- {\n              \
    \ ^\n                <#type#>\n/tmp/tmpqin7ml16.swift:33:9: error: expected 'in'\
    \ after for-each pattern\n        for i := n - 1; i >= 0; i-- {\n            \
    \   ^\n/tmp/tmpqin7ml16.swift:33:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := n - 1; i >= 0; i-- {\n               ^\n/tmp/tmpqin7ml16.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpqin7ml16.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p < 1\")\n \
    \               ^~~~~\n/tmp/tmpqin7ml16.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p > p\")\n              \
    \  ^~~~~\n/tmp/tmpqin7ml16.swift:32:2: error: cannot find 'r' in scope\n     \
    \   r := 1\n        ^\n/tmp/tmpqin7ml16.swift:37:9: error: cannot find 'r' in\
    \ scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n - 1, p)\n    }\n    if p < p {\n\
    \        return modp(n - 2, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 3, p)\n    }\n    if p < p {\n        return modp(n - 4, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 5, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 6, p)\n    }\n    if p < p {\n        return modp(n - 7, p)\n    }\n\
    \    if p < p {\n        return modp(n - 8, p)\n    }\n    if p < p {\n      \
    \  return modp(n - 9, p)\n    }\n    if p < p {\n        return modp(n - 10, p)\n\
    \    }\n    if p < p {\n        return modp(n - 11, p)\n    }\n    if p < p {\n\
    \        return modp(n - 12, p)\n    }\n    if p < p {\n        return modp(n\
    \ - 13, p)\n    }\n    if p < p {\n        return modp(n - 14, p)\n    }\n   \
    \ if p < p {\n        return modp(n - 15, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 16, p)\n    }\n    if p < p {\n        return modp(n - 17, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 18, p)\n    }\n    if p < p {\n \
    \       return modp(n - 19, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 20, p)\n    }\n    if p < p {\n        return modp(n - 21, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 22, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 23, p)\n    }\n    if p < p {\n        return modp(n - 24, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 25, p)\n    }\n    if p < p {\n \
    \       return modp(n - 26, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 27, p)\n    }\n    if p < p {\n        return modp(n - 28, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 29, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 30, p)\n    }\n    if p < p {\n        return modp(n - 31, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 32, p)\n    }\n    if p < p {\n \
    \       return modp(n - 33, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 34, p)\n    }\n    if p < p {\n        return modp(n - 35, \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7h2ai214.swift:127:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp7h2ai214.swift:148:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp7h2ai214.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp7h2ai214.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - 1, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmp7h2ai214.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 2, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:30:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - 3, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 4, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 5, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 9, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp7h2ai214.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 10, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmp7h2ai214.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 11, p)\n\
    \   "
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tm := n % (p - 1)\n\tif m == 0 {\n\t\treturn p\n\t}\n\treturn m\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_fouptwv.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        m := n % (p - 1)\n         ^\n         ;\n/tmp/tmp_fouptwv.swift:29:4:\
    \ error: expected expression\n        m := n % (p - 1)\n          ^\n/tmp/tmp_fouptwv.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp_fouptwv.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmp_fouptwv.swift:29:2: error: cannot find 'm' in scope\n   \
    \     m := n % (p - 1)\n        ^\n/tmp/tmp_fouptwv.swift:30:5: error: cannot\
    \ find 'm' in scope\n        if m == 0 {\n           ^\n/tmp/tmp_fouptwv.swift:33:9:\
    \ error: cannot find 'm' in scope\n        return m\n               ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n += p\n    }\n  \
    \  if n < p {\n        return n\n    }\n    if n == p {\n        return 1\n  \
    \  }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((p\
    \ - n) % p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6eevf7mf.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n/tmp/tmp6eevf7mf.swift:24:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp6eevf7mf.swift:26:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp((p - n) % p,\
    \ p)\n               ^\n                n:           p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == 2 {\n        return p + 1\n    }\n    if n == 3 {\n        return\
    \ p + 2\n    }\n    if n == 4 {\n        return p + 3\n    }\n    if n == 5 {\n\
    \        return p + 4\n    }\n    if n == 6 {\n        return p + 5\n    }\n \
    \   if n == 7 {\n        return p + 6\n    }\n    if n == 8 {\n        return\
    \ p + 7\n    }\n    if n == 9 {\n        return p + 8\n    }\n    if n == 10 {\n\
    \        return p + 9\n    }\n    if n == 11 {\n        return p + 10\n    }\n\
    \    if n == 12 {\n        return p + 11\n    }\n    if n == 13 {\n        return\
    \ p + 12\n    }\n    if n == 14 {\n        return p + 13\n    }\n    if n == 15\
    \ {\n        return p + 14\n    }\n    if n == 16 {\n        return p + 15\n \
    \   }\n    if n == 17 {\n        return p + 16\n    }\n    if n == 18 {\n    \
    \    return p + 17\n    }\n    if n == 19 {\n        return p + 18\n    }\n  \
    \  if n == 20 {\n        return p + 19\n    }\n    if n == 21 {\n        return\
    \ p + 20\n    }\n    if n == 22 {\n        return p + 21\n    }\n    if n == 23\
    \ {\n        return p + 22\n    }\n    if n == 24 {\n        return p + 23\n \
    \   }\n    if n == 25 {\n        return p + 24\n    }\n    if n == 26 {\n    \
    \    return p + 25\n    }\n    if n == 27 {\n        return p + 26\n    }\n  \
    \  if n == 28 {\n        return p + 27\n    }\n    if n == 29 {\n        return\
    \ p + 28\n    }\n    if n == 30 {\n        return p + 29\n    }\n    if n == 31\
    \ {\n        return p + 30\n    }\n    if n == 32 {\n        return p + 31\n \
    \   }\n    if n == 33 {\n        return p + 32\n    }\n    if n == 34 {\n    \
    \    return p + 33\n    }\n    if n == 35 {\n        return p + 34\n    }\n  \
    \  if n == 36 {\n        return p + 35\n    }\n    if n == 37 {\n        return\
    \ p + 36\n    }\n    if n == 38 {\n        return p + 37\n    }\n    if n == 39\
    \ {\n        return p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_g9ep_tr.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp_g9ep_tr.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp_g9ep_tr.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp_g9ep_tr.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp_g9ep_tr.swift:148:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires n\
    \ >= 0\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires p >= 1\")\n\t}\n\tif n\
    \ == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - 1, p)\n\t}\n\tif p > p {\n\
    \t\treturn modp(n, p - 1)\n\t}\n\tq := modp(n - 1, p)\n\tr := modp(n, p - 1)\n\
    \treturn q * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjj3ju5ag.swift:35:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := modp(n - 1, p)\n         ^\n         ;\n/tmp/tmpjj3ju5ag.swift:35:4:\
    \ error: expected expression\n        q := modp(n - 1, p)\n          ^\n/tmp/tmpjj3ju5ag.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires n\
    \ >= 0\")\n                ^~~~~\n/tmp/tmpjj3ju5ag.swift:18:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires p >= 1\")\n        \
    \        ^~~~~\n/tmp/tmpjj3ju5ag.swift:30:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp(n - 1, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmpjj3ju5ag.swift:33:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n, p - 1)\n\
    \                           ^\n                            n: p: \n/tmp/tmpjj3ju5ag.swift:35:2:\
    \ error: cannot find 'q' in scope\n        q := modp(n - 1, p)\n        ^\n/tmp/tmpjj3ju5ag.swift:37:9:\
    \ error: cannot find 'q' in scope\n        return q * p + r\n               ^\n\
    /tmp/tmpjj3ju5ag.swift:37:17: error: cannot find 'r' in scope\n        return\
    \ q * p + r\n                       ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(n + p, p)\n\tcase p > n:\n\t\treturn modp(n,\
    \ p)\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsr_x7nk1.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpsr_x7nk1.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpsr_x7nk1.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ + p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpsr_x7nk1.swift:20:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p)\n                           ^\n           \
    \                 n: p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if p > n {\n        return modp(n, p)\n    }\n    if p < n {\n        return\
    \ modp(n, p)\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n\
    \        return p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n \
    \   if n == 4 {\n        return p + 3\n    }\n    if n == 5 {\n        return\
    \ p + 4\n    }\n    if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n\
    \        return p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n \
    \   if n == 9 {\n        return p + 8\n    }\n    if n == 10 {\n        return\
    \ p + 9\n    }\n    if n == 11 {\n        return p + 10\n    }\n    if n == 12\
    \ {\n        return p + 11\n    }\n    if n == 13 {\n        return p + 12\n \
    \   }\n    if n == 14 {\n        return p + 13\n    }\n    if n == 15 {\n    \
    \    return p + 14\n    }\n    if n == 16 {\n        return p + 15\n    }\n  \
    \  if n == 17 {\n        return p + 16\n    }\n    if n == 18 {\n        return\
    \ p + 17\n    }\n    if n == 19 {\n        return p + 18\n    }\n    if n == 20\
    \ {\n        return p + 19\n    }\n    if n == 21 {\n        return p + 20\n \
    \   }\n    if n == 22 {\n        return p + 21\n    }\n    if n == 23 {\n    \
    \    return p + 22\n    }\n    if n == 24 {\n        return p + 23\n    }\n  \
    \  if n == 25 {\n        return p + 24\n    }\n    if n == 26 {\n        return\
    \ p + 25\n    }\n    if n == 27 {\n        return p + 26\n    }\n    if n == 28\
    \ {\n        return p + 27\n    }\n    if n == 29 {\n        return p + 28\n \
    \   }\n    if n == 30 {\n        return p + 29\n    }\n    if n == 31 {\n    \
    \    return p + 30\n    }\n    if n == 32 {\n        return p + 31\n    }\n  \
    \  if n == 33 {\n        return p + 32\n    }\n    if n == 34 {\n        return\
    \ p + 33\n    }\n    if n == 35 {\n        return p + 34\n    }\n    if n == 36\
    \ {\n        return p + 35\n    }\n    if n == 37 {\n        return p + 36\n \
    \   }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp89fpol91.swift:143:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp89fpol91.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmp89fpol91.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n   \
    \                ^\n                    n: p: \n/tmp/tmp89fpol91.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmp89fpol91.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n % p + p) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj_u4m5qj/tmpj_u4m5qj.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bbc0bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bbbdb5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bbbdb5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bbbdb47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj_u4m5qj                        0x00005582e10492cd <unavailable> + 4813

    5    libc.so.6                          0x00002b2bbc2aa460 __libc_start_main +
    245

    6    tmpj_u4m5qj                        0x00005582e1048ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014804
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return n & (p - 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphrqsdavf/tmphrqsdavf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d67b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d67877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d67877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d678767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrqsdavf                        0x000055d17c19c1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b0d67d6c460 __libc_start_main +
    245

    6    tmphrqsdavf                        0x000055d17c19be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n & (p - 1)) == 0) ? n : n -\
    \ p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp334x_hfy/tmp334x_hfy.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44f3ac9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44f37c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44f37c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44f37bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp334x_hfy                        0x000055964d2d923d <unavailable> + 4669

    5    libc.so.6                          0x00002b44f3cb5460 __libc_start_main +
    245

    6    tmp334x_hfy                        0x000055964d2d8e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p > p {\n\
    \        return modp(n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9yeuxduf.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp9yeuxduf.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp9yeuxduf.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmp9yeuxduf.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmp9yeuxduf.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmp9yeuxduf.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmp9yeuxduf.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn 0\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p - 1 {\n\t\treturn\
    \ 2\n\t}\n\tif n == p - 2 {\n\t\treturn 3\n\t}\n\tif n == p - 3 {\n\t\treturn\
    \ 4\n\t}\n\tif n == p - 4 {\n\t\treturn 5\n\t}\n\tif n == p - 5 {\n\t\treturn\
    \ 6\n\t}\n\tif n == p - 6 {\n\t\treturn 7\n\t}\n\tif n == p - 7 {\n\t\treturn\
    \ 8\n\t}\n\tif n == p - 8 {\n\t\treturn 9\n\t}\n\tif n == p - 9 {\n\t\treturn\
    \ 10\n\t}\n\tif n == p - 10 {\n\t\treturn 11\n\t}\n\tif n == p - 11 {\n\t\treturn\
    \ 12\n\t}\n\tif n == p - 12 {\n\t\treturn 13\n\t}\n\tif n == p - 13 {\n\t\treturn\
    \ 14\n\t}\n\tif n == p - 14 {\n\t\treturn 15\n\t}\n\tif n == p - 15 {\n\t\treturn\
    \ 16\n\t}\n\tif n == p - 16 {\n\t\treturn 17\n\t}\n\tif n == p - 17 {\n\t\treturn\
    \ 18\n\t}\n\tif n == p - 18 {\n\t\treturn 19\n\t}\n\tif n == p - 19 {\n\t\treturn\
    \ 20\n\t}\n\tif n == p - 20 {\n\t\treturn 21\n\t}\n\tif n == p - 21 {\n\t\treturn\
    \ 22\n\t}\n\tif n == p - 22 {\n\t\treturn 23\n\t}\n\tif n == p - 23 {\n\t\treturn\
    \ 24\n\t}\n\tif n == p - 24 {\n\t\treturn 25\n\t}\n\tif n == p - 25 {\n\t\treturn\
    \ 26\n\t}\n\tif n == p - 26 {\n\t\treturn 27\n\t}\n\tif n == p - 27 {\n\t\treturn\
    \ 28\n\t}\n\tif n == p - 28 {\n\t\treturn 29\n\t}\n\tif n == p - 29 {\n\t\treturn\
    \ 30\n\t}\n\tif n == p - 30 {\n\t\treturn 31\n\t}\n\tif n == p - 31 {\n\t\treturn\
    \ 32\n\t}\n\tif n == p - 32 {\n\t\treturn 33\n\t}\n\tif n == p - 33 {\n\t\treturn\
    \ 34\n\t}\n\tif n == p - 34 {\n\t\treturn 35\n\t}\n\tif n == p - 35 {\n\t\treturn\
    \ 36\n\t}\n\tif n == p - 36 {\n\t\treturn 37\n\t}\n\tif n == p - 37 {\n\t\treturn\
    \ 38\n\t}\n\tif n == p - 38 {\n\t\treturn 39\n\t}\n\tif n == p - 39 {\n\t\treturn\
    \ 40\n\t}\n\tif n == p - 40 {\n\t\treturn 41\n\t}\n\tif n == p - 41 {\n\t\treturn\
    \ 42\n\t}\n\tif n == p - 42 {\n\t\treturn 43\n\t}\n\tif n == p - 43 {\n\t\treturn\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpce4tqh5z.swift:178:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpce4tqh5z.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpce4tqh5z.swift:156:3: error: non-void function\
    \ should return a value\n                return \n                ^\n/tmp/tmpce4tqh5z.swift:160:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tswitch {\n\tcase p < 0:\n\t\treturn 0\n\tcase p == 0:\n\t\treturn 1\n\tcase\
    \ p == 1:\n\t\treturn n\n\tcase p < n:\n\t\treturn p % n\n\tdefault:\n\t\tn %=\
    \ p\n\t\tif n == 0 {\n\t\t\treturn 1\n\t\t}\n\t\tif n == p {\n\t\t\treturn 0\n\
    \t\t}\n\t\tif n < p {\n\t\t\treturn modp(n - p, p)\n\t\t}\n\t\treturn modp(n,\
    \ p - n)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsh4j4cm0.swift:18:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpsh4j4cm0.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpsh4j4cm0.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmpsh4j4cm0.swift:28:5:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n %= p\n                ~ ^\n/tmp/tmpsh4j4cm0.swift:36:15: error:\
    \ missing argument labels 'n:p:' in call\n                        return modp(n\
    \ - p, p)\n                                   ^\n                            \
    \        n:     p: \n/tmp/tmpsh4j4cm0.swift:38:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(n, p - n)\n                    \
    \       ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\t\
    return 0\n\t}\n\tif p > n {\n\t\treturn 0\n\t}\n\tlet d = p - n\n\tlet r = powMod(Int64(1),\
    \ d, p)\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq90cfb93.swift:30:10: error: cannot find 'powMod' in scope\n  \
    \      let r = powMod(Int64(1), d, p)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires n\
    \ >= 0\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires p >= 1\")\n\t}\n\tif n\
    \ == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tx := n\n\tfor x != 0 {\n\t\tx := x % p\n\t\tif x == 0 {\n\
    \t\t\treturn x\n\t\t}\n\t}\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4xxc1fjq.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp4xxc1fjq.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp4xxc1fjq.swift:30:8:\
    \ error: expected 'in' after for-each pattern\n        for x != 0 {\n        \
    \      ^\n/tmp/tmp4xxc1fjq.swift:30:8: error: unary operator cannot be separated\
    \ from its operand\n        for x != 0 {\n              ^ ~\n                \n\
    /tmp/tmp4xxc1fjq.swift:31:4: error: consecutive statements on a line must be separated\
    \ by ';'\n                x := x % p\n                 ^\n                 ;\n\
    /tmp/tmp4xxc1fjq.swift:31:5: error: expected expression\n                x :=\
    \ x % p\n                  ^\n/tmp/tmp4xxc1fjq.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires n >= 0\")\n        \
    \        ^~~~~\n/tmp/tmp4xxc1fjq.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp requires p >= 1\")\n                ^~~~~\n/tmp/tmp4xxc1fjq.swift:29:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmp4xxc1fjq.swift:30:8:\
    \ error: '!=' is not a prefix unary operator\n        for x != 0 {\n         \
    \     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tm := n\n\tfor m > p {\n\t\tm\
    \ >>= 1\n\t}\n\treturn m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyi9lid05.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        m := n\n         ^\n         ;\n/tmp/tmpyi9lid05.swift:32:4:\
    \ error: expected expression\n        m := n\n          ^\n/tmp/tmpyi9lid05.swift:33:8:\
    \ error: expected 'in' after for-each pattern\n        for m > p {\n         \
    \     ^\n/tmp/tmpyi9lid05.swift:33:8: error: unary operator cannot be separated\
    \ from its operand\n        for m > p {\n              ^~\n               \n/tmp/tmpyi9lid05.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpyi9lid05.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmpyi9lid05.swift:30:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpyi9lid05.swift:32:2:\
    \ error: cannot find 'm' in scope\n        m := n\n        ^\n/tmp/tmpyi9lid05.swift:33:8:\
    \ error: '>' is not a prefix unary operator\n        for m > p {\n           \
    \   ^\n/tmp/tmpyi9lid05.swift:36:9: error: cannot find 'm' in scope\n        return\
    \ m\n               ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn n % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp_vnddjwn/tmp_vnddjwn.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad023956c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad02364db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad02364d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad02364c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_vnddjwn                        0x0000560a7f34e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad023b42460 __libc_start_main +
    245

    6    tmp_vnddjwn                        0x0000560a7f34def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\t\
    case p == 1:\n\t\treturn n\n\tcase p % 2 == 1:\n\t\treturn modp(n / 2, p)\n\t\
    default:\n\t\tlet r = n % p\n\t\tif r == 0 {\n\t\t\treturn modp(n / p, p)\n\t\t\
    }\n\t\treturn modp(r * p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvd_ivks0.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvd_ivks0.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpvd_ivks0.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmpvd_ivks0.swift:24:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ / 2, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpvd_ivks0.swift:28:15: error: missing argument labels 'n:p:' in call\n\
    \                        return modp(n / p, p)\n                             \
    \      ^\n                                    n:     p: \n/tmp/tmpvd_ivks0.swift:30:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(r\
    \ * p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((n%p) + p) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpslrupqfj/tmpslrupqfj.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0dd053dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0dd0234b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0dd0234988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0dd02337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpslrupqfj                        0x000056527668b2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b0dd0729460 __libc_start_main +
    245

    6    tmpslrupqfj                        0x000056527668aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014804
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return n\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if n >= p {\n        return n -\
    \ p\n    }\n    return n - p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpdi7nk18x/tmpdi7nk18x.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5da9dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5da6d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5da6d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5da6d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdi7nk18x                        0x0000562a03fe623d <unavailable> + 4669

    5    libc.so.6                          0x00002af5dabc7460 __libc_start_main +
    245

    6    tmpdi7nk18x                        0x0000562a03fe5e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014804
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - p\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpl63ovk0q/tmpl63ovk0q.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bded6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bdea66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9bdea66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9bdea657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl63ovk0q                        0x000055f8a3d7c23d <unavailable> + 4669

    5    libc.so.6                          0x00002b9bdef5b460 __libc_start_main +
    245

    6    tmpl63ovk0q                        0x000055f8a3d7be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbkmf0uyq.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpbkmf0uyq.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpbkmf0uyq.swift:18:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014470
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p - 1)\n    }\n    if p > p {\n\
    \        return modp(n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppsbyh2lm.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmppsbyh2lm.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmppsbyh2lm.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmppsbyh2lm.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmppsbyh2lm.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmppsbyh2lm.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmppsbyh2lm.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpv46e953w.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive n\")\n                ^~~~~\n/tmp/tmpv46e953w.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ p\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tp = p\n\t}\n\tlet mut n2 =\
    \ n\n\tlet mut p2 = p\n\twhile p2 > 1 {\n\t\tn2 = n2 << 1\n\t\tp2 = p2 >> 1\n\t\
    }\n\tn2 = n2 << 1\n\tp2 = p2 >> 1\n\tlet mut n3 = n\n\tlet mut p3 = p\n\twhile\
    \ p3 > 1 {\n\t\tn3 = n3 << 1\n\t\tp3 = p3 >> 1\n\t}\n\tn3 = n3 << 1\n\tp3 = p3\
    \ >> 1\n\tlet mut n4 = n\n\tlet mut p4 = p\n\twhile p4 > 1 {\n\t\tn4 = n4 << 1\n\
    \t\tp4 = p4 >> 1\n\t}\n\tn4 = n4 << 1\n\tp4 = p4 >> 1\n\tlet mut n5 = n\n\tlet\
    \ mut p5 = p\n\twhile p5 > 1 {\n\t\tn5 = n5 << 1\n\t\tp5 = p5 >> 1\n\t}\n\tn5\
    \ = n5 << 1\n\tp5 = p5 >> 1\n\tlet mut n6 = n\n\tlet mut p6 = p\n\twhile p6 >\
    \ 1 {\n\t\tn6 = n6 << 1\n\t\tp6 = p6 >> 1\n\t}\n\tn6 = n6 << 1\n\tp6 = p6 >> 1\n\
    \tlet mut n7 = n\n\tlet mut p7 = p\n\twhile p7 > 1 {\n\t\tn7 = n7 << 1\n\t\tp7\
    \ = p7 >> 1\n\t}\n\tn7 = n7 << 1\n\tp7 = p7 >> 1\n\tlet mut n8 = n\n\tlet mut\
    \ p8 = p\n\twhile p8 > 1 {\n\t\tn8 = n8 << 1\n\t\tp8 = p8 >> 1\n\t}\n\tn8 = n8\
    \ << 1\n\tp8 = p8 >> 1\n\tlet mut n9 = n\n\tlet mut p9 = p\n\twhile p9 > 1 {\n\
    \t\tn9 = n9 << 1\n\t\tp9 = p9 >> 1\n\t}\n\tn9 = n9 << 1\n\tp9 = p9 >> 1\n\tlet\
    \ mut n10 = n\n\tlet mut p10 = p\n\twhile p10 > 1 {\n\t\tn10 = n10 << \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_froqnpr.swift:24:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut n2 =\
    \ n\n                ^\n/tmp/tmp_froqnpr.swift:24:10: note: join the identifiers\
    \ together\n        let mut n2 = n\n            ~~~~^~\n            mutn2\n/tmp/tmp_froqnpr.swift:24:10:\
    \ note: join the identifiers together with camel-case\n        let mut n2 = n\n\
    \            ~~~~^~\n            mutN2\n/tmp/tmp_froqnpr.swift:25:10: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut p2 = p\n                ^\n/tmp/tmp_froqnpr.swift:25:10:\
    \ note: join the identifiers together\n        let mut p2 = p\n            ~~~~^~\n\
    \            mutp2\n/tmp/tmp_froqnpr.swift:25:10: note: join the identifiers together\
    \ with camel-case\n        let mut p2 = p\n            ~~~~^~\n            mutP2\n\
    /tmp/tmp_froqnpr.swift:32:10: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n        let mut n3 = n\n\
    \                ^\n/tmp/tmp_froqnpr.swift:32:10: note: join the identifiers together\n\
    \        let mut n3 = n\n            ~~~~^~\n            mutn3\n/tmp/tmp_froqnpr.swift:32:10:\
    \ note: join the identifiers together with camel-case\n        let mut n3 = n\n\
    \            ~~~~^~\n            mutN3\n/tmp/tmp_froqnpr.swift:33:10: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut p3 = p\n                ^\n/tmp/tmp_froqnpr.swift:33:10:\
    \ note: join the identifiers together\n        let mut p3 = p\n            ~~~~^~\n\
    \            mutp3\n/tmp/tmp_froqnpr.swift:33:10: note: join the identifiers together\
    \ with camel-case\n        let mut p3 = p\n            ~~~~^~\n            mutP3\n\
    /tmp/tmp_froqnpr.swift:40:10: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n        let mut n4 = n\n\
    \                ^\n/tmp/tmp_froqnpr.swift:40:10: note: join the identifiers together\n\
    \        let mut n4 = n\n            ~~~~^~\n            m"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(-n, p)\n\tcase n <= p:\n\t\treturn n\n\t\
    default:\n\t\treturn modp(n - p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpiylmi559.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpiylmi559.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpiylmi559.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmpiylmi559.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - p, p)\n\t}\n\tif p > p {\n\
    \t\treturn modp(n, p - p)\n\t}\n\treturn modp((n - p) * (n - p), p) + p\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsr2u4w_1.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires positive n\")\n                ^~~~~\n/tmp/tmpsr2u4w_1.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ p\")\n                ^~~~~\n/tmp/tmpsr2u4w_1.swift:30:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpsr2u4w_1.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - p)\n                           ^\n                            n: p: \n/tmp/tmpsr2u4w_1.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((n - p) *\
    \ (n - p), p) + p\n                   ^\n                    n:              \
    \   p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\treturn modp(n - p, p)\n\t}\n\t\
    if p < p {\n\t\treturn modp(n, p - p)\n\t}\n\treturn modp(n - p, p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5xeccx01.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmp5xeccx01.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 1\")\n                ^~~~~\n/tmp/tmp5xeccx01.swift:30:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmp5xeccx01.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - p)\n                           ^\n                            n: p: \n/tmp/tmp5xeccx01.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if p < p {\n        return modp(n\
    \ - p, p)\n    }\n    if p > p {\n        return modp(n, p - p)\n    }\n    return\
    \ modp(n + p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdmmns0oj.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpdmmns0oj.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmpdmmns0oj.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpdmmns0oj.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - p)\n            \
    \       ^\n                    n: p: \n/tmp/tmpdmmns0oj.swift:35:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp(n + p, p)\n               ^\n\
    \                n:     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n += p\n    }\n  \
    \  if n < p {\n        return n\n    }\n    if n == p {\n        return 1\n  \
    \  }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp5q28ashn.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n/tmp/tmp5q28ashn.swift:23:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp(n - p, p)\n \
    \              ^\n                n:     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3ghfgaed.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp3ghfgaed.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp3ghfgaed.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp3ghfgaed.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmp3ghfgaed.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmp3ghfgaed.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 || p == 0 {\n        return 0\n    }\n    if n == 1 {\n        return p\n\
    \    }\n    if p == 1 {\n        return n\n    }\n    if n == p {\n        return\
    \ modp(n - 1, p)\n    }\n    if n == p + 1 {\n        return modp(n, p - 1)\n\
    \    }\n    if n == p - 1 {\n        return modp(n, p)\n    }\n    if n == p -\
    \ 2 {\n        return modp(n, p - 1)\n    }\n    if n == p - 3 {\n        return\
    \ modp(n, p - 2)\n    }\n    if n == p - 4 {\n        return modp(n, p - 3)\n\
    \    }\n    if n == p - 5 {\n        return modp(n, p - 4)\n    }\n    if n ==\
    \ p - 6 {\n        return modp(n, p - 5)\n    }\n    if n == p - 7 {\n       \
    \ return modp(n, p - 6)\n    }\n    if n == p - 8 {\n        return modp(n, p\
    \ - 7)\n    }\n    if n == p - 9 {\n        return modp(n, p - 8)\n    }\n   \
    \ if n == p - 10 {\n        return modp(n, p - 9)\n    }\n    if n == p - 11 {\n\
    \        return modp(n, p - 10)\n    }\n    if n == p - 12 {\n        return modp(n,\
    \ p - 11)\n    }\n    if n == p - 13 {\n        return modp(n, p - 12)\n    }\n\
    \    if n == p - 14 {\n        return modp(n, p - 13)\n    }\n    if n == p -\
    \ 15 {\n        return modp(n, p - 14)\n    }\n    if n == p - 16 {\n        return\
    \ modp(n, p - 15)\n    }\n    if n == p - 17 {\n        return modp(n, p - 16)\n\
    \    }\n    if n == p - 18 {\n        return modp(n, p - 17)\n    }\n    if n\
    \ == p - 19 {\n        return modp(n, p - 18)\n    }\n    if n == p - 20 {\n \
    \       return modp(n, p - 19)\n    }\n    if n == p - 21 {\n        return modp(n,\
    \ p - 20)\n    }\n    if n == p - 22 {\n        return modp(n, p - 21)\n    }\n\
    \    if n == p - 23 {\n        return modp(n, p - 22)\n    }\n    if n == p -\
    \ 24 {\n        return modp(n, p - 23)\n    }\n    if n == p - 25 {\n        return\
    \ modp(n, p - 24)\n    }\n    if n == p - 26 {\n        return modp(n, p - 25)\n\
    \    }\n    if n == p - 27 {\n        return modp(n, p - 26)\n    }\n    if n\
    \ == p - 28 {\n        return modp(n, p - 27)\n    }\n    if n == p - 29 {\n \
    \       return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpf2vp3549.swift:142:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpf2vp3549.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpf2vp3549.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpf2vp3549.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpf2vp3549.swift:33:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 1)\n    \
    \               ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:36:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:39:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 1)\n    \
    \               ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:42:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 2)\n    \
    \               ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:45:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 3)\n    \
    \               ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:48:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 4)\n    \
    \               ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:51:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 5)\n    \
    \               ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:54:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - 6)\n    \
    \               ^\n                    n: p: \n/tmp/tmpf2vp3549.swift:57:20: error:\
    \ missing argument labels 'n:p:' in call"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p % p)\n    }\n    if p >\
    \ p {\n        return modp(n, p - 1)\n    }\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwh847upv.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpwh847upv.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n/tmp/tmpwh847upv.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptlzzr4fo.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmptlzzr4fo.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmptlzzr4fo.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmptlzzr4fo.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(n - 1, p)\n    }\n    if p < p {\n        return modp(n - 2, p)\n\
    \    }\n    if p < p {\n        return modp(n - 3, p)\n    }\n    if p < p {\n\
    \        return modp(n - 4, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 5, p)\n    }\n    if p < p {\n        return modp(n - 6, p)\n    }\n    if p\
    \ < p {\n        return modp(n - 7, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 8, p)\n    }\n    if p < p {\n        return modp(n - 9, p)\n    }\n\
    \    if p < p {\n        return modp(n - 10, p)\n    }\n    if p < p {\n     \
    \   return modp(n - 11, p)\n    }\n    if p < p {\n        return modp(n - 12,\
    \ p)\n    }\n    if p < p {\n        return modp(n - 13, p)\n    }\n    if p <\
    \ p {\n        return modp(n - 14, p)\n    }\n    if p < p {\n        return modp(n\
    \ - 15, p)\n    }\n    if p < p {\n        return modp(n - 16, p)\n    }\n   \
    \ if p < p {\n        return modp(n - 17, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 18, p)\n    }\n    if p < p {\n        return modp(n - 19, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 20, p)\n    }\n    if p < p {\n \
    \       return modp(n - 21, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 22, p)\n    }\n    if p < p {\n        return modp(n - 23, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 24, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 25, p)\n    }\n    if p < p {\n        return modp(n - 26, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 27, p)\n    }\n    if p < p {\n \
    \       return modp(n - 28, p)\n    }\n    if p < p {\n        return modp(n -\
    \ 29, p)\n    }\n    if p < p {\n        return modp(n - 30, p)\n    }\n    if\
    \ p < p {\n        return modp(n - 31, p)\n    }\n    if p < p {\n        return\
    \ modp(n - 32, p)\n    }\n    if p < p {\n        return modp(n - 33, p)\n   \
    \ }\n    if p < p {\n        return modp(n - 34, p)\n    }\n    if p < p {\n \
    \       return modp(n - 35, p)\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxb62c1dr.swift:146:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxb62c1dr.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpxb62c1dr.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpxb62c1dr.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:24:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - 2, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 3, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 4, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 5, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 9, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpxb62c1dr.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 10, p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmpxb62c1dr.swift:51:20:\
    \ erro"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n < p {\n\t\t\
    return modp(n - p, p)\n\t}\n\treturn modp((p - n) % p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8isfptio.swift:24:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n - p, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmp8isfptio.swift:26:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((p - n) % p, p)\n\
    \                   ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp20b_mec.swift:203:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpp20b_mec.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpp20b_mec.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpp20b_mec.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpp20b_mec.swift:185:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014468
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpafc833o5/tmpafc833o5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab13eb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab13e848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab13e848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab13e8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafc833o5                        0x000055d8a7eed23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab13ed3d460 __libc_start_main +
    245

    6    tmpafc833o5                        0x000055d8a7eece69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\tp = p\n\t}\n\tif n == 0 {\n\
    \t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpltt7zl5u.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpltt7zl5u.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpltt7zl5u.swift:22:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = p\n                ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n, p)\n    }\n    if p < p {\n   \
    \     return modp(n - p, p)\n    }\n    if p < p {\n        return modp(n - p,\
    \ p)\n    }\n    return modp(n, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_xl923fm.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n, p)\n                   ^\n                    n:\
    \ p: \n/tmp/tmp_xl923fm.swift:27:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp_xl923fm.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmp_xl923fm.swift:32:16: error: missing argument\
    \ labels 'n:p:' in call\n    return modp(n, p)\n               ^\n           \
    \     n: p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        n += p\n    }\n  \
    \  if n < p {\n        return n\n    }\n    return n - p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp16ldv2_c.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p < p {\n\t\treturn modp(n - p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n,\
    \ p - p)\n\t}\n\treturn modp(n + p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp23f_92o.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpp23f_92o.swift:18:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpp23f_92o.swift:33:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - p, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpp23f_92o.swift:36:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - p)\n                           ^\n                            n: p: \n/tmp/tmpp23f_92o.swift:38:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n + p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n\
    \    }\n    return modp(n / p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcvgr2wwk.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpcvgr2wwk.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpcvgr2wwk.swift:24:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpcvgr2wwk.swift:26:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp(n / p, p)\n               ^\n\
    \                n:     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif p < p {\n\t\treturn modp(n - 1, p)\n\t}\n\t\
    if p > p {\n\t\treturn modp(n, p - 1)\n\t}\n\treturn modp(n - 1, p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8ktnijdq.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmp8ktnijdq.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ p < 1\")\n                ^~~~~\n/tmp/tmp8ktnijdq.swift:30:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmp8ktnijdq.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - 1)\n                           ^\n                            n: p: \n/tmp/tmp8ktnijdq.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if p > p {\n\
    \        return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 1\n   \
    \ }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa51zq45e.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpa51zq45e.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpa51zq45e.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpa51zq45e.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpa51zq45e.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpa51zq45e.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n > p {\n\
    \        return modp(n, p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppwytpltp.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmppwytpltp.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0\
    \ {\n\t\tp = -p\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpd2nfo7y_.swift:205:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpd2nfo7y_.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpd2nfo7y_.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmpd2nfo7y_.swift:18:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmpd2nfo7y_.swift:187:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n, p)\n    }\n    return modp(n - p, p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0m5zqch2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmp0m5zqch2.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmp0m5zqch2.swift:29:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n - p, p)\n               ^\n              \
    \  n:     p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tp = p + 1\n\t}\n\tlet mut result = 1\n\tlet mut carry = 0\n\t\
    for i := 0; i < n; i++ {\n\t\tlet digit = p % 10\n\t\tresult = result * 10 + digit\n\
    \t\tcarry = digit * 10 + carry\n\t\tp = p / 10\n\t}\n\tif carry != 0 {\n\t\tresult\
    \ = result + carry\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_h_5_9h1.swift:21:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut result\
    \ = 1\n                ^\n/tmp/tmp_h_5_9h1.swift:21:10: note: join the identifiers\
    \ together\n        let mut result = 1\n            ~~~~^~~~~~\n            mutresult\n\
    /tmp/tmp_h_5_9h1.swift:21:10: note: join the identifiers together with camel-case\n\
    \        let mut result = 1\n            ~~~~^~~~~~\n            mutResult\n/tmp/tmp_h_5_9h1.swift:22:10:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut carry = 0\n                ^\n/tmp/tmp_h_5_9h1.swift:22:10:\
    \ note: join the identifiers together\n        let mut carry = 0\n           \
    \ ~~~~^~~~~\n            mutcarry\n/tmp/tmp_h_5_9h1.swift:22:10: note: join the\
    \ identifiers together with camel-case\n        let mut carry = 0\n          \
    \  ~~~~^~~~~\n            mutCarry\n/tmp/tmp_h_5_9h1.swift:23:9: error: expected\
    \ type\n        for i := 0; i < n; i++ {\n               ^\n                <#type#>\n\
    /tmp/tmp_h_5_9h1.swift:23:9: error: expected 'in' after for-each pattern\n   \
    \     for i := 0; i < n; i++ {\n               ^\n/tmp/tmp_h_5_9h1.swift:23:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < n; i++ {\n               ^\n/tmp/tmp_h_5_9h1.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmp_h_5_9h1.swift:16:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmp_h_5_9h1.swift:19:3: error:\
    \ cannot assign to value: 'p' is a 'let' constant\n                p = p + 1\n\
    \                ^\n/tmp/tmp_h_5_9h1.swift:22:6: error: invalid redeclaration\
    \ of 'mut'\n        let mut carry = 0\n            ^\n/tmp/tmp_h_5_9h1.swift:21:6:\
    \ note: 'mut' previously declared here\n        let mut result = 1\n         \
    \   ^\n/tmp/tmp_h_5_9h1.swift:29:5: error: cannot find 'carry' in scope\n    \
    \    if carry != 0 {\n           ^~~~~\n/tmp/tmp_h_5_9h1.swift:30:3: error: cannot"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    return modp((p\
    \ - n) % p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeettots2.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpeettots2.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((p - n) % p, p)\n               ^\n        \
    \        n:           p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyvwzfoo0.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyvwzfoo0.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\t\
    case p == 1:\n\t\treturn n\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\tdefault:\n\
    \t\treturn modp((p - 1) * (n - p) + p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp09rpmg_o.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp09rpmg_o.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmp09rpmg_o.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmp09rpmg_o.swift:24:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp09rpmg_o.swift:26:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp((p - 1) * (n - p) + p, p)\n                     \
    \      ^\n                            n:                     p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p % p)\n    }\n    if p >\
    \ p {\n        return modp(n, p % p)\n    }\n    return n - (n % p)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnqdo6tlh.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpnqdo6tlh.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n/tmp/tmpnqdo6tlh.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"p > p\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t\
    }\n\tn /= p\n\treturn n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpg9cbeg9t.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmpg9cbeg9t.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpg9cbeg9t.swift:19:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p < 1\")\n                ^~~~~\n/tmp/tmpg9cbeg9t.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"p > p\")\n    \
    \            ^~~~~\n/tmp/tmpg9cbeg9t.swift:27:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n\
    /tmp/tmpg9cbeg9t.swift:31:4: error: left side of mutating operator isn't mutable:\
    \ 'n' is a 'let' constant\n        n /= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t\
    }\n\tswitch {\n\tcase p < 0:\n\t\treturn modp(n - 1, p)\n\tcase p > n:\n\t\treturn\
    \ modp(n, p)\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(n - 1, p) + p\n\t\
    case n > p:\n\t\treturn modp(n, p)\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= p:\n\t\treturn p\n\t}\n\tswitch {\n\tcase n >= \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmwdeodf0.swift:17:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:23:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:29:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:35:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:41:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:47:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:53:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:59:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:65:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:71:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:77:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:83:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:89:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:95:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:101:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:107:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:113:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmpmwdeodf0.swift:119:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmpmwdeodf0.swift:125:9"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    return modp(n,\
    \ p - n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpossf2r3j.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpossf2r3j.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - n)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014468
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n > p {\n        return modp(n - p, p)\n    }\n    if n < p {\n\
    \        return modp(n, p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpalg8x9hk.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpalg8x9hk.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(-n, p)\n\
    \    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n  \
    \      return 1\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if p % n == 0 {\n        return modp(n / p,\
    \ p)\n    }\n    return modp((n - 1) * (p / n), p)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppt47cjrx.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmppt47cjrx.swift:18:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p)\n                   ^\n                 \
    \   n: p: \n/tmp/tmppt47cjrx.swift:30:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n / p, p)\n                   ^\n             \
    \       n:     p: \n/tmp/tmppt47cjrx.swift:32:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp((n - 1) * (p / n), p)\n               ^\n  \
    \              n:                 p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp requires p <= p\")\n\t}\n\t\
    if p > p {\n\t\tpanic(\"modp requires p <= p\")\n\t}\n\tswitch {\n\tcase p < 0:\n\
    \t\tpanic(\"modp requires positive p\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\
    \t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\
    \t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\
    \t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\
    \t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\
    \t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\
    \t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\
    \t\tpanic(\"modp requires p <= n\")\n\tcase p < n:\n\t\tpanic(\"modp requires\
    \ p \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa2hlq_3x.swift:35:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpa2hlq_3x.swift:81:9: error: unterminated\
    \ string literal\n                panic(\"modp requires p \n                 \
    \     ^\n/tmp/tmpa2hlq_3x.swift:103:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpa2hlq_3x.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpa2hlq_3x.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive n\")\n    \
    \            ^~~~~\n/tmp/tmpa2hlq_3x.swift:18:3: error: cannot find 'panic' in\
    \ scope\n                panic(\"modp requires positive p\")\n               \
    \ ^~~~~\n/tmp/tmpa2hlq_3x.swift:30:3: error: cannot find 'panic' in scope\n  \
    \              panic(\"modp requires p <= p\")\n                ^~~~~\n/tmp/tmpa2hlq_3x.swift:33:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ <= p\")\n                ^~~~~\n/tmp/tmpa2hlq_3x.swift:37:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive p\")\n    \
    \            ^~~~~\n/tmp/tmpa2hlq_3x.swift:39:3: error: cannot find 'panic' in\
    \ scope\n                panic(\"modp requires p <= n\")\n                ^~~~~\n\
    /tmp/tmpa2hlq_3x.swift:41:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires p <= n\")\n                ^~~~~\n/tmp/tmpa2hlq_3x.swift:43:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ <= n\")\n                ^~~~~\n/tmp/tmpa2hlq_3x.swift:45:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires p <= n\")\n        \
    \        ^~~~~\n/tmp/tmpa2hlq_3x.swift:47:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp requires p <= n\")\n                ^~~~~\n/tmp/tmpa2hlq_3x.swift:49:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ <= n\")\n                ^~~~~\n/tmp/tmpa2hlq_3x.swift:51:3: error: cannot find\
    \ 'panic' in sc"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\t\
    case n <= p:\n\t\treturn n\n\tcase n >= p:\n\t\treturn p\n\t}\n\tlet r = n % p\n\
    \treturn r < p ? r + p : r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq27qgg3q.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\t\
    case n >= p:\n\t\treturn n\n\tcase n == p:\n\t\treturn 1\n\tdefault:\n\t\treturn\
    \ pow(2, n) % p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphagbf8te.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmphagbf8te.swift:22:10: error: cannot\
    \ find 'pow' in scope\n                return pow(2, n) % p\n                \
    \       ^~~\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tr := 1\n\tfor i := n - 1; i >=\
    \ 0; i-- {\n\t\tr *= p\n\t\tr += n\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4m6i1bhf.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmp4m6i1bhf.swift:32:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmp4m6i1bhf.swift:33:9:\
    \ error: expected type\n        for i := n - 1; i >= 0; i-- {\n              \
    \ ^\n                <#type#>\n/tmp/tmp4m6i1bhf.swift:33:9: error: expected 'in'\
    \ after for-each pattern\n        for i := n - 1; i >= 0; i-- {\n            \
    \   ^\n/tmp/tmp4m6i1bhf.swift:33:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := n - 1; i >= 0; i-- {\n               ^\n/tmp/tmp4m6i1bhf.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp4m6i1bhf.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmp4m6i1bhf.swift:30:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp4m6i1bhf.swift:32:2:\
    \ error: cannot find 'r' in scope\n        r := 1\n        ^\n/tmp/tmp4m6i1bhf.swift:37:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp called with\
    \ negative n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp called with p < 1\")\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n\
    \ == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpo9p3uru5.swift:200:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpo9p3uru5.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpo9p3uru5.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp called with negative n\")\n \
    \               ^~~~~\n/tmp/tmpo9p3uru5.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with p < 1\")\n              \
    \  ^~~~~\n/tmp/tmpo9p3uru5.swift:182:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n, p)\n    }\n    if n == 0 {\n\
    \        return 0\n    }\n    if p == 1 {\n        return n\n    }\n    if p ==\
    \ 2 {\n        return n + 1\n    }\n    if p == 3 {\n        return n * 2\n  \
    \  }\n    if p == 4 {\n        return n * 3\n    }\n    if p == 5 {\n        return\
    \ n * 4\n    }\n    if p == 6 {\n        return n * 5\n    }\n    if p == 7 {\n\
    \        return n * 6\n    }\n    if p == 8 {\n        return n * 7\n    }\n \
    \   if p == 9 {\n        return n * 8\n    }\n    if p == 10 {\n        return\
    \ n * 9\n    }\n    if p == 11 {\n        return n * 10\n    }\n    if p == 12\
    \ {\n        return n * 11\n    }\n    if p == 13 {\n        return n * 12\n \
    \   }\n    if p == 14 {\n        return n * 13\n    }\n    if p == 15 {\n    \
    \    return n * 14\n    }\n    if p == 16 {\n        return n * 15\n    }\n  \
    \  if p == 17 {\n        return n * 16\n    }\n    if p == 18 {\n        return\
    \ n * 17\n    }\n    if p == 19 {\n        return n * 18\n    }\n    if p == 20\
    \ {\n        return n * 19\n    }\n    if p == 21 {\n        return n * 20\n \
    \   }\n    if p == 22 {\n        return n * 21\n    }\n    if p == 23 {\n    \
    \    return n * 22\n    }\n    if p == 24 {\n        return n * 23\n    }\n  \
    \  if p == 25 {\n        return n * 24\n    }\n    if p == 26 {\n        return\
    \ n * 25\n    }\n    if p == 27 {\n        return n * 26\n    }\n    if p == 28\
    \ {\n        return n * 27\n    }\n    if p == 29 {\n        return n * 28\n \
    \   }\n    if p == 30 {\n        return n * 29\n    }\n    if p == 31 {\n    \
    \    return n * 30\n    }\n    if p == 32 {\n        return n * 31\n    }\n  \
    \  if p == 33 {\n        return n * 32\n    }\n    if p == 34 {\n        return\
    \ n * 33\n    }\n    if p == 35 {\n        return n * 34\n    }\n    if p == 36\
    \ {\n        return n * 35\n    }\n    if p == 37 {\n        return n * 36\n \
    \   }\n    if p == 38 {\n        return n * 37\n    }\n    if p == 39 {\n    \
    \    return n * 38\n    }\n    if p == 40 {\n        return n * 39\n    }\n  \
    \  if p == 41 {\n        return n * 40\n    }\n    if p == 42 {\n        return\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxpusgq90.swift:169:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpxpusgq90.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpxpusgq90.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpxpusgq90.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpxpusgq90.swift:147:9: error: non-void\
    \ function should return a value\n        return \n        ^\n/tmp/tmpxpusgq90.swift:151:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n),\
    \ p)\n\tcase p < 0:\n\t\treturn modp(n, -p)\n\tcase n >= p:\n\t\treturn n\n\t\
    default:\n\t\treturn n % p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphb2gkzlm.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmphb2gkzlm.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmphb2gkzlm.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ -p)\n                           ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n > p {\n\
    \        return modp(n, p)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppwytpltp.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmppwytpltp.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\
    \tif p < 1 {\n\t\tpanic(\"p must be positive\")\n\t}\n\tif p > p {\n\t\tpanic(\"\
    p must be smaller than p\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n ==\
    \ 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9c1dmyyh.swift:200:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp9c1dmyyh.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp9c1dmyyh.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmp9c1dmyyh.swift:16:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmp9c1dmyyh.swift:19:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"p must be positive\")\n\
    \                ^~~~~\n/tmp/tmp9c1dmyyh.swift:22:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p must be smaller than p\")\n            \
    \    ^~~~~\n/tmp/tmp9c1dmyyh.swift:182:6: error: operator functions can only be\
    \ declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014803
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 1\
    \ {\n\t\tp = -p\n\t}\n\tif p > p {\n\t\tpanic(\"p must be less than or equal to\
    \ 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn 0\n\t\
    }\n\tif n == p {\n\t\treturn n\n\t}\n\tif n <= p {\n\t\treturn n - p\n\t}\n\t\
    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3u5z8ji0.swift:15:3: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n                n = -n\n                ^\n/tmp/tmp3u5z8ji0.swift:18:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmp3u5z8ji0.swift:21:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"p must be less than or equal to 1\")\n   \
    \             ^~~~~\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < 2 {\n        return modp(n, p)\n    }\n    if p < p {\n   \
    \     return modp(n, p - 1)\n    }\n    if p < p {\n        return modp((n - p)\
    \ / 2, p)\n    }\n    if p < p {\n        return modp((n - p) / 2, p - 1)\n  \
    \  }\n    return modp((n - p) / 2, p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdnmk6ik9.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n, p)\n                   ^\n                    n:\
    \ p: \n/tmp/tmpdnmk6ik9.swift:27:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n, p - 1)\n                   ^\n                \
    \    n: p: \n/tmp/tmpdnmk6ik9.swift:30:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp((n - p) / 2, p)\n                   ^\n       \
    \             n:           p: \n/tmp/tmpdnmk6ik9.swift:33:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp((n - p) / 2, p - 1)\n           \
    \        ^\n                    n:           p: \n/tmp/tmpdnmk6ik9.swift:35:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp((n - p) / 2,\
    \ p - 1)\n               ^\n                n:           p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n,\
    \ p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2fjdafm8.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp2fjdafm8.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014469
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ argument\")\n\t}\n\tif p < 2 {\n\t\tpanic(\"modp requires positive argument\"\
    )\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase p < 2:\n\t\treturn n\n\
    \tcase p < n:\n\t\treturn p - 1\n\tdefault:\n\t\treturn p - 1\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpn_k113jg.swift:20:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpn_k113jg.swift:15:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp requires positive argument\"\
    )\n                ^~~~~\n/tmp/tmpn_k113jg.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp requires positive argument\")\n     \
    \           ^~~~~\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 0 {\n        return modp(n, abs(p))\n    }\n    if n ==\
    \ 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if n == 1 {\n        return p\n    }\n    if p == 1 {\n        return n\n  \
    \  }\n    if n == p {\n        return modp(n - 1, p)\n    }\n    if n == p+1 {\n\
    \        return modp(n, p)\n    }\n    if n == p+2 {\n        return modp(n-1,\
    \ p)\n    }\n    if n == p+3 {\n        return modp(n, p)\n    }\n    if n ==\
    \ p+4 {\n        return modp(n-1, p)\n    }\n    if n == p+5 {\n        return\
    \ modp(n, p)\n    }\n    if n == p+6 {\n        return modp(n-1, p)\n    }\n \
    \   if n == p+7 {\n        return modp(n, p)\n    }\n    if n == p+8 {\n     \
    \   return modp(n-1, p)\n    }\n    if n == p+9 {\n        return modp(n, p)\n\
    \    }\n    if n == p+10 {\n        return modp(n-1, p)\n    }\n    if n == p+11\
    \ {\n        return modp(n, p)\n    }\n    if n == p+12 {\n        return modp(n-1,\
    \ p)\n    }\n    if n == p+13 {\n        return modp(n, p)\n    }\n    if n ==\
    \ p+14 {\n        return modp(n-1, p)\n    }\n    if n == p+15 {\n        return\
    \ modp(n, p)\n    }\n    if n == p+16 {\n        return modp(n-1, p)\n    }\n\
    \    if n == p+17 {\n        return modp(n, p)\n    }\n    if n == p+18 {\n  \
    \      return modp(n-1, p)\n    }\n    if n == p+19 {\n        return modp(n,\
    \ p)\n    }\n    if n == p+20 {\n        return modp(n-1, p)\n    }\n    if n\
    \ == p+21 {\n        return modp(n, p)\n    }\n    if n == p+22 {\n        return\
    \ modp(n-1, p)\n    }\n    if n == p+23 {\n        return modp(n, p)\n    }\n\
    \    if n == p+24 {\n        return modp(n-1, p)\n    }\n    if n == p+25 {\n\
    \        return modp(n, p)\n    }\n    if n == p+26 {\n        return modp(n-1,\
    \ p)\n    }\n    if n == p+27 {\n        return modp(n, p)\n    }\n    if n ==\
    \ p+28 {\n        return modp(n-1, p)\n    }\n    if n == p+\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbbq0292c.swift:119:15: error: expected '{' after 'if' condition\n\
    \    if n == p+\n              ^\n/tmp/tmpbbq0292c.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpbbq0292c.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n   \
    \                ^\n                    n: p: \n/tmp/tmpbbq0292c.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpbbq0292c.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpbbq0292c.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n-1, p)\n\
    \                   ^\n                    n:   p: \n/tmp/tmpbbq0292c.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpbbq0292c.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n-1, p)\n\
    \                   ^\n                    n:   p: \n/tmp/tmpbbq0292c.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpbbq0292c.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n-1, p)\n\
    \                   ^\n                    n:   p: \n/tmp/tmpbbq0292c.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpbbq0292c.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n-1, p)\n\
    \                   ^\n                    n:   p: \n/tmp/tmpbbq0292c.swift:60:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpbbq0292c.swift:63:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n-1, p)\n\
    \  "
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 2 {\n        return n\n    }\n    if p < p {\n       \
    \ return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n\
    \    }\n    if p < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n\
    \        return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n /\
    \ p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n    }\n    if p\
    \ < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n        return\
    \ modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n    }\n\
    \    if p < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n      \
    \  return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n\
    \    }\n    if p < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n\
    \        return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n /\
    \ p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n    }\n    if p\
    \ < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n        return\
    \ modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n    }\n\
    \    if p < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n      \
    \  return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n\
    \    }\n    if p < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n\
    \        return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n /\
    \ p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n    }\n    if p\
    \ < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n        return\
    \ modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n    }\n\
    \    if p < p {\n        return modp(n / p, p)\n    }\n    if p < p {\n      \
    \  return modp(n / p, p)\n    }\n    if p < p {\n        return modp(n / p, p)\n\
    \    }\n    if p < p {\n        return modp(\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpugva6o4w.swift:118:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpugva6o4w.swift:139:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpugva6o4w.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpugva6o4w.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpugva6o4w.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n / p, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:24:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n    \
    \               ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpugva6o4w.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n / p, p)\n\
    \    "
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive\
    \ n\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive p\")\n\t}\n\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tm := p\n\tfor m > n {\n\t\tm >>= 1\n\t}\n\treturn m\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8q2ckave.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        m := p\n         ^\n         ;\n/tmp/tmp8q2ckave.swift:29:4:\
    \ error: expected expression\n        m := p\n          ^\n/tmp/tmp8q2ckave.swift:30:8:\
    \ error: expected 'in' after for-each pattern\n        for m > n {\n         \
    \     ^\n/tmp/tmp8q2ckave.swift:30:8: error: unary operator cannot be separated\
    \ from its operand\n        for m > n {\n              ^~\n               \n/tmp/tmp8q2ckave.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ n\")\n                ^~~~~\n/tmp/tmp8q2ckave.swift:18:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive p\")\n    \
    \            ^~~~~\n/tmp/tmp8q2ckave.swift:29:2: error: cannot find 'm' in scope\n\
    \        m := p\n        ^\n/tmp/tmp8q2ckave.swift:30:8: error: '>' is not a prefix\
    \ unary operator\n        for m > n {\n              ^\n/tmp/tmp8q2ckave.swift:33:9:\
    \ error: cannot find 'm' in scope\n        return m\n               ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n\
    \    }\n    if p < n {\n        return modp(n - p, p)\n    }\n    if p > n {\n\
    \        return modp(n - p, p)\n    }\n    return modp(n + p - n, p)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsynup2zg.swift:24:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n/tmp/tmpsynup2zg.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpsynup2zg.swift:29:16: error: missing argument\
    \ labels 'n:p:' in call\n    return modp(n + p - n, p)\n               ^\n   \
    \             n:         p: \n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\"\
    )\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tq := p\n\tfor {\n\t\tq /= 2\n\
    \t\tif q == 1 {\n\t\t\treturn n\n\t\t}\n\t\tif q == p {\n\t\t\treturn q\n\t\t\
    }\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp6wk0g4u.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpp6wk0g4u.swift:32:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpp6wk0g4u.swift:33:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpp6wk0g4u.swift:33:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpp6wk0g4u.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpp6wk0g4u.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmpp6wk0g4u.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpp6wk0g4u.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p\n        ^\n"
  stdout: ''
  timestamp: 1660014804
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(abs(n),\
    \ p)\n    }\n    if p < 1 {\n        return modp(n / p, p)\n    }\n    if p >\
    \ p {\n        return modp((n - 1) / p, p)\n    }\n    if n == 0 {\n        return\
    \ 1\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbnrvfu82.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpbnrvfu82.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n / p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpbnrvfu82.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp((n - 1) / p, p)\n               \
    \    ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014804
