language: swift
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity {\n        result +=\
    \ max_fill_helper(grid, 0)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsln8bmn8.swift:26:19: error: cannot find 'max_fill_helper' in scope\n\
    \        result += max_fill_helper(grid, 0)\n                  ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var cur = 0\n    for row in grid {\n        for col in row {\n          \
    \  if col == 0 {\n                cur += 1\n            } else {\n           \
    \     if cur > max {\n                    max = cur\n                }\n     \
    \           cur = 0\n            }\n        }\n    }\n    if cur > max {\n   \
    \     max = cur\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpa77cu6o9.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var result = 0\n    \n    for row in grid {\n        var\
    \ max = 0\n        for col in row {\n            if col > max {\n            \
    \    max = col\n            }\n        }\n        \n        if max > capacity\
    \ {\n            result += capacity - max\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxrvnj10b/tmpxrvnj10b.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5235e7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5235b73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5235b73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5235b727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxrvnj10b                        0x000055e011e31546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5236068460 __libc_start_main +
    245

    6    tmpxrvnj10b                        0x000055e011e310d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var maxCount = 0\n    for row in grid {\n   \
    \     var count = 0\n        for val in row {\n            if val == 1 {\n   \
    \             count += 1\n            }\n        }\n        if count > max {\n\
    \            max = count\n            maxCount = 1\n        } else {\n       \
    \     if count == max {\n                maxCount += 1\n            }\n      \
    \  }\n    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf0dqly7r/tmpf0dqly7r.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e9f249c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e9ef40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e9ef40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e9ef3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf0dqly7r                        0x000055df4090b546 <unavailable> + 5446

    5    libc.so.6                          0x00002b8e9f435460 __libc_start_main +
    245

    6    tmpf0dqly7r                        0x000055df4090b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        var minBucket = capacity\n        for bucket in row {\n    \
    \        if bucket > minBucket {\n                minBucket = bucket\n       \
    \     }\n        }\n        result += minBucket - minCapacity\n        minCapacity\
    \ = minBucket\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplmixc427/tmplmixc427.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b703f3c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b703f0b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b703f0b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b703f0b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplmixc427                        0x00005615b1e0f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b703f5ae460 __libc_start_main +
    245

    6    tmplmixc427                        0x00005615b1e0f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                count +=\
    \ 1\n                if count > max {\n                    max = count\n     \
    \           }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmptcw0ytmi/tmptcw0ytmi.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef0f77ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef0f471b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef0f471988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef0f4707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptcw0ytmi                        0x0000555b3bbbf717 <unavailable> + 5911

    5    libc.so.6                          0x00002aef0f966460 __libc_start_main +
    245

    6    tmptcw0ytmi                        0x0000555b3bbbf0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col > 0 {\n                max += col\n                if\
    \ max > capacity {\n                    max = capacity\n                    maxIndex\
    \ = col.index\n                }\n            }\n        }\n    }\n    \n    return\
    \ maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq5sl2xmw.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpq5sl2xmw.swift:37:36: error: value of type 'Int' has no member\
    \ 'index'\n                    maxIndex = col.index\n                        \
    \       ~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var index = 0\n    var buckets = make([][]int, capacity)\n    for row\
    \ in grid {\n        for col in row {\n            if col == 1 {\n           \
    \     buckets[index%capacity] = append(buckets[index%capacity], 0)\n         \
    \   }\n            buckets[index%capacity][index%capacity] = col\n           \
    \ index++\n        }\n    }\n    for bucket in buckets {\n        max = max(max,\
    \ bucket.count)\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1p43m6ln.swift:30:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp1p43m6ln.swift:30:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp1p43m6ln.swift:30:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp1p43m6ln.swift:30:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp1p43m6ln.swift:34:43:\
    \ error: cannot find 'append' in scope\n                buckets[index%capacity]\
    \ = append(buckets[index%capacity], 0)\n                                     \
    \     ^~~~~~\n/tmp/tmp1p43m6ln.swift:37:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            index++\n                 ^~\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    var maxRow = 0\n    var maxCol = 0\n    \n  \
    \  for row in grid {\n        for col in row {\n            if col == 0 {\n  \
    \              maxCount = 0\n                maxRow = row\n                maxCol\
    \ = col\n            } else {\n                maxCount = maxCount + 1\n     \
    \           if maxCount > max {\n                    max = maxCount\n        \
    \            maxRow = row\n                    maxCol = col\n                }\n\
    \            }\n        }\n    }\n    \n    for row in grid {\n        for col\
    \ in row {\n            if col == 0 {\n                grid[row][col] = maxRow\n\
    \                grid[maxRow][col] = maxCol\n            }\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2cc5imu3.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp2cc5imu3.swift:37:26: error: cannot assign value of type '[Int]'\
    \ to type 'Int'\n                maxRow = row\n                         ^~~\n\
    /tmp/tmp2cc5imu3.swift:43:30: error: cannot assign value of type '[Int]' to type\
    \ 'Int'\n                    maxRow = row\n                             ^~~\n\
    /tmp/tmp2cc5imu3.swift:53:22: error: cannot convert value of type '[Int]' to expected\
    \ argument type 'Int'\n                grid[row][col] = maxRow\n             \
    \        ^\n/tmp/tmp2cc5imu3.swift:54:29: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[maxRow][col] = maxCol\n   \
    \             ~~~~        ^\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var maxCount = 0\n    for row in grid {\n        if row[0] == 0 {\n     \
    \       continue\n        }\n        var count = 0\n        for j in 0..<row[0]\
    \ {\n            if row[j] == 1 {\n                count += 1\n            }\n\
    \        }\n        if count > max {\n            max = count\n            maxCount\
    \ = 1\n        } else {\n            maxCount *= count\n        }\n    }\n   \
    \ return maxCount * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqt39da8k.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    \n    var max = 0\n\
    \    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                max += capacity\n \
    \           }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_xj24j3s/tmp_xj24j3s.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2720769c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2720460b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2720460988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b272045f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_xj24j3s                        0x00005636ce9f8827 <unavailable> + 6183

    5    libc.so.6                          0x00002b2720955460 __libc_start_main +
    245

    6    tmp_xj24j3s                        0x00005636ce9f81e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    \n    var max = 0\n\
    \    var maxCount = 0\n    \n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     grid[row][col] = 0\n                \n                if capacity > 0 {\n\
    \                    capacity -= 1\n                }\n                \n    \
    \            if capacity == 0 {\n                    max += 1\n              \
    \      maxCount += 1\n                }\n            }\n        }\n    }\n   \
    \ \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplzj5b6jx.swift:32:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n/tmp/tmplzj5b6jx.swift:35:30: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                    capacity -= 1\n\
    \                    ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max = 0\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0] ==\
    \ 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n   \
    \     if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyliirybn.swift:156:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpyliirybn.swift:175:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpyliirybn.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpyliirybn.swift:159:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity {\n        for _ in\
    \ 0..<grid.count {\n            if grid[_][0] == 0 {\n                grid[_][0]\
    \ = grid[_][1]\n                grid[_][1] = 0\n                grid[_][2] = 0\n\
    \                grid[_][3] = 0\n                grid[_][4] = 0\n            \
    \    grid[_][5] = 0\n                grid[_][6] = 0\n                grid[_][7]\
    \ = 0\n                grid[_][8] = 0\n                grid[_][9] = 0\n      \
    \          grid[_][10] = 0\n                grid[_][11] = 0\n                grid[_][12]\
    \ = 0\n                grid[_][13] = 0\n                grid[_][14] = 0\n    \
    \            grid[_][15] = 0\n                grid[_][16] = 0\n              \
    \  grid[_][17] = 0\n                grid[_][18] = 0\n                grid[_][19]\
    \ = 0\n                grid[_][20] = 0\n                grid[_][21] = 0\n    \
    \            grid[_][22] = 0\n                grid[_][23] = 0\n              \
    \  grid[_][24] = 0\n                grid[_][25] = 0\n                grid[_][26]\
    \ = 0\n                grid[_][27] = 0\n                grid[_][28] = 0\n    \
    \            grid[_][29] = 0\n                grid[_][30] = 0\n              \
    \  grid[_][31] = 0\n                grid[_][32] = 0\n                grid[_][33]\
    \ = 0\n                grid[_][34] = 0\n                grid[_][35] = 0\n    \
    \            grid[_][36] = 0\n                grid[_][37] = 0\n              \
    \  grid[_][38] = 0\n                grid[_][39] = 0\n                grid[_][40]\
    \ = 0\n                grid[_][41] = 0\n                grid[_][42] = 0\n    \
    \            grid[_][43] = 0\n                grid[_][44] = 0\n              \
    \  grid[_][45] = 0\n                grid[_][46] = 0\n                grid[_][47]\
    \ = 0\n                grid[_][48] = 0\n                grid[_][49] = 0\n    \
    \            grid[_][50] = 0\n                grid[_][51] = 0\n              \
    \  grid[_][52] = 0\n                grid[_][53] = 0\n                grid[_][54]\
    \ = 0\n                grid[_][55] = 0\n                grid[_][56] = 0\n    \
    \            grid[_][57] = 0\n                grid[_][58] = 0\n              \
    \  grid[_][59] = 0\n                grid[_][60] = 0\n                grid[_][61]\
    \ = 0\n                grid[_][62] = 0\n                grid[_][63] = 0\n    \
    \            grid[_][64] = 0\n                grid[_][65] = 0\n              \
    \  grid[_][66] = 0\n                grid[_][67\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3lh85dfd.swift:96:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp3lh85dfd.swift:95:24: note: to match this opening '['\n           \
    \     grid[_][67\n                       ^\n/tmp/tmp3lh85dfd.swift:115:71: error:\
    \ expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)\n                                        \
    \                              ^\n/tmp/tmp3lh85dfd.swift:26:33: note: to match\
    \ this opening '{'\n        for _ in 0..<grid.count {\n                      \
    \          ^\n/tmp/tmp3lh85dfd.swift:115:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmp3lh85dfd.swift:25:27: note: to match this opening '{'\n    for _\
    \ in 0..<capacity {\n                          ^\n/tmp/tmp3lh85dfd.swift:115:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmp3lh85dfd.swift:23:52: note: to\
    \ match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n\
    \                                                   ^\n/tmp/tmp3lh85dfd.swift:27:21:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            if grid[_][0] == 0 {\n                    ^\n/tmp/tmp3lh85dfd.swift:28:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][0] = grid[_][1]\n                     ^\n/tmp/tmp3lh85dfd.swift:29:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][1] = 0\n                     ^\n/tmp/tmp3lh85dfd.swift:30:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][2] = 0\n                     ^\n/tmp/tmp3lh85dfd.swift:31:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][3"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > max {\n                max = bucket\n           \
    \ }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmphlhwupkg/tmphlhwupkg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b720dd86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b720da7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b720da7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b720da7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphlhwupkg                        0x0000562c71a80546 <unavailable> + 5446

    5    libc.so.6                          0x00002b720df72460 __libc_start_main +
    245

    6    tmphlhwupkg                        0x0000562c71a800d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
