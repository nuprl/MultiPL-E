language: swift
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity {\n        result +=\
    \ max_fill_helper(grid, 0)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsln8bmn8.swift:26:19: error: cannot find 'max_fill_helper' in scope\n\
    \        result += max_fill_helper(grid, 0)\n                  ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var cur = 0\n    for row in grid {\n        for col in row {\n          \
    \  if col == 0 {\n                cur += 1\n            } else {\n           \
    \     if cur > max {\n                    max = cur\n                }\n     \
    \           cur = 0\n            }\n        }\n    }\n    if cur > max {\n   \
    \     max = cur\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpa77cu6o9.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var result = 0\n    \n    for row in grid {\n        var\
    \ max = 0\n        for col in row {\n            if col > max {\n            \
    \    max = col\n            }\n        }\n        \n        if max > capacity\
    \ {\n            result += capacity - max\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxrvnj10b/tmpxrvnj10b.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5235e7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5235b73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5235b73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5235b727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxrvnj10b                        0x000055e011e31546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5236068460 __libc_start_main +
    245

    6    tmpxrvnj10b                        0x000055e011e310d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var maxCount = 0\n    for row in grid {\n   \
    \     var count = 0\n        for val in row {\n            if val == 1 {\n   \
    \             count += 1\n            }\n        }\n        if count > max {\n\
    \            max = count\n            maxCount = 1\n        } else {\n       \
    \     if count == max {\n                maxCount += 1\n            }\n      \
    \  }\n    }\n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf0dqly7r/tmpf0dqly7r.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e9f249c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e9ef40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e9ef40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e9ef3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf0dqly7r                        0x000055df4090b546 <unavailable> + 5446

    5    libc.so.6                          0x00002b8e9f435460 __libc_start_main +
    245

    6    tmpf0dqly7r                        0x000055df4090b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        var minBucket = capacity\n        for bucket in row {\n    \
    \        if bucket > minBucket {\n                minBucket = bucket\n       \
    \     }\n        }\n        result += minBucket - minCapacity\n        minCapacity\
    \ = minBucket\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplmixc427/tmplmixc427.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b703f3c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b703f0b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b703f0b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b703f0b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplmixc427                        0x00005615b1e0f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b703f5ae460 __libc_start_main +
    245

    6    tmplmixc427                        0x00005615b1e0f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 0 {\n                count +=\
    \ 1\n                if count > max {\n                    max = count\n     \
    \           }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmptcw0ytmi/tmptcw0ytmi.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef0f77ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef0f471b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef0f471988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef0f4707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptcw0ytmi                        0x0000555b3bbbf717 <unavailable> + 5911

    5    libc.so.6                          0x00002aef0f966460 __libc_start_main +
    245

    6    tmptcw0ytmi                        0x0000555b3bbbf0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col > 0 {\n                max += col\n                if\
    \ max > capacity {\n                    max = capacity\n                    maxIndex\
    \ = col.index\n                }\n            }\n        }\n    }\n    \n    return\
    \ maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq5sl2xmw.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpq5sl2xmw.swift:37:36: error: value of type 'Int' has no member\
    \ 'index'\n                    maxIndex = col.index\n                        \
    \       ~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var index = 0\n    var buckets = make([][]int, capacity)\n    for row\
    \ in grid {\n        for col in row {\n            if col == 1 {\n           \
    \     buckets[index%capacity] = append(buckets[index%capacity], 0)\n         \
    \   }\n            buckets[index%capacity][index%capacity] = col\n           \
    \ index++\n        }\n    }\n    for bucket in buckets {\n        max = max(max,\
    \ bucket.count)\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1p43m6ln.swift:30:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp1p43m6ln.swift:30:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp1p43m6ln.swift:30:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp1p43m6ln.swift:30:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp1p43m6ln.swift:34:43:\
    \ error: cannot find 'append' in scope\n                buckets[index%capacity]\
    \ = append(buckets[index%capacity], 0)\n                                     \
    \     ^~~~~~\n/tmp/tmp1p43m6ln.swift:37:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            index++\n                 ^~\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    var maxRow = 0\n    var maxCol = 0\n    \n  \
    \  for row in grid {\n        for col in row {\n            if col == 0 {\n  \
    \              maxCount = 0\n                maxRow = row\n                maxCol\
    \ = col\n            } else {\n                maxCount = maxCount + 1\n     \
    \           if maxCount > max {\n                    max = maxCount\n        \
    \            maxRow = row\n                    maxCol = col\n                }\n\
    \            }\n        }\n    }\n    \n    for row in grid {\n        for col\
    \ in row {\n            if col == 0 {\n                grid[row][col] = maxRow\n\
    \                grid[maxRow][col] = maxCol\n            }\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2cc5imu3.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp2cc5imu3.swift:37:26: error: cannot assign value of type '[Int]'\
    \ to type 'Int'\n                maxRow = row\n                         ^~~\n\
    /tmp/tmp2cc5imu3.swift:43:30: error: cannot assign value of type '[Int]' to type\
    \ 'Int'\n                    maxRow = row\n                             ^~~\n\
    /tmp/tmp2cc5imu3.swift:53:22: error: cannot convert value of type '[Int]' to expected\
    \ argument type 'Int'\n                grid[row][col] = maxRow\n             \
    \        ^\n/tmp/tmp2cc5imu3.swift:54:29: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[maxRow][col] = maxCol\n   \
    \             ~~~~        ^\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var maxCount = 0\n    for row in grid {\n        if row[0] == 0 {\n     \
    \       continue\n        }\n        var count = 0\n        for j in 0..<row[0]\
    \ {\n            if row[j] == 1 {\n                count += 1\n            }\n\
    \        }\n        if count > max {\n            max = count\n            maxCount\
    \ = 1\n        } else {\n            maxCount *= count\n        }\n    }\n   \
    \ return maxCount * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqt39da8k.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    \n    var max = 0\n\
    \    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                max += capacity\n \
    \           }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_xj24j3s/tmp_xj24j3s.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2720769c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2720460b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2720460988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b272045f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_xj24j3s                        0x00005636ce9f8827 <unavailable> + 6183

    5    libc.so.6                          0x00002b2720955460 __libc_start_main +
    245

    6    tmp_xj24j3s                        0x00005636ce9f81e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    \n    var max = 0\n\
    \    var maxCount = 0\n    \n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     grid[row][col] = 0\n                \n                if capacity > 0 {\n\
    \                    capacity -= 1\n                }\n                \n    \
    \            if capacity == 0 {\n                    max += 1\n              \
    \      maxCount += 1\n                }\n            }\n        }\n    }\n   \
    \ \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplzj5b6jx.swift:32:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n/tmp/tmplzj5b6jx.swift:35:30: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                    capacity -= 1\n\
    \                    ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var max = 0\n    for row in grid {\n     \
    \   if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0] ==\
    \ 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n   \
    \     if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n        }\n        if row[0]\
    \ == 1 {\n            max = row[0]\n        }\n    }\n    for row in grid {\n\
    \        if row[0] == \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyliirybn.swift:156:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpyliirybn.swift:175:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpyliirybn.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpyliirybn.swift:159:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824728
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity {\n        for _ in\
    \ 0..<grid.count {\n            if grid[_][0] == 0 {\n                grid[_][0]\
    \ = grid[_][1]\n                grid[_][1] = 0\n                grid[_][2] = 0\n\
    \                grid[_][3] = 0\n                grid[_][4] = 0\n            \
    \    grid[_][5] = 0\n                grid[_][6] = 0\n                grid[_][7]\
    \ = 0\n                grid[_][8] = 0\n                grid[_][9] = 0\n      \
    \          grid[_][10] = 0\n                grid[_][11] = 0\n                grid[_][12]\
    \ = 0\n                grid[_][13] = 0\n                grid[_][14] = 0\n    \
    \            grid[_][15] = 0\n                grid[_][16] = 0\n              \
    \  grid[_][17] = 0\n                grid[_][18] = 0\n                grid[_][19]\
    \ = 0\n                grid[_][20] = 0\n                grid[_][21] = 0\n    \
    \            grid[_][22] = 0\n                grid[_][23] = 0\n              \
    \  grid[_][24] = 0\n                grid[_][25] = 0\n                grid[_][26]\
    \ = 0\n                grid[_][27] = 0\n                grid[_][28] = 0\n    \
    \            grid[_][29] = 0\n                grid[_][30] = 0\n              \
    \  grid[_][31] = 0\n                grid[_][32] = 0\n                grid[_][33]\
    \ = 0\n                grid[_][34] = 0\n                grid[_][35] = 0\n    \
    \            grid[_][36] = 0\n                grid[_][37] = 0\n              \
    \  grid[_][38] = 0\n                grid[_][39] = 0\n                grid[_][40]\
    \ = 0\n                grid[_][41] = 0\n                grid[_][42] = 0\n    \
    \            grid[_][43] = 0\n                grid[_][44] = 0\n              \
    \  grid[_][45] = 0\n                grid[_][46] = 0\n                grid[_][47]\
    \ = 0\n                grid[_][48] = 0\n                grid[_][49] = 0\n    \
    \            grid[_][50] = 0\n                grid[_][51] = 0\n              \
    \  grid[_][52] = 0\n                grid[_][53] = 0\n                grid[_][54]\
    \ = 0\n                grid[_][55] = 0\n                grid[_][56] = 0\n    \
    \            grid[_][57] = 0\n                grid[_][58] = 0\n              \
    \  grid[_][59] = 0\n                grid[_][60] = 0\n                grid[_][61]\
    \ = 0\n                grid[_][62] = 0\n                grid[_][63] = 0\n    \
    \            grid[_][64] = 0\n                grid[_][65] = 0\n              \
    \  grid[_][66] = 0\n                grid[_][67\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3lh85dfd.swift:96:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp3lh85dfd.swift:95:24: note: to match this opening '['\n           \
    \     grid[_][67\n                       ^\n/tmp/tmp3lh85dfd.swift:115:71: error:\
    \ expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)\n                                        \
    \                              ^\n/tmp/tmp3lh85dfd.swift:26:33: note: to match\
    \ this opening '{'\n        for _ in 0..<grid.count {\n                      \
    \          ^\n/tmp/tmp3lh85dfd.swift:115:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmp3lh85dfd.swift:25:27: note: to match this opening '{'\n    for _\
    \ in 0..<capacity {\n                          ^\n/tmp/tmp3lh85dfd.swift:115:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmp3lh85dfd.swift:23:52: note: to\
    \ match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n\
    \                                                   ^\n/tmp/tmp3lh85dfd.swift:27:21:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            if grid[_][0] == 0 {\n                    ^\n/tmp/tmp3lh85dfd.swift:28:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][0] = grid[_][1]\n                     ^\n/tmp/tmp3lh85dfd.swift:29:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][1] = 0\n                     ^\n/tmp/tmp3lh85dfd.swift:30:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][2] = 0\n                     ^\n/tmp/tmp3lh85dfd.swift:31:22:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[_][3"
  stdout: ''
  timestamp: 1659824728
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > max {\n                max = bucket\n           \
    \ }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmphlhwupkg/tmphlhwupkg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b720dd86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b720da7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b720da7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b720da7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphlhwupkg                        0x0000562c71a80546 <unavailable> + 5446

    5    libc.so.6                          0x00002b720df72460 __libc_start_main +
    245

    6    tmphlhwupkg                        0x0000562c71a800d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    for row in grid {\n        for col in row {\n            if col\
    \ > max {\n                max = col\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3nocaky0/tmp3nocaky0.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1884557c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b188424eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b188424e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b188424d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3nocaky0                        0x0000560c90165546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1884743460 __libc_start_main +
    245

    6    tmp3nocaky0                        0x0000560c901650d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        for bucket in row {\n            buckets[bucket] += 1\n \
    \       }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n     \
    \       result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0l9vr4hs.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        var minBucket = capacity\n        for bucket in row {\n    \
    \        if bucket > minBucket {\n                minBucket = bucket\n       \
    \     }\n        }\n        result += minBucket - capacity\n        minCapacity\
    \ -= minBucket\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpylud60sg/tmpylud60sg.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc5eff6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc5ecedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc5eced988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc5ecec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpylud60sg                        0x0000560aa2ce6546 <unavailable> + 5446

    5    libc.so.6                          0x00002acc5f1e2460 __libc_start_main +
    245

    6    tmpylud60sg                        0x0000560aa2ce60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        var count =\
    \ 0\n        for val in row {\n            if val == 1 {\n                count\
    \ += 1\n            }\n        }\n        if count > max {\n            max =\
    \ count\n            maxCount = 1\n        }\n        if count == max {\n    \
    \        maxCount += 1\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmmawon3t.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Write your code here.\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpji6knhbi/tmpji6knhbi.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b98e894ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b98e8645b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b98e8645988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b98e86447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpji6knhbi                        0x0000563f3a6983d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b98e8b3a460 __libc_start_main +
    245

    6    tmpji6knhbi                        0x0000563f3a697f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity <= 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = [Int](capacity)\n    \n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                buckets[col] =\
    \ buckets[col] + 1\n            }\n        }\n    }\n    \n    for bucket in buckets\
    \ {\n        if bucket > max {\n            max = bucket\n        }\n    }\n \
    \   \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyrakbw3g.swift:29:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var count = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                count\
    \ += capacity\n            } else {\n                count -= 1\n            }\n\
    \            if count > max {\n                max = count\n            }\n  \
    \      }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpiikmgrv0/tmpiikmgrv0.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f3262ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f32321b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f32321988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f323207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiikmgrv0                        0x000055eb6944f546 <unavailable> + 5446

    5    libc.so.6                          0x00002b7f32816460 __libc_start_main +
    245

    6    tmpiikmgrv0                        0x000055eb6944f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    var index = 0\n    \n    for row in grid {\n\
    \        if row[0] == 0 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 1 {\n            max = row[0]\n   \
    \         maxIndex = index\n        }\n        \n        if row[0] == 2 {\n  \
    \          max = row[0]\n            maxIndex = index\n        }\n        \n \
    \       if row[0] == 3 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 4 {\n            max = row[0]\n   \
    \         maxIndex = index\n        }\n        \n        if row[0] == 5 {\n  \
    \          max = row[0]\n            maxIndex = index\n        }\n        \n \
    \       if row[0] == 6 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 7 {\n            max = row[0]\n   \
    \         maxIndex = index\n        }\n        \n        if row[0] == 8 {\n  \
    \          max = row[0]\n            maxIndex = index\n        }\n        \n \
    \       if row[0] == 9 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 10 {\n            max = row[0]\n  \
    \          maxIndex = index\n        }\n        \n        if row[0] == 11 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        \n\
    \        if row[0] == 12 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 13 {\n            max = row[0]\n  \
    \          maxIndex = index\n        }\n        \n        if row[0] == 14 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        \n\
    \        if row[0] == 15 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 16 {\n            max = row[0]\n  \
    \          maxIndex = index\n        }\n        \n        if row[0] == 17 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        \n\
    \        if row[0] == 18 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 19 {\n            max = row[0]\n  \
    \          maxIndex = index\n        }\n        \n        if row[0] == 20 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        \n\
    \        if row[0] == 21 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 22 {\n            max = row[0]\n  \
    \          maxIndex = index\n        }\n        \n        if row[0] == 23 {\n\
    \            max = row[0]\n            maxIndex = index\n        }\n        \n\
    \        if row[0] == 24 {\n            max = row[0]\n            maxIndex = index\n\
    \        }\n        \n        if row[0] == 25 {\n            max = row[0]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpypd76j16.swift:179:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpypd76j16.swift:32:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpypd76j16.swift:179:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpypd76j16.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpypd76j16.swift:163:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpypd76j16.swift:28:9:\
    \ warning: variable 'max' was written to, but never read\n    var max = 0\n  \
    \      ^\n/tmp/tmpypd76j16.swift:29:9: warning: variable 'maxIndex' was written\
    \ to, but never read\n    var maxIndex = 0\n        ^\n/tmp/tmpypd76j16.swift:30:9:\
    \ warning: variable 'index' was never mutated; consider changing to 'let' constant\n\
    \    var index = 0\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        if row[0] ==\
    \ 0 {\n            continue\n        }\n        \n        var count = 0\n    \
    \    for col in row {\n            if col == 0 {\n                count += 1\n\
    \            }\n        }\n        \n        if count > max {\n            max\
    \ = count\n            maxCount = 1\n        } else if count == max {\n      \
    \      maxCount += 1\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp77ol166s.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity <= 0 {\n        return 0\n    }\n    if grid[0][0]\
    \ == 0 {\n        return 0\n    }\n    if grid[0][0] == 1 {\n        return grid[0].length\n\
    \    }\n    var max = 0\n    var min = 0\n    for row in 0..<grid.length {\n \
    \       for col in 0..<grid[row].length {\n            if grid[row][col] == 1\
    \ {\n                max += capacity\n            } else {\n                min\
    \ += capacity\n            }\n        }\n    }\n    return max - min\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp620j8wkl.swift:31:24: error: value of type '[Int]' has no member\
    \ 'length'\n        return grid[0].length\n               ~~~~~~~ ^~~~~~\n/tmp/tmp620j8wkl.swift:35:25:\
    \ error: value of type '[[Int]]' has no member 'length'\n    for row in 0..<grid.length\
    \ {\n                   ~~~~ ^~~~~~\n/tmp/tmp620j8wkl.swift:36:34: error: reference\
    \ to member 'length' cannot be resolved without a contextual type\n        for\
    \ col in 0..<grid[row].length {\n                                 ^\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  minCapacity = minCapacity - col\n            }\n        }\n    }\n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     count = count + 1\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxrpvposy/tmpxrpvposy.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78a830ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78a8001b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78a8001988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78a80007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxrpvposy                        0x000055887a903717 <unavailable> + 5911

    5    libc.so.6                          0x00002b78a84f6460 __libc_start_main +
    245

    6    tmpxrpvposy                        0x000055887a9030d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    \n    var max = 0\n    \n    for\
    \ _ in 0..<n {\n        let bucket = buckets[capacity]\n        \n        for\
    \ _ in 0..<n {\n            if bucket[grid[Int(i)]] == 1 {\n                bucket[grid[Int(i)]]\
    \ = 0\n                max += 1\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpglhllw8j.swift:30:22: error: cannot find 'buckets' in scope\n \
    \       let bucket = buckets[capacity]\n                     ^~~~~~~\n/tmp/tmpglhllw8j.swift:33:32:\
    \ error: cannot find 'i' in scope\n            if bucket[grid[Int(i)]] == 1 {\n\
    \                               ^\n/tmp/tmpglhllw8j.swift:34:33: error: cannot\
    \ find 'i' in scope\n                bucket[grid[Int(i)]] = 0\n              \
    \                  ^\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var max = 0\n    var i = 0\n\
    \    var j = 0\n    var count = 0\n    for i < grid.length {\n        for j =\
    \ 0 ; j < grid[i].length ; j++ {\n            if grid[i][j] == 1 {\n         \
    \       count += 1\n            }\n        }\n    }\n    \n    if count > capacity\
    \ {\n        max = count\n    } else {\n        max = capacity\n    }\n    \n\
    \    for i = 0 ; i <= grid.length ; i++ {\n        for j = 0 ; j <= grid[i].length\
    \ ; j++ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n\
    \                count -= 1\n                if count <= 0 {\n               \
    \     grid[i][j] = 1\n                    count += capacity\n                }\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpke_vioqm.swift:30:11: error: expected 'in' after for-each pattern\n\
    \    for i < grid.length {\n          ^\n/tmp/tmpke_vioqm.swift:30:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < grid.length\
    \ {\n          ^~\n           \n/tmp/tmpke_vioqm.swift:31:9: error: C-style for\
    \ statement has been removed in Swift 3\n        for j = 0 ; j < grid[i].length\
    \ ; j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpke_vioqm.swift:44:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for i = 0 ; i\
    \ <= grid.length ; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpke_vioqm.swift:45:9:\
    \ error: C-style for statement has been removed in Swift 3\n        for j = 0\
    \ ; j <= grid[i].length ; j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpke_vioqm.swift:30:11: error: '<' is not a prefix unary operator\n    for\
    \ i < grid.length {\n          ^\n/tmp/tmpke_vioqm.swift:30:18: error: value of\
    \ type '[[Int]]' has no member 'length'\n    for i < grid.length {\n         \
    \   ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  if row[0] == 0 {\n            count += row[1]\n        } else {\n         \
    \   count += capacity - row[1]\n        }\n        if count > max {\n        \
    \    max = count\n        }\n        count = 0\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpj0v9dtna/tmpj0v9dtna.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b19d55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b19a4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b19a4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b19a4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj0v9dtna                        0x0000558bd3798596 <unavailable> + 5526

    5    libc.so.6                          0x00002b5b19f41460 __libc_start_main +
    245

    6    tmpj0v9dtna                        0x0000558bd3798129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    var max = 0\n\
    \    var maxIndex = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                max += 1\n            \
    \    if max > capacity {\n                    max = capacity\n               \
    \     maxIndex = i\n                }\n            }\n        }\n    }\n    return\
    \ maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_59_bhhc/tmp_59_bhhc.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5e6f0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5e6c04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5e6c04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5e6c037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_59_bhhc                        0x0000558f795c26f6 <unavailable> + 5878

    5    libc.so.6                          0x00002ab5e70f9460 __libc_start_main +
    245

    6    tmp_59_bhhc                        0x0000558f795c2289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well > capacity {\n                result += 1\n         \
    \       capacity = well\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppj6qqdur.swift:29:17: error: cannot assign to value: 'capacity'\
    \ is a 'let' constant\n                capacity = well\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minBucket = capacity\n    for row in grid\
    \ {\n        for bucket in row {\n            if bucket < minBucket {\n      \
    \          minBucket = bucket\n            }\n        }\n    }\n    for row in\
    \ grid {\n        for bucket in row {\n            if bucket == minBucket {\n\
    \                result += 1\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphhl5f5fy/tmphhl5f5fy.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55607ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55604d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55604d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55604d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphhl5f5fy                        0x0000562c429f6717 <unavailable> + 5911

    5    libc.so.6                          0x00002b55609c9460 __libc_start_main +
    245

    6    tmphhl5f5fy                        0x0000562c429f60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxCount = 0\n    \n    for row in grid {\n        if\
    \ row[0] > max {\n            max = row[0]\n            maxCount = 1\n       \
    \ }\n        \n        if row[0] > max && row[1] > max {\n            max = row[0]\n\
    \            maxCount = 1\n        }\n        \n        if row[0] > max && row[1]\
    \ > max && row[2] > max {\n            max = row[0]\n            maxCount = 1\n\
    \        }\n        \n        if row[0] > max && row[1] > max && row[2] > max\
    \ && row[3] > max {\n            max = row[0]\n            maxCount = 1\n    \
    \    }\n        \n        if row[0] > max && row[1] > max && row[2] > max && row[3]\
    \ > max && row[4] > max {\n            max = row[0]\n            maxCount = 1\n\
    \        }\n        \n        if row[0] > max && row[1] > max && row[2] > max\
    \ && row[3] > max && row[4] > max && row[5] > max {\n            max = row[0]\n\
    \            maxCount = 1\n        }\n        \n        if row[0] > max && row[1]\
    \ > max && row[2] > max && row[3] > max && row[4] > max && row[5] > max && row[6]\
    \ > max {\n            max = row[0]\n            maxCount = 1\n        }\n   \
    \     \n        if row[0] > max && row[1] > max && row[2] > max && row[3] > max\
    \ && row[4] > max && row[5] > max && row[6] > max && row[7] > max {\n        \
    \    max = row[0]\n            maxCount = 1\n        }\n        \n        if row[0]\
    \ > max && row[1] > max && row[2] > max && row[3] > max && row[4] > max && row[5]\
    \ > max && row[6] > max && row[7] > max && row[8] > max {\n            max = row[0]\n\
    \            maxCount = 1\n        }\n        \n        if row[0] > max && row[1]\
    \ > max && row[2] > max && row[3] > max && row[4] > max && row[5] > max && row[6]\
    \ > max && row[7] > max && row[8] > max && row[9] > max {\n            max = row[0]\n\
    \            maxCount = 1\n        }\n        \n        if row[0] > max && row[1]\
    \ > max && row[2] > max && row[3] > max && row[4] > max && row[5] > max && row[6]\
    \ > max && row[7] > max && row[8] > max && row[9] > max && row[10] > max {\n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpp08eb46j.swift:103:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpp08eb46j.swift:31:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpp08eb46j.swift:103:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpp08eb46j.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpp08eb46j.swift:87:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpp08eb46j.swift:29:9:\
    \ warning: variable 'maxCount' was written to, but never read\n    var maxCount\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                count += min_fill(grid: grid, row:\
    \ row, col: col, capacity: capacity)\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxsuk_2br.swift:28:26: error: cannot find 'min_fill' in scope\n\
    \                count += min_fill(grid: grid, row: row, col: col, capacity: capacity)\n\
    \                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1tjgnvj0/tmp1tjgnvj0.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2c92dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2c8fd1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2c8fd1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2c8fd07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1tjgnvj0                        0x000055776210c546 <unavailable> + 5446

    5    libc.so.6                          0x00002ad2c94c6460 __libc_start_main +
    245

    6    tmp1tjgnvj0                        0x000055776210c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.count {\n \
    \       for col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n\
    \                max += capacity\n                maxCount += 1\n            }\n\
    \        }\n    }\n    \n    return maxCount > max ? maxCount : max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpv3i9z2v9/tmpv3i9z2v9.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab655168c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab654e5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab654e5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab654e5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv3i9z2v9                        0x0000559bcfcd9827 <unavailable> + 6183

    5    libc.so.6                          0x00002ab655354460 __libc_start_main +
    245

    6    tmpv3i9z2v9                        0x0000559bcfcd91e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var max = 0\n    var count\
    \ = 0\n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                grid[row][col] = 0\n\
    \                count += capacity - grid[row][col]\n                if count\
    \ > max {\n                    max = count\n                }\n              \
    \  grid[row][col] = 1\n            }\n        }\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_u0dmqg2.swift:31:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n/tmp/tmp_u0dmqg2.swift:36:26: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[row][col] = 1\n           \
    \     ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > max {\n                max = bucket\n           \
    \ }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmphlhwupkg/tmphlhwupkg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b720dd86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b720da7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b720da7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b720da7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphlhwupkg                        0x0000562c71a80546 <unavailable> + 5446

    5    libc.so.6                          0x00002b720df72460 __libc_start_main +
    245

    6    tmphlhwupkg                        0x0000562c71a800d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    var buckets = make([][]int, capacity)\n    \n\
    \    for row in grid {\n        for bucket in bucket {\n            if bucket\
    \ > 0 {\n                buckets[bucket]++\n            }\n        }\n    }\n\
    \    \n    for bucket in buckets {\n        if bucket > max {\n            max\
    \ = bucket\n            maxCount = 1\n        } else if bucket == max {\n    \
    \        maxCount++\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdudlihwu.swift:30:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpdudlihwu.swift:30:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpdudlihwu.swift:30:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpdudlihwu.swift:30:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpdudlihwu.swift:33:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([][]int, capacity)\n    for row in grid {\n    \
    \    for bucket in bucket {\n            if bucket > 0 {\n                buckets[bucket-1][row\
    \ - 1]++\n            }\n        }\n    }\n    for bucket in buckets {\n     \
    \   if bucket > max {\n            max = bucket\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1eld5837.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp1eld5837.swift:29:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp1eld5837.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp1eld5837.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp1eld5837.swift:31:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col > 0 {\n                max += col\n                maxIndex\
    \ += 1\n            }\n        }\n    }\n    \n    if maxIndex == 0 {\n      \
    \  return 0\n    }\n    \n    if maxIndex == 1 {\n        return max\n    }\n\
    \    \n    var buckets = [Int](capacity)\n    \n    for row in grid {\n      \
    \  for col in row {\n            if col > 0 {\n                buckets[col-1]\
    \ += 1\n            }\n        }\n    }\n    \n    for bucket in buckets {\n \
    \       if bucket > max {\n            max = bucket\n            maxIndex = buckets.indexOf(bucket)\n\
    \        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9sxptkx4.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp9sxptkx4.swift:48:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var count = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                count\
    \ += 1\n            } else {\n                count = 0\n            }\n     \
    \       \n            if count > max {\n                max = count\n        \
    \    }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpka1qg72p/tmpka1qg72p.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2975bdac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29758d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29758d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29758d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpka1qg72p                        0x000056038e2da546 <unavailable> + 5446

    5    libc.so.6                          0x00002b2975dc6460 __libc_start_main +
    245

    6    tmpka1qg72p                        0x000056038e2da0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minCapacity = capacity\n    for _ in 0..<grid.count\
    \ {\n        var minBucket = capacity\n        for _ in 0..<grid[0].count {\n\
    \            if grid[0][_] == 1 {\n                minBucket = minBucket - 1\n\
    \            } else {\n                minBucket = minBucket + 1\n           \
    \ }\n        }\n        if minBucket < minCapacity {\n            minCapacity\
    \ = minBucket\n        }\n    }\n    for _ in 0..<grid.count {\n        for _\
    \ in 0..<grid[0].count {\n            if grid[0][_] == 1 {\n                grid[0][_]\
    \ = 0\n            } else {\n                grid[0][_] = 1\n            }\n \
    \       }\n    }\n    for _ in 0..<grid.count {\n        for _ in 0..<grid[0].count\
    \ {\n            if grid[0][_] == 1 {\n                grid[0][_] = 0\n      \
    \      } else {\n                grid[0][_] = 1\n            }\n        }\n  \
    \  }\n    for _ in 0..<grid.count {\n        for _ in 0..<grid[0].count {\n  \
    \          if grid[0][_] == 1 {\n                grid[0][_] = 0\n            }\
    \ else {\n                grid[0][_] = 1\n            }\n        }\n    }\n  \
    \  for _ in 0..<grid.count {\n        for _ in 0..<grid[0].count {\n         \
    \   if grid[0][_] == 1 {\n                grid[0][_] = 0\n            } else {\n\
    \                grid[0][_] = 1\n            }\n        }\n    }\n    for _ in\
    \ 0..<grid.count {\n        for _ in 0..<grid[0].count {\n            if grid[0][_]\
    \ == 1 {\n                grid[0][_] = 0\n            } else {\n             \
    \   grid[0][_] = 1\n            }\n        }\n    }\n    for _ in 0..<grid.count\
    \ {\n        for _ in 0..<grid[0].count {\n            if grid[0][_] == 1 {\n\
    \                grid[0][_] = 0\n            } else {\n                grid[0][_]\
    \ = 1\n            }\n        }\n    }\n    for _ in 0..<grid.count {\n      \
    \  for _ in 0..<grid[0].count {\n            if grid[0][_] == 1 {\n          \
    \      grid[0][_] = 0\n            } else {\n                grid[0][_] = 1\n\
    \            }\n        }\n    }\n    for _ in 0..<grid.count {\n        for _\
    \ in 0..<grid[0].count {\n            if grid[0][_] == 1 {\n                grid[0][_]\
    \ = 0\n            } else {\n                grid[0][_] = 1\n            }\n \
    \       }\n    }\n    for _ in 0..<grid.count {\n        for _ in 0..<grid[0].count\
    \ {\n            if grid[0][_] == 1 {\n                grid[0][_] = 0\n      \
    \      } else {\n                grid[0][_] = 1\n            }\n        }\n  \
    \  }\n    for _ in 0..<grid.count {\n        for _ in \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq2btupdh.swift:121:17: error: expected Sequence expression for\
    \ for-each loop\n        for _ in \n                ^\n/tmp/tmpq2btupdh.swift:121:17:\
    \ error: expected '{' to start the body of for-each loop\n        for _ in \n\
    \                ^\n/tmp/tmpq2btupdh.swift:141:71: error: expected '}' at end\
    \ of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 9) == 2)\n                                                                 \
    \     ^\n/tmp/tmpq2btupdh.swift:23:52: note: to match this opening '{'\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n                                         \
    \          ^\n/tmp/tmpq2btupdh.swift:29:24: error: '_' can only appear in a pattern\
    \ or on the left side of an assignment\n            if grid[0][_] == 1 {\n   \
    \                    ^\n/tmp/tmpq2btupdh.swift:41:24: error: '_' can only appear\
    \ in a pattern or on the left side of an assignment\n            if grid[0][_]\
    \ == 1 {\n                       ^\n/tmp/tmpq2btupdh.swift:42:25: error: '_' can\
    \ only appear in a pattern or on the left side of an assignment\n            \
    \    grid[0][_] = 0\n                        ^\n/tmp/tmpq2btupdh.swift:44:25:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[0][_] = 1\n                        ^\n/tmp/tmpq2btupdh.swift:50:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            if grid[0][_] == 1 {\n                       ^\n/tmp/tmpq2btupdh.swift:51:25:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[0][_] = 0\n                        ^\n/tmp/tmpq2btupdh.swift:53:25:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                grid[0][_] = 1\n                        ^\n/tmp/tmpq2btupdh.swift:59:24:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            if grid[0][_] == 1 {\n                       ^\n/tmp/tmpq2btupdh.swift:60:25:\
    \ error: '_' can only appear in a pattern or on the left side of an assig"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var index = 0\n    var buckets = [Int](capacity)\n    \n    for row\
    \ in grid {\n        for col in row {\n            if col == 0 {\n           \
    \     buckets[index] += 1\n            }\n        }\n    }\n    \n    for bucket\
    \ in buckets {\n        if bucket > max {\n            max = bucket\n        \
    \    index = buckets.indexOf(bucket)\n        }\n    }\n    \n    return index\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpr9_ux1nj.swift:30:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         max += 1\n                if max > capacity {\n                    maxIndex\
    \ = row\n                    break\n                }\n            }\n       \
    \ }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpr96bgu51/tmpr96bgu51.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6a6dbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6a6ab3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6a6ab3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6a6ab27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr96bgu51                        0x0000562584869656 <unavailable> + 5718

    5    libc.so.6                          0x00002af6a6fa8460 __libc_start_main +
    245

    6    tmpr96bgu51                        0x00005625848691e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        for bucket in row {\n            buckets[bucket] = buckets[bucket]\
    \ + 1\n        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n\
    \            result = max(result, bucket)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmvkl3bx0.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                count += capacity\n\
    \            } else {\n                count -= 1\n            }\n        }\n\
    \    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppiztqb1r/tmppiztqb1r.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59efccdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59ef9c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59ef9c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59ef9c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppiztqb1r                        0x00005633c3db0546 <unavailable> + 5446

    5    libc.so.6                          0x00002b59efeb9460 __libc_start_main +
    245

    6    tmppiztqb1r                        0x00005633c3db00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well > 0 {\n                result += capacity - well\n  \
    \          }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpaexds291/tmpaexds291.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1105e93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1105b8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1105b8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1105b897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaexds291                        0x0000558fa3fa6546 <unavailable> + 5446

    5    libc.so.6                          0x00002b110607f460 __libc_start_main +
    245

    6    tmpaexds291                        0x0000558fa3fa60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity <= 0 {\n        return 0\n    }\n    \n    var result\
    \ = 0\n    var current = 0\n    var currentCapacity = capacity\n    \n    for\
    \ row in grid {\n        for col in row {\n            if col == 0 {\n       \
    \         currentCapacity -= 1\n                current++\n            }\n   \
    \         if current > currentCapacity {\n                current = 0\n      \
    \          currentCapacity = capacity\n            }\n        }\n        result\
    \ += current\n        current = 0\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpedkzcz57.swift:36:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                current++\n                       ^~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count {\n \
    \       for col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n\
    \                max += capacity\n                maxIndex = row * grid[row].count\
    \ + col\n            }\n        }\n    }\n    \n    return max - maxIndex\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjlmogqaf/tmpjlmogqaf.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afddd313c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afddd00ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afddd00a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afddd0097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjlmogqaf                        0x000055d42fc9c656 <unavailable> + 5718

    5    libc.so.6                          0x00002afddd4ff460 __libc_start_main +
    245

    6    tmpjlmogqaf                        0x000055d42fc9c1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        if row[0] ==\
    \ 0 {\n            continue\n        }\n        \n        for col in row {\n \
    \           if col == 0 {\n                continue\n            }\n         \
    \   \n            if col > max {\n                max = col\n                maxIndex\
    \ = col\n            }\n        }\n    }\n    \n    if maxIndex == capacity {\n\
    \        return maxIndex\n    }\n    \n    return maxIndex + 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3l7x4t9l/tmp3l7x4t9l.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ebe532c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ebe229b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ebe229988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ebe2287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3l7x4t9l                        0x0000556644bed5e6 <unavailable> + 5606

    5    libc.so.6                          0x00002b3ebe71e460 __libc_start_main +
    245

    6    tmp3l7x4t9l                        0x0000556644bed179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                count += capacity\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpi7fet6f8/tmpi7fet6f8.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82b0392c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82b0089b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82b0089988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82b00887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi7fet6f8                        0x0000561ca7df0717 <unavailable> + 5911

    5    libc.so.6                          0x00002b82b057e460 __libc_start_main +
    245

    6    tmpi7fet6f8                        0x0000561ca7df00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid[0].length\
    \ {\n        for j in 0..<grid.count {\n            if grid[j][i] == 1 {\n   \
    \             max += 1\n                if max > capacity {\n                \
    \    maxIndex = j\n                    break\n                }\n            }\n\
    \        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdm6pfpf2.swift:31:26: error: value of type '[Int]' has no member\
    \ 'length'\n    for i in 0..<grid[0].length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for bucket in row {\n            if bucket > max {\n                max\
    \ = bucket\n            }\n        }\n        result += max - capacity\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb0yhelbd/tmpb0yhelbd.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4df1be9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4df18e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4df18e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4df18df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0yhelbd                        0x000055bae67ef546 <unavailable> + 5446

    5    libc.so.6                          0x00002b4df1dd5460 __libc_start_main +
    245

    6    tmpb0yhelbd                        0x000055bae67ef0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \           } else {\n                count = 0\n            }\n            if\
    \ count > max {\n                max = count\n            }\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe4wvi09e/tmpe4wvi09e.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1abaffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1abacf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1abacf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1abacf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4wvi09e                        0x000055c55bfe8546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1abb1e7460 __libc_start_main +
    245

    6    tmpe4wvi09e                        0x000055c55bfe80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    \n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 0 {\n                grid[row][col] = capacity\n\
    \                \n                if capacity > max {\n                    max\
    \ = capacity\n                }\n                \n                for _ in 0..<capacity\
    \ {\n                    grid[row][col] = 0\n                }\n            }\n\
    \        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp83cypk7h.swift:33:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = capacity\n           \
    \     ~~~~     ^\n/tmp/tmp83cypk7h.swift:40:30: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                    grid[row][col] = 0\n       \
    \             ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for _ in row {\n            max += capacity\n        }\n        max -=\
    \ capacity\n        if max > 0 {\n            result += max\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp14w0icp0/tmp14w0icp0.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae978ec8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae978bbfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae978bbf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae978bbe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp14w0icp0                        0x000055b7ec846546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae9790b4460 __libc_start_main +
    245

    6    tmp14w0icp0                        0x000055b7ec8460d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var min = 0\n    var minRow = grid[0]\n    var minCol = grid[0]\n    var\
    \ minVal = grid[0]\n    for row in grid {\n        for col in row {\n        \
    \    if col > 0 {\n                max = max(max, col - minVal)\n            \
    \    min = min(min, col - minVal)\n            }\n        }\n    }\n    for row\
    \ in grid {\n        for col in row {\n            if col > 0 {\n            \
    \    minVal = minVal * capacity / max\n                minRow = minRow * capacity\
    \ / max\n                minCol = minCol * capacity / max\n            }\n   \
    \     }\n    }\n    return max - min\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwojo7re4.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpwojo7re4.swift:35:23: error: cannot call value of non-function\
    \ type 'Int'\n                max = max(max, col - minVal)\n                 \
    \     ^\n/tmp/tmpwojo7re4.swift:35:38: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n                max = max(max, col - minVal)\n\
    \                                     ^\n/tmp/tmpwojo7re4.swift:36:23: error:\
    \ cannot call value of non-function type 'Int'\n                min = min(min,\
    \ col - minVal)\n                      ^\n/tmp/tmpwojo7re4.swift:36:38: error:\
    \ cannot convert value of type '[Int]' to expected argument type 'Int'\n     \
    \           min = min(min, col - minVal)\n                                   \
    \  ^\n/tmp/tmpwojo7re4.swift:43:33: error: binary operator '*' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n                minVal = minVal * capacity\
    \ / max\n                         ~~~~~~ ^ ~~~~~~~~\n/tmp/tmpwojo7re4.swift:43:33:\
    \ note: overloads for '*' exist with these partially matching parameter lists:\
    \ (Int, Int)\n                minVal = minVal * capacity / max\n             \
    \                   ^\n/tmp/tmpwojo7re4.swift:43:44: error: no '/' candidates\
    \ produce the expected contextual result type '[Int]'\n                minVal\
    \ = minVal * capacity / max\n                                           ^\nSwift.Int:10:24:\
    \ note: '/' produces 'Int', not the expected contextual result type '[Int]'\n\
    \    public static func / (lhs: Int, rhs: Int) -> Int\n                      \
    \ ^\nSwift.BinaryInteger:14:17: note: '/' produces 'Int', not the expected contextual\
    \ result type '[Int]'\n    static func / (lhs: Self, rhs: Self) -> Self\n    \
    \            ^\nSwift.Int:10:24: note: '/' produces 'Int', not the expected contextual\
    \ result type '[Int]'\n    public static func / (lhs: Int, rhs: Int) -> Int\n\
    \                       ^\nSwift.BinaryInteger:14:17: note: '/' produces 'Int',\
    \ not the expected contextual result type '[Int]'\n   "
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Your code here\n    var max = 0\n    var count = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                count += 1\n            }\n            if count > max {\n   \
    \             max = count\n            }\n            count = 0\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpoyyycs_d/tmpoyyycs_d.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3de44b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3de41a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3de41a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3de41a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoyyycs_d                        0x0000564c63c33546 <unavailable> + 5446

    5    libc.so.6                          0x00002b3de469e460 __libc_start_main +
    245

    6    tmpoyyycs_d                        0x0000564c63c330d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col > 0 {\n                max += col\n                maxIndex\
    \ += 1\n            }\n        }\n    }\n    \n    if capacity == 1 {\n      \
    \  return maxIndex\n    }\n    \n    if capacity == max {\n        return maxIndex\n\
    \    }\n    \n    if capacity > max {\n        return maxIndex\n    }\n    \n\
    \    return maxIndex + max_fill(grid: grid[..<maxIndex], capacity: capacity -\
    \ max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0_4uco80.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp0_4uco80.swift:52:42: error: cannot convert value of type 'ArraySlice<[Int]>'\
    \ to expected argument type '[[Int]]'\n    return maxIndex + max_fill(grid: grid[..<maxIndex],\
    \ capacity: capacity - max)\n                                         ^\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var max = 0\n  \
    \      for _ in row {\n            max += capacity\n        }\n        for _ in\
    \ row {\n            max -= capacity\n        }\n        if max > 0 {\n      \
    \      count += max - capacity\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpnevuzsfa/tmpnevuzsfa.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7b8769c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7b8460b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba7b8460988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7b845f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnevuzsfa                        0x000055af0a973546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba7b8955460 __libc_start_main +
    245

    6    tmpnevuzsfa                        0x000055af0a9730d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         max += capacity\n                maxCount += 1\n            }\n    \
    \    }\n    }\n    \n    return maxCount > max ? maxCount : max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmjtmnc60/tmpmjtmnc60.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afec8f9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afec8c93b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afec8c93988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afec8c927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmjtmnc60                        0x00005573a5981827 <unavailable> + 6183

    5    libc.so.6                          0x00002afec9188460 __libc_start_main +
    245

    6    tmpmjtmnc60                        0x00005573a59811e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                count += min_fill(grid: grid, row:\
    \ row, col: col, capacity: capacity)\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxsuk_2br.swift:28:26: error: cannot find 'min_fill' in scope\n\
    \                count += min_fill(grid: grid, row: row, col: col, capacity: capacity)\n\
    \                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n       \
    \         max += 1\n                if max > capacity {\n                    max\
    \ = capacity\n                    maxIndex = row\n                }\n        \
    \    }\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpcpn_2n1m/tmpcpn_2n1m.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afad4cd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afad49cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afad49cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afad49cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcpn_2n1m                        0x000055632065c656 <unavailable> + 5718

    5    libc.so.6                          0x00002afad4ec2460 __libc_start_main +
    245

    6    tmpcpn_2n1m                        0x000055632065c1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var max = 0\n  \
    \      for _ in row {\n            max += capacity\n        }\n        for _ in\
    \ row {\n            max -= capacity\n        }\n        if max > 0 {\n      \
    \      count += max - capacity\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpnevuzsfa/tmpnevuzsfa.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7b8769c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7b8460b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba7b8460988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7b845f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnevuzsfa                        0x000055af0a973546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba7b8955460 __libc_start_main +
    245

    6    tmpnevuzsfa                        0x000055af0a9730d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    \n    for row in grid {\n        var\
    \ max = 0\n        for _ in row {\n            max = max(max, buckets[row])\n\
    \        }\n        \n        if max > capacity {\n            count += capacity\
    \ - max\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_anylxwb.swift:30:28: error: cannot find 'buckets' in scope\n \
    \           max = max(max, buckets[row])\n                           ^~~~~~~\n\
    /tmp/tmp_anylxwb.swift:30:19: error: cannot call value of non-function type 'Int'\n\
    \            max = max(max, buckets[row])\n                  ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                count += 1\n            }\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpoc2_q31r/tmpoc2_q31r.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a28559c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a28250b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a28250988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a2824f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoc2_q31r                        0x000055e8837fc717 <unavailable> + 5911

    5    libc.so.6                          0x00002b6a28745460 __libc_start_main +
    245

    6    tmpoc2_q31r                        0x000055e8837fc0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var max = 0\n  \
    \      for col in row {\n            if col > max {\n                max = col\n\
    \            }\n        }\n        if max > capacity {\n            count = 0\n\
    \        } else {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmplnumkhyd/tmplnumkhyd.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0a49ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0a46e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0a46e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0a46e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplnumkhyd                        0x00005584886c3546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae0a4bd8460 __libc_start_main +
    245

    6    tmplnumkhyd                        0x00005584886c30d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for _ in row {\n            max += capacity\n        }\n        if max\
    \ > capacity {\n            max -= capacity\n        }\n        result += max\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprkk3u7jp/tmprkk3u7jp.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2064fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2061f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2061f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2061f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprkk3u7jp                        0x000055b34f791546 <unavailable> + 5446

    5    libc.so.6                          0x00002ad2066e6460 __libc_start_main +
    245

    6    tmprkk3u7jp                        0x000055b34f7910d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                result += capacity - grid[row][col]\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpep_ypoox.swift:28:43: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n                result += capacity - grid[row][col]\n\
    \                                          ^\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var result\
    \ = 0\n    \n    for row in grid {\n        if row[0] == 0 {\n            result\
    \ += 1\n        }\n    }\n    \n    for row in grid {\n        if row[0] == 1\
    \ {\n            result -= capacity\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpp0vonghp.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = make([][]int, capacity)\n    for row in grid {\n    \
    \    for bucket in row {\n            buckets[bucket] = buckets[bucket] + 1\n\
    \        }\n    }\n    for bucket in buckets {\n        if bucket > max {\n  \
    \          max = bucket\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0tgkmrfy.swift:29:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp0tgkmrfy.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp0tgkmrfy.swift:29:19: error: cannot find 'make' in scope\n   \
    \ var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp0tgkmrfy.swift:29:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp0tgkmrfy.swift:29:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var result = 0\n    \n    for row in grid {\n        var\
    \ buckets = make([]int, capacity)\n        for bucket in bucket {\n          \
    \  buckets[bucket] = 1\n        }\n        \n        for bucket in buckets {\n\
    \            if bucket > 0 {\n                buckets[bucket] = 0\n          \
    \  }\n        }\n        \n        for bucket in buckets {\n            result\
    \ += bucket\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8ucz7bwp.swift:28:30: error: expected ',' separator\n        var\
    \ buckets = make([]int, capacity)\n                             ^\n          \
    \                   ,\n/tmp/tmp8ucz7bwp.swift:28:23: error: cannot find 'make'\
    \ in scope\n        var buckets = make([]int, capacity)\n                    \
    \  ^~~~\n/tmp/tmp8ucz7bwp.swift:28:30: error: cannot find 'int' in scope\n   \
    \     var buckets = make([]int, capacity)\n                             ^~~\n\
    /tmp/tmp8ucz7bwp.swift:29:23: error: cannot find 'bucket' in scope\n        for\
    \ bucket in bucket {\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \           } else {\n                count -= 1\n            }\n            if\
    \ count > max {\n                max = count\n            }\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkgyoefdi/tmpkgyoefdi.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca4bcdcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca4b9d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca4b9d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca4b9d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkgyoefdi                        0x000055785a270546 <unavailable> + 5446

    5    libc.so.6                          0x00002aca4bec8460 __libc_start_main +
    245

    6    tmpkgyoefdi                        0x000055785a2700d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for _ in 0..<capacity {\n        result +=\
    \ 1\n        for j in 0..<grid[0].length {\n            if grid[0][j] == 1 {\n\
    \                for i in 0..<grid.length {\n                    if grid[i][j]\
    \ == 1 {\n                        grid[i][j] = 0\n                        result\
    \ = max(result, max_fill(grid, capacity - 1))\n                        grid[i][j]\
    \ = 1\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7hdvfkfn.swift:27:30: error: value of type '[Int]' has no member\
    \ 'length'\n        for j in 0..<grid[0].length {\n                     ~~~~~~~\
    \ ^~~~~~\n/tmp/tmp7hdvfkfn.swift:29:35: error: value of type '[[Int]]' has no\
    \ member 'length'\n                for i in 0..<grid.length {\n              \
    \               ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var result = 0\n    \n    for row in 0..<grid.count {\n\
    \        for col in 0..<grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                result += capacity\n            }\n        }\n    }\n   \
    \ \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe4vt73h6/tmpe4vt73h6.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b48084c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b47d7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b47d7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b47d7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4vt73h6                        0x0000559cf39e4827 <unavailable> + 6183

    5    libc.so.6                          0x00002b0b48270460 __libc_start_main +
    245

    6    tmpe4vt73h6                        0x0000559cf39e41e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxCount = 0\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            continue\n        }\n        \n        var count = 0\n \
    \       for col in row {\n            if col == 0 {\n                count +=\
    \ 1\n            }\n        }\n        \n        if count > max {\n          \
    \  max = count\n            maxCount = 1\n        } else {\n            maxCount\
    \ += 1\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmm77as9e/tmpmm77as9e.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ba4950c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ba4647b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ba4647988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ba46467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmm77as9e                        0x00005583d671d596 <unavailable> + 5526

    5    libc.so.6                          0x00002b0ba4b3c460 __libc_start_main +
    245

    6    tmpmm77as9e                        0x00005583d671d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return -1\n    }\n    \n\
    \    var max = 0\n    var maxIndex = 0\n    var index = 0\n    \n    for row in\
    \ 0..<grid.count {\n        for col in 0..<grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                grid[row][col] = 0\n                \n             \
    \   if capacity > 0 {\n                    capacity -= 1\n                }\n\
    \                \n                if capacity == 0 {\n                    maxIndex\
    \ += 1\n                    \n                    if maxIndex > max {\n      \
    \                  max = maxIndex\n                    }\n                }\n\
    \            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkbjl014i.swift:35:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n/tmp/tmpkbjl014i.swift:38:30: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                    capacity -= 1\n\
    \                    ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var count = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                count += 1\n                if\
    \ count > max {\n                    max = count\n                }\n        \
    \    }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpt47bca56.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        for bucket in row {\n            buckets[bucket]++\n\
    \        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n    \
    \        result += bucket\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_lqe9gij.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp_lqe9gij.swift:25:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmp_lqe9gij.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmp_lqe9gij.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp_lqe9gij.swift:28:28:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  buckets[bucket]++\n                           ^~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for cell in row {\n            if cell > max {\n                max =\
    \ cell\n            }\n        }\n        if max > capacity {\n            result\
    \ += capacity - max\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjz8vmg2d/tmpjz8vmg2d.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d2aec5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d2abbcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d2abbc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d2abbb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjz8vmg2d                        0x0000559a1af07546 <unavailable> + 5446

    5    libc.so.6                          0x00002b3d2b0b1460 __libc_start_main +
    245

    6    tmpjz8vmg2d                        0x0000559a1af070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        for bucket in bucket {\n            buckets[bucket]++\n\
    \        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n    \
    \        result += 1\n            bucket -= 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpn46y0khz.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpn46y0khz.swift:25:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpn46y0khz.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpn46y0khz.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpn46y0khz.swift:27:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n   \
    \     for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n       \
    \         grid[i][j] = 0\n                \n                if max < capacity\
    \ {\n                    max = capacity\n                    maxIndex = i\n  \
    \              }\n                \n                grid[i][j] = 1\n         \
    \   }\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyseqhuxx.swift:34:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n/tmp/tmpyseqhuxx.swift:41:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 1\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = [Int](capacity)\n    \n    for row in grid {\n      \
    \  for bucket in row {\n            buckets[bucket] += 1 \n        }\n    }\n\
    \    \n    for bucket in buckets {\n        if bucket > max {\n            max\
    \ = bucket \n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsqt2r1by.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpsqt2r1by.swift:29:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well > capacity {\n                result += 1\n         \
    \       capacity = well\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppj6qqdur.swift:29:17: error: cannot assign to value: 'capacity'\
    \ is a 'let' constant\n                capacity = well\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for cell in row {\n            if cell > max {\n                max =\
    \ cell\n            }\n        }\n        if max > capacity {\n            result\
    \ += capacity - max\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjz8vmg2d/tmpjz8vmg2d.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d2aec5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d2abbcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d2abbc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d2abbb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjz8vmg2d                        0x0000559a1af07546 <unavailable> + 5446

    5    libc.so.6                          0x00002b3d2b0b1460 __libc_start_main +
    245

    6    tmpjz8vmg2d                        0x0000559a1af070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for _ in row {\n            max += capacity\n        }\n        if max\
    \ > result {\n            result = max\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl906buyi/tmpl906buyi.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0530a3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0530731b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0530731988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05307307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl906buyi                        0x0000563fc6b6e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b0530c26460 __libc_start_main +
    245

    6    tmpl906buyi                        0x0000563fc6b6e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 || grid.count == grid[0].length else {\n\
    \        return 0\n    }\n    \n    var max = 0\n    var maxIndex = 0\n    \n\
    \    for i in 0..<grid[0].length {\n        for j in 0..<grid.count {\n      \
    \      if grid[j][i] == 1 {\n                grid[j][i] = 0\n                \n\
    \                if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex]\
    \ = 0\n                    \n                    if grid[j][maxIndex] == 1 {\n\
    \                        grid[j][maxIndex] = 0\n                        \n   \
    \                     if grid[j][maxIndex] == 1 {\n                          \
    \  grid[j][maxIndex] = 0\n                        }\n                    }\n \
    \               }\n                \n                if grid[j][maxIndex] == 1\
    \ {\n                    grid[j][maxIndex] = 0\n                }\n          \
    \      \n                if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex]\
    \ = 0\n                }\n                \n                if grid[j][maxIndex]\
    \ == 1 {\n                    grid[j][maxIndex] = 0\n                }\n     \
    \           \n                if grid[j][maxIndex] == 1 {\n                  \
    \  grid[j][maxIndex] = 0\n                }\n                \n              \
    \  if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex] = 0\n  \
    \              }\n                \n                if grid[j][maxIndex] == 1\
    \ {\n                    grid[j][maxIndex] = 0\n                }\n          \
    \      \n                if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex]\
    \ = 0\n                }\n                \n                if grid[j][maxIndex]\
    \ == 1 {\n                    grid[j][maxIndex] = 0\n                }\n     \
    \           \n                if grid[j][maxIndex] == 1 {\n                  \
    \  grid[j][maxIndex] = 0\n                }\n                \n              \
    \  if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex] = 0\n  \
    \              }\n                \n                if grid[j][maxIndex] == 1\
    \ {\n                    grid[j][maxIndex] = 0\n                }\n          \
    \      \n                if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex]\
    \ = 0\n                }\n                \n                if grid[j][maxIndex]\
    \ == 1 {\n                    grid[j][maxIndex] = 0\n                }\n     \
    \           \n                if grid[j][maxIndex] == 1 {\n                  \
    \  grid[j][maxIndex] = 0\n                }\n                \n              \
    \  if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex] = 0\n  \
    \              }\n                \n                if grid[j][maxIndex] == 1\
    \ {\n                    grid[j][maxIndex] = 0\n                }\n          \
    \      \n                if grid[j][maxIndex] == 1 {\n                    grid[j][maxIndex]\
    \ = 0\n                }\n                \n                if grid[j][maxIndex]\
    \ == 1 {\n                    grid[j][maxIndex] = 0\n                }\n     \
    \           \n                if grid[j][maxIndex] == 1 {\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyj8p802l.swift:140:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpyj8p802l.swift:33:32:\
    \ note: to match this opening '{'\n            if grid[j][i] == 1 {\n        \
    \                       ^\n/tmp/tmpyj8p802l.swift:140:71: error: expected '}'\
    \ at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)\n                                                       \
    \               ^\n/tmp/tmpyj8p802l.swift:32:33: note: to match this opening '{'\n\
    \        for j in 0..<grid.count {\n                                ^\n/tmp/tmpyj8p802l.swift:140:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpyj8p802l.swift:31:33: note: to\
    \ match this opening '{'\n    for i in 0..<grid[0].length {\n                \
    \                ^\n/tmp/tmpyj8p802l.swift:140:71: error: expected '}' at end\
    \ of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 9) == 2)\n                                                                 \
    \     ^\n/tmp/tmpyj8p802l.swift:23:52: note: to match this opening '{'\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n                                         \
    \          ^\n/tmp/tmpyj8p802l.swift:24:52: error: value of type '[Int]' has no\
    \ member 'length'\n    guard grid.count == 1 || grid.count == grid[0].length else\
    \ {\n                                           ~~~~~~~ ^~~~~~\n/tmp/tmpyj8p802l.swift:31:26:\
    \ error: value of type '[Int]' has no member 'length'\n    for i in 0..<grid[0].length\
    \ {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = [Int](capacity)\n    for row\
    \ in grid {\n        for bucket in row {\n            buckets[bucket] += 1\n \
    \       }\n    }\n    for bucket in buckets {\n        result += bucket\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1u5iw74l.swift:25:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var max = 0\n    var count\
    \ = 0\n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                count += capacity\n\
    \            } else {\n                count -= capacity\n            }\n    \
    \        if count > max {\n                max = count\n            }\n      \
    \  }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbl8mojf9/tmpbl8mojf9.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57a4c20c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57a4917b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57a4917988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57a49167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbl8mojf9                        0x0000560d72f78656 <unavailable> + 5718

    5    libc.so.6                          0x00002b57a4e0c460 __libc_start_main +
    245

    6    tmpbl8mojf9                        0x0000560d72f781e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let rowCount = grid.count\n    let colCount = grid[0].count\n\
    \    \n    var max = 0\n    \n    for row in 0..<rowCount {\n        for col in\
    \ 0..<colCount {\n            if grid[row][col] == 1 {\n                \n   \
    \             let bucket = grid[row][col]\n                \n                for\
    \ _ in 0..<capacity {\n                    \n                    grid[row][col]\
    \ = 0\n                    \n                    if bucket > 0 {\n           \
    \             \n                        max += 1\n                        \n \
    \                       grid[row][col] = bucket\n                        \n  \
    \                  }\n                    \n                }\n              \
    \  \n            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjapjqoz6.swift:38:30: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[row][col] = 0\n              \
    \      ~~~~     ^\n/tmp/tmpjapjqoz6.swift:44:34: error: cannot assign through\
    \ subscript: 'grid' is a 'let' constant\n                        grid[row][col]\
    \ = bucket\n                        ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity <= 0 {\n        return 0\n    }\n    if grid.isEmpty()\
    \ {\n        return 0\n    }\n    var max = 0\n    var maxIndex = 0\n    for i\
    \ := 0; i < grid.length-1; i++ {\n        for j := 0; j < grid[0].length-1; j++\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n      \
    \          grid[i+1][j] = 0\n                grid[i][j+1] = 0\n              \
    \  grid[i+1][j+1] = 0\n                max += capacity\n                if max\
    \ > capacity {\n                    max = 0\n                    maxIndex = i\n\
    \                }\n            }\n        }\n    }\n    return maxIndex\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppferea5k.swift:32:12: error: expected type\n    for i := 0; i <\
    \ grid.length-1; i++ {\n           ^\n            <#type#>\n/tmp/tmppferea5k.swift:32:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < grid.length-1;\
    \ i++ {\n           ^\n/tmp/tmppferea5k.swift:32:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < grid.length-1; i++ {\n   \
    \        ^\n/tmp/tmppferea5k.swift:33:16: error: expected type\n        for j\
    \ := 0; j < grid[0].length-1; j++ {\n               ^\n                <#type#>\n\
    /tmp/tmppferea5k.swift:33:16: error: expected 'in' after for-each pattern\n  \
    \      for j := 0; j < grid[0].length-1; j++ {\n               ^\n/tmp/tmppferea5k.swift:33:16:\
    \ error: expected Sequence expression for for-each loop\n        for j := 0; j\
    \ < grid[0].length-1; j++ {\n               ^\n/tmp/tmppferea5k.swift:27:13: error:\
    \ cannot call value of non-function type 'Bool'\n    if grid.isEmpty() {\n   \
    \         ^      ~~\n                   \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var count =\
    \ 0\n    var max = 0\n    for row in grid {\n        for col in row {\n      \
    \      if col == 0 {\n                count += 1\n                max = max(max,\
    \ count)\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpybw6zwou.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpybw6zwou.swift:33:23: error: cannot call value of non-function\
    \ type 'Int'\n                max = max(max, count)\n                      ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                count += capacity - bucket\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpfxeld57e/tmpfxeld57e.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f7daa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f7d79ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f7d79a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f7d7997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfxeld57e                        0x0000560204139546 <unavailable> + 5446

    5    libc.so.6                          0x00002b6f7dc8f460 __libc_start_main +
    245

    6    tmpfxeld57e                        0x00005602041390d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    \n    var result = 0\n    \n   \
    \ for _ in 0..<n {\n        \n        let buckets = [Int](repeating: 0, count:\
    \ capacity)\n        \n        for _ in 0..<n {\n            \n            let\
    \ bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \            \n            if bucket == 0 {\n                \n              \
    \  buckets[Int(arc4random_uniform(UInt32(capacity)))] += 1\n                \n\
    \            }\n            \n        }\n        \n        for bucket in buckets\
    \ {\n            \n            if bucket > 0 {\n                \n           \
    \     result += bucket\n                \n            }\n            \n      \
    \  }\n        \n    }\n    \n    return result\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpv5e0mwv0.swift:35:35: error: cannot find 'arc4random_uniform' in\
    \ scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                  ^~~~~~~~~~~~~~~~~~\n/tmp/tmpv5e0mwv0.swift:35:71:\
    \ error: cannot find 'arc4random_uniform' in scope\n            let bucket = grid[Int(arc4random_uniform(UInt32(n)))][Int(arc4random_uniform(UInt32(n)))]\n\
    \                                                                      ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpv5e0mwv0.swift:39:29: error: cannot find 'arc4random_uniform' in scope\n\
    \                buckets[Int(arc4random_uniform(UInt32(capacity)))] += 1\n   \
    \                         ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978665
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var maxCount = 0\n    for row in grid {\n   \
    \     var count = 0\n        for col in row {\n            if col == 1 {\n   \
    \             count += 1\n            }\n        }\n        if count > max {\n\
    \            max = count\n            maxCount = 1\n        } else {\n       \
    \     maxCount *= count\n        }\n    }\n    return maxCount * capacity\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpczlqxxfl/tmpczlqxxfl.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b163b73ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163b435b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163b435988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163b4347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpczlqxxfl                        0x000055a353287546 <unavailable> + 5446

    5    libc.so.6                          0x00002b163b92a460 __libc_start_main +
    245

    6    tmpczlqxxfl                        0x000055a3532870d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var index = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                max += 1\n   \
    \         } else {\n                max += capacity - col\n            }\n   \
    \     }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphemq01qg/tmphemq01qg.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b98a38c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b9872fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b9872f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b9872e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphemq01qg                        0x000055c6fbb62717 <unavailable> + 5911

    5    libc.so.6                          0x00002b7b98c24460 __libc_start_main +
    245

    6    tmphemq01qg                        0x000055c6fbb620d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                result += capacity\n         \
    \   }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpbdmdbcn8/tmpbdmdbcn8.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afab0ad0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afab07c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afab07c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afab07c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbdmdbcn8                        0x000055b9a1248717 <unavailable> + 5911

    5    libc.so.6                          0x00002afab0cbc460 __libc_start_main +
    245

    6    tmpbdmdbcn8                        0x000055b9a12480d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var min = 0\n    \n    for row in 0..<grid.count {\n        for col\
    \ in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n           \
    \     max += capacity\n                min += capacity\n            }\n      \
    \  }\n    }\n    \n    if max < min {\n        return max\n    }\n    \n    return\
    \ min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprqykm0lr/tmprqykm0lr.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b897ad0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b897aa02b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b897aa02988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b897aa017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprqykm0lr                        0x0000556725a538c7 <unavailable> + 6343

    5    libc.so.6                          0x00002b897aef7460 __libc_start_main +
    245

    6    tmprqykm0lr                        0x0000556725a53289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    var max = 0\n    for row in\
    \ grid {\n        for col in row {\n            if col > max {\n             \
    \   max = col\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpb2jbgiuf/tmpb2jbgiuf.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba82f4c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba82f1b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba82f1b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba82f1b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb2jbgiuf                        0x0000558064439546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba82f6ae460 __libc_start_main +
    245

    6    tmpb2jbgiuf                        0x00005580644390d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        var maxRow = 0\n \
    \       for col in row {\n            if col == 1 {\n                maxRow =\
    \ maxRow + 1\n            }\n        }\n        if maxRow > max {\n          \
    \  max = maxRow\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpm77y0_jm/tmpm77y0_jm.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aead337ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aead3071b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aead3071988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aead30707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm77y0_jm                        0x0000560a924f1546 <unavailable> + 5446

    5    libc.so.6                          0x00002aead3566460 __libc_start_main +
    245

    6    tmpm77y0_jm                        0x0000560a924f10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    var min = 0\n    \n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                count += 1\n                max = max(max, col)\n           \
    \     min = min(min, col)\n            }\n        }\n    }\n    \n    if count\
    \ > capacity {\n        return 0\n    }\n    \n    return count - capacity\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4c4lb7n7.swift:33:23: error: cannot call value of non-function\
    \ type 'Int'\n                max = max(max, col)\n                      ^\n/tmp/tmp4c4lb7n7.swift:34:23:\
    \ error: cannot call value of non-function type 'Int'\n                min = min(min,\
    \ col)\n                      ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  count += 1\n                if count > minCapacity {\n                    minCapacity\
    \ = count\n                }\n            }\n        }\n    }\n    return minCapacity\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5nrmfs_z/tmp5nrmfs_z.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af197d37c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af197a2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af197a2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af197a2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5nrmfs_z                        0x000055e653419717 <unavailable> + 5911

    5    libc.so.6                          0x00002af197f23460 __libc_start_main +
    245

    6    tmp5nrmfs_z                        0x000055e6534190d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // TODO: write your code here\n    \n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpd2e5sf68/tmpd2e5sf68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5c8ce1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5c89d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5c89d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5c89d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2e5sf68                        0x00005638e8c453d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ae5c8ecd460 __libc_start_main +
    245

    6    tmpd2e5sf68                        0x00005638e8c44f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    var max = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \               if count > max {\n                    max = count\n          \
    \      }\n            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjy088jmd/tmpjy088jmd.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5df07afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5df04a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5df04a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5df04a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjy088jmd                        0x000055943fa07717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5df099b460 __libc_start_main +
    245

    6    tmpjy088jmd                        0x000055943fa070d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.length == 0 || grid[0].length == 0 {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var maxIndex = 0\n    var maxVal = grid[0][0]\
    \ // first row is max value\n    \n    for i in 1..<grid.length {\n        for\
    \ j in 1..<grid[i].length {\n            if grid[i][j] > maxVal {\n          \
    \      maxVal = grid[i][j]\n                maxIndex = i\n            }\n    \
    \    }\n    }\n    \n    for i in 1..<grid.length {\n        for j in 1..<grid[i].length\
    \ {\n            if grid[i][j] == maxVal {\n                grid[maxIndex][j]\
    \ = capacity // fill bucket with capacity\n                max += capacity - grid[maxIndex][j]\n\
    \            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd5ay0wu9.swift:24:13: error: value of type '[[Int]]' has no member\
    \ 'length'\n    if grid.length == 0 || grid[0].length == 0 {\n       ~~~~ ^~~~~~\n\
    /tmp/tmpd5ay0wu9.swift:24:36: error: value of type '[Int]' has no member 'length'\n\
    \    if grid.length == 0 || grid[0].length == 0 {\n                          \
    \ ~~~~~~~ ^~~~~~\n/tmp/tmpd5ay0wu9.swift:32:23: error: value of type '[[Int]]'\
    \ has no member 'length'\n    for i in 1..<grid.length {\n                 ~~~~\
    \ ^~~~~~\n/tmp/tmpd5ay0wu9.swift:41:23: error: value of type '[[Int]]' has no\
    \ member 'length'\n    for i in 1..<grid.length {\n                 ~~~~ ^~~~~~\n\
    /tmp/tmpd5ay0wu9.swift:33:30: error: reference to member 'length' cannot be resolved\
    \ without a contextual type\n        for j in 1..<grid[i].length {\n         \
    \                    ^\n/tmp/tmpd5ay0wu9.swift:42:30: error: reference to member\
    \ 'length' cannot be resolved without a contextual type\n        for j in 1..<grid[i].length\
    \ {\n                             ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var max = 0\n    var count = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col == 0 {\n                count\
    \ += 1\n            } else {\n                count = 0\n            }\n     \
    \       if count > max {\n                max = count\n            }\n       \
    \ }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkoqngxxo/tmpkoqngxxo.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0f57d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0f54ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0f54ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0f54cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkoqngxxo                        0x0000562d644ae546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac0f59c3460 __libc_start_main +
    245

    6    tmpkoqngxxo                        0x0000562d644ae0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var count = 0\n\
    \        for val in row {\n            if val == 1 {\n                count +=\
    \ 1\n            }\n        }\n        if count > capacity {\n            result\
    \ = count\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpv21ps3j9/tmpv21ps3j9.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc33bd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc338cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc338cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc338cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv21ps3j9                        0x000055a76e176546 <unavailable> + 5446

    5    libc.so.6                          0x00002acc33dc2460 __libc_start_main +
    245

    6    tmpv21ps3j9                        0x000055a76e1760d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    var count = 0\n    var\
    \ max = 0\n    for row in grid {\n        if row[0] > max {\n            max =\
    \ row[0]\n        }\n    }\n    for row in grid {\n        if row[0] > max {\n\
    \            max = row[0]\n        }\n    }\n    for row in grid {\n        if\
    \ row[0] > max {\n            max = row[0]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] > max {\n            max = row[0]\n        }\n    }\n \
    \   for row in grid {\n        if row[0] > max {\n            max = row[0]\n \
    \       }\n    }\n    for row in grid {\n        if row[0] > max {\n         \
    \   max = row[0]\n        }\n    }\n    for row in grid {\n        if row[0] >\
    \ max {\n            max = row[0]\n        }\n    }\n    for row in grid {\n \
    \       if row[0] > max {\n            max = row[0]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] > max {\n            max = row[0]\n       \
    \ }\n    }\n    for row in grid {\n        if row[0] > max {\n            max\
    \ = row[0]\n        }\n    }\n    for row in grid {\n        if row[0] > max {\n\
    \            max = row[0]\n        }\n    }\n    for row in grid {\n        if\
    \ row[0] > max {\n            max = row[0]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] > max {\n            max = row[0]\n        }\n    }\n \
    \   for row in grid {\n        if row[0] > max {\n            max = row[0]\n \
    \       }\n    }\n    for row in grid {\n        if row[0] > max {\n         \
    \   max = row[0]\n        }\n    }\n    for row in grid {\n        if row[0] >\
    \ max {\n            max = row[0]\n        }\n    }\n    for row in grid {\n \
    \       if row[0] > max {\n            max = row[0]\n        }\n    }\n    for\
    \ row in grid {\n        if row[0] > max {\n            max = row[0]\n       \
    \ }\n    }\n    for row in grid {\n        if row[0] > max {\n            max\
    \ = row[0]\n        }\n    }\n    for row in grid {\n        if row[0] > max {\n\
    \            max = row[0]\n        }\n    }\n    for row in grid {\n        if\
    \ row[0] > max {\n            max = row[0]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] > max {\n            max = row[0]\n        }\n    }\n \
    \   for row in grid {\n        if row[0] > max {\n            max = row[0]\n \
    \       }\n    }\n    for row in grid {\n        if row[0] > max {\n         \
    \   \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
    \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1,\
    \ 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpg0dyye0_.swift:166:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpg0dyye0_.swift:144:21:\
    \ note: to match this opening '{'\n    for row in grid {\n                   \
    \ ^\n/tmp/tmpg0dyye0_.swift:166:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmpg0dyye0_.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmpg0dyye0_.swift:150:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpg0dyye0_.swift:27:9:\
    \ warning: initialization of variable 'count' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n  \
    \  _\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        for bucket in\
    \ row {\n            if bucket > max {\n                max = bucket\n       \
    \         maxCount = 1\n            } else {\n                maxCount += 1\n\
    \            }\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgyh64z06.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Write your code here.\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpji6knhbi/tmpji6knhbi.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b98e894ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b98e8645b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b98e8645988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b98e86447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpji6knhbi                        0x0000563f3a6983d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b98e8b3a460 __libc_start_main +
    245

    6    tmpji6knhbi                        0x0000563f3a697f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var minCapacity = capacity\n    for row in\
    \ grid {\n        for bucket in row {\n            if bucket > minCapacity {\n\
    \                minCapacity = bucket\n            }\n        }\n    }\n    for\
    \ row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for bucket in row {\n            if bucket > minCapacity\
    \ {\n                minCapacity = bucket\n            }\n        }\n    }\n \
    \   for row in grid {\n        for \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_x6fv3v6.swift:139:12: error: expected pattern\n        for \n\
    \           ^\n/tmp/tmp_x6fv3v6.swift:139:12: error: expected Sequence expression\
    \ for for-each loop\n        for \n           ^\n/tmp/tmp_x6fv3v6.swift:139:12:\
    \ error: expected '{' to start the body of for-each loop\n        for \n     \
    \      ^\n/tmp/tmp_x6fv3v6.swift:159:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmp_x6fv3v6.swift:23:52:\
    \ note: to match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n                                                   ^\n/tmp/tmp_x6fv3v6.swift:143:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var count = 0\n    var max = 0\n    \n    for i in 0..<grid[0].length {\n\
    \        for j in 0..<grid.count {\n            if grid[j][i] == 0 {\n       \
    \         grid[j][i] = 1\n                count += capacity\n                max\
    \ += capacity\n            }\n        }\n    }\n    \n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzb91vrzs.swift:31:26: error: value of type '[Int]' has no member\
    \ 'length'\n    for i in 0..<grid[0].length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    var min = 0\n    \n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                count += 1\n                if count > max {\n              \
    \      max = count\n                }\n                if count < min {\n    \
    \                min = count\n                }\n            }\n        }\n  \
    \  }\n    \n    return max - min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5vtj4x83/tmp5vtj4x83.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12445f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12442ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12442eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12442ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5vtj4x83                        0x000055ed41da2717 <unavailable> + 5911

    5    libc.so.6                          0x00002b12447e0460 __libc_start_main +
    245

    6    tmp5vtj4x83                        0x000055ed41da20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // init result and bucket array\n    var result = 0\n  \
    \  var buckets = [Int](capacity)\n    \n    // init bucket index\n    var bucketIndex\
    \ = 0\n    \n    // init bucket capacity\n    var bucketCapacity = 0\n    \n \
    \   // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n\
    \    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n\
    \    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init bucket\
    \ sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\
    \ = 0\n    \n    // init bucket sum\n    var bucketSum = 0\n    \n    // init\
    \ bucket sum\n    var bucketSum = 0\n    \n    // init bucket sum\n    var bucketSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq8yangcf.swift:27:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpq8yangcf.swift:39:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:36:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpq8yangcf.swift:42:9: error: invalid redeclaration of 'bucketSum'\n   \
    \ var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:36:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:45:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpq8yangcf.swift:36:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:48:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:36:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpq8yangcf.swift:51:9: error: invalid redeclaration of 'bucketSum'\n   \
    \ var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:36:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:54:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpq8yangcf.swift:36:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:57:9: error: invalid\
    \ redeclaration of 'bucketSum'\n    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:36:9:\
    \ note: 'bucketSum' previously declared here\n    var bucketSum = 0\n        ^\n\
    /tmp/tmpq8yangcf.swift:60:9: error: invalid redeclaration of 'bucketSum'\n   \
    \ var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:36:9: note: 'bucketSum'\
    \ previously declared here\n    var bucketSum = 0\n        ^\n/tmp/tmpq8yangcf.swift:63:9:\
    \ error: invalid redeclaration of 'bucketSum'\n    var bucketSum = 0\n       \
    \ ^\n/tmp/tmpq8yangcf.swift:36:9: note: 'bucketSum' previously declared here\n\
    \    var bucketSu"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well > capacity {\n                count += well - capacity\n\
    \            } else {\n                count = 0\n            }\n        }\n \
    \   }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwv9i1y_3/tmpwv9i1y_3.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab54c261c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab54bf58b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab54bf58988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab54bf577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwv9i1y_3                        0x00005580f6f23546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab54c44d460 __libc_start_main +
    245

    6    tmpwv9i1y_3                        0x00005580f6f230d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var max = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n   \
    \     for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n       \
    \         max += 1\n                if max > capacity {\n                    maxIndex\
    \ = i\n                    break\n                }\n            }\n        }\n\
    \    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjkxhko1k/tmpjkxhko1k.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae46caa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae46c79ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae46c79a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae46c7997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjkxhko1k                        0x00005646fc5b7656 <unavailable> + 5718

    5    libc.so.6                          0x00002ae46cc8f460 __libc_start_main +
    245

    6    tmpjkxhko1k                        0x00005646fc5b71e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n               \
    \ max += 1\n                if max > capacity {\n                    max = capacity\n\
    \                    maxIndex = i\n                }\n            }\n        }\n\
    \    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprknywo31/tmprknywo31.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa394a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa3919cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa3919c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa3919b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprknywo31                        0x000055a3009ef6f6 <unavailable> + 5878

    5    libc.so.6                          0x00002afa39691460 __libc_start_main +
    245

    6    tmprknywo31                        0x000055a3009ef289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    guard capacity > 0\
    \ else { return 0 }\n    \n    var max = 0\n    var maxCount = 0\n    \n    for\
    \ i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if\
    \ grid[i][j] == 1 {\n                grid[i][j] = 0\n                \n      \
    \          let newCount = capacity\n                \n                while newCount\
    \ > 0 {\n                    newCount -= 1\n                    \n           \
    \         if newCount > max {\n                        max = newCount\n      \
    \                  maxCount = i\n                    }\n                    \n\
    \                    if grid[maxCount][j] == 1 {\n                        grid[maxCount][j]\
    \ = 0\n                        break\n                    }\n                }\n\
    \            }\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpktccc3yw.swift:33:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n/tmp/tmpktccc3yw.swift:38:30: error: left side of mutating operator isn't\
    \ mutable: 'newCount' is a 'let' constant\n                    newCount -= 1\n\
    \                    ~~~~~~~~ ^\n/tmp/tmpktccc3yw.swift:35:17: note: change 'let'\
    \ to 'var' to make it mutable\n                let newCount = capacity\n     \
    \           ^~~\n                var\n/tmp/tmpktccc3yw.swift:46:39: error: cannot\
    \ assign through subscript: 'grid' is a 'let' constant\n                     \
    \   grid[maxCount][j] = 0\n                        ~~~~          ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = [Int](capacity)\n    \n    for row in grid {\n      \
    \  for bucket in row {\n            buckets[bucket] += 1\n        }\n    }\n \
    \   \n    for bucket in buckets {\n        if bucket > max {\n            max\
    \ = bucket\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkf5e9zb9.swift:29:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var buckets = [Int](capacity)\n    \n    for row in grid {\n      \
    \  for bucket in row {\n            buckets[bucket] += 1\n        }\n    }\n \
    \   \n    for bucket in buckets {\n        if bucket > max {\n            max\
    \ = bucket\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy42jbs7_.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpy42jbs7_.swift:29:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    \n    // init buckets\n    var buckets\
    \ = [Int](capacity)\n    \n    // init result\n    var result = 0\n    \n    //\
    \ init bucket\n    var bucket: Int = 0\n    \n    // init wells\n    var wells\
    \ = [Int](n) { _ in 0 }\n    \n    // init index\n    var index: Int = 0\n   \
    \ \n    // init index\n    var row: Int = 0\n    \n    // init index\n    var\
    \ col: Int = 0\n    \n    // init index\n    var i: Int = 0\n    \n    // init\
    \ index\n    var j: Int = 0\n    \n    // init index\n    var k: Int = 0\n   \
    \ \n    // init index\n    var l: Int = 0\n    \n    // init index\n    var m:\
    \ Int = 0\n    \n    // init index\n    var n: Int = 0\n    \n    // init index\n\
    \    var o: Int = 0\n    \n    // init index\n    var p: Int = 0\n    \n    //\
    \ init index\n    var q: Int = 0\n    \n    // init index\n    var r: Int = 0\n\
    \    \n    // init index\n    var s: Int = 0\n    \n    // init index\n    var\
    \ t: Int = 0\n    \n    // init index\n    var u: Int = 0\n    \n    // init index\n\
    \    var v: Int = 0\n    \n    // init index\n    var w: Int = 0\n    \n    //\
    \ init index\n    var x: Int = 0\n    \n    // init index\n    var y: Int = 0\n\
    \    \n    // init index\n    var z: Int = 0\n    \n    // init index\n    var\
    \ A: Int = 0\n    \n    // init index\n    var B: Int = 0\n    \n    // init index\n\
    \    var C: Int = 0\n    \n    // init index\n    var D: Int = 0\n    \n    //\
    \ init index\n    var E: Int = 0\n    \n    // init index\n    var F: Int = 0\n\
    \    \n    // init index\n    var G: Int = 0\n    \n    // init index\n    var\
    \ H: Int = 0\n    \n    // init index\n    var I: Int = 0\n    \n    // init index\n\
    \    var J: Int = 0\n    \n    // init index\n    var K: Int = 0\n    \n    //\
    \ init index\n    var L: Int = 0\n    \n    // init index\n    var M: Int = 0\n\
    \    \n    // init index\n    var N: Int = 0\n    \n    // init index\n    var\
    \ O: Int = 0\n    \n    // init index\n    var P: Int = 0\n    \n    // init index\n\
    \    var Q: Int = 0\n    \n    // init index\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpn1l3gl6h.swift:28:25: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var buckets = [Int](capacity)\n                        ^\n    \
    \                    arrayLiteral: \n/tmp/tmpn1l3gl6h.swift:37:22: error: missing\
    \ argument label 'unsafeUninitializedCapacity:' in call\n    var wells = [Int](n)\
    \ { _ in 0 }\n                     ^\n                      unsafeUninitializedCapacity:\
    \ \n/tmp/tmpn1l3gl6h.swift:37:28: error: contextual closure type '(inout UnsafeMutableBufferPointer<Int>,\
    \ inout Int) throws -> Void' expects 2 arguments, but 1 was used in closure body\n\
    \    var wells = [Int](n) { _ in 0 }\n                           ^\n         \
    \                   ,_ \n/tmp/tmpn1l3gl6h.swift:64:9: error: invalid redeclaration\
    \ of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmpn1l3gl6h.swift:25:9: note: 'n'\
    \ previously declared here\n    let n = grid.count\n        ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    let n = grid.count\n    var max = 0\n    \n    for i in\
    \ 0..<n {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n      \
    \          max += capacity\n            }\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn65isjcv/tmpn65isjcv.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac39ced4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac39cbcbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac39cbcb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac39cbca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn65isjcv                        0x000055bf6494f606 <unavailable> + 5638

    5    libc.so.6                          0x00002ac39d0c0460 __libc_start_main +
    245

    6    tmpn65isjcv                        0x000055bf6494f199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1tjgnvj0/tmp1tjgnvj0.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2c92dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2c8fd1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2c8fd1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2c8fd07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1tjgnvj0                        0x000055776210c546 <unavailable> + 5446

    5    libc.so.6                          0x00002ad2c94c6460 __libc_start_main +
    245

    6    tmp1tjgnvj0                        0x000055776210c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if capacity <= 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                max += 1\n                maxCount\
    \ += 1\n            }\n        }\n    }\n    \n    if maxCount > capacity {\n\
    \        return 0\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpr2vo9x2e/tmpr2vo9x2e.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff6e3f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff6e0ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff6e0ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff6e0eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr2vo9x2e                        0x000055fcc18cf546 <unavailable> + 5446

    5    libc.so.6                          0x00002aff6e5e1460 __libc_start_main +
    245

    6    tmpr2vo9x2e                        0x000055fcc18cf0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 && capacity <= 10 else { return 0 }\n    \n\
    \    var max = 0\n    var maxCount = 0\n    \n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            max += capacity\n                maxCount++\n            }\n    \
    \    }\n    }\n    \n    return maxCount > max ? maxCount : max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq9emarwe.swift:33:25: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                maxCount++\n                        ^~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // TODO: write your code here\n    \n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpd2e5sf68/tmpd2e5sf68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5c8ce1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5c89d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5c89d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5c89d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd2e5sf68                        0x00005638e8c453d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ae5c8ecd460 __libc_start_main +
    245

    6    tmpd2e5sf68                        0x00005638e8c44f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var count = 0\n    for row in grid {\n      \
    \  for col in row {\n            if col == 0 {\n                count += 1\n \
    \           } else {\n                count = 0\n            }\n            if\
    \ count > max {\n                max = count\n            }\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe4wvi09e/tmpe4wvi09e.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1abaffbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1abacf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1abacf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1abacf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4wvi09e                        0x000055c55bfe8546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1abb1e7460 __libc_start_main +
    245

    6    tmpe4wvi09e                        0x000055c55bfe80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 && capacity <= 10 else { return 0 }\n    \n\
    \    var max = 0\n    var count = 0\n    \n    for row in grid {\n        if row[0]\
    \ == 0 {\n            count += row[1]\n        } else {\n            count -=\
    \ row[1]\n            if count > max {\n                max = count\n        \
    \    }\n            count = 0\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpee2u8uo2/tmpee2u8uo2.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3cd8232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3cd7f29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3cd7f29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3cd7f287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpee2u8uo2                        0x000055d231a9c596 <unavailable> + 5526

    5    libc.so.6                          0x00002b3cd841e460 __libc_start_main +
    245

    6    tmpee2u8uo2                        0x000055d231a9c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var result\
    \ = 0\n    \n    var minBucket = capacity\n    for row in 0..<grid.count {\n \
    \       for col in 0..<grid[row].count {\n            if grid[row][col] == 1 {\n\
    \                minBucket = minBucket > capacity ? minBucket : capacity\n   \
    \             \n                if minBucket == capacity {\n                 \
    \   result = result + 1\n                }\n                \n               \
    \ minBucket -= 1\n            }\n        }\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9t9_m73p.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return -1\n    }\n    \n\
    \    var count = 0\n    \n    for row in grid {\n        if row[0] == 0 {\n  \
    \          count += row[1]\n        }\n    }\n    \n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsa_4rxsx/tmpsa_4rxsx.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a3e79dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a3e494b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a3e494988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a3e4937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsa_4rxsx                        0x000055680fa4a596 <unavailable> + 5526

    5    libc.so.6                          0x00002b2a3e989460 __libc_start_main +
    245

    6    tmpsa_4rxsx                        0x000055680fa4a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var result = 0\n    \n    for row in grid {\n        var\
    \ count = 0\n        for cell in row {\n            if cell == 1 {\n         \
    \       count += 1\n            }\n        }\n        if count > capacity {\n\
    \            result = count\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_no7y6rp/tmp_no7y6rp.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0025b6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0025862b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0025862988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00258617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_no7y6rp                        0x000055ec8aab6546 <unavailable> + 5446

    5    libc.so.6                          0x00002b0025d57460 __libc_start_main +
    245

    6    tmp_no7y6rp                        0x000055ec8aab60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity > 0 else {\n        return 0\n    }\n    \n   \
    \ var count = 0\n    var max = 0\n    \n    for row in grid {\n        for col\
    \ in row {\n            if col == 0 {\n                count += 1\n          \
    \  }\n        }\n    }\n    \n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                max += 1\n            }\n        }\n\
    \    }\n    \n    return count - max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp0tpvku28/tmp0tpvku28.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b112e0fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b112ddf2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b112ddf2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b112ddf17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0tpvku28                        0x00005652bb5cc546 <unavailable> + 5446

    5    libc.so.6                          0x00002b112e2e7460 __libc_start_main +
    245

    6    tmp0tpvku28                        0x00005652bb5cc0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                count += capacity\n            } else\
    \ {\n                count -= 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpcj61wcqj/tmpcj61wcqj.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31e718ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31e6e81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31e6e81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31e6e807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcj61wcqj                        0x0000557516bf3546 <unavailable> + 5446

    5    libc.so.6                          0x00002b31e7376460 __libc_start_main +
    245

    6    tmpcj61wcqj                        0x0000557516bf30d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    var max = 0\n    \n    for row in grid\
    \ {\n        for col in row {\n            if col > max {\n                max\
    \ = col\n            }\n        }\n    }\n    \n    for row in grid {\n      \
    \  for col in row {\n            if col == max {\n                count += 1\n\
    \            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7ssbid9q/tmp7ssbid9q.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9111efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad910ee6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad910ee6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad910ee57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ssbid9q                        0x000055c9d5096717 <unavailable> + 5911

    5    libc.so.6                          0x00002ad9113db460 __libc_start_main +
    245

    6    tmp7ssbid9q                        0x000055c9d50960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var max = 0\n \
    \       for _ in row {\n            max += capacity\n        }\n        if max\
    \ > result {\n            result = max\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl906buyi/tmpl906buyi.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0530a3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0530731b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0530731988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05307307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl906buyi                        0x0000563fc6b6e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b0530c26460 __libc_start_main +
    245

    6    tmpl906buyi                        0x0000563fc6b6e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for row in grid {\n        for bucket in bucket {\n            buckets[bucket]++\n\
    \        }\n    }\n    for bucket in buckets {\n        if bucket > 0 {\n    \
    \        result += bucket\n            bucket -= 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwlbv7ggv.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmpwlbv7ggv.swift:25:19: error: cannot find 'make' in scope\n\
    \    var buckets = make([][]int, capacity)\n                  ^~~~\n/tmp/tmpwlbv7ggv.swift:25:28:\
    \ error: cannot find 'int' in scope\n    var buckets = make([][]int, capacity)\n\
    \                           ^~~\n/tmp/tmpwlbv7ggv.swift:25:27: error: missing\
    \ argument for parameter #1 in call\n    var buckets = make([][]int, capacity)\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmpwlbv7ggv.swift:27:23:\
    \ error: cannot find 'bucket' in scope\n        for bucket in bucket {\n     \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var count = 0\n    \n    for row in grid {\n        for\
    \ col in row {\n            if col == 1 {\n                count += capacity\n\
    \            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp6bztsd2q/tmp6bztsd2q.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b3a170c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b39e67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b39e67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b39e667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6bztsd2q                        0x000055fd6fa42717 <unavailable> + 5911

    5    libc.so.6                          0x00002b6b3a35c460 __libc_start_main +
    245

    6    tmp6bztsd2q                        0x000055fd6fa420d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count == 1 else {\n        return 0\n    }\n    \n\
    \    var max = 0\n    var maxCount = 0\n    var maxIndex = 0\n    \n    for i\
    \ in 0..<grid[0].length {\n        for j in 0..<grid.count {\n            if grid[j][i]\
    \ == 0 {\n                grid[j][i] = 1\n                \n                if\
    \ capacity > max {\n                    max = capacity\n                    maxCount\
    \ = 1\n                    maxIndex = j\n                } else {\n          \
    \          maxCount += 1\n                }\n            }\n        }\n    }\n\
    \    \n    return maxCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvu3jz3pp.swift:32:26: error: value of type '[Int]' has no member\
    \ 'length'\n    for i in 0..<grid[0].length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        if row[0] == 0\
    \ {\n            result += row[1]\n        }\n    }\n    for row in grid {\n \
    \       if row[0] == 1 {\n            result += row[1]\n        }\n    }\n   \
    \ for row in grid {\n        if row[0] == 2 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 3 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 4 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 5 {\n            result += row[1]\n        }\n    }\n\
    \    for row in grid {\n        if row[0] == 6 {\n            result += row[1]\n\
    \        }\n    }\n    for row in grid {\n        if row[0] == 7 {\n         \
    \   result += row[1]\n        }\n    }\n    for row in grid {\n        if row[0]\
    \ == 8 {\n            result += row[1]\n        }\n    }\n    for row in grid\
    \ {\n        if row[0] == 9 {\n            result += row[1]\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpeps59ap5/tmpeps59ap5.swift:91: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab61d36ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab61d065b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab61d065988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab61d0647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeps59ap5                        0x000055d0e42ea596 <unavailable> + 5526

    5    libc.so.6                          0x00002ab61d55a460 __libc_start_main +
    245

    6    tmpeps59ap5                        0x000055d0e42ea129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        var index =\
    \ 0\n        for _ in row {\n            if index == capacity {\n            \
    \    index = 0\n            }\n            \n            if row[index] == 1 {\n\
    \                index++\n            }\n        }\n        \n        if index\
    \ > max {\n            max = index\n            maxIndex = row\n        }\n  \
    \  }\n    \n    return maxIndex.count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj1bg_4xl.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpj1bg_4xl.swift:39:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                index++\n                     ^~\n/tmp/tmpj1bg_4xl.swift:45:24:\
    \ error: cannot assign value of type '[Int]' to type 'Int'\n            maxIndex\
    \ = row\n                       ^~~\n/tmp/tmpj1bg_4xl.swift:49:21: error: value\
    \ of type 'Int' has no member 'count'\n    return maxIndex.count\n           ~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count {\n        for\
    \ col in 0..<grid[row].count {\n            if grid[row][col] == 0 {\n       \
    \         grid[row][col] = capacity\n                \n                if capacity\
    \ > max {\n                    max = capacity\n                    maxIndex =\
    \ row\n                }\n                \n                capacity -= 1\n  \
    \          }\n        }\n    }\n    \n    return maxIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppxwk5o7q.swift:34:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = capacity\n           \
    \     ~~~~     ^\n/tmp/tmppxwk5o7q.swift:41:26: error: left side of mutating operator\
    \ isn't mutable: 'capacity' is a 'let' constant\n                capacity -= 1\n\
    \                ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        if row[0] == 0 {\n\
    \            count += row[1]\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpbeapu3n6/tmpbeapu3n6.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd581a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd57e9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd57e9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd57e9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbeapu3n6                        0x0000561dc9154596 <unavailable> + 5526

    5    libc.so.6                          0x00002acd58394460 __libc_start_main +
    245

    6    tmpbeapu3n6                        0x0000561dc9154129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978665
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    for row in grid {\n        for col in row {\n\
    \            if col > max {\n                max = col\n            }\n      \
    \  }\n    }\n    var count = 0\n    for row in grid {\n        for col in row\
    \ {\n            if col > 0 {\n                count += 1\n                col\
    \ -= max\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpi8drb92c.swift:37:21: error: left side of mutating operator isn't\
    \ mutable: 'col' is a 'let' constant\n                col -= max\n           \
    \     ~~~ ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for col in row\
    \ {\n            if col == 0 {\n                result += capacity\n         \
    \   } else {\n                result -= capacity\n            }\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxvphzcut/tmpxvphzcut.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95a739ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95a7091b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95a7091988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95a70907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxvphzcut                        0x0000557ad7e1a546 <unavailable> + 5446

    5    libc.so.6                          0x00002b95a7586460 __libc_start_main +
    245

    6    tmpxvphzcut                        0x0000557ad7e1a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978665
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Write your code here.\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpji6knhbi/tmpji6knhbi.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b98e894ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b98e8645b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b98e8645988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b98e86447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpji6knhbi                        0x0000563f3a6983d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b98e8b3a460 __libc_start_main +
    245

    6    tmpji6knhbi                        0x0000563f3a697f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var buckets = make([][]int, capacity)\n  \
    \  for _, row := range grid {\n        for _, bucket := range row {\n        \
    \    buckets[bucket]++\n        }\n    }\n    for _, bucket := range buckets {\n\
    \        if bucket > 0 {\n            result += 1\n            bucket -= 1\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3bvl4mt9.swift:25:28: error: expected ',' separator\n    var buckets\
    \ = make([][]int, capacity)\n                           ^\n                  \
    \         ,\n/tmp/tmp3bvl4mt9.swift:26:10: error: expected 'in' after for-each\
    \ pattern\n    for _, row := range grid {\n         ^\n/tmp/tmp3bvl4mt9.swift:26:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, row := range\
    \ grid {\n         ^\n/tmp/tmp3bvl4mt9.swift:27:14: error: expected 'in' after\
    \ for-each pattern\n        for _, bucket := range row {\n             ^\n/tmp/tmp3bvl4mt9.swift:27:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, bucket\
    \ := range row {\n             ^\n/tmp/tmp3bvl4mt9.swift:31:10: error: expected\
    \ 'in' after for-each pattern\n    for _, bucket := range buckets {\n        \
    \ ^\n/tmp/tmp3bvl4mt9.swift:31:10: error: expected Sequence expression for for-each\
    \ loop\n    for _, bucket := range buckets {\n         ^\n/tmp/tmp3bvl4mt9.swift:25:19:\
    \ error: cannot find 'make' in scope\n    var buckets = make([][]int, capacity)\n\
    \                  ^~~~\n/tmp/tmp3bvl4mt9.swift:25:28: error: cannot find 'int'\
    \ in scope\n    var buckets = make([][]int, capacity)\n                      \
    \     ^~~\n/tmp/tmp3bvl4mt9.swift:25:27: error: missing argument for parameter\
    \ #1 in call\n    var buckets = make([][]int, capacity)\n                    \
    \      ^\n                          <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)'\
    \ declared here\n    @inlinable public subscript(index: Int) -> Element { get\
    \ set }\n                      ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // write your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsb9pt9i9/tmpsb9pt9i9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba519a6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba519762b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba519762988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5197617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb9pt9i9                        0x0000555fd59013d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ba519c57460 __libc_start_main +
    245

    6    tmpsb9pt9i9                        0x0000555fd5900f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        for bucket in row\
    \ {\n            if bucket > capacity {\n                result += capacity -\
    \ bucket\n            } else {\n                result += bucket\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplavb_nuk/tmplavb_nuk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c65a1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c65711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c65711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c657107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplavb_nuk                        0x0000562a40a00717 <unavailable> + 5911

    5    libc.so.6                          0x00002b5c65c06460 __libc_start_main +
    245

    6    tmplavb_nuk                        0x0000562a40a000d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824578
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    var max = 0\n\
    \    var maxIndex = 0\n    for row in grid {\n        for col in row {\n     \
    \       if col > max {\n                max = col\n                maxIndex =\
    \ row.startIndex\n            }\n        }\n    }\n    if maxIndex == 0 {\n  \
    \      return 0\n    }\n    var count = 0\n    for row in grid {\n        for\
    \ col in row {\n            if col == 0 {\n                count += 1\n      \
    \      }\n        }\n    }\n    if count > capacity {\n        return count\n\
    \    }\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 0 {\n                grid[row.startIndex][col] = max\n                count\
    \ -= capacity\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpl82r0p6z.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpl82r0p6z.swift:54:37: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                grid[row.startIndex][col] = max\n\
    \                ~~~~                ^\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    \n    for row in grid {\n        var count =\
    \ 0\n        for cell in row {\n            if cell == 1 {\n                count\
    \ += 1\n            }\n        }\n        if count > max {\n            max =\
    \ count\n            maxCount = 1\n        } else if count == max {\n        \
    \    maxCount += 1\n        }\n    }\n    \n    return maxCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpt2e6jt6w.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978664
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Write your code here.\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpji6knhbi/tmpji6knhbi.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b98e894ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b98e8645b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b98e8645988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b98e86447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpji6knhbi                        0x0000563f3a6983d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b98e8b3a460 __libc_start_main +
    245

    6    tmpji6knhbi                        0x0000563f3a697f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978663
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxIndex = 0\n    \n    for row in grid {\n        if row[0] ==\
    \ 0 {\n            continue\n        }\n        \n        var index = row[0]\n\
    \        \n        for _ in 1...row[0] {\n            index = index * capacity\
    \ + row[1]\n        }\n        \n        if index > max {\n            max = index\n\
    \            maxIndex = index\n        }\n    }\n    \n    return maxIndex\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp93j2s9xv/tmp93j2s9xv.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe171b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe16eb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe16eb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe16eaf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp93j2s9xv                        0x000055d3ced8a776 <unavailable> + 6006

    5    libc.so.6                          0x00002afe173a5460 __libc_start_main +
    245

    6    tmp93j2s9xv                        0x000055d3ced8a309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978665
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for row in grid {\n        var max = 0\n  \
    \      for col in row {\n            if col > max {\n                max = col\n\
    \            }\n        }\n        if max > capacity {\n            count = 0\n\
    \        } else {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmplnumkhyd/tmplnumkhyd.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0a49ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0a46e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0a46e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0a46e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplnumkhyd                        0x00005584886c3546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae0a4bd8460 __libc_start_main +
    245

    6    tmplnumkhyd                        0x00005584886c30d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty() {\n        return 0\n    }\n    \n    var max\
    \ = 0\n    var maxCount = 0\n    var maxIndex = 0\n    \n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                max += capacity\n                maxCount += 1\n      \
    \          if maxCount > max {\n                    max = maxCount\n         \
    \           maxIndex = row\n                }\n            }\n        }\n    }\n\
    \    \n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprl8_bj85.swift:24:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if grid.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1659978664
