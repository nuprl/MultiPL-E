name: HumanEval_18_how_many_times
language: swift
prompt: "\n/// Find how many times a given substring can be found in the original\
  \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
  \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
  \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string:\
  \ String, substring: String) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(how_many_times(string: \"\", substring:\
  \ \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") ==\
  \ 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
  \ \"john doe\", substring: \"john\") == 1)"
completions: ["    if string == \"\" {\n        return 0\n    }\n    if substring\
    \ == \"\" {\n        return 1\n    }\n    var count = 0\n    var i = 0\n    var\
    \ j = string.count\n    var k = substring.count\n    while i < j {\n        if\
    \ string[i] == substring[k] {\n            count += 1\n            i += k\n  \
    \          k += k\n        }\n        i += 1\n    }\n    return count", '    return
    count_occurrences(string, substring)', "    if string == \"\" {\n        return\
    \ 0\n    }\n    if substring == \"\" {\n        return 1\n    }\n    if string.hasPrefix(substring)\
    \ {\n        return 1 + how_many_times(string[string.startIndex..<string.endIndex],\
    \ substring)\n    }\n    if string.hasSuffix(substring) {\n        return 1 +\
    \ how_many_times(string[string.endIndex..<string.startIndex], substring)\n   \
    \ }\n    if string.hasPrefix(substring) || string.hasSuffix(substring) {\n   \
    \     return how_many_times(string[string.startIndex..<string.endIndex], substring)\
    \ + how_many_times(string[string.endIndex..<string.startIndex], substring)\n \
    \   }\n    return 0", "    if string == \"\" || substring == \"\" {\n        return\
    \ 0\n    }\n    var count = 0\n    var start = 0\n    var end = string.characters.count\n\
    \    while start < end {\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n        if index == nil {\n            break\n \
    \       }\n        start = index!\n        end = start\n        count += 1\n \
    \   }\n    return count", "    if string == \"\" {\n        return 0\n    }\n\
    \    if substring == \"\" {\n        return count(string)\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.startIndex\n    while i < string.endIndex\
    \ && j < string.endIndex {\n        if string[i] == substring[0] {\n         \
    \   count += 1\n            i += substring.length - 1\n        } else {\n    \
    \        i += 1\n        }\n        j += 1\n    }\n    return count", "    if\
    \ string.hasSuffix(substring) {\n        return string.countSubstrings(substring)\n\
    \    } else {\n        return string.countSubstrings(substring) + 1\n    }", '    return
    string.countSubstrings(substring)', '    return count_overlapping_cases(string,
    substring)', "    if string == \"\" {\n        return 0\n    }\n    if substring\
    \ == \"\" {\n        return count(string)\n    }\n    var count = 0\n    var i\
    \ = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[k] {\n            count\
    \ += 1\n        }\n        i += 1\n        k += 1\n    }\n    return count", " \
    \   if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n\
    \        return 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += how_many_times(string: String(string[i..<k]), substring:\
    \ String(substring[1..<string.count]))\n            i += k\n            k += string.count\n\
    \        }\n        i += 1\n    }\n    return count", '    return count(string,
    substring)', '    return count_overlapping_cases(string, substring)', "    var\
    \ count = 0\n    for s in string.split(substring) {\n        if s == substring\
    \ {\n            count += 1\n        }\n    }\n    return count", "    if string\
    \ == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n \
    \   var l = 0\n    var m = string.characters.count\n    var n = substring.characters.count\n\
    \    while i < m && j < n {\n        if string.characters[i] == substring.characters[j]\
    \ {\n            count += 1\n            i += 1\n            j += 1\n        }\
    \ else if string.characters[i] == substring.characters[j] {\n            count\
    \ += 1\n            i += 1\n        } else {\n            j += 1\n        }\n\
    \    }\n    if i < m {\n        while i < m {\n            if string.characters[i]\
    \ == substring.characters[j] {\n                count += 1\n                i\
    \ += 1\n            } else {\n                i += 1\n            }\n        }\n\
    \    }\n    if j < n {\n        while j < n {\n            if string.characters[i]\
    \ == substring.characters[j] {\n                count += 1\n                j\
    \ += 1\n            } else {\n                j += 1\n            }\n        }\n\
    \    }\n    return count", "    if string == \"\" {\n        return 0\n    }\n\
    \    if substring == \"\" {\n        return count(string)\n    }\n    var count\
    \ = 0\n    var startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count\
    \ {\n        endIndex = string.index(substring, startIndex)\n        if endIndex\
    \ == startIndex {\n            count += 1\n            startIndex += 1\n     \
    \       continue\n        }\n        count += 1\n        startIndex = endIndex\
    \ + 1\n    }\n    return count", '    return count(string, substring)', "    if\
    \ string.hasSuffix(substring) {\n        return string.countSubstrings(substring)\n\
    \    }\n    return string.countSubstrings(substring) + 1", "    if string == \"\
    \" {\n        return 0\n    }\n    if substring == \"\" {\n        return 1\n\
    \    }\n    var count = 0\n    var i = 0\n    var j = string.count\n    var k\
    \ = substring.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            i++\n            count++\n            while i < j && string[i] ==\
    \ substring[1] {\n                i++\n                count++\n            }\n\
    \        } else {\n            i++\n        }\n    }\n    return count", "   \
    \ if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n \
    \       return count(string)\n    }\n    var count = 0\n    var start = 0\n  \
    \  var end = count(string)\n    while start < end {\n        start = string.startIndex.advanced(by:\
    \ 1)\n        end = string.endIndex.advanced(by: -1)\n        if string.substring(from:\
    \ start, to: end) == substring {\n            count += 1\n        }\n    }\n \
    \   return count", "    if string == \"\" {\n        return 0\n    }\n    if substring\
    \ == \"\" {\n        return string.count\n    }\n    var count = 0\n    var i\
    \ = 0\n    var j = string.count\n    var k = substring.count\n    while i < j\
    \ {\n        if string[i] == substring[0] {\n            count += 1\n        \
    \    i += k\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ count"]
stop_tokens:
- "\n}"
