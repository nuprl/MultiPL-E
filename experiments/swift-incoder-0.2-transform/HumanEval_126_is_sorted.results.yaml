language: swift
name: HumanEval_126_is_sorted
results:
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if num != last {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp17kn8ayt/tmp17kn8ayt.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9778d32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9778a29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9778a29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9778a287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp17kn8ayt                        0x000055629894e45a <unavailable> + 5210

    5    libc.so.6                          0x00002b9778f1e460 __libc_start_main +
    245

    6    tmp17kn8ayt                        0x000055629894e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst.contains(&lst[0]) {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx4o6qhsy.swift:29:21: error: '&' used with non-inout argument of\
    \ type 'Int'\n    if lst.contains(&lst[0]) {\n                    ^~~~~~~\n  \
    \                  \n/tmp/tmpx4o6qhsy.swift:29:21: error: cannot pass immutable\
    \ value as inout argument: 'lst' is a 'let' constant\n    if lst.contains(&lst[0])\
    \ {\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmptrpm5896/tmptrpm5896.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2bef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab2bbe8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab2bbe8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab2bbe77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptrpm5896                        0x000055bebcbab697 <unavailable> + 5783

    5    libc.so.6                          0x00002aab2c0dd460 __libc_start_main +
    245

    6    tmptrpm5896                        0x000055bebcbab249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpanu4fu2b/tmpanu4fu2b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f807b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f804a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f804a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f804a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpanu4fu2b                        0x000055fb5c37c4c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b4f8099d460 __libc_start_main +
    245

    6    tmpanu4fu2b                        0x000055fb5c37c079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] == nil {\n            seen[num] = true\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9uwofnmc.swift:25:22: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[num] == nil {\n  \
    \         ~~~~~~~~~ ^  ~~~\n/tmp/tmp9uwofnmc.swift:26:25: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[num] = true\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        let first = lst[0]\n        var seen = Set<Int>()\n\
    \        for v in lst {\n            if seen.contains(v) {\n                return\
    \ false\n            }\n            seen.insert(v)\n        }\n        return\
    \ true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpcz01adph/tmpcz01adph.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6013d2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6013a25b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6013a25988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6013a247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcz01adph                        0x000055d76c9a87f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b6013f1a460 __libc_start_main +
    245

    6    tmpcz01adph                        0x000055d76c9a82d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet set = Set(lst)\n\treturn\
    \ set.count == lst.count && set.sorted() == lst\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp3l91ydsm/tmp3l91ydsm.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5d138cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5d1083b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5d1083988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5d10827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3l91ydsm                        0x000055e4e0875f43 <unavailable> + 8003

    5    libc.so.6                          0x00002af5d1578460 __libc_start_main +
    245

    6    tmp3l91ydsm                        0x000055e4e0875209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst[1..<lst.count])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4e1y_dir.swift:32:30: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst[1..<lst.count])\n\
    \                             ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for num in lst {\n        if seen.contains(num) {\n            return false\n\
    \        }\n        seen.insert(num)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpij5b1ea0/tmpij5b1ea0.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b715df68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b715dc5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b715dc5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b715dc5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpij5b1ea0                        0x000055a3667e7746 <unavailable> + 5958

    5    libc.so.6                          0x00002b715e154460 __libc_start_main +
    245

    6    tmpij5b1ea0                        0x000055a3667e7229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    return\
    \ set.count == lst.count && set.sorted() == true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_hru_w62.swift:24:51: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                     ~~~~~~~~~~~~ ^  ~~~~\n\
    /tmp/tmp_hru_w62.swift:24:51: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Bool, Bool)\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                                  ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpanu4fu2b/tmpanu4fu2b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f807b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f804a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f804a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f804a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpanu4fu2b                        0x000055fb5c37c4c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b4f8099d460 __libc_start_main +
    245

    6    tmpanu4fu2b                        0x000055fb5c37c079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var lastCount: Int = 0\n\
    \    for num in lst {\n        if num == last {\n            lastCount++\n   \
    \     } else {\n            last = num\n            lastCount = 1\n        }\n\
    \    }\n    return lastCount <= 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu4vcv1h1.swift:30:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lastCount++\n                     ^~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    var cur: Int = 0\n    for\
    \ cur in lst {\n        if prev > cur {\n            return false\n        }\n\
    \        prev = cur\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpigw6af3a/tmpigw6af3a.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fdb395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fdb08cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fdb08c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fdb08b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpigw6af3a                        0x000055ce463b6c7b <unavailable> + 7291

    5    libc.so.6                          0x00002b6fdb581460 __libc_start_main +
    245

    6    tmpigw6af3a                        0x000055ce463b6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if !seen.contains(num) {\n                seen.append(num)\n    \
    \        } else {\n                return false\n            }\n        }\n  \
    \      return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpl7zh3b7h/tmpl7zh3b7h.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1566603c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15662fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15662fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15662f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl7zh3b7h                        0x0000562fbaff5766 <unavailable> + 5990

    5    libc.so.6                          0x00002b15667ef460 __libc_start_main +
    245

    6    tmpl7zh3b7h                        0x0000562fbaff5249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if num != last {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp17kn8ayt/tmp17kn8ayt.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9778d32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9778a29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9778a29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9778a287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp17kn8ayt                        0x000055629894e45a <unavailable> + 5210

    5    libc.so.6                          0x00002b9778f1e460 __libc_start_main +
    245

    6    tmp17kn8ayt                        0x000055629894e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen.contains(v) {\n                seen.append(v)\n    \
    \        }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp7x967tk0/tmp7x967tk0.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af89ffc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af89fcbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af89fcbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af89fcbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7x967tk0                        0x0000560eb304061a <unavailable> + 5658

    5    libc.so.6                          0x00002af8a01b2460 __libc_start_main +
    245

    6    tmp7x967tk0                        0x0000560eb3040299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tswitch lst.count {\n\tcase\
    \ 0:\n\t\treturn true\n\tcase 1:\n\t\treturn lst[0] < lst[0]\n\tdefault:\n\t\t\
    let last = lst.last!\n\t\tvar i = 0\n\t\tvar j = lst.count - 1\n\t\tvar sorted\
    \ = false\n\t\twhile i < j {\n\t\t\tif lst[i] < last {\n\t\t\t\tsorted = true\n\
    \t\t\t\tbreak\n\t\t\t}\n\t\t\ti += 1\n\t\t}\n\t\tif !sorted {\n\t\t\treturn false\n\
    \t\t}\n\t\ti = j\n\t\twhile i < lst.count {\n\t\t\tif lst[i] != last {\n\t\t\t\
    \treturn false\n\t\t\t}\n\t\t\ti += 1\n\t\t}\n\t\treturn true\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp9ubu1ywc/tmp9ubu1ywc.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b814347dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8143174b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8143174988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81431737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ubu1ywc                        0x000055f4e89e34ca <unavailable> + 5322

    5    libc.so.6                          0x00002b8143669460 __libc_start_main +
    245

    6    tmp9ubu1ywc                        0x000055f4e89e3149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1tk3ahmo/tmp1tk3ahmo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b265a721c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b265a418b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b265a418988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b265a4177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1tk3ahmo                        0x000055f5b5605646 <unavailable> + 5702

    5    libc.so.6                          0x00002b265a90d460 __libc_start_main +
    245

    6    tmp1tk3ahmo                        0x000055f5b5605129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return true\n    }\n    if lst.count > 2 {\n\
    \        return false\n    }\n    if lst[0] != lst[1] {\n        return false\n\
    \    }\n    return is_sorted(lst[1..<lst.count])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprrpw4lvw.swift:38:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmprrpw4lvw.swift:38:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen.contains(v) {\n                seen.append(v)\n    \
    \        }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp7x967tk0/tmp7x967tk0.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af89ffc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af89fcbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af89fcbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af89fcbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7x967tk0                        0x0000560eb304061a <unavailable> + 5658

    5    libc.so.6                          0x00002af8a01b2460 __libc_start_main +
    245

    6    tmp7x967tk0                        0x0000560eb3040299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    guard lst.count <= lst.max() else { return false }\n  \
    \  var last: Int = 0\n    for x in lst {\n        if x == last {\n           \
    \ return false\n        }\n        last = x\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmjzquzop.swift:24:28: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard lst.count <= lst.max() else\
    \ { return false }\n                           ^\n/tmp/tmpmjzquzop.swift:24:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard lst.count <= lst.max() else { return false }\n            \
    \               ^\n                                 ?? <#default value#>\n/tmp/tmpmjzquzop.swift:24:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard lst.count <= lst.max() else { return false }\n            \
    \               ^\n                                !\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var seen = [Int]()\n    for x in lst {\n        if seen[x\
    \ - 1] != nil {\n            return false\n        } else {\n            seen[x\
    \ - 1] = true\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpw7k_iif9.swift:26:24: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns true\n        if seen[x - 1] != nil {\n \
    \          ~~~~~~~~~~~ ^  ~~~\n/tmp/tmpw7k_iif9.swift:29:27: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[x - 1] = true\n\
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst: lst[1..<lst.count])\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0vjnwmaz.swift:30:34: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n        return is_sorted(lst: lst[1..<lst.count])\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen[num] == true {\n                return false\n          \
    \  }\n            seen[num] = true\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp87w0kv6i.swift:32:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'Bool'\n            if seen[num] == true {\n \
    \              ~~~~~~~~~ ^  ~~~~\n/tmp/tmp87w0kv6i.swift:32:26: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool),\
    \ (Int, Int)\n            if seen[num] == true {\n                         ^\n\
    /tmp/tmp87w0kv6i.swift:35:25: error: cannot assign value of type 'Bool' to subscript\
    \ of type 'Int'\n            seen[num] = true\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return true\n    }\n    if lst.count == 3 {\n\
    \        return true\n    }\n    if lst.count == 4 {\n        return true\n  \
    \  }\n    if lst.count == 5 {\n        return true\n    }\n    if lst.count ==\
    \ 6 {\n        return true\n    }\n    if lst.count == 7 {\n        return true\n\
    \    }\n    if lst.count == 8 {\n        return true\n    }\n    if lst.count\
    \ == 9 {\n        return true\n    }\n    if lst.count == 10 {\n        return\
    \ true\n    }\n    if lst.count == 11 {\n        return true\n    }\n    if lst.count\
    \ == 12 {\n        return true\n    }\n    if lst.count == 13 {\n        return\
    \ true\n    }\n    if lst.count == 14 {\n        return true\n    }\n    if lst.count\
    \ == 15 {\n        return true\n    }\n    if lst.count == 16 {\n        return\
    \ true\n    }\n    if lst.count == 17 {\n        return true\n    }\n    if lst.count\
    \ == 18 {\n        return true\n    }\n    if lst.count == 19 {\n        return\
    \ true\n    }\n    if lst.count == 20 {\n        return true\n    }\n    if lst.count\
    \ == 21 {\n        return true\n    }\n    if lst.count == 22 {\n        return\
    \ true\n    }\n    if lst.count == 23 {\n        return true\n    }\n    if lst.count\
    \ == 24 {\n        return true\n    }\n    if lst.count == 25 {\n        return\
    \ true\n    }\n    if lst.count == 26 {\n        return true\n    }\n    if lst.count\
    \ == 27 {\n        return true\n    }\n    if lst.count == 28 {\n        return\
    \ true\n    }\n    if lst.count == 29 {\n        return true\n    }\n    if lst.count\
    \ == 30 {\n        return true\n    }\n    if lst.count == 31 {\n        return\
    \ true\n    }\n    if lst.count == 32 {\n        return true\n    }\n    if lst.count\
    \ == 33 {\n        return true\n    }\n    if lst.count == 34 {\n        return\
    \ true\n    }\n    if lst.count == 35 {\n        return true\n    }\n    if lst.count\
    \ == 36 {\n        return true\n    }\n    if lst.count == 37 {\n        return\
    \ true\n    }\n    if lst.count == 38 {\n        return true\n    }\n    if lst.count\
    \ == 39 {\n        return true\n    }\n    if lst.count == 40 {\n        return\
    \ true\n    }\n    if lst.count == 41 {\n        return true\n    }\n    if lst.count\
    \ == 42 {\n        return true\n    }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7dwmgmgh.swift:152:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var set = Set<Int>()\n  \
    \  for num in lst {\n        if !set.contains(num) {\n            set.insert(num)\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpmj0anv9s/tmpmj0anv9s.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf2fa1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf2f716b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf2f716988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf2f7157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmj0anv9s                        0x000055ccd8371746 <unavailable> + 5958

    5    libc.so.6                          0x00002acf2fc0b460 __libc_start_main +
    245

    6    tmpmj0anv9s                        0x000055ccd8371229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        return false\n    }\n    if lst[0] != lst[1]\
    \ {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgv5jzb5y.swift:35:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpgv5jzb5y.swift:35:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    if lst[0] < lst[1]\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aba30d01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba309f8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aba309f8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aba309f813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aba309f7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aba307f7e83 <unavailable> + 188035

    6    tmpkfsjws_j                        0x000055f93824bed0 <unavailable> + 7888

    7    tmpkfsjws_j                        0x000055f93824b325 <unavailable> + 4901

    8    libc.so.6                          0x00002aba30eed460 __libc_start_main +
    245

    9    tmpkfsjws_j                        0x000055f93824b019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] != nil {\n            return false\n    \
    \    }\n        seen[num] = num\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae257fe1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae257cd8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae257cd8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae257cd813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae257cd7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae257ad7e83 <unavailable> + 188035

    6    tmpx8xg2jtv                        0x00005570a20ef137 <unavailable> + 8503

    7    tmpx8xg2jtv                        0x00005570a20ee4e5 <unavailable> + 5349

    8    libc.so.6                          0x00002ae2581cd460 __libc_start_main +
    245

    9    tmpx8xg2jtv                        0x00005570a20ee1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpi_8ph5jg/tmpi_8ph5jg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5aed0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5aea03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5aea03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5aea027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_8ph5jg                        0x0000563bf87e7646 <unavailable> + 5702

    5    libc.so.6                          0x00002ad5aeef8460 __libc_start_main +
    245

    6    tmpi_8ph5jg                        0x0000563bf87e7129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] < lst[0]\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen.contains(v) {\n                seen.append(v)\n    \
    \        }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp8juh7ttp/tmp8juh7ttp.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af459744c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af45943bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af45943b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af45943a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8juh7ttp                        0x0000558d20fe861a <unavailable> + 5658

    5    libc.so.6                          0x00002af459930460 __libc_start_main +
    245

    6    tmp8juh7ttp                        0x0000558d20fe8299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return lst.sorted() == lst\n    }\n    if lst.count\
    \ == 3 {\n        return lst.sorted() == lst && lst.sorted() == lst\n    }\n \
    \   if lst.count == 4 {\n        return lst.sorted() == lst && lst.sorted() ==\
    \ lst && lst.sorted() == lst\n    }\n    if lst.count == 5 {\n        return lst.sorted()\
    \ == lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst\n\
    \    }\n    if lst.count == 6 {\n        return lst.sorted() == lst && lst.sorted()\
    \ == lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst\n\
    \    }\n    if lst.count == 7 {\n        return lst.sorted() == lst && lst.sorted()\
    \ == lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst\
    \ && lst.sorted() == lst\n    }\n    if lst.count == 8 {\n        return lst.sorted()\
    \ == lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst\
    \ && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst\n    }\n\
    \    if lst.count == 9 {\n        return lst.sorted() == lst && lst.sorted() ==\
    \ lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst &&\
    \ lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst\n    }\n \
    \   if lst.count == 10 {\n        return lst.sorted() == lst && lst.sorted() ==\
    \ lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst &&\
    \ lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted()\
    \ == lst\n    }\n    if lst.count == 11 {\n        return lst.sorted() == lst\
    \ && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted()\
    \ == lst && lst.sorted() == lst && lst.sorted() == lst && lst.sorted() == lst\
    \ && lst.sorted() == lst && lst.sorted() == lst\n    }\n    if lst.count == 12\
    \ {\n        return lst.sorted() == lst && lst.sorted(\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsope10_e.swift:61:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpsope10_e.swift:88:45: error: expected '}' at end of brace statement\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)\n                               \
    \             ^\n/tmp/tmpsope10_e.swift:22:36: note: to match this opening '{'\n\
    func is_sorted(lst: [Int]) -> Bool {\n                                   ^\n/tmp/tmpsope10_e.swift:60:43:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Bool'\n\
    \        return lst.sorted() == lst && lst.sorted(\n                         \
    \                 ^\n/tmp/tmpsope10_e.swift:64:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if seen[v] == nil {\n                seen[v] = true\n       \
    \         return false\n            }\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnmwy2l27.swift:32:24: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n            if seen[v] == nil {\n\
    \               ~~~~~~~ ^  ~~~\n/tmp/tmpnmwy2l27.swift:33:27: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n                seen[v] = true\n\
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                return false\n          \
    \  }\n            seen.append(v)\n        }\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_sa53cn5/tmp_sa53cn5.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab24caeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab24c7e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab24c7e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab24c7e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_sa53cn5                        0x000055cced851697 <unavailable> + 5783

    5    libc.so.6                          0x00002ab24ccd6460 __libc_start_main +
    245

    6    tmp_sa53cn5                        0x000055cced851249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if num != last {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp17kn8ayt/tmp17kn8ayt.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9778d32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9778a29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9778a29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9778a287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp17kn8ayt                        0x000055629894e45a <unavailable> + 5210

    5    libc.so.6                          0x00002b9778f1e460 __libc_start_main +
    245

    6    tmp17kn8ayt                        0x000055629894e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aebbfe7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebbfb75561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aebbfb75286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aebbfb7513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aebbfb74bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aebbf974e83 <unavailable> + 188035

    6    tmpoy5_v_kj                        0x0000556a4b5f8153 <unavailable> + 8531

    7    tmpoy5_v_kj                        0x0000556a4b5f74e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aebc006a460 __libc_start_main +
    245

    9    tmpoy5_v_kj                        0x0000556a4b5f71d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    if lst[0] < lst[1]\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqhlcw1a8/tmpqhlcw1a8.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b239d6c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b239d3bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b239d3bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b239d3ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqhlcw1a8                        0x000055b390c4d467 <unavailable> + 5223

    5    libc.so.6                          0x00002b239d8b0460 __libc_start_main +
    245

    6    tmpqhlcw1a8                        0x000055b390c4d019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        return false\n    }\n    if lst[0] != lst[1]\
    \ {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgv5jzb5y.swift:35:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmpgv5jzb5y.swift:35:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmptrpm5896/tmptrpm5896.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2bef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab2bbe8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab2bbe8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab2bbe77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptrpm5896                        0x000055bebcbab697 <unavailable> + 5783

    5    libc.so.6                          0x00002aab2c0dd460 __libc_start_main +
    245

    6    tmptrpm5896                        0x000055bebcbab249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if last == num {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmptj5df8zc/tmptj5df8zc.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b790cf60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b790cc57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b790cc57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b790cc567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptj5df8zc                        0x000055f218ad25f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b790d14c460 __libc_start_main +
    245

    6    tmptj5df8zc                        0x000055f218ad20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet set = Set(lst)\n\treturn\
    \ set.count == lst.count && set.count == lst.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpaamu2lgk/tmpaamu2lgk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc8e024c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc8dd1bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc8dd1b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc8dd1a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaamu2lgk                        0x0000555e467ba5e6 <unavailable> + 5606

    5    libc.so.6                          0x00002afc8e210460 __libc_start_main +
    245

    6    tmpaamu2lgk                        0x0000555e467ba0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var set = Set<Int>()\n  \
    \  for num in lst {\n        if !set.contains(num) {\n            set.insert(num)\n\
    \        } else {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmps2fs89oi/tmps2fs89oi.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95321cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9531ec2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9531ec2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9531ec17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps2fs89oi                        0x0000555c2d408746 <unavailable> + 5958

    5    libc.so.6                          0x00002b95323b7460 __libc_start_main +
    245

    6    tmps2fs89oi                        0x0000555c2d408229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen[v] {\n                return false\n            }\n    \
    \        seen[v] = true\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwbumr2ae.swift:32:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmpwbumr2ae.swift:35:23: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[v] = true\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpi_8ph5jg/tmpi_8ph5jg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5aed0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5aea03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5aea03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5aea027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_8ph5jg                        0x0000563bf87e7646 <unavailable> + 5702

    5    libc.so.6                          0x00002ad5aeef8460 __libc_start_main +
    245

    6    tmpi_8ph5jg                        0x0000563bf87e7129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] == nil {\n            seen[num] = true\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9uwofnmc.swift:25:22: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[num] == nil {\n  \
    \         ~~~~~~~~~ ^  ~~~\n/tmp/tmp9uwofnmc.swift:26:25: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[num] = true\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpyr0kmejb/tmpyr0kmejb.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79f179fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79f1496b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79f1496988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79f14957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyr0kmejb                        0x000055f4e4dda4d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b79f198b460 __libc_start_main +
    245

    6    tmpyr0kmejb                        0x000055f4e4dda089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    for x in lst {\n        if\
    \ x == prev {\n            return false\n        }\n        prev = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp73v3s_76/tmp73v3s_76.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5403b6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5403866b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5403866988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54038657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp73v3s_76                        0x000055a73471b646 <unavailable> + 5702

    5    libc.so.6                          0x00002b5403d5b460 __libc_start_main +
    245

    6    tmp73v3s_76                        0x000055a73471b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] < lst[0]\n\
    \    }\n    if lst.count > 1 {\n        var prev: Int = 0\n        for idx in\
    \ 0..<lst.count {\n            if prev == lst[idx] {\n                return false\n\
    \            }\n            prev = lst[idx]\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpes4fhitq/tmpes4fhitq.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b485ecc7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b485e9beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b485e9be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b485e9bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpes4fhitq                        0x00005566d8f5152a <unavailable> + 5418

    5    libc.so.6                          0x00002b485eeb3460 __libc_start_main +
    245

    6    tmpes4fhitq                        0x00005566d8f511a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if last < num {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpi3511cds/tmpi3511cds.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31e594dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31e5644b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31e5644988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31e56437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi3511cds                        0x000056524870b45a <unavailable> + 5210

    5    libc.so.6                          0x00002b31e5b39460 __libc_start_main +
    245

    6    tmpi3511cds                        0x000056524870b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    var last: Int = 0\n    for idx in lst {\n      \
    \  if idx == last {\n            return false\n        }\n        last = idx\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpul_hcj69/tmpul_hcj69.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b437c185c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b437be7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b437be7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b437be7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpul_hcj69                        0x000055bc272e4577 <unavailable> + 5495

    5    libc.so.6                          0x00002b437c371460 __libc_start_main +
    245

    6    tmpul_hcj69                        0x000055bc272e4129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for num in lst {\n        if seen.contains(num) {\n            return false\n\
    \        }\n        seen.insert(num)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpij5b1ea0/tmpij5b1ea0.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b715df68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b715dc5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b715dc5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b715dc5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpij5b1ea0                        0x000055a3667e7746 <unavailable> + 5958

    5    libc.so.6                          0x00002b715e154460 __libc_start_main +
    245

    6    tmpij5b1ea0                        0x000055a3667e7229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var lastVal = lst[0]\n    for val in lst {\n   \
    \     if val > lastVal {\n            return false\n        }\n        lastVal\
    \ = val\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp2crm81us/tmp2crm81us.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5117392c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5117089b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5117089988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51170887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2crm81us                        0x0000561d48bcd5d7 <unavailable> + 5591

    5    libc.so.6                          0x00002b511757e460 __libc_start_main +
    245

    6    tmp2crm81us                        0x0000561d48bcd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if !seen.contains(num) {\n                return false\n        \
    \    }\n            seen.append(num)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqxe6msi1/tmpqxe6msi1.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2fd4b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2fd1a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2fd1a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2fd1a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqxe6msi1                        0x0000564738e40697 <unavailable> + 5783

    5    libc.so.6                          0x00002af2fd69c460 __libc_start_main +
    245

    6    tmpqxe6msi1                        0x0000564738e40249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst[1..<lst.count])\n   \
    \ }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzhyfon4d.swift:30:26: error: missing argument label 'lst:' in call\n\
    \        return is_sorted(lst[1..<lst.count])\n                         ^\n  \
    \                       lst: \n/tmp/tmpzhyfon4d.swift:30:29: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        return\
    \ is_sorted(lst[1..<lst.count])\n                            ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                seen.append(v)\n        \
    \    }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmptrpm5896/tmptrpm5896.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2bef1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab2bbe8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab2bbe8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab2bbe77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptrpm5896                        0x000055bebcbab697 <unavailable> + 5783

    5    libc.so.6                          0x00002aab2c0dd460 __libc_start_main +
    245

    6    tmptrpm5896                        0x000055bebcbab249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    for num in lst {\n      \
    \  if prev == num {\n            return false\n        }\n        prev = num\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp5ruu0dn6/tmp5ruu0dn6.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41c2a22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41c2719b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41c2719988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41c27187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ruu0dn6                        0x0000556c02519646 <unavailable> + 5702

    5    libc.so.6                          0x00002b41c2c0e460 __libc_start_main +
    245

    6    tmp5ruu0dn6                        0x0000556c02519129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var seen = [Int]()\n    for x in lst {\n       \
    \ if seen[x] == nil {\n            seen[x] = true\n            return true\n \
    \       }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl4p3pmnb.swift:28:20: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[x] == nil {\n    \
    \       ~~~~~~~ ^  ~~~\n/tmp/tmpl4p3pmnb.swift:29:23: error: cannot assign value\
    \ of type 'Bool' to subscript of type 'Int'\n            seen[x] = true\n    \
    \                  ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    var next: Int = 0\n    for\
    \ idx in lst {\n        if idx == prev {\n            prev = idx\n           \
    \ continue\n        }\n        if idx == next {\n            return false\n  \
    \      }\n        if idx < prev {\n            return false\n        }\n     \
    \   prev = idx\n        next = idx\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzx2_by3d/tmpzx2_by3d.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b228ac80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b228a977b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b228a977988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b228a9767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzx2_by3d                        0x0000558360f41c7b <unavailable> + 7291

    5    libc.so.6                          0x00002b228ae6c460 __libc_start_main +
    245

    6    tmpzx2_by3d                        0x0000558360f41129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        return false\n    }\n    if lst[0] == lst[1]\
    \ {\n        return false\n    }\n    if lst[0] < lst[1] {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpau2laei0/tmpau2laei0.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb0603bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb05d32b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb05d32988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb05d317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpau2laei0                        0x00005607516a0467 <unavailable> + 5223

    5    libc.so.6                          0x00002aeb06227460 __libc_start_main +
    245

    6    tmpau2laei0                        0x00005607516a0019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tswitch lst.count {\n\tcase\
    \ 0:\n\t\treturn true\n\tcase 1:\n\t\treturn lst[0] < lst[0]\n\tdefault:\n\t\t\
    let last = lst[0]\n\t\tfor elem in lst[1..] {\n\t\t\tif elem < last {\n\t\t\t\t\
    return false\n\t\t\t}\n\t\t\tlast = elem\n\t\t}\n\t\treturn true\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo8ktnyvn.swift:30:20: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n                for elem in lst[1..] {\n              \
    \                   ^~\n                                 ...\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aebbfe7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebbfb75561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aebbfb75286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aebbfb7513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aebbfb74bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aebbf974e83 <unavailable> + 188035

    6    tmpoy5_v_kj                        0x0000556a4b5f8153 <unavailable> + 8531

    7    tmpoy5_v_kj                        0x0000556a4b5f74e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aebc006a460 __libc_start_main +
    245

    9    tmpoy5_v_kj                        0x0000556a4b5f71d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen.contains(num) {\n                return false\n         \
    \   } else {\n                seen.insert(num)\n            }\n        }\n   \
    \ }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnulihce3.swift:35:32: error: missing argument for parameter 'at'\
    \ in call\n                seen.insert(num)\n                               ^\n\
    \                               , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return true\n    }\n    if lst.count > 2 {\n\
    \        return false\n    }\n    if lst.contains(&lst.first!) {\n        return\
    \ false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9dbyp8dj.swift:35:21: error: '&' used with non-inout argument of\
    \ type 'Int'\n    if lst.contains(&lst.first!) {\n                    ^~~~~~~~~~~\n\
    \                    \n/tmp/tmp9dbyp8dj.swift:35:21: error: cannot pass immutable\
    \ value as inout argument: 'first' is a get-only property\n    if lst.contains(&lst.first!)\
    \ {\n                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if last < num {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpi3511cds/tmpi3511cds.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31e594dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31e5644b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31e5644988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31e56437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi3511cds                        0x000056524870b45a <unavailable> + 5210

    5    libc.so.6                          0x00002b31e5b39460 __libc_start_main +
    245

    6    tmpi3511cds                        0x000056524870b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen.contains(v) {\n                seen.append(v)\n    \
    \        }\n        }\n        return false\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp7x967tk0/tmp7x967tk0.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af89ffc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af89fcbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af89fcbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af89fcbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7x967tk0                        0x0000560eb304061a <unavailable> + 5658

    5    libc.so.6                          0x00002af8a01b2460 __libc_start_main +
    245

    6    tmp7x967tk0                        0x0000560eb3040299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for i := 0; i < lst.count;\
    \ i++ {\n        if lst[i] != last {\n            last = lst[i]\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsy2dwqc4.swift:27:12: error: expected type\n    for i := 0; i <\
    \ lst.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpsy2dwqc4.swift:27:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmpsy2dwqc4.swift:27:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < lst.count; i++ {\n       \
    \    ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] != nil {\n            return false\n    \
    \    }\n        seen[num] = num\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae257fe1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae257cd8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae257cd8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae257cd813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae257cd7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae257ad7e83 <unavailable> + 188035

    6    tmpx8xg2jtv                        0x00005570a20ef137 <unavailable> + 8503

    7    tmpx8xg2jtv                        0x00005570a20ee4e5 <unavailable> + 5349

    8    libc.so.6                          0x00002ae2581cd460 __libc_start_main +
    245

    9    tmpx8xg2jtv                        0x00005570a20ee1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] != nil {\n            return false\n    \
    \    }\n        seen[num] = num\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae257fe1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae257cd8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae257cd8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae257cd813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae257cd7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae257ad7e83 <unavailable> + 188035

    6    tmpx8xg2jtv                        0x00005570a20ef137 <unavailable> + 8503

    7    tmpx8xg2jtv                        0x00005570a20ee4e5 <unavailable> + 5349

    8    libc.so.6                          0x00002ae2581cd460 __libc_start_main +
    245

    9    tmpx8xg2jtv                        0x00005570a20ee1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet set = Set(lst)\n\treturn\
    \ set.count == lst.count && set.count == lst.count && set.count == lst.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpytexaxd2/tmpytexaxd2.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8450f0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae844de7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae844de7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae844de67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpytexaxd2                        0x000055bed66855e6 <unavailable> + 5606

    5    libc.so.6                          0x00002ae8452dc460 __libc_start_main +
    245

    6    tmpytexaxd2                        0x000055bed66850c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == lst[0]\n\
    \    }\n    var last: Int = 0\n    var lastCount: Int = 0\n    for x in lst {\n\
    \        if x == last {\n            lastCount++\n        } else {\n         \
    \   lastCount = 1\n            last = x\n        }\n        if lastCount > 1 {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1fiwdxka.swift:33:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lastCount++\n                     ^~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpyr0kmejb/tmpyr0kmejb.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79f179fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79f1496b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79f1496988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79f14957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyr0kmejb                        0x000055f4e4dda4d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b79f198b460 __libc_start_main +
    245

    6    tmpyr0kmejb                        0x000055f4e4dda089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen[v] {\n                return false\n            }\n    \
    \        seen[v] = true\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwbumr2ae.swift:32:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmpwbumr2ae.swift:35:23: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[v] = true\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var prev: Int = 0\n    for x in lst {\n        if x ==\
    \ prev {\n            return false\n        }\n        prev = x\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp7r83t97o/tmp7r83t97o.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27edf5cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27edc53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27edc53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27edc527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7r83t97o                        0x000055ccf8e21646 <unavailable> + 5702

    5    libc.so.6                          0x00002b27ee148460 __libc_start_main +
    245

    6    tmp7r83t97o                        0x000055ccf8e21129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    return\
    \ set.count == lst.count && set.sorted() == true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_hru_w62.swift:24:51: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                     ~~~~~~~~~~~~ ^  ~~~~\n\
    /tmp/tmp_hru_w62.swift:24:51: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Bool, Bool)\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                                  ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var lastCount: Int = 0\n\
    \    for num in lst {\n        if num == last {\n            lastCount += 1\n\
    \        } else {\n            last = num\n            lastCount = 1\n       \
    \ }\n    }\n    return lastCount <= 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp6a7n0w_l/tmp6a7n0w_l.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ab00c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2aafdc0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2aafdc0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2aafdbf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6a7n0w_l                        0x000055ed67954646 <unavailable> + 5702

    5    libc.so.6                          0x00002b2ab02b5460 __libc_start_main +
    245

    6    tmp6a7n0w_l                        0x000055ed67954129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = Set<Int>()\n        for value in lst\
    \ {\n            if !seen.contains(value) {\n                seen.insert(value)\n\
    \                return true\n            }\n        }\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpwy32edfz/tmpwy32edfz.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af782ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af782bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af782bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af782bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwy32edfz                        0x000055f69574d7a6 <unavailable> + 6054

    5    libc.so.6                          0x00002af7830b0460 __libc_start_main +
    245

    6    tmpwy32edfz                        0x000055f69574d289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var last: Int = 0\n        for idx in\
    \ 0..<lst.count {\n            if lst[idx] != last {\n                return false\n\
    \            }\n            last = idx\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbzmyygiu/tmpbzmyygiu.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20bff00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20bfbf7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20bfbf7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20bfbf67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbzmyygiu                        0x0000564951cab52a <unavailable> + 5418

    5    libc.so.6                          0x00002b20c00ec460 __libc_start_main +
    245

    6    tmpbzmyygiu                        0x0000564951cab1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return lst.sorted() == lst\n    }\n    if lst.count\
    \ > 2 {\n        return false\n    }\n    var seen = [Int]()\n    for x in lst\
    \ {\n        if seen[x] == true {\n            return false\n        }\n     \
    \   seen[x] = true\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6tc5hdp6.swift:37:20: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'Bool'\n        if seen[x] == true {\n       \
    \    ~~~~~~~ ^  ~~~~\n/tmp/tmp6tc5hdp6.swift:37:20: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Bool, Bool), (Int, Int)\n  \
    \      if seen[x] == true {\n                   ^\n/tmp/tmp6tc5hdp6.swift:40:19:\
    \ error: cannot assign value of type 'Bool' to subscript of type 'Int'\n     \
    \   seen[x] = true\n                  ^~~~\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst[1..<lst.count])\n   \
    \ }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpivz5bt61.swift:30:26: error: missing argument label 'lst:' in call\n\
    \        return is_sorted(lst[1..<lst.count])\n                         ^\n  \
    \                       lst: \n/tmp/tmpivz5bt61.swift:30:29: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        return\
    \ is_sorted(lst[1..<lst.count])\n                            ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1tk3ahmo/tmp1tk3ahmo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b265a721c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b265a418b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b265a418988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b265a4177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1tk3ahmo                        0x000055f5b5605646 <unavailable> + 5702

    5    libc.so.6                          0x00002b265a90d460 __libc_start_main +
    245

    6    tmp1tk3ahmo                        0x000055f5b5605129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var lastCount: Int = 0\n\
    \    for num in lst {\n        if num == last {\n            lastCount++\n   \
    \     } else {\n            last = num\n            lastCount = 1\n        }\n\
    \    }\n    return lastCount <= 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu4vcv1h1.swift:30:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lastCount++\n                     ^~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] == nil {\n            seen[x] = true\n      \
    \      return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpopjj01g0.swift:25:20: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[x] == nil {\n    \
    \       ~~~~~~~ ^  ~~~\n/tmp/tmpopjj01g0.swift:26:23: error: cannot assign value\
    \ of type 'Bool' to subscript of type 'Int'\n            seen[x] = true\n    \
    \                  ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = 0\n    for num\
    \ in lst {\n        if prev < num {\n            return false\n        }\n   \
    \     prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmps5uamlcf/tmps5uamlcf.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7560900c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75605f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75605f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75605f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps5uamlcf                        0x0000555d732dd45a <unavailable> + 5210

    5    libc.so.6                          0x00002b7560aec460 __libc_start_main +
    245

    6    tmps5uamlcf                        0x0000555d732dd0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return true\n    }\n    return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp195am8ra/tmp195am8ra.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5345056c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5344d4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5344d4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5344d4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp195am8ra                        0x000055b5f3a73467 <unavailable> + 5223

    5    libc.so.6                          0x00002b5345242460 __libc_start_main +
    245

    6    tmp195am8ra                        0x000055b5f3a73019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpyr0kmejb/tmpyr0kmejb.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79f179fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79f1496b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79f1496988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79f14957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyr0kmejb                        0x000055f4e4dda4d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b79f198b460 __libc_start_main +
    245

    6    tmpyr0kmejb                        0x000055f4e4dda089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpx77zj8pp/tmpx77zj8pp.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30f76dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30f73d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30f73d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30f73d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx77zj8pp                        0x000055e045242467 <unavailable> + 5223

    5    libc.so.6                          0x00002b30f78ca460 __libc_start_main +
    245

    6    tmpx77zj8pp                        0x000055e045242019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var last: Int = 0\n        for idx in 0..<lst.count\
    \ {\n            if lst[idx] != last {\n                return false\n       \
    \     }\n            last = idx\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpyjqcpw1w/tmpyjqcpw1w.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ff80c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ff7db8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ff7db8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ff7db77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyjqcpw1w                        0x000055f170e3d5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002b0ff82ad460 __libc_start_main +
    245

    6    tmpyjqcpw1w                        0x000055f170e3d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] != nil {\n            return false\n    \
    \    }\n        seen[num] = num\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae257fe1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae257cd8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae257cd8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae257cd813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae257cd7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae257ad7e83 <unavailable> + 188035

    6    tmpx8xg2jtv                        0x00005570a20ef137 <unavailable> + 8503

    7    tmpx8xg2jtv                        0x00005570a20ee4e5 <unavailable> + 5349

    8    libc.so.6                          0x00002ae2581cd460 __libc_start_main +
    245

    9    tmpx8xg2jtv                        0x00005570a20ee1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        let lastIndex = lst.count - 1\n      \
    \  let lastValue = lst[lastIndex]\n        for idx in 0..<lst.count {\n      \
    \      if idx == lastIndex {\n                continue\n            }\n      \
    \      if lst[idx] != lastValue {\n                return false\n            }\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp06_982oc/tmp06_982oc.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acec4d0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acec4a04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acec4a04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acec4a037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06_982oc                        0x0000556ba86a252a <unavailable> + 5418

    5    libc.so.6                          0x00002acec4ef9460 __libc_start_main +
    245

    6    tmp06_982oc                        0x0000556ba86a21a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen[num] != nil {\n                return false\n           \
    \ }\n            seen[num] = num\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0736cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07369ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b07369ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b07369ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b07369ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b07367ece83 <unavailable> + 188035

    6    tmpxjdkylaa                        0x000055901ccfc1db <unavailable> + 8667

    7    tmpxjdkylaa                        0x000055901ccfb602 <unavailable> + 5634

    8    libc.so.6                          0x00002b0736ee2460 __libc_start_main +
    245

    9    tmpxjdkylaa                        0x000055901ccfb229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for num in\
    \ lst {\n            if seen.contains(num) {\n                return false\n \
    \           }\n            seen.insert(num)\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplywco8g2.swift:35:28: error: missing argument for parameter 'at'\
    \ in call\n            seen.insert(num)\n                           ^\n      \
    \                     , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    var cur: Int = 0\n    var\
    \ next: Int = 0\n    var last: Int = 0\n    var found: Bool = false\n    for cur\
    \ in lst {\n        if cur == prev {\n            if cur == last {\n         \
    \       found = true\n            } else {\n                found = false\n  \
    \          }\n        } else {\n            found = false\n        }\n       \
    \ if found {\n            break\n        }\n        prev = cur\n    }\n    return\
    \ found\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpnsolmj5o/tmpnsolmj5o.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9de2174c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9de1e6bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9de1e6b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9de1e6a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnsolmj5o                        0x000055d372e1d577 <unavailable> + 5495

    5    libc.so.6                          0x00002b9de2360460 __libc_start_main +
    245

    6    tmpnsolmj5o                        0x000055d372e1d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] != nil {\n            return false\n    \
    \    }\n        seen[num] = num\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae257fe1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae257cd8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae257cd8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae257cd813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae257cd7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae257ad7e83 <unavailable> + 188035

    6    tmpx8xg2jtv                        0x00005570a20ef137 <unavailable> + 8503

    7    tmpx8xg2jtv                        0x00005570a20ee4e5 <unavailable> + 5349

    8    libc.so.6                          0x00002ae2581cd460 __libc_start_main +
    245

    9    tmpx8xg2jtv                        0x00005570a20ee1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    var i = 0\n    var j = 0\n    while i < lst.count\
    \ {\n        if lst[i] > lst[j] {\n            return false\n        }\n     \
    \   i += 1\n        j += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp94uiocxx/tmp94uiocxx.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af961a6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af961765b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af961765988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9617647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94uiocxx                        0x00005576d3a7e467 <unavailable> + 5223

    5    libc.so.6                          0x00002af961c5a460 __libc_start_main +
    245

    6    tmp94uiocxx                        0x00005576d3a7e019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var lastCount: Int = 0\n\
    \    for num in lst {\n        if num == last {\n            lastCount++\n   \
    \     } else {\n            last = num\n            lastCount = 1\n        }\n\
    \    }\n    if lastCount > 1 {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg8ehfh0j.swift:30:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lastCount++\n                     ^~\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst[1..<lst.count])\n   \
    \ }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpixr186qm.swift:30:26: error: missing argument label 'lst:' in call\n\
    \        return is_sorted(lst[1..<lst.count])\n                         ^\n  \
    \                       lst: \n/tmp/tmpixr186qm.swift:30:29: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        return\
    \ is_sorted(lst[1..<lst.count])\n                            ^\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    return\
    \ set.count == lst.count && set.sorted() == true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_hru_w62.swift:24:51: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                     ~~~~~~~~~~~~ ^  ~~~~\n\
    /tmp/tmp_hru_w62.swift:24:51: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Bool, Bool)\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                                  ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var seen = [Int]()\n    for x in lst {\n       \
    \ if seen[x - 1] != nil {\n            return false\n        }\n        seen[x]\
    \ = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b21c9599c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21c9290561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b21c9290286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b21c929013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b21c928fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b21c908fe83 <unavailable> + 188035

    6    tmpnt9fzu0r                        0x000055961d2761bb <unavailable> + 8635

    7    tmpnt9fzu0r                        0x000055961d275602 <unavailable> + 5634

    8    libc.so.6                          0x00002b21c9785460 __libc_start_main +
    245

    9    tmpnt9fzu0r                        0x000055961d275229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for num in\
    \ lst {\n            if seen[num] != nil {\n                return false\n   \
    \         }\n            seen[num] = num\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp36bfemzg/tmp36bfemzg.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d7a108c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d79dffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d79dff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d79dfe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp36bfemzg                        0x0000555642c0e5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b6d7a2f4460 __libc_start_main +
    245

    6    tmp36bfemzg                        0x0000555642c0e229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = Set<Int>()\n \
    \   for num in lst {\n        if seen.contains(num) {\n            return false\n\
    \        }\n        seen.insert(num)\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpij5b1ea0/tmpij5b1ea0.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b715df68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b715dc5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b715dc5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b715dc5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpij5b1ea0                        0x000055a3667e7746 <unavailable> + 5958

    5    libc.so.6                          0x00002b715e154460 __libc_start_main +
    245

    6    tmpij5b1ea0                        0x000055a3667e7229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] == nil {\n            seen[num] = true\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9uwofnmc.swift:25:22: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[num] == nil {\n  \
    \         ~~~~~~~~~ ^  ~~~\n/tmp/tmp9uwofnmc.swift:26:25: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[num] = true\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    return is_sorted(lst.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp58dn11nz.swift:29:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst.sorted())\n                     ^\n                \
    \     lst: \n"
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen[num] == true {\n                return false\n          \
    \  }\n            seen[num] = true\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp87w0kv6i.swift:32:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'Bool'\n            if seen[num] == true {\n \
    \              ~~~~~~~~~ ^  ~~~~\n/tmp/tmp87w0kv6i.swift:32:26: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool),\
    \ (Int, Int)\n            if seen[num] == true {\n                         ^\n\
    /tmp/tmp87w0kv6i.swift:35:25: error: cannot assign value of type 'Bool' to subscript\
    \ of type 'Int'\n            seen[num] = true\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return lst.sorted() == lst\n    }\n    if lst.count\
    \ > 2 {\n        return false\n    }\n    if lst.sorted == nil {\n        return\
    \ false\n    }\n    return lst.sorted() == lst\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpt5oz_224/tmpt5oz_224.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae15fa06c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae15f6fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae15f6fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae15f6fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt5oz_224                        0x000055d50457f5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002ae15fbf2460 __libc_start_main +
    245

    6    tmpt5oz_224                        0x000055d50457f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    for x in lst {\n        if\
    \ prev > x {\n            return false\n        }\n        prev = x\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpcwa6b0tb/tmpcwa6b0tb.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76394b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76391b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76391b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76391af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcwa6b0tb                        0x0000560cb0e35c7b <unavailable> + 7291

    5    libc.so.6                          0x00002b76396a5460 __libc_start_main +
    245

    6    tmpcwa6b0tb                        0x0000560cb0e35129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count == 2 {\n        return lst.sorted() == lst\n    }\n    if lst.count\
    \ > 2 {\n        return false\n    }\n    var prev: Int = 0\n    var next: Int\
    \ = 0\n    for idx in lst {\n        if prev == idx {\n            next = idx\
    \ + 1\n        } else {\n            if next > idx {\n                return false\n\
    \            }\n            prev = idx\n            next = idx + 1\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp4t0pxkhe/tmp4t0pxkhe.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae357a71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae357768b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae357768988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae3577677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4t0pxkhe                        0x000055db6e655687 <unavailable> + 5767

    5    libc.so.6                          0x00002ae357c5d460 __libc_start_main +
    245

    6    tmp4t0pxkhe                        0x000055db6e655239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.dropLast())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpyr0kmejb/tmpyr0kmejb.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79f179fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79f1496b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79f1496988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79f14957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyr0kmejb                        0x000055f4e4dda4d7 <unavailable> + 5335

    5    libc.so.6                          0x00002b79f198b460 __libc_start_main +
    245

    6    tmpyr0kmejb                        0x000055f4e4dda089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst {\n\
    \            if !seen.contains(v) {\n                return false\n          \
    \  }\n            seen.append(v)\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpvdboydl1/tmpvdboydl1.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afac7b7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afac7872b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afac7872988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afac78717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvdboydl1                        0x0000564c683e2697 <unavailable> + 5783

    5    libc.so.6                          0x00002afac7d67460 __libc_start_main +
    245

    6    tmpvdboydl1                        0x0000564c683e2249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst[1..<lst.count])\n   \
    \ }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzhyfon4d.swift:30:26: error: missing argument label 'lst:' in call\n\
    \        return is_sorted(lst[1..<lst.count])\n                         ^\n  \
    \                       lst: \n/tmp/tmpzhyfon4d.swift:30:29: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        return\
    \ is_sorted(lst[1..<lst.count])\n                            ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    var prev: Int = 0\n    var found: Bool = false\n    for x in lst {\n\
    \        if x == prev {\n            found = true\n        } else {\n        \
    \    prev = x\n            found = false\n        }\n    }\n    return found\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpabvyhztd/tmpabvyhztd.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5666c3cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5666933b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5666933988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56669327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpabvyhztd                        0x000055d52c54850a <unavailable> + 5386

    5    libc.so.6                          0x00002b5666e28460 __libc_start_main +
    245

    6    tmpabvyhztd                        0x000055d52c548189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] == nil {\n            seen[num] = true\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9uwofnmc.swift:25:22: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[num] == nil {\n  \
    \         ~~~~~~~~~ ^  ~~~\n/tmp/tmp9uwofnmc.swift:26:25: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[num] = true\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen[num] == true {\n                return false\n          \
    \  }\n            seen[num] = true\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp87w0kv6i.swift:32:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'Bool'\n            if seen[num] == true {\n \
    \              ~~~~~~~~~ ^  ~~~~\n/tmp/tmp87w0kv6i.swift:32:26: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool),\
    \ (Int, Int)\n            if seen[num] == true {\n                         ^\n\
    /tmp/tmp87w0kv6i.swift:35:25: error: cannot assign value of type 'Bool' to subscript\
    \ of type 'Int'\n            seen[num] = true\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] < lst[0]\n\
    \    }\n    var last: Int = 0\n    var lastCount: Int = 0\n    for x in lst {\n\
    \        if x == last {\n            lastCount++\n        } else {\n         \
    \   lastCount = 1\n            last = x\n        }\n        if lastCount > 1 {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpt85awh2h.swift:33:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lastCount++\n                     ^~\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpanu4fu2b/tmpanu4fu2b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f807b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f804a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f804a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f804a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpanu4fu2b                        0x000055fb5c37c4c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b4f8099d460 __libc_start_main +
    245

    6    tmpanu4fu2b                        0x000055fb5c37c079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    return lst.sorted() == true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbgm4n42h.swift:29:25: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return lst.sorted() == true\n  \
    \         ~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpbgm4n42h.swift:29:25: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Bool, Bool)\n\
    \    return lst.sorted() == true\n                        ^\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if last < num {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpi3511cds/tmpi3511cds.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31e594dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31e5644b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31e5644988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31e56437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi3511cds                        0x000056524870b45a <unavailable> + 5210

    5    libc.so.6                          0x00002b31e5b39460 __libc_start_main +
    245

    6    tmpi3511cds                        0x000056524870b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var seen = [Int]()\n    for x in lst {\n        if seen[x\
    \ - 1] != nil {\n            return false\n        }\n        seen[x] = true\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp82mcd8s8.swift:26:24: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns true\n        if seen[x - 1] != nil {\n \
    \          ~~~~~~~~~~~ ^  ~~~\n/tmp/tmp82mcd8s8.swift:29:19: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n        seen[x] = true\n  \
    \                ^~~~\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == 0\n\
    \    }\n    if lst.count > 1 {\n        var last: Int = 0\n        for idx in\
    \ 0..<lst.count {\n            if lst[idx] != last {\n                return false\n\
    \            }\n            last = idx\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpkqkotwml/tmpkqkotwml.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b943a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b9409fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b9409f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b9409e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkqkotwml                        0x000055b1db9a652a <unavailable> + 5418

    5    libc.so.6                          0x00002b6b94594460 __libc_start_main +
    245

    6    tmpkqkotwml                        0x000055b1db9a61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x] == nil {\n            seen[x] = true\n      \
    \      return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpopjj01g0.swift:25:20: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[x] == nil {\n    \
    \       ~~~~~~~ ^  ~~~\n/tmp/tmpopjj01g0.swift:26:23: error: cannot assign value\
    \ of type 'Bool' to subscript of type 'Int'\n            seen[x] = true\n    \
    \                  ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        return false\n    }\n    if lst[0] == lst[1]\
    \ {\n        return false\n    }\n    if lst[0] < lst[1] {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpau2laei0/tmpau2laei0.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb0603bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb05d32b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb05d32988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb05d317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpau2laei0                        0x00005607516a0467 <unavailable> + 5223

    5    libc.so.6                          0x00002aeb06227460 __libc_start_main +
    245

    6    tmpau2laei0                        0x00005607516a0019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ num in lst {\n        if seen[num] == nil {\n            seen[num] = true\n\
    \            return true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9uwofnmc.swift:25:22: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if seen[num] == nil {\n  \
    \         ~~~~~~~~~ ^  ~~~\n/tmp/tmp9uwofnmc.swift:26:25: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[num] = true\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ num in lst {\n        if num != last {\n            return false\n        }\n\
    \        last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp17kn8ayt/tmp17kn8ayt.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9778d32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9778a29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9778a29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9778a287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp17kn8ayt                        0x000055629894e45a <unavailable> + 5210

    5    libc.so.6                          0x00002b9778f1e460 __libc_start_main +
    245

    6    tmp17kn8ayt                        0x000055629894e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = Set<Int>()\n        for num in lst\
    \ {\n            if seen.contains(num) {\n                return false\n     \
    \       }\n            seen.insert(num)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzc85ov77/tmpzc85ov77.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c7d254c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c7cf4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c7cf4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c7cf4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzc85ov77                        0x0000564b4815a7a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b4c7d440460 __libc_start_main +
    245

    6    tmpzc85ov77                        0x0000564b4815a289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpx77zj8pp/tmpx77zj8pp.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30f76dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30f73d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30f73d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30f73d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx77zj8pp                        0x000055e045242467 <unavailable> + 5223

    5    libc.so.6                          0x00002b30f78ca460 __libc_start_main +
    245

    6    tmpx77zj8pp                        0x000055e045242019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst[1..<lst.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9w3si51m.swift:32:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst[1..<lst.count])\n                     ^\n          \
    \           lst: \n/tmp/tmp9w3si51m.swift:32:25: error: cannot convert value of\
    \ type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return is_sorted(lst[1..<lst.count])\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    var lastCount: Int = 0\n\
    \    for num in lst {\n        if num == last {\n            lastCount++\n   \
    \     } else {\n            last = num\n            lastCount = 1\n        }\n\
    \    }\n    if lastCount > 1 {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg8ehfh0j.swift:30:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            lastCount++\n                     ^~\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var last: Int = 0\n    for x in lst {\n        if\
    \ x == last {\n            return false\n        }\n        last = x\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpi_8ph5jg/tmpi_8ph5jg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5aed0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5aea03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5aea03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5aea027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_8ph5jg                        0x0000563bf87e7646 <unavailable> + 5702

    5    libc.so.6                          0x00002ad5aeef8460 __libc_start_main +
    245

    6    tmpi_8ph5jg                        0x0000563bf87e7129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpanu4fu2b/tmpanu4fu2b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f807b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f804a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f804a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f804a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpanu4fu2b                        0x000055fb5c37c4c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b4f8099d460 __libc_start_main +
    245

    6    tmpanu4fu2b                        0x000055fb5c37c079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] < lst[0]\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen[v] {\n                return false\n            }\n\
    \            seen[v] = true\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpeueo5b7t.swift:32:21: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n            if !seen[v] {\n               ~    ^\n\
    \                (       == 0)\n/tmp/tmpeueo5b7t.swift:35:23: error: cannot assign\
    \ value of type 'Bool' to subscript of type 'Int'\n            seen[v] = true\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return is_sorted(lst[1..<lst.count])\n   \
    \ }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpivz5bt61.swift:30:26: error: missing argument label 'lst:' in call\n\
    \        return is_sorted(lst[1..<lst.count])\n                         ^\n  \
    \                       lst: \n/tmp/tmpivz5bt61.swift:30:29: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        return\
    \ is_sorted(lst[1..<lst.count])\n                            ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    if lst.count > 1 {\n        return false\n    }\n\
    \    if lst[0] != 1 {\n        return false\n    }\n    for index in 1..<lst.count\
    \ {\n        if lst[index] != lst[index-1] {\n            return false\n     \
    \   }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpci9380kk/tmpci9380kk.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b594d7e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b594d4dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b594d4da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b594d4d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpci9380kk                        0x000055cf4a3cb5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002b594d9cf460 __libc_start_main +
    245

    6    tmpci9380kk                        0x000055cf4a3cb1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == lst[0]\n\
    \    }\n    if lst.count > 1 {\n        var seen = [Int]()\n        for v in lst\
    \ {\n            if !seen.contains(v) {\n                return false\n      \
    \      }\n            seen.append(v)\n        }\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpvjet5rmp/tmpvjet5rmp.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24c028ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24bff85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24bff85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24bff847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvjet5rmp                        0x000055a5c5f646e7 <unavailable> + 5863

    5    libc.so.6                          0x00002b24c047a460 __libc_start_main +
    245

    6    tmpvjet5rmp                        0x000055a5c5f64299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ x in lst {\n        if seen[x - 1] != nil {\n            return false\n    \
    \    }\n        seen[x] = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aebbfe7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebbfb75561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aebbfb75286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aebbfb7513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aebbfb74bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aebbf974e83 <unavailable> + 188035

    6    tmpoy5_v_kj                        0x0000556a4b5f8153 <unavailable> + 8531

    7    tmpoy5_v_kj                        0x0000556a4b5f74e5 <unavailable> + 5349

    8    libc.so.6                          0x00002aebc006a460 __libc_start_main +
    245

    9    tmpoy5_v_kj                        0x0000556a4b5f71d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpanu4fu2b/tmpanu4fu2b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f807b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f804a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f804a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f804a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpanu4fu2b                        0x000055fb5c37c4c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b4f8099d460 __libc_start_main +
    245

    6    tmpanu4fu2b                        0x000055fb5c37c079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] == lst[1] {\n        return false\n    }\n    if lst[0] < lst[1]\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp3xzp0exq/tmp3xzp0exq.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6579499c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6579190b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6579190988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b657918f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3xzp0exq                        0x000055bcb9c04467 <unavailable> + 5223

    5    libc.so.6                          0x00002b6579685460 __libc_start_main +
    245

    6    tmp3xzp0exq                        0x000055bcb9c04019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    var found: Bool = false\n\
    \    for x in lst {\n        if x == prev {\n            found = true\n      \
    \  } else {\n            prev = x\n            found = false\n        }\n    }\n\
    \    return found\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp2wriag_5/tmp2wriag_5.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b5d7aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b5d4a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b5d4a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b5d4a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2wriag_5                        0x000056509fe3a4aa <unavailable> + 5290

    5    libc.so.6                          0x00002b7b5d99a460 __libc_start_main +
    245

    6    tmp2wriag_5                        0x000056509fe3a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst.count > 1 {\n        var seen = [Int]()\n        for num in lst {\n\
    \            if seen[num] != nil {\n                return false\n           \
    \ }\n            seen[num] = num\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0736cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07369ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b07369ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b07369ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b07369ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b07367ece83 <unavailable> + 188035

    6    tmpxjdkylaa                        0x000055901ccfc1db <unavailable> + 8667

    7    tmpxjdkylaa                        0x000055901ccfb602 <unavailable> + 5634

    8    libc.so.6                          0x00002b0736ee2460 __libc_start_main +
    245

    9    tmpxjdkylaa                        0x000055901ccfb229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tswitch lst.count {\n\tcase\
    \ 0:\n\t\treturn true\n\tcase 1:\n\t\treturn lst[0] == 0\n\tcase 2:\n\t\treturn\
    \ lst[0] == lst[1]\n\tdefault:\n\t\tsort.Sort(&lst)\n\t\treturn lst[0] == lst[lst.count-1]\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3,\
    \ 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\
    \ == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst:\
    \ [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1u80i_4h.swift:31:3: error: cannot find 'sort' in scope\n     \
    \           sort.Sort(&lst)\n                ^~~~\n/tmp/tmp1u80i_4h.swift:31:13:\
    \ error: cannot pass immutable value as inout argument: 'lst' is a 'let' constant\n\
    \                sort.Sort(&lst)\n                          ^~~~\n"
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet set = Set(lst)\n\treturn\
    \ set.count == lst.count && set.count == lst.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpaamu2lgk/tmpaamu2lgk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc8e024c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc8dd1bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc8dd1b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc8dd1a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaamu2lgk                        0x0000555e467ba5e6 <unavailable> + 5606

    5    libc.so.6                          0x00002afc8e210460 __libc_start_main +
    245

    6    tmpaamu2lgk                        0x0000555e467ba0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    if lst.count == 1 {\n        return lst[0] == lst[0]\n\
    \    }\n    if lst.count > 1 {\n        var seen = Set<Int>()\n        for v in\
    \ lst {\n            if !seen.contains(v) {\n                seen.insert(v)\n\
    \                return false\n            }\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpewnq5893/tmpewnq5893.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd93a27c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd9371eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd9371e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd9371d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewnq5893                        0x0000556066db0727 <unavailable> + 5927

    5    libc.so.6                          0x00002afd93c13460 __libc_start_main +
    245

    6    tmpewnq5893                        0x0000556066db02d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = 0\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp_46_640i/tmp_46_640i.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52fa6c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52fa3beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52fa3be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52fa3bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46_640i                        0x0000557f6937f5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b52fa8b3460 __libc_start_main +
    245

    6    tmp_46_640i                        0x0000557f6937f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014018
- exit_code: 1
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(from: 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppiv348kw.swift:32:31: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return is_sorted(lst: lst.suffix(from:\
    \ 1))\n                              ^\n"
  stdout: ''
  timestamp: 1660014018
