language: swift
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name = class_name_components[class_name_components.count\
    \ - 1]\n        let extension = extension_components[extension_components.count\
    \ - 1]\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_count_index = class_name_components_count - 1\n  \
    \      let extension_components_count_index = extension_components_count - 1\n\
    \        let class_name_components_count_index_minus_1 = class_name_components_count_index\
    \ - 1\n        let extension_components_count_index_minus_1 = extension_components_count_index\
    \ - 1\n        let class_name_components_count_minus_1 = class_name_components_count\
    \ - 1\n        let extension_components_count_minus_1 = extension_components_count\
    \ - 1\n        let class_name_components_count_minus_2 = class_name_components_count\
    \ - 2\n        let extension_components_count_minus_2 = extension_components_count\
    \ - 2\n        let class_name_components_count_minus_3 = class_name_components_count\
    \ - 3\n        let extension_components_count_minus_3 = extension_components_count\
    \ - 3\n        let class_name_components_count_minus_4 = class_name_components_count\
    \ - 4\n        let extension_components_count_minus_4 = extension_components_count\
    \ - 4\n        let class_name_components_count_minus_5 = class_name_components_count\
    \ - 5\n        let extension_components_count_minus_5 = extension_components_count\
    \ - 5\n        let class_name_components_count_minus_6 = class_name_components_count\
    \ - 6\n        let extension_components_count_minus_6 = extension_components_count\
    \ - 6\n        let class_name_components_count_minus_7 = class_name_components_count\
    \ - 7\n        let extension_components_count_minus_7 = extension_components_count\
    \ - 7\n        let class_name_components_count_minus_8 = class_name_components_count\
    \ - 8\n        let extension_components_count_minus_8 = extension_components_count\
    \ - 8\n        let class_name_components_count_minus_9 = class_name_components_count\
    \ - 9\n        let extension_components_count_minus_9 = extension_components_count\
    \ - 9\n        let class_name_components_count_minus_10 = class_name_components_count\
    \ - 10\n        let extension_components_count_minus_10 = extension_components_count\
    \ - 10\n        let class_name_components_count_minus_11 = class_name_components_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpy5_33uw_.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpy5_33uw_.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpy5_33uw_.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpy5_33uw_.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpy5_33uw_.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpy5_33uw_.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpy5_33uw_.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpy5_33uw_.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpy5_33uw_.swift:25:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^\n/tmp/tmpy5_33uw_.swift:25:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^~~~~~~~~\n            `extension`\n/tmp/tmpy5_33uw_.swift:76:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpy5_33uw_.swift:18:78: note: to matc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        var extension_length = extension.count\n        var\
    \ extension_strength = extension_length - 1\n        for _ in 0..<extension_length\
    \ {\n            let index = extension.index(extension.startIndex, offsetBy: 1)\n\
    \            let char = extension[index].lowercased()\n            if char ==\
    \ char.lowercased() {\n                extension_strength -= 1\n            }\n\
    \        }\n        if extension_strength > strength {\n            strongest_extension\
    \ = class_name\n            strength = extension_strength\n        }\n    }\n\
    \    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3iwnjbi.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr3iwnjbi.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr3iwnjbi.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr3iwnjbi.swift:22:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpr3iwnjbi.swift:22:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpr3iwnjbi.swift:22:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpr3iwnjbi.swift:22:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpr3iwnjbi.swift:22:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpr3iwnjbi.swift:25:25: error: expected\
    \ initial value after '='\n            let index = extension.index(extension.startIndex,\
    \ offsetBy: 1)\n                        ^\n/tmp/tmpr3iwnjbi.swift:25:24: error:\
    \ consecutive statements on a line must be separated by ';'\n            let index\
    \ = extension.index(extension.startIndex, offsetBy: 1)\n                     \
    \  ^\n                       ;\n/tmp/tmpr3iwnjbi.swift:25:34: error: expected\
    \ type name in extension declaration\n            let index = extension.index(extension.startIndex,\
    \ offsetBy: 1)\n                                 ^\n/tmp/tmpr3iwnjbi.swift:25:34:\
    \ error: expected '{' in extension\n            let index = extension.index(extension.startIndex,\
    \ offsetBy: 1)\n                                 ^\n/tmp/tmpr3iwnjbi.swift:25:25:\
    \ error: declaration is only valid at file scope\n            let index = exten"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name = class_name_components[0]\n        let extension = extension_components[0]\n\
    \        let class_name_components_count = class_name_components.count\n     \
    \   let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components_count - class_name_components_count.count\n        let\
    \ extension_components_count_upper = extension_components_count - extension_components_count.count\n\
    \        let class_name_components_count_lower = class_name_components_count -\
    \ class_name_components_count_upper\n        let extension_components_count_lower\
    \ = extension_components_count - extension_components_count_upper\n        let\
    \ class_name_components_count_diff = class_name_components_count_upper - class_name_components_count_lower\n\
    \        let extension_components_count_diff = extension_components_count_upper\
    \ - extension_components_count_lower\n        let class_name_components_count_diff_upper\
    \ = class_name_components_count_diff - class_name_components_count_upper\n   \
    \     let extension_components_count_diff_upper = extension_components_count_diff\
    \ - extension_components_count_upper\n        let class_name_components_count_diff_lower\
    \ = class_name_components_count_diff - class_name_components_count_lower\n   \
    \     let extension_components_count_diff_lower = extension_components_count_diff\
    \ - extension_components_count_lower\n        let class_name_components_count_diff_diff\
    \ = class_name_components_count_diff_upper - class_name_components_count_diff_lower\n\
    \        let extension_components_count_diff_diff = extension_components_count_diff_upper\
    \ - extension_components_count_diff_lower\n        let class_name_components_count_diff_diff_upper\
    \ = class_name_components_count_diff_diff - class_name_components_count_diff_upper\n\
    \        let extension_components_count_diff_diff_upper = extension_components_count_diff_diff\
    \ - extension_components_count_diff_upper\n        let class_name_components_count_diff_diff_lower\
    \ = class_name_components_count_diff_diff - class_name_components_count_diff_lower\n\
    \        let extension_components_count_diff_diff_lower = extension_components_count_diff_diff\
    \ - extension_components_count_diff_lower\n        let class_name_components_count_diff_diff_diff\
    \ = class_name_components_count_diff_diff_upper - class_name_components_count_diff_diff_lower\n\
    \        let extension_components_count_diff_diff_diff = extension_components_count_diff_diff_upper\
    \ - extension_components_count_diff_diff_lower\n        let class_name_components_count_diff_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnc10i8i9.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnc10i8i9.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnc10i8i9.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnc10i8i9.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpnc10i8i9.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpnc10i8i9.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpnc10i8i9.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpnc10i8i9.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpnc10i8i9.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[0]\n   \
    \         ^\n/tmp/tmpnc10i8i9.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[0]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpnc10i8i9.swift:69:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpnc10i8i9.swift:18:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ St"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphkaxlo5t.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphkaxlo5t.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphkaxlo5t.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphkaxlo5t.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmphkaxlo5t.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmphkaxlo5t.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmphkaxlo5t.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmphkaxlo5t.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmphkaxlo5t.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmphkaxlo5t.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmphkaxlo5t.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp9kja0rpt.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp9kja0rpt.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp9kja0rpt.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp9kja0rpt.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp9kja0rpt.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmp9kja0rpt.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmp9kja0rpt.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmp9kja0rpt.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp9kja0rpt.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp9kja0rpt.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp9kja0rpt.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_uppercase_count = extension.count\n \
    \       let extension_lowercase_count = extension.count\n        let extension_strength\
    \ = extension_uppercase_count - extension_lowercase_count\n        if extension_strength\
    \ > strength {\n            strongest_extension = extension\n            strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpn5fyrcjb.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpn5fyrcjb.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpn5fyrcjb.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpn5fyrcjb.swift:22:41:\
    \ error: expected initial value after '='\n        let extension_uppercase_count\
    \ = extension.count\n                                        ^\n/tmp/tmpn5fyrcjb.swift:22:40:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_uppercase_count = extension.count\n                              \
    \         ^\n                                       ;\n/tmp/tmpn5fyrcjb.swift:22:50:\
    \ error: expected type name in extension declaration\n        let extension_uppercase_count\
    \ = extension.count\n                                                 ^\n/tmp/tmpn5fyrcjb.swift:22:50:\
    \ error: expected '{' in extension\n        let extension_uppercase_count = extension.count\n\
    \                                                 ^\n/tmp/tmpn5fyrcjb.swift:22:41:\
    \ error: declaration is only valid at file scope\n        let extension_uppercase_count\
    \ = extension.count\n                                        ^\n/tmp/tmpn5fyrcjb.swift:23:41:\
    \ error: expected initial value after '='\n        let extension_lowercase_count\
    \ = extension.count\n                                        ^\n/tmp/tmpn5fyrcjb.swift:23:40:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_lowercase_count = extension.count\n                              \
    \         ^\n                                       ;\n/tmp/tmpn5fyrcjb.swift:23:50:\
    \ error: expected type name in extension declaration\n        let extension_lowercase_count\
    \ = extension.count\n                                                 ^\n/tmp/tmpn5fyrcjb.swift:23:50:\
    \ error: expected '{' in extension\n        let extension_lowercase_count = extension.count\n\
    \                                                 ^\n/tm"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for char in extension {\n            if char.uppercased() != char {\n\
    \                extension_strength -= 1\n            }\n        }\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0do7k412.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp0do7k412.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp0do7k412.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp0do7k412.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp0do7k412.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp0do7k412.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp0do7k412.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp0do7k412.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp0do7k412.swift:23:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmp0do7k412.swift:23:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n/tmp/tmp0do7k412.swift:30:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp0do7k412.swift:31:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp0do7k412.swift:30:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmp0do7k412.swift:30:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplxj9rzjr.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplxj9rzjr.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmplxj9rzjr.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmplxj9rzjr.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmplxj9rzjr.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        var strength = count_capital_letters(extension) - count_capital_letters(class_name)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpbb7iv656.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpbb7iv656.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpbb7iv656.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpbb7iv656.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpbb7iv656.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpbb7iv656.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpbb7iv656.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpbb7iv656.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpbb7iv656.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpbb7iv656.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpbb7iv656.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpbb7iv656.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        var strength = count_capital_letters(extension) - count_capital_letters(class_name)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnyac0ss6.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnyac0ss6.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpnyac0ss6.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpnyac0ss6.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpnyac0ss6.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpnyac0ss6.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpnyac0ss6.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8jp2a853.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8jp2a853.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8jp2a853.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8jp2a853.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmp8jp2a853.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmp8jp2a853.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters - extension.countLowercaseLetters\n      \
    \                                    ^\n/tmp/tmp8jp2a853.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmp8jp2a853.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUppercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmp8jp2a853.swift:22:77: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                    ^\n/tmp/tmp8jp2a853.swift:22:77: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                    ^\n/tmp/tmp8jp2a853.swift:22:68: error: declaration\
    \ is only valid at file scope\n        let ex"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            if strength\
    \ > strongest_extension.count {\n                strongest_extension = extension\n\
    \            }\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7n6pypas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7n6pypas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7n6pypas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7n6pypas.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp7n6pypas.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp7n6pypas.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp7n6pypas.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp7n6pypas.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp7n6pypas.swift:27:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmp7n6pypas.swift:28:13:\
    \ error: expected type name in extension declaration\n            }\n        \
    \    ^\n/tmp/tmp7n6pypas.swift:27:48: error: expected '{' in extension\n     \
    \           strongest_extension = extension\n                                \
    \               ^\n/tmp/tmp7n6pypas.swift:27:39: error: declaration is only valid\
    \ at file scope\n                strongest_extension = extension\n           \
    \                           ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let (class_name, extension) = extension.split(\".\"\
    )\n        let class_name_lowercase = class_name.lowercased()\n        let extension_lowercase\
    \ = extension.lowercased()\n        let class_name_length = class_name_lowercase.count\n\
    \        let extension_length = extension_lowercase.count\n        let class_name_uppercase_count\
    \ = class_name_lowercase\n            .unicodeScalars\n            .filter({$0.isUppercase})\n\
    \            .count\n        let extension_uppercase_count = extension_lowercase\n\
    \            .unicodeScalars\n            .filter({$0.isUppercase})\n        \
    \    .count\n        let class_name_uppercase_fraction = class_name_uppercase_count\
    \ / class_name_length\n        let extension_uppercase_fraction = extension_uppercase_count\
    \ / extension_length\n        let strength = class_name_uppercase_fraction - extension_uppercase_fraction\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphys5xfde.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphys5xfde.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphys5xfde.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphys5xfde.swift:22:26:\
    \ error: expected pattern\n        let (class_name, extension) = extension.split(\"\
    .\")\n                         ^\n/tmp/tmphys5xfde.swift:22:25: error: consecutive\
    \ statements on a line must be separated by ';'\n        let (class_name, extension)\
    \ = extension.split(\".\")\n                        ^\n                      \
    \  ;\n/tmp/tmphys5xfde.swift:22:35: error: expected type name in extension declaration\n\
    \        let (class_name, extension) = extension.split(\".\")\n              \
    \                    ^\n                                   <#type#>\n/tmp/tmphys5xfde.swift:22:35:\
    \ error: expected '{' in extension\n        let (class_name, extension) = extension.split(\"\
    .\")\n                                  ^\n/tmp/tmphys5xfde.swift:22:26: error:\
    \ declaration is only valid at file scope\n        let (class_name, extension)\
    \ = extension.split(\".\")\n                         ^\n/tmp/tmphys5xfde.swift:22:48:\
    \ error: expected type name in extension declaration\n        let (class_name,\
    \ extension) = extension.split(\".\")\n                                      \
    \         ^\n/tmp/tmphys5xfde.swift:22:48: error: expected '{' in extension\n\
    \        let (class_name, extension) = extension.split(\".\")\n              \
    \                                 ^\n/tmp/tmphys5xfde.swift:22:39: error: declaration\
    \ is only valid at file scope\n        let (class_name, extension) = extension.split(\"\
    .\")\n                                      ^\n/tmp/tmphys5xfde.swift:24:35: error:\
    \ expected initial value after '='\n        let extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmphys5xfde.swift:24:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        let ext"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strength =\
    \ -1\n    for extension in extensions {\n        var count = 0\n        for c\
    \ in extension {\n            if c.isUpper() {\n                count += 1\n \
    \           }\n        }\n        if count == 0 {\n            strength = -1\n\
    \        } else {\n            strength = count - count\n        }\n        if\
    \ strength > 0 {\n            if strongest_extension == \"\" {\n             \
    \   strongest_extension = class_name\n            } else {\n                strongest_extension\
    \ = strongest_extension + \".\" + extension\n            }\n        }\n    }\n\
    \    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ueg_3r9.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8ueg_3r9.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8ueg_3r9.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8ueg_3r9.swift:24:18:\
    \ error: expected Sequence expression for for-each loop\n        for c in extension\
    \ {\n                 ^\n/tmp/tmp8ueg_3r9.swift:24:18: error: expected '{' to\
    \ start the body of for-each loop\n        for c in extension {\n            \
    \     ^\n/tmp/tmp8ueg_3r9.swift:38:67: error: expected expression after operator\n\
    \                strongest_extension = strongest_extension + \".\" + extension\n\
    \                                                                  ^\n/tmp/tmp8ueg_3r9.swift:39:13:\
    \ error: expected type name in extension declaration\n            }\n        \
    \    ^\n/tmp/tmp8ueg_3r9.swift:38:76: error: expected '{' in extension\n     \
    \           strongest_extension = strongest_extension + \".\" + extension\n  \
    \                                                                         ^\n\
    /tmp/tmp8ueg_3r9.swift:38:67: error: declaration is only valid at file scope\n\
    \                strongest_extension = strongest_extension + \".\" + extension\n\
    \                                                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptbabkas5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptbabkas5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptbabkas5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptbabkas5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmptbabkas5.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmptbabkas5.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmptbabkas5.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmptbabkas5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmptbabkas5.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmptbabkas5.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmptbabkas5.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmptbabkas5.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpiectq_i2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpiectq_i2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpiectq_i2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpiectq_i2.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpiectq_i2.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpiectq_i2.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \        ^\n/tmp/tmpiectq_i2.swift:22:43: error: expected '{' in extension\n \
    \       let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpiectq_i2.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpiectq_i2.swift:22:83: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpiectq_i2.swift:22:83: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \   "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let strength = extension.countUpToLowercaseLetters()\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3jnc6yl7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3jnc6yl7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3jnc6yl7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3jnc6yl7.swift:22:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3jnc6yl7.swift:22:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmp3jnc6yl7.swift:22:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3jnc6yl7.swift:22:33: error: expected\
    \ '{' in extension\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3jnc6yl7.swift:22:24: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3jnc6yl7.swift:25:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp3jnc6yl7.swift:26:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp3jnc6yl7.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3jnc6yl7.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   let class_name_extension = class_name + extension\n        let extension_strength\
    \ = class_name_extension.characters.count\n        if extension_strength > strongest_extension.characters.count\
    \ {\n            strongest_extension = class_name_extension\n        }\n    }\n\
    \    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmx2doedw.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmx2doedw.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmx2doedw.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmx2doedw.swift:21:49:\
    \ error: expected expression after operator\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n\
    /tmp/tmpmx2doedw.swift:21:48: error: consecutive statements on a line must be\
    \ separated by ';'\n        let class_name_extension = class_name + extension\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmpmx2doedw.swift:22:9: error: expected type name\
    \ in extension declaration\n        let extension_strength = class_name_extension.characters.count\n\
    \        ^\n/tmp/tmpmx2doedw.swift:21:58: error: expected '{' in extension\n \
    \       let class_name_extension = class_name + extension\n                  \
    \                                       ^\n/tmp/tmpmx2doedw.swift:21:49: error:\
    \ declaration is only valid at file scope\n        let class_name_extension =\
    \ class_name + extension\n                                                ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplxj9rzjr.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplxj9rzjr.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmplxj9rzjr.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmplxj9rzjr.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmplxj9rzjr.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqzx3p7f.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqzx3p7f.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpuqzx3p7f.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpuqzx3p7f.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpuqzx3p7f.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strongest_extension_strength\
    \ = -1\n    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6vwyhp6n.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6vwyhp6n.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6vwyhp6n.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6vwyhp6n.swift:23:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6vwyhp6n.swift:23:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6vwyhp6n.swift:23:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6vwyhp6n.swift:23:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6vwyhp6n.swift:23:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6vwyhp6n.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6vwyhp6n.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6vwyhp6n.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6vwyhp6n.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            strongest_extension\
    \ = class_name + \".\" + extension\n            break\n        }\n    }\n    return\
    \ strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1hg5j289.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1hg5j289.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1hg5j289.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1hg5j289.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp1hg5j289.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp1hg5j289.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp1hg5j289.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp1hg5j289.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp1hg5j289.swift:26:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmp1hg5j289.swift:27:13: error: expected type name in extension\
    \ declaration\n            break\n            ^\n/tmp/tmp1hg5j289.swift:26:63:\
    \ error: expected '{' in extension\n            strongest_extension = class_name\
    \ + \".\" + extension\n                                                      \
    \        ^\n/tmp/tmp1hg5j289.swift:26:54: error: declaration is only valid at\
    \ file scope\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                     ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplt14p0s0.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplt14p0s0.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplt14p0s0.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplt14p0s0.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmplt14p0s0.swift:22:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmplt14p0s0.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmplt14p0s0.swift:22:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmplt14p0s0.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmplt14p0s0.swift:22:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmplt14p0s0.swift:22:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmplt14p0s0.swift:22:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1 // default strength\
    \ to -1\n    var class_name_components = class_name.components(separatedBy: \"\
    .\")\n    var extension_components = extensions.components(separatedBy: \".\"\
    )\n    for component in class_name_components {\n        if let index = extension_components.index(of:\
    \ component) {\n            strength = extension_components[index].count\n   \
    \     }\n    }\n    if strength > 0 {\n        for component in extension_components\
    \ {\n            if let index = class_name_components.index(of: component) {\n\
    \                strongest_extension = class_name_components[index] + \".\" +\
    \ extension_components[index]\n            }\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr5wbv11r.swift:21:44: error: value of type 'String' has no member\
    \ 'components'\n    var class_name_components = class_name.components(separatedBy:\
    \ \".\")\n                                ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpr5wbv11r.swift:22:43:\
    \ error: value of type '[String]' has no member 'components'\n    var extension_components\
    \ = extensions.components(separatedBy: \".\")\n                              \
    \ ~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + Strongest_Extension_Strongest(extensions)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwrvfv_x3.swift:19:31: error: cannot find 'Strongest_Extension_Strongest'\
    \ in scope\n    return class_name + \".\" + Strongest_Extension_Strongest(extensions)\n\
    \                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_uppercase_count = extension.uppercaseString.count\n\
    \        let extension_lowercase_count = extension.lowercaseString.count\n   \
    \     let extension_strength = extension_uppercase_count - extension_lowercase_count\n\
    \        if extension_strength > strength {\n            strongest_extension =\
    \ extension\n            strength = extension_strength\n        }\n    }\n   \
    \ return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpk1xs1rpy.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpk1xs1rpy.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpk1xs1rpy.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpk1xs1rpy.swift:22:41:\
    \ error: expected initial value after '='\n        let extension_uppercase_count\
    \ = extension.uppercaseString.count\n                                        ^\n\
    /tmp/tmpk1xs1rpy.swift:22:40: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_uppercase_count = extension.uppercaseString.count\n\
    \                                       ^\n                                  \
    \     ;\n/tmp/tmpk1xs1rpy.swift:22:50: error: expected type name in extension\
    \ declaration\n        let extension_uppercase_count = extension.uppercaseString.count\n\
    \                                                 ^\n/tmp/tmpk1xs1rpy.swift:22:50:\
    \ error: expected '{' in extension\n        let extension_uppercase_count = extension.uppercaseString.count\n\
    \                                                 ^\n/tmp/tmpk1xs1rpy.swift:22:41:\
    \ error: declaration is only valid at file scope\n        let extension_uppercase_count\
    \ = extension.uppercaseString.count\n                                        ^\n\
    /tmp/tmpk1xs1rpy.swift:23:41: error: expected initial value after '='\n      \
    \  let extension_lowercase_count = extension.lowercaseString.count\n         \
    \                               ^\n/tmp/tmpk1xs1rpy.swift:23:40: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lowercase_count\
    \ = extension.lowercaseString.count\n                                       ^\n\
    \                                       ;\n/tmp/tmpk1xs1rpy.swift:23:50: error:\
    \ expected type name in extension declaration\n        let extension_lowercase_count\
    \ = extension.lowercaseString.count\n                                        \
    \         ^\n/tmp/tmpk1xs1rpy.swift:23:50: error: expected"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_length = extension.count\n        let\
    \ class_name_length = class_name.count\n        let extension_strength = extension_length\
    \ - class_name_length\n        if extension_strength > strength {\n          \
    \  strongest_extension = extension\n            strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9st0hyu.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpa9st0hyu.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpa9st0hyu.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpa9st0hyu.swift:22:32:\
    \ error: expected initial value after '='\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpa9st0hyu.swift:22:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpa9st0hyu.swift:22:41: error: expected type name in extension\
    \ declaration\n        let extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpa9st0hyu.swift:22:41: error: expected '{'\
    \ in extension\n        let extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpa9st0hyu.swift:22:32: error: declaration\
    \ is only valid at file scope\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpa9st0hyu.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpa9st0hyu.swift:27:22: error: expected\
    \ '{' in extension\n            strength = extension_strength\n              \
    \       ^\n/tmp/tmpa9st0hyu.swift:26:35: error: declaration is only valid at file\
    \ scope\n            strongest_extension = extension\n                       \
    \           ^\n/tmp/tmpa9st0hyu.swift:27:13: error: cannot find type 'strength'\
    \ in scope\n            strength = extension_strength\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    var extension_counter = 0\n    for extension in extensions {\n        extension_counter\
    \ += 1\n        let extension_strength = extension.characters.count\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    if extension_counter > 1 {\n        let extension_strength_fraction\
    \ = extension_counter / Double(extensions.count)\n        let extension_strength_rounded\
    \ = Int(extension_strength_fraction * Double(strongest_extension_strength))\n\
    \        strongest_extension = class_name + \".\" + strongest_extension.substring(extension_strength_rounded)\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw83mwu5j.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw83mwu5j.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw83mwu5j.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw83mwu5j.swift:24:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpw83mwu5j.swift:24:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpw83mwu5j.swift:24:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpw83mwu5j.swift:24:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpw83mwu5j.swift:24:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpw83mwu5j.swift:27:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw83mwu5j.swift:28:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw83mwu5j.swift:27:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw83mwu5j.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpw83mwu5j.swift:31:61: error: binary\
    \ operator '/' cannot be applied to operands of type 'Int' and 'Double'\n    \
    \    let extension_strength_fraction = extension_counter / Double(extensions.count)\n\
    \                       "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name_length = class_name_components.count\n      \
    \  let extension_length = extension_components.count\n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        let class_name_components_count_upper = class_name_components_count -\
    \ class_name_length\n        let extension_components_count_upper = extension_components_count\
    \ - extension_length\n        let class_name_components_count_lower = class_name_length\
    \ - class_name_components_count\n        let extension_components_count_lower\
    \ = extension_length - extension_components_count\n        let class_name_components_count_equal\
    \ = class_name_components_count_upper + class_name_components_count_lower\n  \
    \      let extension_components_count_equal = extension_components_count_upper\
    \ + extension_components_count_lower\n        let class_name_components_count_greater\
    \ = class_name_components_count_equal > class_name_components_count_upper\n  \
    \      let extension_components_count_greater = extension_components_count_equal\
    \ > extension_components_count_upper\n        let class_name_components_count_less\
    \ = class_name_components_count_equal < class_name_components_count_upper\n  \
    \      let extension_components_count_less = extension_components_count_equal\
    \ < extension_components_count_upper\n        let class_name_components_count_greater_or_equal\
    \ = class_name_components_count_greater || class_name_components_count_equal\n\
    \        let extension_components_count_greater_or_equal = extension_components_count_greater\
    \ || extension_components_count_equal\n        let class_name_components_count_less_or_equal\
    \ = class_name_components_count_less || class_name_components_count_equal\n  \
    \      let extension_components_count_less_or_equal = extension_components_count_less\
    \ || extension_components_count_equal\n        let class_name_components_count_greater_or_equal_or_less\
    \ = class_name_components_count_greater_or_equal || class_name_components_count_less_or_equal\n\
    \        let extension_components_count_greater_or_equal_or_less = extension_components_count_greater_or_equal\
    \ || extension_components_count_less_or_equal\n        let class_name_components_count_greater_or_equal_or_less_or_equal\
    \ = class_name_components_count_greater_or_equal_or_less || class_name_components_count_greater\n\
    \        let extension_components_count_greater_or_equal_or_less_or_equal = extension_components_count_greater_or_equal_or_less\
    \ || \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2zqetmx.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg2zqetmx.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg2zqetmx.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg2zqetmx.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpg2zqetmx.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpg2zqetmx.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpg2zqetmx.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpg2zqetmx.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpg2zqetmx.swift:46:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpg2zqetmx.swift:69:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpg2zqetmx.swift:18:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmpg2zqetmx.swift:49:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_lowercase = extension.lowercased()\n\
    \        let class_lowercase = class_name.lowercased()\n        let strength_of_extension\
    \ = class_lowercase.characters.count - extension_lowercase.characters.count\n\
    \        if strength_of_extension > strength {\n            strongest_extension\
    \ = extension\n            strength = strength_of_extension\n        }\n    }\n\
    \    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjej2c8un.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjej2c8un.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjej2c8un.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjej2c8un.swift:22:35:\
    \ error: expected initial value after '='\n        let extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpjej2c8un.swift:22:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpjej2c8un.swift:22:44: error: expected type name\
    \ in extension declaration\n        let extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpjej2c8un.swift:22:44: error:\
    \ expected '{' in extension\n        let extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpjej2c8un.swift:22:35: error:\
    \ declaration is only valid at file scope\n        let extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpjej2c8un.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjej2c8un.swift:27:22: error: expected\
    \ '{' in extension\n            strength = strength_of_extension\n           \
    \          ^\n/tmp/tmpjej2c8un.swift:26:35: error: declaration is only valid at\
    \ file scope\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpjej2c8un.swift:27:13: error: cannot find type 'strength'\
    \ in scope\n            strength = strength_of_extension\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        var strength = count_capital_letters(extension) - count_capital_letters(class_name)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnyac0ss6.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnyac0ss6.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpnyac0ss6.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpnyac0ss6.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpnyac0ss6.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpnyac0ss6.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpnyac0ss6.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_length = extension.count\n        let\
    \ class_name_length = class_name.count\n        let extension_strength = extension_length\
    \ - class_name_length\n        if extension_strength > strength {\n          \
    \  strongest_extension = extension\n            strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9st0hyu.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpa9st0hyu.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpa9st0hyu.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpa9st0hyu.swift:22:32:\
    \ error: expected initial value after '='\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpa9st0hyu.swift:22:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpa9st0hyu.swift:22:41: error: expected type name in extension\
    \ declaration\n        let extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpa9st0hyu.swift:22:41: error: expected '{'\
    \ in extension\n        let extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpa9st0hyu.swift:22:32: error: declaration\
    \ is only valid at file scope\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpa9st0hyu.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpa9st0hyu.swift:27:22: error: expected\
    \ '{' in extension\n            strength = extension_strength\n              \
    \       ^\n/tmp/tmpa9st0hyu.swift:26:35: error: declaration is only valid at file\
    \ scope\n            strongest_extension = extension\n                       \
    \           ^\n/tmp/tmpa9st0hyu.swift:27:13: error: cannot find type 'strength'\
    \ in scope\n            strength = extension_strength\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strongest_extension_strength\
    \ = -1\n    for extension in extensions {\n        let extension_strength = extension.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8bia9_gp.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8bia9_gp.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8bia9_gp.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8bia9_gp.swift:23:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8bia9_gp.swift:23:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp8bia9_gp.swift:23:43: error: expected type name in extension\
    \ declaration\n        let extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp8bia9_gp.swift:23:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp8bia9_gp.swift:23:34: error: declaration\
    \ is only valid at file scope\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8bia9_gp.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp8bia9_gp.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp8bia9_gp.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp8bia9_gp.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components.count - class_name_components_count\n        let extension_components_count_lower\
    \ = extension_components.count - extension_components_count\n        let extension_components_count_upper_smallest\
    \ = extension_components_count_upper - extension_components_count_lower\n    \
    \    let extension_components_count_lower_smallest = extension_components_count_lower\
    \ - extension_components_count_upper\n        let extension_components_count_upper_smallest_extension\
    \ = extension_components_count_upper_smallest / extension_components_count\n \
    \       let extension_components_count_lower_smallest_extension = extension_components_count_lower_smallest\
    \ / extension_components_count\n        let extension_components_count_upper_smallest_extension_extension\
    \ = extension_components_count_upper_smallest_extension * extension_components_count_upper\n\
    \        let extension_components_count_lower_smallest_extension_extension = extension_components_count_lower_smallest_extension\
    \ * extension_components_count_lower\n        let extension_components_count_upper_smallest_extension_extension_extension\
    \ = extension_components_count_upper_smallest_extension_extension * extension_components_count_upper_smallest\n\
    \        let extension_components_count_lower_smallest_extension_extension_extension\
    \ = extension_components_count_lower_smallest_extension_extension * extension_components_count_lower_smallest\n\
    \        let extension_components_count_upper_smallest_extension_extension_extension_extension\
    \ = extension_components_count_upper_smallest_extension_extension_extension *\
    \ extension_components_count_upper_smallest_extension\n        let extension_components_count_lower_smallest_extension_extension_extension_extension\
    \ = extension_components_count_lower_smallest_extension_extension_extension *\
    \ extension_components_count_lower_smallest_extension\n        let extension_components_count_upper_smallest_extension_extension_extension_extension_extension\
    \ = extension_components_count_upper_smallest_extension_extension_extension_extension\
    \ * extension_components_count_upper_smallest_extension_extension\n        let\
    \ extension_components_count_lower_smallest_extension_extension_extension_extension_extension_extension\
    \ = extension_components_count_lower_smallest_extension_extension_extension_extension\
    \ * extension_component\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptyxr9fec.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptyxr9fec.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptyxr9fec.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptyxr9fec.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmptyxr9fec.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmptyxr9fec.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmptyxr9fec.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmptyxr9fec.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmptyxr9fec.swift:62:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmptyxr9fec.swift:18:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmptyxr9fec.swift:42:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmptyxr9fec.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkmsdxkhf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkmsdxkhf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkmsdxkhf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkmsdxkhf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpkmsdxkhf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpkmsdxkhf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpkmsdxkhf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpkmsdxkhf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpkmsdxkhf.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpkmsdxkhf.swift:25:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpkmsdxkhf.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpkmsdxkhf.swift:25:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_uppercase_count = extension.uppercased().count\n\
    \        let extension_lowercase_count = extension.lowercased().count\n      \
    \  let extension_strength = extension_uppercase_count - extension_lowercase_count\n\
    \        if extension_strength > strength {\n            strongest_extension =\
    \ extension\n            strength = extension_strength\n        }\n    }\n   \
    \ return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpa36nb0dj.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpa36nb0dj.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpa36nb0dj.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpa36nb0dj.swift:22:41:\
    \ error: expected initial value after '='\n        let extension_uppercase_count\
    \ = extension.uppercased().count\n                                        ^\n\
    /tmp/tmpa36nb0dj.swift:22:40: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_uppercase_count = extension.uppercased().count\n\
    \                                       ^\n                                  \
    \     ;\n/tmp/tmpa36nb0dj.swift:22:50: error: expected type name in extension\
    \ declaration\n        let extension_uppercase_count = extension.uppercased().count\n\
    \                                                 ^\n/tmp/tmpa36nb0dj.swift:22:50:\
    \ error: expected '{' in extension\n        let extension_uppercase_count = extension.uppercased().count\n\
    \                                                 ^\n/tmp/tmpa36nb0dj.swift:22:41:\
    \ error: declaration is only valid at file scope\n        let extension_uppercase_count\
    \ = extension.uppercased().count\n                                        ^\n\
    /tmp/tmpa36nb0dj.swift:23:41: error: expected initial value after '='\n      \
    \  let extension_lowercase_count = extension.lowercased().count\n            \
    \                            ^\n/tmp/tmpa36nb0dj.swift:23:40: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lowercase_count\
    \ = extension.lowercased().count\n                                       ^\n \
    \                                      ;\n/tmp/tmpa36nb0dj.swift:23:50: error:\
    \ expected type name in extension declaration\n        let extension_lowercase_count\
    \ = extension.lowercased().count\n                                           \
    \      ^\n/tmp/tmpa36nb0dj.swift:23:50: error: expected '{' in extension\n   \
    \   "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        var extension_strength = extension.count\n        for\
    \ letter in extension {\n            if letter.isUpper() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strength {\n\
    \            strongest_extension = extension\n            strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpc2kojyxd.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpc2kojyxd.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpc2kojyxd.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpc2kojyxd.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpc2kojyxd.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpc2kojyxd.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpc2kojyxd.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpc2kojyxd.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpc2kojyxd.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpc2kojyxd.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpc2kojyxd.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpc2kojyxd.swift:30:22: error: expected '{' in extension\n\
    \            strength = extension_strength\n                     ^\n/tmp/tmpc2kojyxd.swift:29:35:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = extension\n                                  ^\n/tmp/tmpc2kojyxd.swift:30:13:\
    \ error: cannot find type 'strength' in scope\n            strength = extension_strength\n\
    \  "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   var class_name_with_extension = class_name + extension\n        var class_name_with_extension_lowercase\
    \ = class_name_with_extension.lowercased()\n        var class_name_with_extension_lowercase_index\
    \ = class_name_with_extension_lowercase.index(class_name_with_extension_lowercase)\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension_lowercase_index.successor()\n\
    \        var class_name_with_extension_lowercase_index = class_name_with_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8gtu2az8.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8gtu2az8.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8gtu2az8.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8gtu2az8.swift:21:54:\
    \ error: expected expression after operator\n        var class_name_with_extension\
    \ = class_name + extension\n                                                 \
    \    ^\n/tmp/tmp8gtu2az8.swift:21:53: error: consecutive statements on a line\
    \ must be separated by ';'\n        var class_name_with_extension = class_name\
    \ + extension\n                                                    ^\n       \
    \                                             ;\n/tmp/tmp8gtu2az8.swift:22:9:\
    \ error: expected type name in extension declaration\n        var class_name_with_extension_lowercase\
    \ = class_name_with_extension.lowercased()\n        ^\n/tmp/tmp8gtu2az8.swift:21:63:\
    \ error: expected '{' in extension\n        var class_name_with_extension = class_name\
    \ + extension\n                                                              ^\n\
    /tmp/tmp8gtu2az8.swift:21:54: error: declaration is only valid at file scope\n\
    \        var class_name_with_extension = class_name + extension\n            \
    \                                         ^\n/tmp/tmp8gtu2az8.swift:71:91: error:\
    \ expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmp8gtu2az8.swift:18:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmp8gtu2az8.swift:51:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1kw36yvq.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: candidate expects value of type\
    \ '(String) throws -> Bool' for parameter #1 (got 'Array<String>.Index?' (aka\
    \ 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkmsdxkhf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkmsdxkhf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkmsdxkhf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkmsdxkhf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpkmsdxkhf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpkmsdxkhf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpkmsdxkhf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpkmsdxkhf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpkmsdxkhf.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpkmsdxkhf.swift:25:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpkmsdxkhf.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpkmsdxkhf.swift:25:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_length = extension.count\n        let\
    \ class_length = class_name.count\n        let strength_fraction = class_length\
    \ - extension_length\n        let strength = strength_fraction * CAP - SM\n  \
    \      if strength > strength {\n            strongest_extension = extension\n\
    \            strength = strength\n        }\n    }\n    return class_name + \"\
    .\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8pzw3bcu.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8pzw3bcu.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8pzw3bcu.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8pzw3bcu.swift:22:32:\
    \ error: expected initial value after '='\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmp8pzw3bcu.swift:22:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmp8pzw3bcu.swift:22:41: error: expected type name in extension\
    \ declaration\n        let extension_length = extension.count\n              \
    \                          ^\n/tmp/tmp8pzw3bcu.swift:22:41: error: expected '{'\
    \ in extension\n        let extension_length = extension.count\n             \
    \                           ^\n/tmp/tmp8pzw3bcu.swift:22:32: error: declaration\
    \ is only valid at file scope\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmp8pzw3bcu.swift:27:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp8pzw3bcu.swift:28:22: error: expected\
    \ '{' in extension\n            strength = strength\n                     ^\n\
    /tmp/tmp8pzw3bcu.swift:27:35: error: declaration is only valid at file scope\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp8pzw3bcu.swift:28:13: error: cannot find type 'strength' in scope\n\
    \            strength = strength\n            ^~~~~~~~\n/tmp/tmp8pzw3bcu.swift:25:44:\
    \ error: cannot find 'CAP' in scope\n        let strength = strength_fraction\
    \ * CAP - SM\n                                           ^~~\n/tmp/tmp8pzw3bcu.swift:25:50:\
    \ error: cannot find 'SM' in scope\n        let strength = strength_fraction *\
    \ CAP - SM\n                              "
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + Strongest_Extension_Name(extensions)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8j0fhtzd.swift:19:25: error: cannot find 'Strongest_Extension_Name'\
    \ in scope\n    return class_name + Strongest_Extension_Name(extensions)\n   \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.characters.count\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpbcdicfvn.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpbcdicfvn.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpbcdicfvn.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpbcdicfvn.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpbcdicfvn.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpbcdicfvn.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpbcdicfvn.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpbcdicfvn.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpbcdicfvn.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpbcdicfvn.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpbcdicfvn.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpbcdicfvn.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for character in extension {\n            if character == character.lowercased()\
    \ {\n                extension_strength -= 1\n            }\n        }\n     \
    \   if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ljsxdh5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7ljsxdh5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7ljsxdh5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7ljsxdh5.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp7ljsxdh5.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp7ljsxdh5.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp7ljsxdh5.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp7ljsxdh5.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp7ljsxdh5.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp7ljsxdh5.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp7ljsxdh5.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp7ljsxdh5.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp7ljsxdh5.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp7ljsxdh5.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    var class_name_uppercase = class_name.uppercased()\n    var class_name_lowercase\
    \ = class_name.lowercased()\n    for extension in extensions {\n        var extension_uppercase\
    \ = extension.uppercased()\n        var extension_lowercase = extension.lowercased()\n\
    \        var extension_strength = class_name_uppercase.distance(class_name_lowercase)\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5_p502c7.swift:23:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5_p502c7.swift:23:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5_p502c7.swift:23:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5_p502c7.swift:24:35:\
    \ error: expected initial value after '='\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmp5_p502c7.swift:24:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_uppercase\
    \ = extension.uppercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmp5_p502c7.swift:24:44: error: expected type name\
    \ in extension declaration\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmp5_p502c7.swift:24:44: error:\
    \ expected '{' in extension\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmp5_p502c7.swift:24:35: error:\
    \ declaration is only valid at file scope\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmp5_p502c7.swift:25:35: error: expected\
    \ initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmp5_p502c7.swift:25:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmp5_p502c7.swift:25:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp5_p502c7.swift:25:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp5_p502c7.swift:25:35: error:\
    \ declaration is only val"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvtst_u65.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvtst_u65.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvtst_u65.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvtst_u65.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpvtst_u65.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpvtst_u65.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpvtst_u65.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpvtst_u65.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpvtst_u65.swift:22:81:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmpvtst_u65.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmpvtst_u65.swift:22:72: error: decl"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptpnanm82.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptpnanm82.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptpnanm82.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptpnanm82.swift:22:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                       ^\n/tmp/tmptpnanm82.swift:22:23:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ strength = extension.countUpToCapitalLetters() - extension.countUpToLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmptpnanm82.swift:22:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                ^\n\
    /tmp/tmptpnanm82.swift:22:33: error: expected '{' in extension\n        let strength\
    \ = extension.countUpToCapitalLetters() - extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmptpnanm82.swift:22:24: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                       ^\n/tmp/tmptpnanm82.swift:22:71:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \                                    ^\n/tmp/tmptpnanm82.swift:22:71: error: expected\
    \ '{' in extension\n        let strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \                                    ^\n/tmp/tmptpnanm82.swift:22:62: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToCapitalLetters()\
    \ - extension.countUpToLowerc"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1 // default strength\
    \ is -1\n    var class_name_array = class_name.characters\n    var extension_array\
    \ = extensions.characters\n    for index in 0..<class_name_array.count {\n   \
    \     let class_character = class_name_array[index]\n        let extension_character\
    \ = extension_array[index]\n        if class_character == extension_character\
    \ {\n            strength += 1\n        } else {\n            if strength > 0\
    \ {\n                strongest_extension += class_character\n            }\n \
    \           strength = 1\n        }\n    }\n    if strength > 0 {\n        strongest_extension\
    \ += class_name_array[class_name_array.count-1]\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphzvv5q2b.swift:21:39: error: 'characters' is unavailable: Please\
    \ use String directly\n    var class_name_array = class_name.characters\n    \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphzvv5q2b.swift:22:38: error: value of type '[String]'\
    \ has no member 'characters'\n    var extension_array = extensions.characters\n\
    \                          ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmphzvv5q2b.swift:24:31:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let class_character = class_name_array[index]\n\
    \                              ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmphzvv5q2b.swift:30:40: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                strongest_extension += class_character\n                    \
    \                   ^\n/tmp/tmphzvv5q2b.swift:36:48: error: no exact matches in\
    \ call to subscript \n        strongest_extension += class_name_array[class_name_array.count-1]\n\
    \                                               ^\nSwift.String:3:12: note: candidate\
    \ expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n \
    \   public subscript(r: Range<String.Index>) -> Substring { get }\n          \
    \ ^\nSwift.Collection:3:23: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    var extension_strength = 0\n    for extension in extensions {\n        extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjh7d1e4d.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjh7d1e4d.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjh7d1e4d.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjh7d1e4d.swift:23:30:\
    \ error: expected expression in assignment\n        extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                             ^\n/tmp/tmpjh7d1e4d.swift:23:39:\
    \ error: expected type name in extension declaration\n        extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                              ^\n/tmp/tmpjh7d1e4d.swift:23:39: error: expected\
    \ '{' in extension\n        extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                      ^\n\
    /tmp/tmpjh7d1e4d.swift:23:30: error: declaration is only valid at file scope\n\
    \        extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                             ^\n/tmp/tmpjh7d1e4d.swift:23:72: error: expected\
    \ type name in extension declaration\n        extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                              ^\n/tmp/tmpjh7d1e4d.swift:23:72: error: expected\
    \ '{' in extension\n        extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                              ^\n/tmp/tmpjh7d1e4d.swift:23:63: error: declaration\
    \ is only valid at file scope\n        extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                     ^\n/tmp/tmpjh7d1e4d.swift:26:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpjh7d1e4d.swift:27:9: "
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for c in extension {\n            if c >= 'A' && c <= 'Z' {\n       \
    \         extension_strength = extension_strength * 26 + c - 'A'\n           \
    \ } else {\n                extension_strength = extension_strength * 10 + c -\
    \ 'a'\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpz3z40if7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpz3z40if7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpz3z40if7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpz3z40if7.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpz3z40if7.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpz3z40if7.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpz3z40if7.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpz3z40if7.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpz3z40if7.swift:23:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpz3z40if7.swift:23:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpz3z40if7.swift:24:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpz3z40if7.swift:24:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpz3z40if7.swift:25:68: error: single-quoted string literal\
    \ found, use '\"'\n                extension_strength = extension_strength * 26\
    \ + c - 'A'\n                                                                "
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.characters.count\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpbcdicfvn.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpbcdicfvn.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpbcdicfvn.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpbcdicfvn.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpbcdicfvn.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpbcdicfvn.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpbcdicfvn.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpbcdicfvn.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpbcdicfvn.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpbcdicfvn.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpbcdicfvn.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpbcdicfvn.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpiectq_i2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpiectq_i2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpiectq_i2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpiectq_i2.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpiectq_i2.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpiectq_i2.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \        ^\n/tmp/tmpiectq_i2.swift:22:43: error: expected '{' in extension\n \
    \       let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpiectq_i2.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpiectq_i2.swift:22:83: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpiectq_i2.swift:22:83: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \   "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for character in extension {\n            if character == character.lowercased()\
    \ {\n                extension_strength -= 1\n            }\n        }\n     \
    \   if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ljsxdh5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7ljsxdh5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7ljsxdh5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7ljsxdh5.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp7ljsxdh5.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp7ljsxdh5.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp7ljsxdh5.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp7ljsxdh5.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp7ljsxdh5.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp7ljsxdh5.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp7ljsxdh5.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp7ljsxdh5.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp7ljsxdh5.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp7ljsxdh5.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    if extensions.isEmpty {\n        return class_name\n    }\n    var max_strength\
    \ = -1\n    var max_extension = \"\"\n    for extension in extensions {\n    \
    \    let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            max_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + max_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyf0v66uv.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyf0v66uv.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyf0v66uv.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyf0v66uv.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpyf0v66uv.swift:25:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpyf0v66uv.swift:25:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpyf0v66uv.swift:25:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpyf0v66uv.swift:25:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpyf0v66uv.swift:25:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpyf0v66uv.swift:25:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpyf0v66uv.swift:25:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqzx3p7f.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqzx3p7f.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpuqzx3p7f.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpuqzx3p7f.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpuqzx3p7f.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplxj9rzjr.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplxj9rzjr.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmplxj9rzjr.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmplxj9rzjr.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmplxj9rzjr.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            strongest_extension\
    \ = class_name + \".\" + extension\n            break\n        }\n    }\n    return\
    \ strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1hg5j289.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1hg5j289.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1hg5j289.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1hg5j289.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp1hg5j289.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp1hg5j289.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp1hg5j289.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp1hg5j289.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp1hg5j289.swift:26:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmp1hg5j289.swift:27:13: error: expected type name in extension\
    \ declaration\n            break\n            ^\n/tmp/tmp1hg5j289.swift:26:63:\
    \ error: expected '{' in extension\n            strongest_extension = class_name\
    \ + \".\" + extension\n                                                      \
    \        ^\n/tmp/tmp1hg5j289.swift:26:54: error: declaration is only valid at\
    \ file scope\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                     ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            if strength\
    \ > strongest_extension.count {\n                strongest_extension = extension\n\
    \            }\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7n6pypas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7n6pypas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7n6pypas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7n6pypas.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp7n6pypas.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp7n6pypas.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp7n6pypas.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp7n6pypas.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp7n6pypas.swift:27:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmp7n6pypas.swift:28:13:\
    \ error: expected type name in extension declaration\n            }\n        \
    \    ^\n/tmp/tmp7n6pypas.swift:27:48: error: expected '{' in extension\n     \
    \           strongest_extension = extension\n                                \
    \               ^\n/tmp/tmp7n6pypas.swift:27:39: error: declaration is only valid\
    \ at file scope\n                strongest_extension = extension\n           \
    \                           ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1kw36yvq.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: candidate expects value of type\
    \ '(String) throws -> Bool' for parameter #1 (got 'Array<String>.Index?' (aka\
    \ 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        var extension_length = extension.count\n        var\
    \ extension_strength = extension_length / class_name.count\n        if extension_strength\
    \ > strength {\n            strongest_extension = extension\n            strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsjiapxw_.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpsjiapxw_.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpsjiapxw_.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpsjiapxw_.swift:22:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpsjiapxw_.swift:22:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpsjiapxw_.swift:22:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpsjiapxw_.swift:22:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpsjiapxw_.swift:22:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpsjiapxw_.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpsjiapxw_.swift:26:22: error: expected\
    \ '{' in extension\n            strength = extension_strength\n              \
    \       ^\n/tmp/tmpsjiapxw_.swift:25:35: error: declaration is only valid at file\
    \ scope\n            strongest_extension = extension\n                       \
    \           ^\n/tmp/tmpsjiapxw_.swift:26:13: error: cannot find type 'strength'\
    \ in scope\n            strength = extension_strength\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = class_name\n\
    \            strongest_extension_strength = extension_strength\n        }\n  \
    \  }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr4y985_y.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr4y985_y.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr4y985_y.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr4y985_y.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpr4y985_y.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpr4y985_y.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpr4y985_y.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpr4y985_y.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpr4y985_y.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpr4y985_y.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name = class_name_components[0]\n        let extension\
    \ = extension_components[0]\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_count_upper = class_name_components_count - class_name_components_count.map\
    \ { $0.isUppercase }.count\n        let extension_components_count_upper = extension_components_count\
    \ - extension_components_count.map { $0.isUppercase }.count\n        let class_name_components_count_lower\
    \ = class_name_components_count - class_name_components_count.map { $0.isLowercase\
    \ }.count\n        let extension_components_count_lower = extension_components_count\
    \ - extension_components_count.map { $0.isLowercase }.count\n        let class_name_components_count_all\
    \ = class_name_components_count + class_name_components_count_upper + class_name_components_count_lower\n\
    \        let extension_components_count_all = extension_components_count + extension_components_count_upper\
    \ + extension_components_count_lower\n        let class_name_components_count_all_upper\
    \ = class_name_components_count_all + class_name_components_count_upper\n    \
    \    let extension_components_count_all_upper = extension_components_count_all\
    \ + extension_components_count_upper\n        let class_name_components_count_all_lower\
    \ = class_name_components_count_all + class_name_components_count_lower\n    \
    \    let extension_components_count_all_lower = extension_components_count_all\
    \ + extension_components_count_lower\n        let class_name_components_count_all_all\
    \ = class_name_components_count_all + class_name_components_count_all_upper +\
    \ class_name_components_count_all_lower\n        let extension_components_count_all_all\
    \ = extension_components_count_all + extension_components_count_all_upper + extension_components_count_all_lower\n\
    \        let class_name_components_count_all_all_upper = class_name_components_count_all_all\
    \ + class_name_components_count_all_upper\n        let extension_components_count_all_all_upper\
    \ = extension_components_count_all_all + extension_components_count_all_upper\n\
    \        let class_name_components_count_all_all_lower = class_name_components_count_all_all\
    \ + class_name_components_count_all_lower\n        let extension_components_count_all_all_lower\
    \ = extension_components_count_all_all + extension_components_count_all_lower\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8_esoh4f.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8_esoh4f.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8_esoh4f.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8_esoh4f.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp8_esoh4f.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp8_esoh4f.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp8_esoh4f.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp8_esoh4f.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp8_esoh4f.swift:25:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[0]\n   \
    \         ^\n/tmp/tmp8_esoh4f.swift:25:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[0]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmp8_esoh4f.swift:67:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmp8_esoh4f.swift:18:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ St"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        var strength = count_capital_letters(extension) - count_capital_letters(class_name)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnyac0ss6.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnyac0ss6.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpnyac0ss6.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpnyac0ss6.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpnyac0ss6.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpnyac0ss6.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpnyac0ss6.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   let cap = extension.count\n        let sm = class_name.count\n        let\
    \ strength = cap - sm\n        if strength > 0 {\n            if strongest_extension\
    \ == \"\" {\n                strongest_extension = class_name\n            } else\
    \ {\n                if strength < strongest_extension.count {\n             \
    \       strongest_extension = class_name\n                }\n            }\n \
    \       }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp07gobwue.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp07gobwue.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp07gobwue.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp07gobwue.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp07gobwue.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp07gobwue.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp07gobwue.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp07gobwue.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strongest_extension_strength\
    \ = -1\n    for extension in extensions {\n        let extension_strength = extension.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8bia9_gp.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8bia9_gp.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8bia9_gp.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8bia9_gp.swift:23:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8bia9_gp.swift:23:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp8bia9_gp.swift:23:43: error: expected type name in extension\
    \ declaration\n        let extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp8bia9_gp.swift:23:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp8bia9_gp.swift:23:34: error: declaration\
    \ is only valid at file scope\n        let extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8bia9_gp.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp8bia9_gp.swift:27:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp8bia9_gp.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp8bia9_gp.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.count - 1]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpyzs_iy9a/tmpyzs_iy9a.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43655e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43652dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43652dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43652db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyzs_iy9a                        0x0000558eda792807 <unavailable> + 6151

    5    libc.so.6                          0x00002b43657d1460 __libc_start_main +
    245

    6    tmpyzs_iy9a                        0x0000558eda792189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name = class_name_components[0]\n        let extension\
    \ = extension_components[0]\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_count_upper = class_name_components_count - class_name_components_count.filter{$0.isUppercase}.count\n\
    \        let extension_components_count_upper = extension_components_count - extension_components_count.filter{$0.isUppercase}.count\n\
    \        let class_name_components_count_lower = class_name_components_count -\
    \ class_name_components_count.filter{$0.isLowercase}.count\n        let extension_components_count_lower\
    \ = extension_components_count - extension_components_count.filter{$0.isLowercase}.count\n\
    \        let class_name_components_count_cap = class_name_components_count - class_name_components_count.filter{$0.isUppercase}.filter{$0.isLowercase}.count\n\
    \        let extension_components_count_cap = extension_components_count - extension_components_count.filter{$0.isUppercase}.filter{$0.isLowercase}.count\n\
    \        let class_name_components_count_sm = class_name_components_count - class_name_components_count.filter{$0.isLowercase}.filter{$0.isUppercase}.count\n\
    \        let extension_components_count_sm = extension_components_count - extension_components_count.filter{$0.isLowercase}.filter{$0.isUppercase}.count\n\
    \        let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ + class_name_components_count_sm) / 2\n        let extension_components_count_cap_sm\
    \ = (extension_components_count_cap + extension_components_count_sm) / 2\n   \
    \     let class_name_components_count_cap_sm_lower = (class_name_components_count_cap_sm\
    \ + class_name_components_count_lower) / 2\n        let extension_components_count_cap_sm_lower\
    \ = (extension_components_count_cap_sm + extension_components_count_lower) / 2\n\
    \        let class_name_components_count_cap_sm_upper = (class_name_components_count_cap_sm\
    \ + class_name_components_count_upper) / 2\n        let extension_components_count_cap_sm_upper\
    \ = (extension_components_count_cap_sm + extension_components_count_upper) / 2\n\
    \        let class_name_components_count_cap_sm_upper_sm = (class_name_components_count_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8qmm2doc.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8qmm2doc.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8qmm2doc.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8qmm2doc.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp8qmm2doc.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp8qmm2doc.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp8qmm2doc.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp8qmm2doc.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp8qmm2doc.swift:25:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[0]\n   \
    \         ^\n/tmp/tmp8qmm2doc.swift:25:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[0]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmp8qmm2doc.swift:43:1:\
    \ error: expected ')' in expression list\n}\n^\n/tmp/tmp8qmm2doc.swift:42:59:\
    \ note: to match this opening '('\n        let class_name_components_count_cap_sm_upper_sm\
    \ = (class_name_components_count_\n                                          \
    \                ^\n/tmp/tmp8qmm2doc.swift:66:91: error: expected '}' at end of\
    \ brace statement\nas"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    for extension\
    \ in extensions {\n        var strength = extension.count\n        for character\
    \ in extension {\n            if character == character.lowercased() {\n     \
    \           strength -= 1\n            }\n        }\n        if strength > 0 {\n\
    \            strongest_extension += extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpopskapys.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpopskapys.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpopskapys.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpopskapys.swift:22:24:\
    \ error: expected initial value after '='\n        var strength = extension.count\n\
    \                       ^\n/tmp/tmpopskapys.swift:22:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = extension.count\n\
    \                      ^\n                      ;\n/tmp/tmpopskapys.swift:22:33:\
    \ error: expected type name in extension declaration\n        var strength = extension.count\n\
    \                                ^\n/tmp/tmpopskapys.swift:22:33: error: expected\
    \ '{' in extension\n        var strength = extension.count\n                 \
    \               ^\n/tmp/tmpopskapys.swift:22:24: error: declaration is only valid\
    \ at file scope\n        var strength = extension.count\n                    \
    \   ^\n/tmp/tmpopskapys.swift:23:26: error: expected Sequence expression for for-each\
    \ loop\n        for character in extension {\n                         ^\n/tmp/tmpopskapys.swift:23:26:\
    \ error: expected '{' to start the body of for-each loop\n        for character\
    \ in extension {\n                         ^\n/tmp/tmpopskapys.swift:29:36: error:\
    \ expected expression after operator\n            strongest_extension += extension\n\
    \                                   ^\n/tmp/tmpopskapys.swift:30:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpopskapys.swift:29:45:\
    \ error: expected '{' in extension\n            strongest_extension += extension\n\
    \                                            ^\n/tmp/tmpopskapys.swift:29:36:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ += extension\n                                   ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3a2rco6p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3a2rco6p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3a2rco6p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3a2rco6p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp3a2rco6p.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp3a2rco6p.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp3a2rco6p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp3a2rco6p.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp3a2rco6p.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp3a2rco6p.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp3a2rco6p.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3a2rco6p.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqzx3p7f.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqzx3p7f.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpuqzx3p7f.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpuqzx3p7f.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpuqzx3p7f.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    if extensions.isEmpty {\n        return class_name\n    }\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp93xueixv.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp93xueixv.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp93xueixv.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp93xueixv.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp93xueixv.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp93xueixv.swift:25:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp93xueixv.swift:25:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp93xueixv.swift:25:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp93xueixv.swift:27:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp93xueixv.swift:28:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmp93xueixv.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmp93xueixv.swift:28:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplxj9rzjr.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplxj9rzjr.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmplxj9rzjr.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmplxj9rzjr.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmplxj9rzjr.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptbabkas5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptbabkas5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptbabkas5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptbabkas5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmptbabkas5.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmptbabkas5.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmptbabkas5.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmptbabkas5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmptbabkas5.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmptbabkas5.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmptbabkas5.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmptbabkas5.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   let extension_length = extension.count\n        let extension_uppercase_count\
    \ = extension.filter{$0.isUpper}.count\n        let extension_lowercase_count\
    \ = extension.filter{$0.isLower}.count\n        let extension_strength = extension_uppercase_count\
    \ - extension_lowercase_count\n        if extension_strength > 0 {\n         \
    \   let extension_uppercase_extension = extension.filter{$0.isUpper}\n       \
    \     let extension_lowercase_extension = extension.filter{$0.isLower}\n     \
    \       let extension_extension = extension_uppercase_extension.count - extension_lowercase_extension.count\n\
    \            if extension_extension > 0 {\n                let extension_strength_percentage\
    \ = extension_strength / extension_extension\n                if extension_strength_percentage\
    \ > strongest_extension.count {\n                    strongest_extension = extension\n\
    \                }\n            }\n        }\n    }\n    return class_name + \"\
    .\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpx_buyauv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpx_buyauv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpx_buyauv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpx_buyauv.swift:21:32:\
    \ error: expected initial value after '='\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpx_buyauv.swift:21:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpx_buyauv.swift:21:41: error: expected type name in extension\
    \ declaration\n        let extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpx_buyauv.swift:21:41: error: expected '{'\
    \ in extension\n        let extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpx_buyauv.swift:21:32: error: declaration\
    \ is only valid at file scope\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpx_buyauv.swift:22:41: error: expected\
    \ initial value after '='\n        let extension_uppercase_count = extension.filter{$0.isUpper}.count\n\
    \                                        ^\n/tmp/tmpx_buyauv.swift:22:40: error:\
    \ consecutive statements on a line must be separated by ';'\n        let extension_uppercase_count\
    \ = extension.filter{$0.isUpper}.count\n                                     \
    \  ^\n                                       ;\n/tmp/tmpx_buyauv.swift:22:50:\
    \ error: expected type name in extension declaration\n        let extension_uppercase_count\
    \ = extension.filter{$0.isUpper}.count\n                                     \
    \            ^\n/tmp/tmpx_buyauv.swift:22:50: error: expected '{' in extension\n\
    \        let extension_uppercase_count = extension.filter{$0.isUpper}.count\n\
    \                                                 ^\n/tmp/tmpx_buyauv.swift:22:"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strongest_extension_strength\
    \ = -1\n    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for c in extension {\n            if c.isUppercase() {\n            \
    \    extension_strength -= 1\n            }\n            if c.isLowercase() {\n\
    \                extension_strength += 1\n            }\n        }\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8c2owvlg.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8c2owvlg.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8c2owvlg.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8c2owvlg.swift:23:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8c2owvlg.swift:23:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp8c2owvlg.swift:23:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp8c2owvlg.swift:23:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp8c2owvlg.swift:23:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8c2owvlg.swift:24:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmp8c2owvlg.swift:24:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmp8c2owvlg.swift:34:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp8c2owvlg.swift:35:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp8c2owvlg.swift:34:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp8c2owvlg.swift:34:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_lowercase = extension.lowercased()\n\
    \        let class_lowercase = class_name.lowercased()\n        let strength_of_extension\
    \ = extension_lowercase.distance(class_lowercase)\n        if strength_of_extension\
    \ > strength {\n            strongest_extension = extension\n            strength\
    \ = strength_of_extension\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjtmjssqd.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjtmjssqd.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjtmjssqd.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjtmjssqd.swift:22:35:\
    \ error: expected initial value after '='\n        let extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpjtmjssqd.swift:22:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmpjtmjssqd.swift:22:44: error: expected type name\
    \ in extension declaration\n        let extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpjtmjssqd.swift:22:44: error:\
    \ expected '{' in extension\n        let extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmpjtmjssqd.swift:22:35: error:\
    \ declaration is only valid at file scope\n        let extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmpjtmjssqd.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpjtmjssqd.swift:27:22: error: expected\
    \ '{' in extension\n            strength = strength_of_extension\n           \
    \          ^\n/tmp/tmpjtmjssqd.swift:26:35: error: declaration is only valid at\
    \ file scope\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpjtmjssqd.swift:27:13: error: cannot find type 'strength'\
    \ in scope\n            strength = strength_of_extension\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    var extension_counter = 0\n    for extension in extensions {\n        extension_counter\
    \ += 1\n        if extension_counter == 1 {\n            strongest_extension =\
    \ extension\n        } else {\n            if extension_counter > strongest_extension_strength\
    \ {\n                strongest_extension_strength = extension_counter\n      \
    \          strongest_extension = extension\n            }\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp71e3o6au.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp71e3o6au.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp71e3o6au.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp71e3o6au.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp71e3o6au.swift:26:9:\
    \ error: expected type name in extension declaration\n        } else {\n     \
    \   ^\n/tmp/tmp71e3o6au.swift:25:44: error: expected '{' in extension\n      \
    \      strongest_extension = extension\n                                     \
    \      ^\n/tmp/tmp71e3o6au.swift:25:35: error: declaration is only valid at file\
    \ scope\n            strongest_extension = extension\n                       \
    \           ^\n/tmp/tmp71e3o6au.swift:29:39: error: expected expression in assignment\n\
    \                strongest_extension = extension\n                           \
    \           ^\n/tmp/tmp71e3o6au.swift:30:13: error: expected type name in extension\
    \ declaration\n            }\n            ^\n/tmp/tmp71e3o6au.swift:29:48: error:\
    \ expected '{' in extension\n                strongest_extension = extension\n\
    \                                               ^\n/tmp/tmp71e3o6au.swift:29:39:\
    \ error: declaration is only valid at file scope\n                strongest_extension\
    \ = extension\n                                      ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqzx3p7f.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqzx3p7f.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpuqzx3p7f.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpuqzx3p7f.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpuqzx3p7f.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplxj9rzjr.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplxj9rzjr.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmplxj9rzjr.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmplxj9rzjr.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmplxj9rzjr.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1vlkvf81.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp1vlkvf81.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp1vlkvf81.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp1vlkvf81.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp1vlkvf81.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmp1vlkvf81.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmp1vlkvf81.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmp1vlkvf81.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp1vlkvf81.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp1vlkvf81.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp1vlkvf81.swift:22:7"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            if strongest_extension\
    \ == \"\" {\n                strongest_extension = class_name + extension\n  \
    \          } else {\n                if strength < strongest_extension.count {\n\
    \                    strongest_extension = class_name + extension\n          \
    \      }\n            }\n        }\n    }\n    return strongest_extension\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_3ugw7ne.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_3ugw7ne.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_3ugw7ne.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_3ugw7ne.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp_3ugw7ne.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp_3ugw7ne.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp_3ugw7ne.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp_3ugw7ne.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp_3ugw7ne.swift:27:52:\
    \ error: expected expression after operator\n                strongest_extension\
    \ = class_name + extension\n                                                 \
    \  ^\n/tmp/tmp_3ugw7ne.swift:28:13: error: expected type name in extension declaration\n\
    \            } else {\n            ^\n/tmp/tmp_3ugw7ne.swift:27:61: error: expected\
    \ '{' in extension\n                strongest_extension = class_name + extension\n\
    \                                                            ^\n/tmp/tmp_3ugw7ne.swift:27:52:\
    \ error: declaration is only valid at file scope\n                strongest_extension\
    \ = class_name + extension\n                                                 \
    \  ^\n/tmp/tmp_3ugw7ne.swift:30:56: error: expected expression after operator\n\
    \                    strongest_extension = class_name + extension\n          \
    \                                             ^\n/tmp/tmp_3ugw7ne.swift:31:17:\
    \ error: expected type name in extension declaration\n                }\n    \
    \            ^\n/tmp/tmp_3ugw7"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    if extensions.count < 2 {\n        return class_name\n    }\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwhjs33k6.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpwhjs33k6.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpwhjs33k6.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpwhjs33k6.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpwhjs33k6.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpwhjs33k6.swift:25:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpwhjs33k6.swift:25:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpwhjs33k6.swift:25:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpwhjs33k6.swift:28:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpwhjs33k6.swift:29:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpwhjs33k6.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpwhjs33k6.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3a2rco6p.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3a2rco6p.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3a2rco6p.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3a2rco6p.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp3a2rco6p.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp3a2rco6p.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp3a2rco6p.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp3a2rco6p.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp3a2rco6p.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp3a2rco6p.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp3a2rco6p.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3a2rco6p.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkmsdxkhf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkmsdxkhf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkmsdxkhf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkmsdxkhf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpkmsdxkhf.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpkmsdxkhf.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpkmsdxkhf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpkmsdxkhf.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpkmsdxkhf.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpkmsdxkhf.swift:25:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpkmsdxkhf.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpkmsdxkhf.swift:25:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for c in extension {\n            if c >= 'A' && c <= 'Z' {\n       \
    \         extension_strength -= 26\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6y2v4lyk.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6y2v4lyk.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6y2v4lyk.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6y2v4lyk.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp6y2v4lyk.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp6y2v4lyk.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp6y2v4lyk.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp6y2v4lyk.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp6y2v4lyk.swift:23:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmp6y2v4lyk.swift:23:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmp6y2v4lyk.swift:24:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmp6y2v4lyk.swift:24:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmp6y2v4lyk.swift:30:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp6y2v4lyk.swift:31:9: error: expected type name in extensi"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n        if strength > max_strength {\n  \
    \          max_strength = strength\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpbo5y8l40.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpbo5y8l40.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpbo5y8l40.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpbo5y8l40.swift:22:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                       ^\n/tmp/tmpbo5y8l40.swift:22:23:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmpbo5y8l40.swift:22:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                ^\n/tmp/tmpbo5y8l40.swift:22:33:\
    \ error: expected '{' in extension\n        let strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                ^\n/tmp/tmpbo5y8l40.swift:22:24:\
    \ error: declaration is only valid at file scope\n        let strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                       ^\n/tmp/tmpbo5y8l40.swift:22:69:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \                              ^\n/tmp/tmpbo5y8l40.swift:22:69: error: expected\
    \ '{' in extension\n        let strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                        \
    \                            ^\n/tmp/tmpbo5y8l40.swift:22:60: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                       "
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptbabkas5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptbabkas5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptbabkas5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptbabkas5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmptbabkas5.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmptbabkas5.swift:22:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmptbabkas5.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmptbabkas5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmptbabkas5.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmptbabkas5.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmptbabkas5.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmptbabkas5.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for character in extension {\n            if character == character.lowercased()\
    \ {\n                extension_strength -= 1\n            }\n        }\n     \
    \   if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ljsxdh5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7ljsxdh5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7ljsxdh5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7ljsxdh5.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp7ljsxdh5.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp7ljsxdh5.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp7ljsxdh5.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp7ljsxdh5.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp7ljsxdh5.swift:23:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmp7ljsxdh5.swift:23:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmp7ljsxdh5.swift:30:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp7ljsxdh5.swift:31:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp7ljsxdh5.swift:30:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp7ljsxdh5.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        var extension_strength = extension.count\n        for\
    \ c in extension {\n            if c.isUppercase {\n                extension_strength\
    \ -= 1\n            }\n            if c.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strength {\n\
    \            strongest_extension = extension\n            strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdle27oe9.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdle27oe9.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdle27oe9.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdle27oe9.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdle27oe9.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdle27oe9.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdle27oe9.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdle27oe9.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdle27oe9.swift:23:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpdle27oe9.swift:23:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpdle27oe9.swift:32:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpdle27oe9.swift:33:22:\
    \ error: expected '{' in extension\n            strength = extension_strength\n\
    \                     ^\n/tmp/tmpdle27oe9.swift:32:35: error: declaration is only\
    \ valid at file scope\n            strongest_extension = extension\n         \
    \                         ^\n/tmp/tmpdle27oe9.swift:33:13: error: cannot find\
    \ type 'strength' in scope\n            strength = extension_strength\n      \
    \      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + Strongest_Extension_Name(extensions)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8j0fhtzd.swift:19:25: error: cannot find 'Strongest_Extension_Name'\
    \ in scope\n    return class_name + Strongest_Extension_Name(extensions)\n   \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    if extensions.count <= 0 {\n        return class_name\n    }\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcrnce6qq.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpcrnce6qq.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpcrnce6qq.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpcrnce6qq.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpcrnce6qq.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpcrnce6qq.swift:25:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpcrnce6qq.swift:25:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpcrnce6qq.swift:25:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpcrnce6qq.swift:28:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpcrnce6qq.swift:29:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpcrnce6qq.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpcrnce6qq.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for c in extension {\n            if c >= 'A' && c <= 'Z' {\n       \
    \         extension_strength -= 1\n            }\n            if c >= 'a' && c\
    \ <= 'z' {\n                extension_strength -= 1\n            }\n        }\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpeoc4xn81.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpeoc4xn81.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpeoc4xn81.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpeoc4xn81.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpeoc4xn81.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpeoc4xn81.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpeoc4xn81.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpeoc4xn81.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpeoc4xn81.swift:23:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpeoc4xn81.swift:23:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpeoc4xn81.swift:24:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpeoc4xn81.swift:24:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpeoc4xn81.swift:27:21: error: single-quoted string literal\
    \ found, use '\"'\n            if c >= 'a' && c <= 'z' {\n                   \
    \ ^~~\n                    \"a\"\n/tmp/tmpeoc4xn81.swift:27:33: error: single-quote"
  stdout: ''
  timestamp: 1660009505
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpdysk23nq/tmpdysk23nq.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba45b49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba45840b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba45840988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba4583f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdysk23nq                        0x0000561bb9d564fd <unavailable> + 5373

    5    libc.so.6                          0x00002aba45d35460 __libc_start_main +
    245

    6    tmpdysk23nq                        0x0000561bb9d56089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp9kja0rpt.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp9kja0rpt.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp9kja0rpt.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp9kja0rpt.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp9kja0rpt.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmp9kja0rpt.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmp9kja0rpt.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmp9kja0rpt.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp9kja0rpt.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp9kja0rpt.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp9kja0rpt.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    var extension_counter = 0\n    for extension in extensions {\n        extension_counter\
    \ += 1\n        if extension_counter > strongest_extension_strength {\n      \
    \      strongest_extension_strength = extension_counter\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpeenwzzal.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpeenwzzal.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpeenwzzal.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpeenwzzal.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpeenwzzal.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpeenwzzal.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpeenwzzal.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            if strength\
    \ > strength {\n                strongest_extension = extension\n            }\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnscz9970.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnscz9970.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnscz9970.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnscz9970.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpnscz9970.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpnscz9970.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpnscz9970.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpnscz9970.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpnscz9970.swift:27:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmpnscz9970.swift:28:13:\
    \ error: expected type name in extension declaration\n            }\n        \
    \    ^\n/tmp/tmpnscz9970.swift:27:48: error: expected '{' in extension\n     \
    \           strongest_extension = extension\n                                \
    \               ^\n/tmp/tmpnscz9970.swift:27:39: error: declaration is only valid\
    \ at file scope\n                strongest_extension = extension\n           \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    if extensions.isEmpty {\n        return class_name\n    }\n    var strongest_extension\
    \ = \"\"\n    var strength = -1\n    for extension in extensions {\n        let\
    \ cap = extension.count\n        let sm = class_name.count\n        let strength\
    \ = cap - sm\n        if strength > 0 {\n            if strength > strongest_extension.count\
    \ {\n                strongest_extension = extension\n            }\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpve7x74lv.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpve7x74lv.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpve7x74lv.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpve7x74lv.swift:25:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpve7x74lv.swift:25:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpve7x74lv.swift:25:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpve7x74lv.swift:25:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpve7x74lv.swift:25:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpve7x74lv.swift:30:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmpve7x74lv.swift:31:13:\
    \ error: expected type name in extension declaration\n            }\n        \
    \    ^\n/tmp/tmpve7x74lv.swift:30:48: error: expected '{' in extension\n     \
    \           strongest_extension = extension\n                                \
    \               ^\n/tmp/tmpve7x74lv.swift:30:39: error: declaration is only valid\
    \ at file scope\n                strongest_extension = extension\n           \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for c in extension {\n            if c >= 'A' && c <= 'Z' {\n       \
    \         extension_strength -= (c - 'A').count\n            }\n            if\
    \ c >= 'a' && c <= 'z' {\n                extension_strength -= (c - 'a').count\n\
    \            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkum6hmvg.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkum6hmvg.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkum6hmvg.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkum6hmvg.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpkum6hmvg.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpkum6hmvg.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpkum6hmvg.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpkum6hmvg.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpkum6hmvg.swift:23:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpkum6hmvg.swift:23:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpkum6hmvg.swift:24:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpkum6hmvg.swift:24:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpkum6hmvg.swift:25:44: error: single-quoted string literal\
    \ found, use '\"'\n                extension_strength -= (c - 'A').count\n   \
    \                                        ^~~\n                               \
    \   "
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   var strength = extension.count\n        for letter in extension {\n      \
    \      if letter.isUpper() {\n                strength -= 1\n            }\n \
    \       }\n        if strength > 0 {\n            strongest_extension += \".\"\
    \ + extension\n        }\n    }\n    return class_name + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpeseeqzyl.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpeseeqzyl.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpeseeqzyl.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpeseeqzyl.swift:21:24:\
    \ error: expected initial value after '='\n        var strength = extension.count\n\
    \                       ^\n/tmp/tmpeseeqzyl.swift:21:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = extension.count\n\
    \                      ^\n                      ;\n/tmp/tmpeseeqzyl.swift:21:33:\
    \ error: expected type name in extension declaration\n        var strength = extension.count\n\
    \                                ^\n/tmp/tmpeseeqzyl.swift:21:33: error: expected\
    \ '{' in extension\n        var strength = extension.count\n                 \
    \               ^\n/tmp/tmpeseeqzyl.swift:21:24: error: declaration is only valid\
    \ at file scope\n        var strength = extension.count\n                    \
    \   ^\n/tmp/tmpeseeqzyl.swift:22:23: error: expected Sequence expression for for-each\
    \ loop\n        for letter in extension {\n                      ^\n/tmp/tmpeseeqzyl.swift:22:23:\
    \ error: expected '{' to start the body of for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmpeseeqzyl.swift:28:42: error: expected\
    \ expression after operator\n            strongest_extension += \".\" + extension\n\
    \                                         ^\n/tmp/tmpeseeqzyl.swift:29:9: error:\
    \ expected type name in extension declaration\n        }\n        ^\n/tmp/tmpeseeqzyl.swift:28:51:\
    \ error: expected '{' in extension\n            strongest_extension += \".\" +\
    \ extension\n                                                  ^\n/tmp/tmpeseeqzyl.swift:28:42:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ += \".\" + extension\n                                         ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            strongest_extension\
    \ = class_name + \".\" + extension\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6loidq3i.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6loidq3i.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6loidq3i.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6loidq3i.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp6loidq3i.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp6loidq3i.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp6loidq3i.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp6loidq3i.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp6loidq3i.swift:26:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmp6loidq3i.swift:27:9: error: expected type name in extension\
    \ declaration\n        }\n        ^\n/tmp/tmp6loidq3i.swift:26:63: error: expected\
    \ '{' in extension\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                              ^\n/tmp/tmp6loidq3i.swift:26:54:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = class_name + \".\" + extension\n                                         \
    \            ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = class_name\n\
    \            strongest_extension_strength = extension_strength\n        }\n  \
    \  }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr4y985_y.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr4y985_y.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr4y985_y.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr4y985_y.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpr4y985_y.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpr4y985_y.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpr4y985_y.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpr4y985_y.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpr4y985_y.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpr4y985_y.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplzgmq3jd.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplzgmq3jd.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplzgmq3jd.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplzgmq3jd.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmplzgmq3jd.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmplzgmq3jd.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters - extension.countLowercaseLetters\n  \
    \                                        ^\n/tmp/tmplzgmq3jd.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmplzgmq3jd.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmplzgmq3jd.swift:22:81: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmplzgmq3jd.swift:22:81: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                        ^\n/tmp/tmplzgmq3jd.swift:22:72: error:\
    \ declaration is onl"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxsl3uhmf.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxsl3uhmf.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxsl3uhmf.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxsl3uhmf.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpxsl3uhmf.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpxsl3uhmf.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpxsl3uhmf.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpxsl3uhmf.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpxsl3uhmf.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpxsl3uhmf.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpxsl3uhmf.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strength =\
    \ -1\n    for extension in extensions {\n        let extension_length = extension.count\n\
    \        let class_name_length = class_name.count\n        let extension_strength\
    \ = class_name_length - extension_length\n        if extension_strength > strength\
    \ {\n            strongest_extension = extension\n            strength = extension_strength\n\
    \        }\n    }\n    return class_name + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpazlyknaz.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpazlyknaz.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpazlyknaz.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpazlyknaz.swift:23:32:\
    \ error: expected initial value after '='\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpazlyknaz.swift:23:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpazlyknaz.swift:23:41: error: expected type name in extension\
    \ declaration\n        let extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpazlyknaz.swift:23:41: error: expected '{'\
    \ in extension\n        let extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpazlyknaz.swift:23:32: error: declaration\
    \ is only valid at file scope\n        let extension_length = extension.count\n\
    \                               ^\n/tmp/tmpazlyknaz.swift:27:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpazlyknaz.swift:28:22: error: expected\
    \ '{' in extension\n            strength = extension_strength\n              \
    \       ^\n/tmp/tmpazlyknaz.swift:27:35: error: declaration is only valid at file\
    \ scope\n            strongest_extension = extension\n                       \
    \           ^\n/tmp/tmpazlyknaz.swift:28:13: error: cannot find type 'strength'\
    \ in scope\n            strength = extension_strength\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    var class_name_uppercase = class_name.uppercased()\n    var class_name_lowercase\
    \ = class_name.lowercased()\n    \n    for extension in extensions {\n       \
    \ var extension_uppercase = extension.uppercased()\n        var extension_lowercase\
    \ = extension.lowercased()\n        var extension_strength = class_name_uppercase.distance(class_name_lowercase)\n\
    \        \n        if extension_strength > strongest_extension_strength {\n  \
    \          strongest_extension_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp09m4xuz1.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp09m4xuz1.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp09m4xuz1.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp09m4xuz1.swift:25:35:\
    \ error: expected initial value after '='\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmp09m4xuz1.swift:25:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_uppercase\
    \ = extension.uppercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmp09m4xuz1.swift:25:44: error: expected type name\
    \ in extension declaration\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmp09m4xuz1.swift:25:44: error:\
    \ expected '{' in extension\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmp09m4xuz1.swift:25:35: error:\
    \ declaration is only valid at file scope\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmp09m4xuz1.swift:26:35: error: expected\
    \ initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmp09m4xuz1.swift:26:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmp09m4xuz1.swift:26:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp09m4xuz1.swift:26:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp09m4xuz1.swift:26:35: error:\
    \ declaration is only val"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_extension_count = class_name_components_count - extension_components_count\n\
    \        let class_name_components_extension_count_str = class_name_components_extension_count.description\n\
    \        let extension_components_extension_count_str = extension_components_extension_count.description\n\
    \        let extension_components_extension_count_int = (extension_components_extension_count\
    \ as NSNumber).integerValue\n        let extension_components_extension_count_float\
    \ = (extension_components_extension_count as NSNumber).floatValue\n        let\
    \ extension_components_extension_count_double = (extension_components_extension_count\
    \ as NSNumber).doubleValue\n        let extension_components_extension_count_bool\
    \ = (extension_components_extension_count as NSNumber).boolValue\n        let\
    \ extension_components_extension_count_string = (extension_components_extension_count\
    \ as NSNumber).stringValue\n        let extension_components_extension_count_array\
    \ = (extension_components_extension_count as NSNumber).arrayValue\n        let\
    \ extension_components_extension_count_dictionary = (extension_components_extension_count\
    \ as NSNumber).dictionaryValue\n        let extension_components_extension_count_set\
    \ = (extension_components_extension_count as NSNumber).setValue\n        let extension_components_extension_count_dictionary_key\
    \ = (extension_components_extension_count as NSNumber).dictionaryKeyValue\n  \
    \      let extension_components_extension_count_dictionary_value = (extension_components_extension_count\
    \ as NSNumber).dictionaryValueValue\n        let extension_components_extension_count_dictionary_key_value\
    \ = (extension_components_extension_count as NSNumber).dictionaryKeyValueValue\n\
    \        let extension_components_extension_count_dictionary_key_value_array =\
    \ (extension_components_extension_count as NSNumber).dictionaryKeyValueValueArray\n\
    \        let extension_components_extension_count_dictionary_key_value_set_array\
    \ = (extension_components_extension_count as NSNumber).dictionaryKeyValueValueSetArray\n\
    \        let extension_components_extension_count_dictionary_key_value_set_set_array\
    \ = (extension_components_extension_count as NSNumber).dictionaryKeyValueValueSetSetArray\n\
    \        let extension_components_extension_count_dictionary_key_value_set_set_set_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpoj8_b1gq.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpoj8_b1gq.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpoj8_b1gq.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpoj8_b1gq.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpoj8_b1gq.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpoj8_b1gq.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpoj8_b1gq.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpoj8_b1gq.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpoj8_b1gq.swift:67:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpoj8_b1gq.swift:18:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmpoj8_b1gq.swift:47:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpoj8_b1gq.swift:22:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1kw36yvq.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: found candidate with type '(Int)\
    \ -> Int'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: candidate expects value of type\
    \ '(String) throws -> Bool' for parameter #1 (got 'Array<String>.Index?' (aka\
    \ 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n/tmp/tmp1kw36yvq.swift:19:53: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))!]\n                                              \
    \      ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strength =\
    \ 0\n    for extension in extensions {\n        var extension_length = extension.count\n\
    \        var class_length = class_name.count\n        var strength_percentage\
    \ = extension_length / class_length\n        if strength_percentage > strength\
    \ {\n            strongest_extension = extension\n            strength = strength_percentage\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplqwrmdv7.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplqwrmdv7.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplqwrmdv7.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplqwrmdv7.swift:23:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmplqwrmdv7.swift:23:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmplqwrmdv7.swift:23:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmplqwrmdv7.swift:23:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmplqwrmdv7.swift:23:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmplqwrmdv7.swift:27:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmplqwrmdv7.swift:28:22: error: expected\
    \ '{' in extension\n            strength = strength_percentage\n             \
    \        ^\n/tmp/tmplqwrmdv7.swift:27:35: error: declaration is only valid at\
    \ file scope\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmplqwrmdv7.swift:28:13: error: cannot find type 'strength'\
    \ in scope\n            strength = strength_percentage\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    // Your code here\n    var strongest_extension = \"\"\n    var strength =\
    \ Int()\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength_frac = cap - sm\n   \
    \     strength = strength * strength_frac / cap\n        if strength > strongest_extension.count\
    \ {\n            strongest_extension = extension\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8kfyse0u.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8kfyse0u.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8kfyse0u.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8kfyse0u.swift:23:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp8kfyse0u.swift:23:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp8kfyse0u.swift:23:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp8kfyse0u.swift:23:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp8kfyse0u.swift:23:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp8kfyse0u.swift:28:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp8kfyse0u.swift:29:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp8kfyse0u.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp8kfyse0u.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    if extensions.isEmpty {\n        return class_name\n    }\n    var strongest_extension\
    \ = \"\"\n    var strongest_extension_strength = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_3tjmnn6.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_3tjmnn6.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_3tjmnn6.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_3tjmnn6.swift:25:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_3tjmnn6.swift:25:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmp_3tjmnn6.swift:25:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_3tjmnn6.swift:25:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_3tjmnn6.swift:25:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_3tjmnn6.swift:28:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp_3tjmnn6.swift:29:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp_3tjmnn6.swift:28:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp_3tjmnn6.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1 // default value\n\
    \    for extension in extensions {\n        let cap = extension.count\n      \
    \  let sm = class_name.count\n        let strength = cap - sm\n        if strength\
    \ > strongest_extension.count {\n            strongest_extension = extension\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppn2l2vns.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmppn2l2vns.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmppn2l2vns.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmppn2l2vns.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmppn2l2vns.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmppn2l2vns.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmppn2l2vns.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmppn2l2vns.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmppn2l2vns.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmppn2l2vns.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmppn2l2vns.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmppn2l2vns.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let strength = extension.countUpToLowercaseLetters()\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3jnc6yl7.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3jnc6yl7.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3jnc6yl7.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3jnc6yl7.swift:22:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3jnc6yl7.swift:22:23: error: consecutive statements\
    \ on a line must be separated by ';'\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmp3jnc6yl7.swift:22:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3jnc6yl7.swift:22:33: error: expected\
    \ '{' in extension\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmp3jnc6yl7.swift:22:24: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToLowercaseLetters()\n\
    \                       ^\n/tmp/tmp3jnc6yl7.swift:25:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp3jnc6yl7.swift:26:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmp3jnc6yl7.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp3jnc6yl7.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqzx3p7f.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqzx3p7f.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqzx3p7f.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpuqzx3p7f.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpuqzx3p7f.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpuqzx3p7f.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpuqzx3p7f.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplxj9rzjr.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplxj9rzjr.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmplxj9rzjr.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmplxj9rzjr.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmplxj9rzjr.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        var extension_length = extension.count\n        var\
    \ class_length = class_name.count\n        var extension_strength = extension_length\
    \ / class_length\n        if extension_strength > strength {\n            strongest_extension\
    \ = extension\n            strength = extension_strength\n        }\n    }\n \
    \   return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5d2aoxy9.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5d2aoxy9.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5d2aoxy9.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5d2aoxy9.swift:22:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmp5d2aoxy9.swift:22:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmp5d2aoxy9.swift:22:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmp5d2aoxy9.swift:22:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmp5d2aoxy9.swift:22:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmp5d2aoxy9.swift:26:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp5d2aoxy9.swift:27:22: error: expected\
    \ '{' in extension\n            strength = extension_strength\n              \
    \       ^\n/tmp/tmp5d2aoxy9.swift:26:35: error: declaration is only valid at file\
    \ scope\n            strongest_extension = extension\n                       \
    \           ^\n/tmp/tmp5d2aoxy9.swift:27:13: error: cannot find type 'strength'\
    \ in scope\n            strength = extension_strength\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009505
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnap0mjab.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnap0mjab.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnap0mjab.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpnap0mjab.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpnap0mjab.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpnap0mjab.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpnap0mjab.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpnap0mjab.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1660009504
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n            return sum + Int(character.isUppercase)\n\
    \        }\n        if extension_strength > strongest_extension_strength {\n \
    \           strongest_extension_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpiuebfrhh.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpiuebfrhh.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpiuebfrhh.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpiuebfrhh.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                 ^\n/tmp/tmpiuebfrhh.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, character) -> Int\
    \ in\n                                ^\n                                ;\n/tmp/tmpiuebfrhh.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, character) -> Int in\n            \
    \                              ^\n/tmp/tmpiuebfrhh.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                          ^\n\
    /tmp/tmpiuebfrhh.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n                                 ^\n/tmp/tmpiuebfrhh.swift:27:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpiuebfrhh.swift:28:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpiuebfrhh.swift:27:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpiuebfrhh.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009505
