language: swift
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let class_name_components = class_name.components(separatedBy:\
    \ \".\")\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n        let class_name = class_name_components[class_name_components.count\
    \ - 1]\n        let extension = extension_components[extension_components.count\
    \ - 1]\n        let class_name_components_count = class_name_components.count\n\
    \        let extension_components_count = extension_components.count\n       \
    \ let class_name_components_count_index = class_name_components_count - 1\n  \
    \      let extension_components_count_index = extension_components_count - 1\n\
    \        let class_name_components_count_index_minus_1 = class_name_components_count_index\
    \ - 1\n        let extension_components_count_index_minus_1 = extension_components_count_index\
    \ - 1\n        let class_name_components_count_minus_1 = class_name_components_count\
    \ - 1\n        let extension_components_count_minus_1 = extension_components_count\
    \ - 1\n        let class_name_components_count_minus_2 = class_name_components_count\
    \ - 2\n        let extension_components_count_minus_2 = extension_components_count\
    \ - 2\n        let class_name_components_count_minus_3 = class_name_components_count\
    \ - 3\n        let extension_components_count_minus_3 = extension_components_count\
    \ - 3\n        let class_name_components_count_minus_4 = class_name_components_count\
    \ - 4\n        let extension_components_count_minus_4 = extension_components_count\
    \ - 4\n        let class_name_components_count_minus_5 = class_name_components_count\
    \ - 5\n        let extension_components_count_minus_5 = extension_components_count\
    \ - 5\n        let class_name_components_count_minus_6 = class_name_components_count\
    \ - 6\n        let extension_components_count_minus_6 = extension_components_count\
    \ - 6\n        let class_name_components_count_minus_7 = class_name_components_count\
    \ - 7\n        let extension_components_count_minus_7 = extension_components_count\
    \ - 7\n        let class_name_components_count_minus_8 = class_name_components_count\
    \ - 8\n        let extension_components_count_minus_8 = extension_components_count\
    \ - 8\n        let class_name_components_count_minus_9 = class_name_components_count\
    \ - 9\n        let extension_components_count_minus_9 = extension_components_count\
    \ - 9\n        let class_name_components_count_minus_10 = class_name_components_count\
    \ - 10\n        let extension_components_count_minus_10 = extension_components_count\
    \ - 10\n        let class_name_components_count_minus_11 = class_name_components_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpy5_33uw_.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpy5_33uw_.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpy5_33uw_.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpy5_33uw_.swift:23:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpy5_33uw_.swift:23:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpy5_33uw_.swift:23:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpy5_33uw_.swift:23:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpy5_33uw_.swift:23:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpy5_33uw_.swift:25:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^\n/tmp/tmpy5_33uw_.swift:25:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^~~~~~~~~\n            `extension`\n/tmp/tmpy5_33uw_.swift:76:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpy5_33uw_.swift:18:78: note: to matc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        var extension_length = extension.count\n        var\
    \ extension_strength = extension_length - 1\n        for _ in 0..<extension_length\
    \ {\n            let index = extension.index(extension.startIndex, offsetBy: 1)\n\
    \            let char = extension[index].lowercased()\n            if char ==\
    \ char.lowercased() {\n                extension_strength -= 1\n            }\n\
    \        }\n        if extension_strength > strength {\n            strongest_extension\
    \ = class_name\n            strength = extension_strength\n        }\n    }\n\
    \    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3iwnjbi.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpr3iwnjbi.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpr3iwnjbi.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpr3iwnjbi.swift:22:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpr3iwnjbi.swift:22:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpr3iwnjbi.swift:22:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpr3iwnjbi.swift:22:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpr3iwnjbi.swift:22:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpr3iwnjbi.swift:25:25: error: expected\
    \ initial value after '='\n            let index = extension.index(extension.startIndex,\
    \ offsetBy: 1)\n                        ^\n/tmp/tmpr3iwnjbi.swift:25:24: error:\
    \ consecutive statements on a line must be separated by ';'\n            let index\
    \ = extension.index(extension.startIndex, offsetBy: 1)\n                     \
    \  ^\n                       ;\n/tmp/tmpr3iwnjbi.swift:25:34: error: expected\
    \ type name in extension declaration\n            let index = extension.index(extension.startIndex,\
    \ offsetBy: 1)\n                                 ^\n/tmp/tmpr3iwnjbi.swift:25:34:\
    \ error: expected '{' in extension\n            let index = extension.index(extension.startIndex,\
    \ offsetBy: 1)\n                                 ^\n/tmp/tmpr3iwnjbi.swift:25:25:\
    \ error: declaration is only valid at file scope\n            let index = exten"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name = class_name_components[0]\n        let extension = extension_components[0]\n\
    \        let class_name_components_count = class_name_components.count\n     \
    \   let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components_count - class_name_components_count.count\n        let\
    \ extension_components_count_upper = extension_components_count - extension_components_count.count\n\
    \        let class_name_components_count_lower = class_name_components_count -\
    \ class_name_components_count_upper\n        let extension_components_count_lower\
    \ = extension_components_count - extension_components_count_upper\n        let\
    \ class_name_components_count_diff = class_name_components_count_upper - class_name_components_count_lower\n\
    \        let extension_components_count_diff = extension_components_count_upper\
    \ - extension_components_count_lower\n        let class_name_components_count_diff_upper\
    \ = class_name_components_count_diff - class_name_components_count_upper\n   \
    \     let extension_components_count_diff_upper = extension_components_count_diff\
    \ - extension_components_count_upper\n        let class_name_components_count_diff_lower\
    \ = class_name_components_count_diff - class_name_components_count_lower\n   \
    \     let extension_components_count_diff_lower = extension_components_count_diff\
    \ - extension_components_count_lower\n        let class_name_components_count_diff_diff\
    \ = class_name_components_count_diff_upper - class_name_components_count_diff_lower\n\
    \        let extension_components_count_diff_diff = extension_components_count_diff_upper\
    \ - extension_components_count_diff_lower\n        let class_name_components_count_diff_diff_upper\
    \ = class_name_components_count_diff_diff - class_name_components_count_diff_upper\n\
    \        let extension_components_count_diff_diff_upper = extension_components_count_diff_diff\
    \ - extension_components_count_diff_upper\n        let class_name_components_count_diff_diff_lower\
    \ = class_name_components_count_diff_diff - class_name_components_count_diff_lower\n\
    \        let extension_components_count_diff_diff_lower = extension_components_count_diff_diff\
    \ - extension_components_count_diff_lower\n        let class_name_components_count_diff_diff_diff\
    \ = class_name_components_count_diff_diff_upper - class_name_components_count_diff_diff_lower\n\
    \        let extension_components_count_diff_diff_diff = extension_components_count_diff_diff_upper\
    \ - extension_components_count_diff_diff_lower\n        let class_name_components_count_diff_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnc10i8i9.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnc10i8i9.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnc10i8i9.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnc10i8i9.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpnc10i8i9.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpnc10i8i9.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpnc10i8i9.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpnc10i8i9.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpnc10i8i9.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[0]\n   \
    \         ^\n/tmp/tmpnc10i8i9.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[0]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpnc10i8i9.swift:69:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpnc10i8i9.swift:18:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ St"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphkaxlo5t.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphkaxlo5t.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphkaxlo5t.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphkaxlo5t.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmphkaxlo5t.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmphkaxlo5t.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmphkaxlo5t.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmphkaxlo5t.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmphkaxlo5t.swift:22:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmphkaxlo5t.swift:22:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmphkaxlo5t.swift:22:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp9kja0rpt.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp9kja0rpt.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp9kja0rpt.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp9kja0rpt.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp9kja0rpt.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmp9kja0rpt.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmp9kja0rpt.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmp9kja0rpt.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmp9kja0rpt.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp9kja0rpt.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmp9kja0rpt.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let extension_uppercase_count = extension.count\n \
    \       let extension_lowercase_count = extension.count\n        let extension_strength\
    \ = extension_uppercase_count - extension_lowercase_count\n        if extension_strength\
    \ > strength {\n            strongest_extension = extension\n            strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpn5fyrcjb.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpn5fyrcjb.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpn5fyrcjb.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpn5fyrcjb.swift:22:41:\
    \ error: expected initial value after '='\n        let extension_uppercase_count\
    \ = extension.count\n                                        ^\n/tmp/tmpn5fyrcjb.swift:22:40:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_uppercase_count = extension.count\n                              \
    \         ^\n                                       ;\n/tmp/tmpn5fyrcjb.swift:22:50:\
    \ error: expected type name in extension declaration\n        let extension_uppercase_count\
    \ = extension.count\n                                                 ^\n/tmp/tmpn5fyrcjb.swift:22:50:\
    \ error: expected '{' in extension\n        let extension_uppercase_count = extension.count\n\
    \                                                 ^\n/tmp/tmpn5fyrcjb.swift:22:41:\
    \ error: declaration is only valid at file scope\n        let extension_uppercase_count\
    \ = extension.count\n                                        ^\n/tmp/tmpn5fyrcjb.swift:23:41:\
    \ error: expected initial value after '='\n        let extension_lowercase_count\
    \ = extension.count\n                                        ^\n/tmp/tmpn5fyrcjb.swift:23:40:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_lowercase_count = extension.count\n                              \
    \         ^\n                                       ;\n/tmp/tmpn5fyrcjb.swift:23:50:\
    \ error: expected type name in extension declaration\n        let extension_lowercase_count\
    \ = extension.count\n                                                 ^\n/tmp/tmpn5fyrcjb.swift:23:50:\
    \ error: expected '{' in extension\n        let extension_lowercase_count = extension.count\n\
    \                                                 ^\n/tm"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp58dfakop.swift:19:53: error: no exact matches in call to instance\
    \ method 'index'\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n    return\
    \ class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of: class_name.lowercased()))]\n\
    \                                                    ^\n/tmp/tmp58dfakop.swift:19:53:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Array<String>.Index?'\
    \ (aka 'Optional<Int>'))\n    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n/tmp/tmp58dfakop.swift:19:53: note: candidate expects value of type 'Array<String>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<String>.Index?' (aka 'Optional<Int>'))\n\
    \    return class_name + \".\" + extensions[extensions.index(extensions.firstIndex(of:\
    \ class_name.lowercased()))]\n                                               \
    \     ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8vv4bo5.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpo8vv4bo5.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpo8vv4bo5.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpo8vv4bo5.swift:22:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpo8vv4bo5.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpo8vv4bo5.swift:22:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpo8vv4bo5.swift:22:7"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for char in extension {\n            if char.uppercased() != char {\n\
    \                extension_strength -= 1\n            }\n        }\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0do7k412.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp0do7k412.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp0do7k412.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp0do7k412.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp0do7k412.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp0do7k412.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp0do7k412.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp0do7k412.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp0do7k412.swift:23:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmp0do7k412.swift:23:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n/tmp/tmp0do7k412.swift:30:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp0do7k412.swift:31:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp0do7k412.swift:30:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmp0do7k412.swift:30:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplxj9rzjr.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplxj9rzjr.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplxj9rzjr.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmplxj9rzjr.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmplxj9rzjr.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmplxj9rzjr.swift:22:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmplxj9rzjr.swift:22:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmplxj9rzjr.swift:22:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4k6zhas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpw4k6zhas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpw4k6zhas.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpw4k6zhas.swift:22:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpw4k6zhas.swift:22:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpw4k6zhas.swift:25:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpw4k6zhas.swift:26:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpw4k6zhas.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpw4k6zhas.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        var strength = count_capital_letters(extension) - count_capital_letters(class_name)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpbb7iv656.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpbb7iv656.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpbb7iv656.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpbb7iv656.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpbb7iv656.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpbb7iv656.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpbb7iv656.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpbb7iv656.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpbb7iv656.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpbb7iv656.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpbb7iv656.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpbb7iv656.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strongest_extension_strength = -1\n\
    \    for extension in extensions {\n        var extension_strength = extension.count\n\
    \        for letter in extension {\n            if letter.isUpper() {\n      \
    \          extension_strength -= 1\n            }\n        }\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd943tv2.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvd943tv2.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvd943tv2.swift:22:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:22:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpvd943tv2.swift:22:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpvd943tv2.swift:22:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpvd943tv2.swift:22:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpvd943tv2.swift:23:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpvd943tv2.swift:30:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpvd943tv2.swift:31:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpvd943tv2.swift:30:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpvd943tv2.swift:30:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        var strength = count_capital_letters(extension) - count_capital_letters(class_name)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnyac0ss6.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnyac0ss6.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:22:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpnyac0ss6.swift:22:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpnyac0ss6.swift:22:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpnyac0ss6.swift:22:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpnyac0ss6.swift:25:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpnyac0ss6.swift:26:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpnyac0ss6.swift:25:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpnyac0ss6.swift:25:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var max_strength = -1\n    for extension\
    \ in extensions {\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n        if extension_strength > max_strength\
    \ {\n            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8jp2a853.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8jp2a853.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8jp2a853.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8jp2a853.swift:22:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmp8jp2a853.swift:22:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmp8jp2a853.swift:22:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters - extension.countLowercaseLetters\n      \
    \                                    ^\n/tmp/tmp8jp2a853.swift:22:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmp8jp2a853.swift:22:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUppercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmp8jp2a853.swift:22:77: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                    ^\n/tmp/tmp8jp2a853.swift:22:77: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                    ^\n/tmp/tmp8jp2a853.swift:22:68: error: declaration\
    \ is only valid at file scope\n        let ex"
  stdout: ''
  timestamp: 1659821119
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(class_name:\
    \ \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc\
    \ Strongest_Extension(class_name: String, extensions: [String]) -> String {\n\
    \    var strongest_extension = \"\"\n    var strength = -1\n    for extension\
    \ in extensions {\n        let cap = extension.count\n        let sm = class_name.count\n\
    \        let strength = cap - sm\n        if strength > 0 {\n            if strength\
    \ > strongest_extension.count {\n                strongest_extension = extension\n\
    \            }\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7n6pypas.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7n6pypas.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7n6pypas.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7n6pypas.swift:22:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp7n6pypas.swift:22:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp7n6pypas.swift:22:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp7n6pypas.swift:22:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp7n6pypas.swift:22:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp7n6pypas.swift:27:39:\
    \ error: expected expression in assignment\n                strongest_extension\
    \ = extension\n                                      ^\n/tmp/tmp7n6pypas.swift:28:13:\
    \ error: expected type name in extension declaration\n            }\n        \
    \    ^\n/tmp/tmp7n6pypas.swift:27:48: error: expected '{' in extension\n     \
    \           strongest_extension = extension\n                                \
    \               ^\n/tmp/tmp7n6pypas.swift:27:39: error: declaration is only valid\
    \ at file scope\n                strongest_extension = extension\n           \
    \                           ^\n"
  stdout: ''
  timestamp: 1659821119
