language: swift
name: HumanEval_84_solve
results:
- exit_code: -1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014030
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderInt = Int(remainderString)\n        remainder -= remainderInt\n\
    \        result += remainderString\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpc9bdna11.swift:21:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        remainder -= remainderInt\n \
    \                    ^\n/tmp/tmpc9bdna11.swift:20:13: note: short-circuit using\
    \ 'guard' to exit this function early if the optional value contains 'nil'\n \
    \       let remainderInt = Int(remainderString)\n            ^\n        guard\
    \                                   else { return <#default value#> }\n/tmp/tmpc9bdna11.swift:20:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let remainderInt = Int(remainderString)\n                   \
    \        ^\n                                                ?? <#default value#>\n\
    /tmp/tmpc9bdna11.swift:20:28: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let remainderInt = Int(remainderString)\n\
    \                           ^\n                                              \
    \ !\n/tmp/tmpc9bdna11.swift:21:22: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        remainder -= remainderInt\n\
    \                     ^\n                                  ?? <#default value#>\n\
    /tmp/tmpc9bdna11.swift:21:22: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        remainder -= remainderInt\n  \
    \                   ^\n                                 !\n/tmp/tmpc9bdna11.swift:22:16:\
    \ error: left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \        result += remainderString\n        ~~~~~~ ^\n/tmp/tmpc9bdna11.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderAsString = String(remainder)\n\
    \        let digitAsString = remainderAsString.substringToIndex(remainderAsString.startIndex.advancedBy(1))\n\
    \        let digitAsInt = Int(digitAsString)!\n        result += digitAsString\n\
    \        remainder -= digitAsInt\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5mmljddw.swift:20:47: error: value of type 'String' has no member\
    \ 'substringToIndex'\n        let digitAsString = remainderAsString.substringToIndex(remainderAsString.startIndex.advancedBy(1))\n\
    \                            ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp5mmljddw.swift:20:93:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ digitAsString = remainderAsString.substringToIndex(remainderAsString.startIndex.advancedBy(1))\n\
    \                                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var remainderCount = 0\n    var currentDigit = 0\n    var currentDigitCount\
    \ = 0\n    var currentDigitSum = 0\n    var currentDigitSumCount = 0\n    var\
    \ currentDigitSumCount2 = 0\n    var currentDigitSumCount3 = 0\n    var currentDigitSumCount4\
    \ = 0\n    var currentDigitSumCount5 = 0\n    var currentDigitSumCount6 = 0\n\
    \    var currentDigitSumCount7 = 0\n    var currentDigitSumCount8 = 0\n    var\
    \ currentDigitSumCount9 = 0\n    var currentDigitSumCount10 = 0\n    var currentDigitSumCount11\
    \ = 0\n    var currentDigitSumCount12 = 0\n    var currentDigitSumCount13 = 0\n\
    \    var currentDigitSumCount14 = 0\n    var currentDigitSumCount15 = 0\n    var\
    \ currentDigitSumCount16 = 0\n    var currentDigitSumCount17 = 0\n    var currentDigitSumCount18\
    \ = 0\n    var currentDigitSumCount19 = 0\n    var currentDigitSumCount20 = 0\n\
    \    var currentDigitSumCount21 = 0\n    var currentDigitSumCount22 = 0\n    var\
    \ currentDigitSumCount23 = 0\n    var currentDigitSumCount24 = 0\n    var currentDigitSumCount25\
    \ = 0\n    var currentDigitSumCount26 = 0\n    var currentDigitSumCount27 = 0\n\
    \    var currentDigitSumCount28 = 0\n    var currentDigitSumCount29 = 0\n    var\
    \ currentDigitSumCount30 = 0\n    var currentDigitSumCount31 = 0\n    var currentDigitSumCount32\
    \ = 0\n    var currentDigitSumCount33 = 0\n    var currentDigitSumCount34 = 0\n\
    \    var currentDigitSumCount35 = 0\n    var currentDigitSumCount36 = 0\n    var\
    \ currentDigitSumCount37 = 0\n    var currentDigitSumCount38 = 0\n    var currentDigitSumCount39\
    \ = 0\n    var currentDigitSumCount40 = 0\n    var currentDigitSumCount41 = 0\n\
    \    var currentDigitSumCount42 = 0\n    var currentDigitSumCount43 = 0\n    var\
    \ currentDigitSumCount44 = 0\n    var currentDigitSumCount45 = 0\n    var currentDigitSumCount46\
    \ = 0\n    var currentDigitSumCount47 = 0\n    var currentDigitSumCount48 = 0\n\
    \    var currentDigitSumCount49 = 0\n    var currentDigitSumCount50 = 0\n    var\
    \ currentDigitSumCount51 = 0\n    var currentDigitSumCount52 = 0\n    var currentDigitSumCount53\
    \ = 0\n    var currentDigitSumCount54 = 0\n    var currentDigitSumCount55 = 0\n\
    \    var currentDigitSumCount56 = 0\n    var currentDigitSumCount57 = 0\n    var\
    \ currentDigitSumCount58 = 0\n    var currentDigitSumCount59 = 0\n    var currentDigitSumCount60\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp3eyaxqkt.swift:82:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp3eyaxqkt.swift:16:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = \"\"\n    ~~~~^~~~~~\n    _\n/tmp/tmp3eyaxqkt.swift:17:9: warning:\
    \ initialization of variable 'remainder' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var remainder = 0\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmp3eyaxqkt.swift:18:9: warning: initialization of variable 'remainderCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainderCount = 0\n    ~~~~^~~~~~~~~~~~~~\n    _\n/tmp/tmp3eyaxqkt.swift:19:9:\
    \ warning: initialization of variable 'currentDigit' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var currentDigit = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmp3eyaxqkt.swift:20:9: warning: initialization\
    \ of variable 'currentDigitCount' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var currentDigitCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmp3eyaxqkt.swift:21:9: warning: initialization of variable 'currentDigitSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var currentDigitSum = 0\n    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp3eyaxqkt.swift:22:9:\
    \ warning: initialization of variable 'currentDigitSumCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var currentDigitSumCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3eyaxqkt.swift:23:9: warning:\
    \ initialization of variable 'currentDigitSumCount2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var currentDigitSumCount2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3eyaxqkt.swift:24:9: warning:\
    \ initialization of variable 'currentDigitSumCount3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var currentDigitSumCount3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp3eyaxqkt.swift:25:9: warning:\
    \ initializati"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp6d5fff7x/tmp6d5fff7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc04413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc0410ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc0410a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc041097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6d5fff7x                        0x000055963ebe63c3 <unavailable> + 5059

    5    libc.so.6                          0x00002abc045ff460 __libc_start_main +
    245

    6    tmp6d5fff7x                        0x000055963ebe6029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var sum =\
    \ 0\n    var remainder = 0\n    var remainderSum = 0\n    var remainderRemainder\
    \ = 0\n    var remainderRemainderSum = 0\n    var remainderRemainderRemainder\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n    var remainderRemainderRemainderSum\
    \ = 0\n    var remainderRemainderRemainderSum = 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpyuu76k4f.swift:24:9: error: invalid redeclaration of 'remainderRemainderRemainderSum'\n\
    \    var remainderRemainderRemainderSum = 0\n        ^\n/tmp/tmpyuu76k4f.swift:23:9:\
    \ note: 'remainderRemainderRemainderSum' previously declared here\n    var remainderRemainderRemainderSum\
    \ = 0\n        ^\n/tmp/tmpyuu76k4f.swift:25:9: error: invalid redeclaration of\
    \ 'remainderRemainderRemainderSum'\n    var remainderRemainderRemainderSum = 0\n\
    \        ^\n/tmp/tmpyuu76k4f.swift:23:9: note: 'remainderRemainderRemainderSum'\
    \ previously declared here\n    var remainderRemainderRemainderSum = 0\n     \
    \   ^\n/tmp/tmpyuu76k4f.swift:26:9: error: invalid redeclaration of 'remainderRemainderRemainderSum'\n\
    \    var remainderRemainderRemainderSum = 0\n        ^\n/tmp/tmpyuu76k4f.swift:23:9:\
    \ note: 'remainderRemainderRemainderSum' previously declared here\n    var remainderRemainderRemainderSum\
    \ = 0\n        ^\n/tmp/tmpyuu76k4f.swift:27:9: error: invalid redeclaration of\
    \ 'remainderRemainderRemainderSum'\n    var remainderRemainderRemainderSum = 0\n\
    \        ^\n/tmp/tmpyuu76k4f.swift:23:9: note: 'remainderRemainderRemainderSum'\
    \ previously declared here\n    var remainderRemainderRemainderSum = 0\n     \
    \   ^\n/tmp/tmpyuu76k4f.swift:28:9: error: invalid redeclaration of 'remainderRemainderRemainderSum'\n\
    \    var remainderRemainderRemainderSum = 0\n        ^\n/tmp/tmpyuu76k4f.swift:23:9:\
    \ note: 'remainderRemainderRemainderSum' previously declared here\n    var remainderRemainderRemainderSum\
    \ = 0\n        ^\n/tmp/tmpyuu76k4f.swift:29:9: error: invalid redeclaration of\
    \ 'remainderRemainderRemainderSum'\n    var remainderRemainderRemainderSum = 0\n\
    \        ^\n/tmp/tmpyuu76k4f.swift:23:9: note: 'remainderRemainderRemainderSum'\
    \ previously declared here\n    var remainderRemainderRemainderSum = 0\n     \
    \   ^\n/tmp/tmpyuu76k4f.swift:30:9: error: invalid redeclaration of 'remainderRemainderRemainderSum'\n\
    \    var remainderRemainderRemainderSum = 0\n        ^\n/tmp/tmpyuu76k4f.swift:23:9:\
    \ note: 'remainderRemainderRemainderSum' previously declared here\n    var remainderRemainderRemainderSum\
    \ = 0\n       "
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var current = 0\n    var sum = 0\n    var power = 0\n\n    for _ in\
    \ 0..<N {\n        current = N % 10\n        remainder = N / 10\n        sum +=\
    \ current\n        power = 10 * power\n        result += String(format: \"%0*d\"\
    , power, current)\n        N = remainder\n    }\n\n    if sum > 0 {\n        result\
    \ += String(format: \"%0*d\", power, sum)\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpgk5xtdr9.swift:27:25: error: incorrect argument labels in call\
    \ (have 'format:_:_:', expected '_:radix:uppercase:')\n        result += String(format:\
    \ \"%0*d\", power, current)\n                        ^~~~~~~~~\n             \
    \                            radix: uppercase: \n/tmp/tmpgk5xtdr9.swift:28:9:\
    \ error: cannot assign to value: 'N' is a 'let' constant\n        N = remainder\n\
    \        ^\n/tmp/tmpgk5xtdr9.swift:32:25: error: incorrect argument labels in\
    \ call (have 'format:_:_:', expected '_:radix:uppercase:')\n        result +=\
    \ String(format: \"%0*d\", power, sum)\n                        ^~~~~~~~~\n  \
    \                                       radix: uppercase: \n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderAsString = String(remainder)\n\
    \        let remainderAsInt = Int(remainder)\n        let remainderAsDouble =\
    \ Double(remainder)\n        let remainderAsFloat = Float(remainder)\n       \
    \ let remainderAsInt = remainderAsInt.description\n        let remainderAsDouble\
    \ = remainderAsDouble.description\n        let remainderAsFloat = remainderAsFloat.description\n\
    \        result = remainderAsString + result\n        remainder = remainder -\
    \ remainderAsInt\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp3r_v3zb0.swift:23:13: error: invalid redeclaration of 'remainderAsInt'\n\
    \        let remainderAsInt = remainderAsInt.description\n            ^\n/tmp/tmp3r_v3zb0.swift:20:13:\
    \ note: 'remainderAsInt' previously declared here\n        let remainderAsInt\
    \ = Int(remainder)\n            ^\n/tmp/tmp3r_v3zb0.swift:24:13: error: invalid\
    \ redeclaration of 'remainderAsDouble'\n        let remainderAsDouble = remainderAsDouble.description\n\
    \            ^\n/tmp/tmp3r_v3zb0.swift:21:13: note: 'remainderAsDouble' previously\
    \ declared here\n        let remainderAsDouble = Double(remainder)\n         \
    \   ^\n/tmp/tmp3r_v3zb0.swift:25:13: error: invalid redeclaration of 'remainderAsFloat'\n\
    \        let remainderAsFloat = remainderAsFloat.description\n            ^\n\
    /tmp/tmp3r_v3zb0.swift:22:13: note: 'remainderAsFloat' previously declared here\n\
    \        let remainderAsFloat = Float(remainder)\n            ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder = remainder / 2\n        result\
    \ = String(format: \"%0*d\", 2, remainder) + result\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhf3fs_t.swift:20:24: error: incorrect argument labels in call\
    \ (have 'format:_:_:', expected '_:radix:uppercase:')\n        result = String(format:\
    \ \"%0*d\", 2, remainder) + result\n                       ^~~~~~~~~\n       \
    \                                 radix:  uppercase: \n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp6d5fff7x/tmp6d5fff7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc04413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc0410ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc0410a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc041097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6d5fff7x                        0x000055963ebe63c3 <unavailable> + 5059

    5    libc.so.6                          0x00002abc045ff460 __libc_start_main +
    245

    6    tmp6d5fff7x                        0x000055963ebe6029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    let binaryDigits = digits.map { String($0) }\n    let binarySum = binaryDigits.reduce(\"\
    \") { $0 + String($1) }\n    return binarySum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6gcd_kdk.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = \"\"\n    for digit in digits {\n        sum += digit\n    }\n\
    \    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpopibkf2o.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpopibkf2o.swift:19:16: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        sum += digit\n               ^\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    let remainder\
    \ = N % 2\n    let remainderAsString = String(remainder)\n    let remainderAsStringLength\
    \ = remainderAsString.length\n    let remainderAsStringArray = remainderAsString.characters\n\
    \    let remainderAsStringArrayLength = remainderAsStringArray.length\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArray.length\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArrayLength\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArrayLength\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArrayLength\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArrayLength\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArrayLength\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArrayLength\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAsStringArrayLength = remainderAsStringArrayLength\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArrayLength\n    let remainderAsStringArrayLength = remainderAsStringArrayLength\n\
    \    let remainderAsStringArrayLength = remainderAsStringArrayLength\n    let\
    \ remainderAs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp93b0mzn_.swift:19:53: error: value of type 'String' has no member\
    \ 'length'\n    let remainderAsStringLength = remainderAsString.length\n     \
    \                             ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp93b0mzn_.swift:20:52:\
    \ error: 'characters' is unavailable: Please use String directly\n    let remainderAsStringArray\
    \ = remainderAsString.characters\n                                           \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp93b0mzn_.swift:21:63:\
    \ error: value of type 'String' has no member 'length'\n    let remainderAsStringArrayLength\
    \ = remainderAsStringArray.length\n                                       ~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmp93b0mzn_.swift:22:63: error: value of type 'String' has no member\
    \ 'length'\n    let remainderAsStringArrayLength = remainderAsStringArray.length\n\
    \                                       ~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp93b0mzn_.swift:54:9:\
    \ error: type annotation missing in pattern\n    let remainderAs\n        ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014030
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var currentDigit = 0\n    while remainder > 0 {\n        remainder\
    \ /= 2\n        currentDigit = remainder % 10\n        result = String(currentDigit)\
    \ + result\n        remainder = Int(remainder) / 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmp_g8nhugp/tmp_g8nhugp.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d5d022c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d5cd19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d5cd19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d5cd187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_g8nhugp                        0x0000564784e705c3 <unavailable> + 5571

    5    libc.so.6                          0x00002b2d5d20e460 __libc_start_main +
    245

    6    tmp_g8nhugp                        0x0000564784e70229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder = remainder % 2\n    }\n    while remainderSum\
    \ > 0 {\n        result = String(remainderSum) + result\n        remainderSum\
    \ = remainderSum / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmpovf0tay_/tmpovf0tay_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2682a9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2682796b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2682796988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26827957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpovf0tay_                        0x000055557fc82493 <unavailable> + 5267

    5    libc.so.6                          0x00002b2682c8b460 __libc_start_main +
    245

    6    tmpovf0tay_                        0x000055557fc820f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderDigit = remainder % 2\n\
    \        remainder = remainder / 2\n        result = String(remainderDigit + result)\
    \ ?? \"\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnm5s2jz.swift:21:40: error: binary operator '+' cannot be applied\
    \ to operands of type 'Int' and 'String'\n        result = String(remainderDigit\
    \ + result) ?? \"\"\n                        ~~~~~~~~~~~~~~ ^ ~~~~~~\n/tmp/tmpvnm5s2jz.swift:21:40:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int), (String, String)\n        result = String(remainderDigit + result)\
    \ ?? \"\"\n                                       ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderInt = Int(remainderString)\n        let remainderBinaryString\
    \ = String(remainderInt.binary, radix: 2)\n        result += remainderBinaryString\n\
    \        remainder -= remainderInt\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpyr4mnly_.swift:21:57: error: value of type 'Int?' has no member\
    \ 'binary'\n        let remainderBinaryString = String(remainderInt.binary, radix:\
    \ 2)\n                                           ~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpyr4mnly_.swift:23:22:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        remainder -= remainderInt\n                     ^\n/tmp/tmpyr4mnly_.swift:23:22:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        remainder -= remainderInt\n                     ^\n         \
    \                         ?? <#default value#>\n/tmp/tmpyr4mnly_.swift:23:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        remainder -= remainderInt\n                     ^\n         \
    \                        !\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var remainder2 = 0\n    var remainder3 = 0\n    var remainder4 = 0\n\
    \    var remainder5 = 0\n    var remainder6 = 0\n    var remainder7 = 0\n    var\
    \ remainder8 = 0\n    var remainder9 = 0\n    var remainder10 = 0\n    var remainder11\
    \ = 0\n    var remainder12 = 0\n    var remainder13 = 0\n    var remainder14 =\
    \ 0\n    var remainder15 = 0\n    var remainder16 = 0\n    var remainder17 = 0\n\
    \    var remainder18 = 0\n    var remainder19 = 0\n    var remainder20 = 0\n \
    \   var remainder21 = 0\n    var remainder22 = 0\n    var remainder23 = 0\n  \
    \  var remainder24 = 0\n    var remainder25 = 0\n    var remainder26 = 0\n   \
    \ var remainder27 = 0\n    var remainder28 = 0\n    var remainder29 = 0\n    var\
    \ remainder30 = 0\n    var remainder31 = 0\n    var remainder32 = 0\n    var remainder33\
    \ = 0\n    var remainder34 = 0\n    var remainder35 = 0\n    var remainder36 =\
    \ 0\n    var remainder37 = 0\n    var remainder38 = 0\n    var remainder39 = 0\n\
    \    var remainder40 = 0\n    var remainder41 = 0\n    var remainder42 = 0\n \
    \   var remainder43 = 0\n    var remainder44 = 0\n    var remainder45 = 0\n  \
    \  var remainder46 = 0\n    var remainder47 = 0\n    var remainder48 = 0\n   \
    \ var remainder49 = 0\n    var remainder50 = 0\n    var remainder51 = 0\n    var\
    \ remainder52 = 0\n    var remainder53 = 0\n    var remainder54 = 0\n    var remainder55\
    \ = 0\n    var remainder56 = 0\n    var remainder57 = 0\n    var remainder58 =\
    \ 0\n    var remainder59 = 0\n    var remainder60 = 0\n    var remainder61 = 0\n\
    \    var remainder62 = 0\n    var remainder63 = 0\n    var remainder64 = 0\n \
    \   var remainder65 = 0\n    var remainder66 = 0\n    var remainder67 = 0\n  \
    \  var remainder68 = 0\n    var remainder69 = 0\n    var remainder70 = 0\n   \
    \ var remainder71 = 0\n    var remainder72 = 0\n    var remainder73 = 0\n    var\
    \ remainder74 = 0\n    var remainder75 = 0\n    var remainder76 = 0\n    var remainder77\
    \ = 0\n    var remainder78 = 0\n    var remainder79 = 0\n    var remainder80 =\
    \ 0\n    var remainder81 = 0\n    var remainder82 = 0\n    var remainder83 = 0\n\
    \    var remainder84 = 0\n    var remainder85 = 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpe4cdilod.swift:16:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = \"\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpe4cdilod.swift:17:9: warning:\
    \ initialization of variable 'remainder' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var remainder = 0\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:18:9: warning: initialization of variable 'remainder2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder2 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:19:9:\
    \ warning: initialization of variable 'remainder3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder3 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:20:9: warning: initialization of variable 'remainder4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder4 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:21:9:\
    \ warning: initialization of variable 'remainder5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder5 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:22:9: warning: initialization of variable 'remainder6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder6 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:23:9:\
    \ warning: initialization of variable 'remainder7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder7 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:24:9: warning: initialization of variable 'remainder8'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder8 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:25:9:\
    \ warning: initialization of variable 'remainder9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder9 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:26:9: warning: initialization of variable 'remain"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var digit = 0\n    while remainder > 0 {\n        digit = remainder\
    \ % 2\n        remainder = remainder / 2\n        result = String(digit) + result\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpr6l_vfct/tmpr6l_vfct.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2e45fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2e42f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2e42f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2e42f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr6l_vfct                        0x00005638e463a493 <unavailable> + 5267

    5    libc.so.6                          0x00002ac2e47e6460 __libc_start_main +
    245

    6    tmpr6l_vfct                        0x00005638e463a0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N, digits:\
    \ []))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\"\
    )\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpdzz5sosp.swift:16:39: error: extra argument 'digits' in call\n\
    \    return String(solve(N: N, digits: []))\n                       ~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainder2 = N\n    while remainder > 0 {\n        remainder2 =\
    \ remainder2 % 2\n        remainder = remainder / 2\n        result = String(remainder2)\
    \ + result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmpmxop3ejk/tmpmxop3ejk.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba39b07fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba39ad76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba39ad76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba39ad757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmxop3ejk                        0x000055de1176f493 <unavailable> + 5267

    5    libc.so.6                          0x00002ba39b26b460 __libc_start_main +
    245

    6    tmpmxop3ejk                        0x000055de1176f0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    let binaryDigits = digits.map { String($0) }\n    let binaryStrings = binaryDigits.map\
    \ { String($0) }\n    let binarySum = binaryStrings.reduce(\"\") { $0 + $1 }\n\
    \    return binarySum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpes9ekhqt.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    for _ in\
    \ 0..<N {\n        let remainder = N % 2\n        result += String(remainder)\n\
    \        N /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpc6yhgdz3.swift:20:11: error: left side of mutating operator isn't\
    \ mutable: 'N' is a 'let' constant\n        N /= 2\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder--\n    }\n    while remainderSum >= 2 {\n  \
    \      remainderSum /= 2\n        result += \"1\"\n    }\n    while remainderSum\
    \ >= 1 {\n        remainderSum /= 1\n        result += \"0\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"\
    1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpqn251yix.swift:21:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n        remainder--\n                 ^~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder *= 2\n    }\n    while remainderSum > 0 {\n\
    \        result = String(remainderSum % 2) + result\n        remainderSum /= 2\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    let result = \"\"\n    for digit in digits {\n        result += String(digit)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpl8u12wd3.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpl8u12wd3.swift:19:16: error: left side of mutating operator isn't mutable:\
    \ 'result' is a 'let' constant\n        result += String(digit)\n        ~~~~~~\
    \ ^\n/tmp/tmpl8u12wd3.swift:17:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    for _ in 0..<remainderSum\
    \ {\n        result += \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpfocz5w1g/tmpfocz5w1g.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaeedd0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaeeda06b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaeeda06988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaeeda057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfocz5w1g                        0x0000564fb2cd04c3 <unavailable> + 5315

    5    libc.so.6                          0x00002aaeedefb460 __libc_start_main +
    245

    6    tmpfocz5w1g                        0x0000564fb2cd0129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderDigit = 0\n    while remainder > 0 {\n        remainderDigit\
    \ = remainder % 2\n        remainder = remainder / 2\n        result = String(remainderDigit\
    \ + result) ?? \"\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpi72y0kyt.swift:22:40: error: binary operator '+' cannot be applied\
    \ to operands of type 'Int' and 'String'\n        result = String(remainderDigit\
    \ + result) ?? \"\"\n                        ~~~~~~~~~~~~~~ ^ ~~~~~~\n/tmp/tmpi72y0kyt.swift:22:40:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int), (String, String)\n        result = String(remainderDigit + result)\
    \ ?? \"\"\n                                       ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = \"\"\n    for d in digits {\n        sum += String(Int(d) + 1)\n\
    \    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpfx8qz3ih.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpfx8qz3ih.swift:19:23: error: no exact matches in call to initializer \n\
    \        sum += String(Int(d) + 1)\n                      ^\nSwift.Int:7:12: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    var remainderSum =\
    \ 0\n    while remainder > 0 {\n        remainderSum += remainder % 2\n      \
    \  remainder = remainder / 2\n    }\n    if remainderSum == 0 {\n        result\
    \ = \"0\"\n    } else {\n        result = String(remainderSum)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"\
    1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmp2eo5rojv/tmp2eo5rojv.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37ab0a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37aad9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37aad9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37aad997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2eo5rojv                        0x0000561c56391433 <unavailable> + 5171

    5    libc.so.6                          0x00002b37ab28f460 __libc_start_main +
    245

    6    tmp2eo5rojv                        0x0000561c56391099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var remainderSum = 0\n    var remainderSumDigit = 0\n    var remainderSumDigit2\
    \ = 0\n    var remainderSumDigit3 = 0\n    var remainderSumDigit4 = 0\n    var\
    \ remainderSumDigit5 = 0\n    var remainderSumDigit6 = 0\n    var remainderSumDigit7\
    \ = 0\n    var remainderSumDigit8 = 0\n    var remainderSumDigit9 = 0\n    var\
    \ remainderSumDigit10 = 0\n    var remainderSumDigit11 = 0\n    var remainderSumDigit12\
    \ = 0\n    var remainderSumDigit13 = 0\n    var remainderSumDigit14 = 0\n    var\
    \ remainderSumDigit15 = 0\n    var remainderSumDigit16 = 0\n    var remainderSumDigit17\
    \ = 0\n    var remainderSumDigit18 = 0\n    var remainderSumDigit19 = 0\n    var\
    \ remainderSumDigit20 = 0\n    var remainderSumDigit21 = 0\n    var remainderSumDigit22\
    \ = 0\n    var remainderSumDigit23 = 0\n    var remainderSumDigit24 = 0\n    var\
    \ remainderSumDigit25 = 0\n    var remainderSumDigit26 = 0\n    var remainderSumDigit27\
    \ = 0\n    var remainderSumDigit28 = 0\n    var remainderSumDigit29 = 0\n    var\
    \ remainderSumDigit30 = 0\n    var remainderSumDigit31 = 0\n    var remainderSumDigit32\
    \ = 0\n    var remainderSumDigit33 = 0\n    var remainderSumDigit34 = 0\n    var\
    \ remainderSumDigit35 = 0\n    var remainderSumDigit36 = 0\n    var remainderSumDigit37\
    \ = 0\n    var remainderSumDigit38 = 0\n    var remainderSumDigit39 = 0\n    var\
    \ remainderSumDigit40 = 0\n    var remainderSumDigit41 = 0\n    var remainderSumDigit42\
    \ = 0\n    var remainderSumDigit43 = 0\n    var remainderSumDigit44 = 0\n    var\
    \ remainderSumDigit45 = 0\n    var remainderSumDigit46 = 0\n    var remainderSumDigit47\
    \ = 0\n    var remainderSumDigit48 = 0\n    var remainderSumDigit49 = 0\n    var\
    \ remainderSumDigit50 = 0\n    var remainderSumDigit51 = 0\n    var remainderSumDigit52\
    \ = 0\n    var remainderSumDigit53 = 0\n    var remainderSumDigit54 = 0\n    var\
    \ remainderSumDigit55 = 0\n    var remainderSumDigit56 = 0\n    var remainderSumDigit57\
    \ = 0\n    var remainderSumDigit58 = 0\n    var remainderSumDigit59 = 0\n    var\
    \ remainderSumDigit60 = 0\n    var remainderSumDigit61 = 0\n    var remainderSumDigit62\
    \ = 0\n    var remain\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpn29lp_v_.swift:81:9: error: type annotation missing in pattern\n\
    \    var remain\n        ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderAsString = String(remainder)\n\
    \        if remainderAsString.characters.count == 1 {\n            result += remainderAsString\n\
    \        } else {\n            result += remainderAsString.reversed()\n      \
    \  }\n        remainder -= Int(remainderAsString)!\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpyg9z26j4.swift:20:30: error: 'characters' is unavailable: Please\
    \ use String directly\n        if remainderAsString.characters.count == 1 {\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder -= 1\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder -= 1\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmptvgqelbr.swift:20:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result += \"1\"\n        ~~~~~~\
    \ ^\n/tmp/tmptvgqelbr.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = \"\"\n    ^~~\n    var\n/tmp/tmptvgqelbr.swift:24:16: error:\
    \ left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \        result += \"0\"\n        ~~~~~~ ^\n/tmp/tmptvgqelbr.swift:16:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderDigit = remainder % 2\n\
    \        remainder = remainder / 2\n        result = String(remainderDigit + result)\
    \ ?? \"\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnm5s2jz.swift:21:40: error: binary operator '+' cannot be applied\
    \ to operands of type 'Int' and 'String'\n        result = String(remainderDigit\
    \ + result) ?? \"\"\n                        ~~~~~~~~~~~~~~ ^ ~~~~~~\n/tmp/tmpvnm5s2jz.swift:21:40:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int), (String, String)\n        result = String(remainderDigit + result)\
    \ ?? \"\"\n                                       ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N, base:\
    \ 2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\"\
    )\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp799xwiv8.swift:16:37: error: extra argument 'base' in call\n  \
    \  return String(solve(N: N, base: 2))\n                       ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        remainder -= Int(remainderString)\n        result = remainderString +\
    \ result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpiml4y_u2.swift:20:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        remainder -= Int(remainderString)\n\
    \                     ^\n/tmp/tmpiml4y_u2.swift:20:22: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        remainder\
    \ -= Int(remainderString)\n                     ^\n                          \
    \                ?? <#default value#>\n/tmp/tmpiml4y_u2.swift:20:22: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        remainder\
    \ -= Int(remainderString)\n                     ^\n                          \
    \               !\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderDigit = remainder % 2\n\
    \        remainder = remainder / 2\n        result = String(repeating: \"0\",\
    \ count: remainderDigit) + result\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpm9_zz5tx/tmpm9_zz5tx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affe0058c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affdfd4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affdfd4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affdfd4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm9_zz5tx                        0x0000555d9addb423 <unavailable> + 5155

    5    libc.so.6                          0x00002affe0244460 __libc_start_main +
    245

    6    tmpm9_zz5tx                        0x0000555d9addb089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder:\
    \ Int = 0\n    var sum = 0\n    for _ in 0..<N {\n        remainder = N % 2\n\
    \        sum += remainder\n        N = N / 2\n    }\n    for _ in 0..<sum {\n\
    \        result += String(format: \"%0*d\", 2, remainder)\n        remainder =\
    \ remainder / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpmd4ws5u8.swift:22:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n/tmp/tmpmd4ws5u8.swift:25:25: error:\
    \ incorrect argument labels in call (have 'format:_:_:', expected '_:radix:uppercase:')\n\
    \        result += String(format: \"%0*d\", 2, remainder)\n                  \
    \      ^~~~~~~~~\n                                         radix:  uppercase:\
    \ \n/tmp/tmpmd4ws5u8.swift:25:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result += String(format: \"%0*d\"\
    , 2, remainder)\n        ~~~~~~ ^\n/tmp/tmpmd4ws5u8.swift:16:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    var remainderSum =\
    \ 0\n    while remainder > 0 {\n        remainderSum += remainder\n        remainder--\n\
    \    }\n    while remainderSum > 0 {\n        result = \"1\" + result\n      \
    \  remainderSum--\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6w7afpzj.swift:24:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n        remainder--\n                 ^~\n/tmp/tmp6w7afpzj.swift:28:21:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        remainderSum--\n\
    \                    ^~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var remainder2 = 0\n    var remainder3 = 0\n    var remainder4 = 0\n\
    \    var remainder5 = 0\n    var remainder6 = 0\n    var remainder7 = 0\n    var\
    \ remainder8 = 0\n    var remainder9 = 0\n    var remainder10 = 0\n    var remainder11\
    \ = 0\n    var remainder12 = 0\n    var remainder13 = 0\n    var remainder14 =\
    \ 0\n    var remainder15 = 0\n    var remainder16 = 0\n    var remainder17 = 0\n\
    \    var remainder18 = 0\n    var remainder19 = 0\n    var remainder20 = 0\n \
    \   var remainder21 = 0\n    var remainder22 = 0\n    var remainder23 = 0\n  \
    \  var remainder24 = 0\n    var remainder25 = 0\n    var remainder26 = 0\n   \
    \ var remainder27 = 0\n    var remainder28 = 0\n    var remainder29 = 0\n    var\
    \ remainder30 = 0\n    var remainder31 = 0\n    var remainder32 = 0\n    var remainder33\
    \ = 0\n    var remainder34 = 0\n    var remainder35 = 0\n    var remainder36 =\
    \ 0\n    var remainder37 = 0\n    var remainder38 = 0\n    var remainder39 = 0\n\
    \    var remainder40 = 0\n    var remainder41 = 0\n    var remainder42 = 0\n \
    \   var remainder43 = 0\n    var remainder44 = 0\n    var remainder45 = 0\n  \
    \  var remainder46 = 0\n    var remainder47 = 0\n    var remainder48 = 0\n   \
    \ var remainder49 = 0\n    var remainder50 = 0\n    var remainder51 = 0\n    var\
    \ remainder52 = 0\n    var remainder53 = 0\n    var remainder54 = 0\n    var remainder55\
    \ = 0\n    var remainder56 = 0\n    var remainder57 = 0\n    var remainder58 =\
    \ 0\n    var remainder59 = 0\n    var remainder60 = 0\n    var remainder61 = 0\n\
    \    var remainder62 = 0\n    var remainder63 = 0\n    var remainder64 = 0\n \
    \   var remainder65 = 0\n    var remainder66 = 0\n    var remainder67 = 0\n  \
    \  var remainder68 = 0\n    var remainder69 = 0\n    var remainder70 = 0\n   \
    \ var remainder71 = 0\n    var remainder72 = 0\n    var remainder73 = 0\n    var\
    \ remainder74 = 0\n    var remainder75 = 0\n    var remainder76 = 0\n    var remainder77\
    \ = 0\n    var remainder78 = 0\n    var remainder79 = 0\n    var remainder80 =\
    \ 0\n    var remainder81 = 0\n    var remainder82 = 0\n    var remainder83 = 0\n\
    \    var remainder84 = 0\n    var remainder85 = 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpe4cdilod.swift:16:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = \"\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpe4cdilod.swift:17:9: warning:\
    \ initialization of variable 'remainder' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var remainder = 0\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:18:9: warning: initialization of variable 'remainder2'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder2 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:19:9:\
    \ warning: initialization of variable 'remainder3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder3 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:20:9: warning: initialization of variable 'remainder4'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder4 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:21:9:\
    \ warning: initialization of variable 'remainder5' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder5 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:22:9: warning: initialization of variable 'remainder6'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder6 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:23:9:\
    \ warning: initialization of variable 'remainder7' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder7 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:24:9: warning: initialization of variable 'remainder8'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainder8 = 0\n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmpe4cdilod.swift:25:9:\
    \ warning: initialization of variable 'remainder9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder9 = 0\n    ~~~~^~~~~~~~~~\n\
    \    _\n/tmp/tmpe4cdilod.swift:26:9: warning: initialization of variable 'remain"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder = remainder % 2\n        result\
    \ = String(format: \"%0*d\", 2, remainder) + result\n        remainder = Int(remainder)\
    \ / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpntwurknp.swift:20:24: error: incorrect argument labels in call\
    \ (have 'format:_:_:', expected '_:radix:uppercase:')\n        result = String(format:\
    \ \"%0*d\", 2, remainder) + result\n                       ^~~~~~~~~\n       \
    \                                 radix:  uppercase: \n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N < 0 {\n        return \"0\"\
    \n    }\n    var sum = 0\n    var result = \"\"\n    var remainder = N\n    while\
    \ remainder > 0 {\n        sum += remainder % 2\n        remainder = remainder\
    \ / 2\n    }\n    if sum > 0 {\n        result += \"1\"\n    }\n    for _ in 1...sum\
    \ {\n        result += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmp6bogr0nw/tmp6bogr0nw.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9d5a16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9d570db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9d570d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9d570c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6bogr0nw                        0x0000559e36b654c3 <unavailable> + 5315

    5    libc.so.6                          0x00002ae9d5c02460 __libc_start_main +
    245

    6    tmp6bogr0nw                        0x0000559e36b65129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: -1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014030
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = 0\n    var binaryString\
    \ = \"\"\n    for _ in 0..<N {\n        sum += N % 2\n        N = N / 2\n    }\n\
    \    for _ in 0..<N {\n        binaryString += String(sum % 2)\n        sum =\
    \ sum / 2\n    }\n    return binaryString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpwtua8ium.swift:20:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    var remainderDigit\
    \ = 0\n    while remainder > 0 {\n        remainderDigit = remainder % 2\n   \
    \     remainder = remainder / 2\n        result = String(remainderDigit + result)\
    \ + String(remainderDigit)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp38kbqeqh.swift:25:25: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String'\n        result = String(remainderDigit +\
    \ result) + String(remainderDigit)\n                        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderInt = Int(remainderString)\n        result += remainderString\n\
    \        remainder -= remainderInt\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp1uxm8sks.swift:22:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        remainder -= remainderInt\n \
    \                    ^\n/tmp/tmp1uxm8sks.swift:20:13: note: short-circuit using\
    \ 'guard' to exit this function early if the optional value contains 'nil'\n \
    \       let remainderInt = Int(remainderString)\n            ^\n        guard\
    \                                   else { return <#default value#> }\n/tmp/tmp1uxm8sks.swift:20:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let remainderInt = Int(remainderString)\n                   \
    \        ^\n                                                ?? <#default value#>\n\
    /tmp/tmp1uxm8sks.swift:20:28: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let remainderInt = Int(remainderString)\n\
    \                           ^\n                                              \
    \ !\n/tmp/tmp1uxm8sks.swift:22:22: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        remainder -= remainderInt\n\
    \                     ^\n                                  ?? <#default value#>\n\
    /tmp/tmp1uxm8sks.swift:22:22: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        remainder -= remainderInt\n  \
    \                   ^\n                                 !\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    let remainder\
    \ = N % 2\n    let quotient = N / 2\n    while quotient > 0 {\n        let remainderString\
    \ = String(remainder)\n        let quotientString = String(quotient)\n       \
    \ let binaryString = remainderString + quotientString\n        result = binaryString\
    \ + result\n        remainder = quotient % 2\n        quotient = quotient / 2\n\
    \    }\n    if remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let binaryString = remainderString + result\n        result = binaryString\
    \ + result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp1bx367c0.swift:23:9: error: cannot assign to value: 'result' is\
    \ a 'let' constant\n        result = binaryString + result\n        ^~~~~~\n/tmp/tmp1bx367c0.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n\
    \    var\n/tmp/tmp1bx367c0.swift:24:9: error: cannot assign to value: 'remainder'\
    \ is a 'let' constant\n        remainder = quotient % 2\n        ^~~~~~~~~\n/tmp/tmp1bx367c0.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let remainder = N % 2\n\
    \    ^~~\n    var\n/tmp/tmp1bx367c0.swift:25:9: error: cannot assign to value:\
    \ 'quotient' is a 'let' constant\n        quotient = quotient / 2\n        ^~~~~~~~\n\
    /tmp/tmp1bx367c0.swift:18:5: note: change 'let' to 'var' to make it mutable\n\
    \    let quotient = N / 2\n    ^~~\n    var\n/tmp/tmp1bx367c0.swift:30:9: error:\
    \ cannot assign to value: 'result' is a 'let' constant\n        result = binaryString\
    \ + result\n        ^~~~~~\n/tmp/tmp1bx367c0.swift:16:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reverse\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp2lmlwxzs.swift:88:33: error: expected '}' at end of brace statement\n\
    assert(solve(N: 963) == \"10010\")\n                                ^\n/tmp/tmp2lmlwxzs.swift:15:30:\
    \ note: to match this opening '{'\nfunc solve(N: Int) -> String {\n          \
    \                   ^\n/tmp/tmp2lmlwxzs.swift:20:13: error: invalid redeclaration\
    \ of 'remainderString'\n        let remainderString = remainderString.reversed()\n\
    \            ^\n/tmp/tmp2lmlwxzs.swift:19:13: note: 'remainderString' previously\
    \ declared here\n        let remainderString = String(remainder)\n           \
    \ ^\n/tmp/tmp2lmlwxzs.swift:72:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = String(N).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reverse\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpijchz5se.swift:36:33: error: expected '}' at end of closure\nassert(solve(N:\
    \ 963) == \"10010\")\n                                ^\n/tmp/tmpijchz5se.swift:16:1810:\
    \ note: to match this opening '{'\n    let result = String(N).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") { $0 + String($1).reversed().reduce(\"\
    \") { $0 + String($1).reversed().reduce(\"\") "
  stdout: ''
  timestamp: 1660014611
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = 0\n    for digit in digits {\n        sum += Int(digit)\n    }\n\
    \    return String(sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpeunwajgj.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpeunwajgj.swift:19:16: error: no exact matches in call to initializer \n\
    \        sum += Int(digit)\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).reversed()\n\
    \    let result = \"\"\n    for digit in digits {\n        let index = Int(digit)\n\
    \        let remainder = index % 2\n        result += String(remainder)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmplsanfufw.swift:19:21: error: no exact matches in call to initializer\
    \ \n        let index = Int(digit)\n                    ^\nSwift.Int:7:12: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float)\n           ^\nSwift.Int:12:12:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'String.Element' (aka 'Character'))\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'String.Element' (aka 'Character'))\n    public init(_\
    \ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).reversed()\n\
    \    let binaryDigits = digits.map { String($0) }\n    let binarySum = binaryDigits.reduce(\"\
    \") { $0 + String($1) }\n    return binarySum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmpjd4tq63i/tmpjd4tq63i.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fc2c25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fc291cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fc291c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fc291b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjd4tq63i                        0x0000559190f027b3 <unavailable> + 6067

    5    libc.so.6                          0x00002b0fc2e11460 __libc_start_main +
    245

    6    tmpjd4tq63i                        0x0000559190f02419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).reversed()\n\
    \    let result = \"\"\n    for digit in digits {\n        let index = Int(digit)\n\
    \        let remainder = index % 2\n        let remainderIndex = Int(index - remainder)\n\
    \        let remainderDigit = String(remainder)\n        let remainderDigitIndex\
    \ = Int(remainderDigit)\n        let remainderDigitIndex = remainderDigitIndex\
    \ * 2\n        let remainderDigit = String(remainderDigitIndex)\n        let remainderDigitIndex\
    \ = String(remainderDigitIndex + remainderDigitIndex)\n        let remainderDigit\
    \ = String(remainderDigitIndex)\n        result += remainderDigit\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpy8emxi5d.swift:19:21: error: no exact matches in call to initializer\
    \ \n        let index = Int(digit)\n                    ^\nSwift.Int:7:12: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float)\n           ^\nSwift.Int:12:12:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'String.Element' (aka 'Character'))\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'String.Element' (aka 'Character'))\n    public init(_\
    \ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n\
    /tmp/tmpy8emxi5d.swift:21:30: error: no exact matches in call to initializer \n\
    \        let remainderIndex = Int(index - remainder)\n                       \
    \      ^\n/tmp/tmpy8emxi5d.swift:21:30: note: found candidate with type '(Float16)\
    \ -> Int'\n        let remainderIndex = Int(index - remainder)\n             \
    \                ^\n/tmp/tmpy8emxi5d.swift:21:30: note: found candidate with type\
    \ '(Float) -> Int'\n        let remainderIndex = Int(index - remainder)\n    \
    \                         ^\n/tmp/tmpy8emxi5d.swift:21:30: note: found candidate\
    \ with type '(Double) -> Int'\n        let remainderIndex = Int(index - remainder)\n\
    \                             ^\n/tmp/tmpy8emxi5d.swi"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var currentDigit = 0\n    var currentSum = 0\n    var currentSumDigit\
    \ = 0\n    var currentSumDigitCount = 0\n    var currentSumDigitCountMax = 0\n\
    \    var currentSumDigitCountMaxIndex = 0\n    var currentSumDigitCountMin = 0\n\
    \    var currentSumDigitCountMinIndex = 0\n    var currentSumDigitCountMaxDigit\
    \ = 0\n    var currentSumDigitCountMinDigit = 0\n    var currentSumDigitCountMaxDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitIndex = 0\n    var currentSumDigitCountMaxDigitDigit\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n    var currentSumDigitCountMinDigitDigit = 0\n    var currentSumDigitCountMaxDigitDigitIndex\
    \ = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\"\
    )\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpcg0_tzgw.swift:33:9: error: invalid redeclaration of 'currentSumDigitCountMinDigitDigit'\n\
    \    var currentSumDigitCountMinDigitDigit = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:31:9:\
    \ note: 'currentSumDigitCountMinDigitDigit' previously declared here\n    var\
    \ currentSumDigitCountMinDigitDigit = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:34:9:\
    \ error: invalid redeclaration of 'currentSumDigitCountMaxDigitDigitIndex'\n \
    \   var currentSumDigitCountMaxDigitDigitIndex = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:32:9:\
    \ note: 'currentSumDigitCountMaxDigitDigitIndex' previously declared here\n  \
    \  var currentSumDigitCountMaxDigitDigitIndex = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:35:9:\
    \ error: invalid redeclaration of 'currentSumDigitCountMinDigitDigit'\n    var\
    \ currentSumDigitCountMinDigitDigit = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:31:9:\
    \ note: 'currentSumDigitCountMinDigitDigit' previously declared here\n    var\
    \ currentSumDigitCountMinDigitDigit = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:36:9:\
    \ error: invalid redeclaration of 'currentSumDigitCountMaxDigitDigitIndex'\n \
    \   var currentSumDigitCountMaxDigitDigitIndex = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:32:9:\
    \ note: 'currentSumDigitCountMaxDigitDigitIndex' previously declared here\n  \
    \  var currentSumDigitCountMaxDigitDigitIndex = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:37:9:\
    \ error: invalid redeclaration of 'currentSumDigitCountMinDigitDigit'\n    var\
    \ currentSumDigitCountMinDigitDigit = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:31:9:\
    \ note: 'currentSumDigitCountMinDigitDigit' previously declared here\n    var\
    \ currentSumDigitCountMinDigitDigit = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:38:9:\
    \ error: invalid redeclaration of 'currentSumDigitCountMaxDigitDigitIndex'\n \
    \   var currentSumDigitCountMaxDigitDigitIndex = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:32:9:\
    \ note: 'currentSumDigitCountMaxDigitDigitIndex' previously declared here\n  \
    \  var currentSumDigitCountMaxDigitDigitIndex = 0\n        ^\n/tmp/tmpcg0_tzgw.swift:39:9:\
    \ error: invalid redeclaration of 'currentSumDigitCountMinDigitDigit'\n    var\
    \ currentSumDigitCountMinDigitDigit = 0\n        ^\n/tmp/"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = Int(remainder / 2)\n    }\n    if remainderSum\
    \ == 0 {\n        result = \"0\"\n    } else {\n        result = \"1\"\n    }\n\
    \    for _ in 1...(remainderSum + 1) {\n        result += result\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"\
    1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpcs9kr76m/tmpcs9kr76m.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cf6adfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cf67d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cf67d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cf67d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcs9kr76m                        0x000056078336f5f3 <unavailable> + 5619

    5    libc.so.6                          0x00002b6cf6ccb460 __libc_start_main +
    245

    6    tmpcs9kr76m                        0x000056078336f259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var remainder2: Int = 0\n    var remainder3: Int = 0\n\
    \    var remainder4: Int = 0\n    var remainder5: Int = 0\n    var remainder6:\
    \ Int = 0\n    var remainder7: Int = 0\n    var remainder8: Int = 0\n    var remainder9:\
    \ Int = 0\n    var remainder10: Int = 0\n    var remainder11: Int = 0\n    var\
    \ remainder12: Int = 0\n    var remainder13: Int = 0\n    var remainder14: Int\
    \ = 0\n    var remainder15: Int = 0\n    var remainder16: Int = 0\n    var remainder17:\
    \ Int = 0\n    var remainder18: Int = 0\n    var remainder19: Int = 0\n    var\
    \ remainder20: Int = 0\n    var remainder21: Int = 0\n    var remainder22: Int\
    \ = 0\n    var remainder23: Int = 0\n    var remainder24: Int = 0\n    var remainder25:\
    \ Int = 0\n    var remainder26: Int = 0\n    var remainder27: Int = 0\n    var\
    \ remainder28: Int = 0\n    var remainder29: Int = 0\n    var remainder30: Int\
    \ = 0\n    var remainder31: Int = 0\n    var remainder32: Int = 0\n    var remainder33:\
    \ Int = 0\n    var remainder34: Int = 0\n    var remainder35: Int = 0\n    var\
    \ remainder36: Int = 0\n    var remainder37: Int = 0\n    var remainder38: Int\
    \ = 0\n    var remainder39: Int = 0\n    var remainder40: Int = 0\n    var remainder41:\
    \ Int = 0\n    var remainder42: Int = 0\n    var remainder43: Int = 0\n    var\
    \ remainder44: Int = 0\n    var remainder45: Int = 0\n    var remainder46: Int\
    \ = 0\n    var remainder47: Int = 0\n    var remainder48: Int = 0\n    var remainder49:\
    \ Int = 0\n    var remainder50: Int = 0\n    var remainder51: Int = 0\n    var\
    \ remainder52: Int = 0\n    var remainder53: Int = 0\n    var remainder54: Int\
    \ = 0\n    var remainder55: Int = 0\n    var remainder56: Int = 0\n    var remainder57:\
    \ Int = 0\n    var remainder58: Int = 0\n    var remainder59: Int = 0\n    var\
    \ remainder60: Int = 0\n    var remainder61: Int = 0\n    var remainder62: Int\
    \ = 0\n    var remainder63: Int = 0\n    var remainder64: Int = 0\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpi4uxy9ms.swift:16:9: warning: variable 'result' was never used;\
    \ consider replacing with '_' or removing it\n    var result: String = \"\"\n\
    \        ^~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:17:9: warning: variable 'remainder'\
    \ was never used; consider replacing with '_' or removing it\n    var remainder:\
    \ Int = 0\n        ^~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:18:9: warning:\
    \ variable 'remainder2' was never used; consider replacing with '_' or removing\
    \ it\n    var remainder2: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:19:9:\
    \ warning: variable 'remainder3' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder3: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:20:9:\
    \ warning: variable 'remainder4' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder4: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:21:9:\
    \ warning: variable 'remainder5' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder5: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:22:9:\
    \ warning: variable 'remainder6' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder6: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:23:9:\
    \ warning: variable 'remainder7' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder7: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:24:9:\
    \ warning: variable 'remainder8' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder8: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:25:9:\
    \ warning: variable 'remainder9' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder9: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:26:9:\
    \ warning: variable 'remainder10' was never used; consider replacing with '_'\
    \ or removing it\n    var remainder10: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpi4uxy9ms.swift:27:9: warning: variable 'remainder11' was never used; consider\
    \ replacing with '_' or removing it\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var digit = 0\n    var temp = 0\n    for _ in 0..<N {\n        digit\
    \ = N % 2\n        remainder = N / 2\n        temp = remainder * 10 + digit\n\
    \        result += String(temp)\n        N = N / 10\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpah9wh3p3.swift:25:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 10\n        ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ sum: Int = 0\n    for _ in 0..<N {\n        sum += N % 2\n        N /= 2\n \
    \   }\n    for _ in 0..<N {\n        result += String(sum % 2)\n        sum /=\
    \ 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ouvac4d.swift:20:11: error: left side of mutating operator isn't\
    \ mutable: 'N' is a 'let' constant\n        N /= 2\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    while remainder > 0\
    \ {\n        remainder, remainder, remainder = remainder / 2, remainder % 2, remainder\n\
    \        result += String(remainder)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp9fp_0ugt.swift:22:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder, remainder = remainder / 2,\
    \ remainder % 2, remainder\n                 ^\n                 ;\n/tmp/tmp9fp_0ugt.swift:22:18:\
    \ error: expected expression\n        remainder, remainder, remainder = remainder\
    \ / 2, remainder % 2, remainder\n                 ^\n/tmp/tmp9fp_0ugt.swift:22:9:\
    \ warning: variable is unused\n        remainder, remainder, remainder = remainder\
    \ / 2, remainder % 2, remainder\n        ^~~~~~~~~\n/tmp/tmp9fp_0ugt.swift:19:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp9fp_0ugt.swift:20:9: warning:\
    \ variable 'remainder' was never mutated; consider changing to 'let' constant\n\
    \    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var digit = 0\n    var power = 1\n    for _ in 0..<N {\n        digit\
    \ = N % 10\n        remainder = N / 10\n        result += String(digit)\n    \
    \    N = remainder\n        power = power * 10\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpsp4fvqkx.swift:24:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = remainder\n        ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var digit: Int = 0\n    var sum: Int = 0\n    var binary:\
    \ String = \"\"\n    \n    for _ in 0..<N {\n        remainder = N % 2\n     \
    \   digit = N / 2\n        sum += digit\n        N = N - remainder\n        \n\
    \        if sum > 0 {\n            binary += String(sum)\n            sum = 0\n\
    \        }\n    }\n    \n    if sum > 0 {\n        binary += String(sum)\n   \
    \ }\n    \n    for _ in 0..<binary.count {\n        if binary[binary.count - 1]\
    \ == \"0\" {\n            result += String(digit)\n        } else {\n        \
    \    result += String(digit) + String(binary[binary.count - 1])\n        }\n \
    \       digit = 0\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6a1e52l4.swift:26:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N - remainder\n        ^\n/tmp/tmp6a1e52l4.swift:39:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if binary[binary.count - 1] == \"0\" {\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6a1e52l4.swift:42:46: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            result += String(digit) + String(binary[binary.count - 1])\n    \
    \                                         ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder -= 10\n        result += \"\
    1\"\n    }\n    while remainder > 0 {\n        remainder -= 10\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp2_jvxb3d/tmp2_jvxb3d.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75d7857c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75d754eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75d754e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75d754d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2_jvxb3d                        0x0000562685991333 <unavailable> + 4915

    5    libc.so.6                          0x00002b75d7a43460 __libc_start_main +
    245

    6    tmp2_jvxb3d                        0x0000562685990f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderDigit = remainder % 2\n\
    \        remainder = remainder / 2\n        result = String(repeating: \"0\",\
    \ count: remainderDigit) + result\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpm9_zz5tx/tmpm9_zz5tx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affe0058c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affdfd4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affdfd4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affdfd4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm9_zz5tx                        0x0000555d9addb423 <unavailable> + 5155

    5    libc.so.6                          0x00002affe0244460 __libc_start_main +
    245

    6    tmpm9_zz5tx                        0x0000555d9addb089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderAsString = String(remainder)\n\
    \        let remainderAsInt = Int(remainder)\n        result = remainderAsString\
    \ + result\n        remainder = remainderAsInt.quotientAndRemainder(dividingBy:\
    \ 2)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpbmi9gf16.swift:22:36: error: cannot assign value of type '(quotient:\
    \ Int, remainder: Int)' to type 'Int'\n        remainder = remainderAsInt.quotientAndRemainder(dividingBy:\
    \ 2)\n                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    while remainder > 0\
    \ {\n        let remainderDigit = remainder % 2\n        remainder = remainder\
    \ / 2\n        result = String(repeating: \"0\", count: Int(remainderDigit)) +\
    \ result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmpgzl8rhtm/tmpgzl8rhtm.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b54f83f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54f80e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54f80e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54f80e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgzl8rhtm                        0x000055c56bb18563 <unavailable> + 5475

    5    libc.so.6                          0x00002b54f85de460 __libc_start_main +
    245

    6    tmpgzl8rhtm                        0x000055c56bb181c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var digit: Int = 0\n    var total: Int = 0\n    var\
    \ remainder2: Int = 0\n    var digit2: Int = 0\n    var total2: Int = 0\n    var\
    \ remainder3: Int = 0\n    var digit3: Int = 0\n    var total3: Int = 0\n    var\
    \ remainder4: Int = 0\n    var digit4: Int = 0\n    var total4: Int = 0\n    var\
    \ remainder5: Int = 0\n    var digit5: Int = 0\n    var total5: Int = 0\n    var\
    \ remainder6: Int = 0\n    var digit6: Int = 0\n    var total6: Int = 0\n    var\
    \ remainder7: Int = 0\n    var digit7: Int = 0\n    var total7: Int = 0\n    var\
    \ remainder8: Int = 0\n    var digit8: Int = 0\n    var total8: Int = 0\n    var\
    \ remainder9: Int = 0\n    var digit9: Int = 0\n    var total9: Int = 0\n    var\
    \ remainder10: Int = 0\n    var digit10: Int = 0\n    var total10: Int = 0\n \
    \   var remainder11: Int = 0\n    var digit11: Int = 0\n    var total11: Int =\
    \ 0\n    var remainder12: Int = 0\n    var digit12: Int = 0\n    var total12:\
    \ Int = 0\n    var remainder13: Int = 0\n    var digit13: Int = 0\n    var total13:\
    \ Int = 0\n    var remainder14: Int = 0\n    var digit14: Int = 0\n    var total14:\
    \ Int = 0\n    var remainder15: Int = 0\n    var digit15: Int = 0\n    var total15:\
    \ Int = 0\n    var remainder16: Int = 0\n    var digit16: Int = 0\n    var total16:\
    \ Int = 0\n    var remainder17: Int = 0\n    var digit17: Int = 0\n    var total17:\
    \ Int = 0\n    var remainder18: Int = 0\n    var digit18: Int = 0\n    var total18:\
    \ Int = 0\n    var remainder19: Int = 0\n    var digit19: Int = 0\n    var total19:\
    \ Int = 0\n    var remainder20: Int = 0\n    var digit20: Int = 0\n    var total20:\
    \ Int = 0\n    var remainder21: Int = 0\n    var digit21: Int = 0\n    var total21:\
    \ Int = 0\n    var remainder22: Int = 0\n    var digit22: Int = 0\n    var total22:\
    \ Int = 0\n    var remainder23: Int = 0\n    var digit23: Int = 0\n    var total23:\
    \ Int = 0\n    var remainder24: Int = 0\n    var digit24: Int = 0\n    var \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpq43g79io.swift:88:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpq43g79io.swift:16:9: warning: variable 'result' was never used; consider\
    \ replacing with '_' or removing it\n    var result: String = \"\"\n        ^~~~~~\n\
    \        _\n/tmp/tmpq43g79io.swift:17:9: warning: variable 'remainder' was never\
    \ used; consider replacing with '_' or removing it\n    var remainder: Int = 0\n\
    \        ^~~~~~~~~\n        _\n/tmp/tmpq43g79io.swift:18:9: warning: variable\
    \ 'digit' was never used; consider replacing with '_' or removing it\n    var\
    \ digit: Int = 0\n        ^~~~~\n        _\n/tmp/tmpq43g79io.swift:19:9: warning:\
    \ variable 'total' was never used; consider replacing with '_' or removing it\n\
    \    var total: Int = 0\n        ^~~~~\n        _\n/tmp/tmpq43g79io.swift:20:9:\
    \ warning: variable 'remainder2' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder2: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpq43g79io.swift:21:9:\
    \ warning: variable 'digit2' was never used; consider replacing with '_' or removing\
    \ it\n    var digit2: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpq43g79io.swift:22:9:\
    \ warning: variable 'total2' was never used; consider replacing with '_' or removing\
    \ it\n    var total2: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpq43g79io.swift:23:9:\
    \ warning: variable 'remainder3' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder3: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpq43g79io.swift:24:9:\
    \ warning: variable 'digit3' was never used; consider replacing with '_' or removing\
    \ it\n    var digit3: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpq43g79io.swift:25:9:\
    \ warning: variable 'total3' was never used; consider replacing with '_' or removing\
    \ it\n    var total3: Int = 0\n        ^~~~~~\n        _\n/tmp/tmpq43g79io.swift:26:9:\
    \ warning: variable 'remainder4' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder4: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpq43g79io.swift:27:9:\
    \ warning: variable 'digit4' was never used; consider replacing with '_' or removing\
    \ it\n    var digit4:"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var digit: Int = 0\n    var temp: Int = 0\n    var i:\
    \ Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var temp2: Int = 0\n  \
    \  var temp3: Int = 0\n    var temp4: Int = 0\n    var temp5: Int = 0\n    var\
    \ temp6: Int = 0\n    var temp7: Int = 0\n    var temp8: Int = 0\n    var temp9:\
    \ Int = 0\n    var temp10: Int = 0\n    var temp11: Int = 0\n    var temp12: Int\
    \ = 0\n    var temp13: Int = 0\n    var temp14: Int = 0\n    var temp15: Int =\
    \ 0\n    var temp16: Int = 0\n    var temp17: Int = 0\n    var temp18: Int = 0\n\
    \    var temp19: Int = 0\n    var temp20: Int = 0\n    var temp21: Int = 0\n \
    \   var temp22: Int = 0\n    var temp23: Int = 0\n    var temp24: Int = 0\n  \
    \  var temp25: Int = 0\n    var temp26: Int = 0\n    var temp27: Int = 0\n   \
    \ var temp28: Int = 0\n    var temp29: Int = 0\n    var temp30: Int = 0\n    var\
    \ temp31: Int = 0\n    var temp32: Int = 0\n    var temp33: Int = 0\n    var temp34:\
    \ Int = 0\n    var temp35: Int = 0\n    var temp36: Int = 0\n    var temp37: Int\
    \ = 0\n    var temp38: Int = 0\n    var temp39: Int = 0\n    var temp40: Int =\
    \ 0\n    var temp41: Int = 0\n    var temp42: Int = 0\n    var temp43: Int = 0\n\
    \    var temp44: Int = 0\n    var temp45: Int = 0\n    var temp46: Int = 0\n \
    \   var temp47: Int = 0\n    var temp48: Int = 0\n    var temp49: Int = 0\n  \
    \  var temp50: Int = 0\n    var temp51: Int = 0\n    var temp52: Int = 0\n   \
    \ var temp53: Int = 0\n    var temp54: Int = 0\n    var temp55: Int = 0\n    var\
    \ temp56: Int = 0\n    var temp57: Int = 0\n    var temp58: Int = 0\n    var temp59:\
    \ Int = 0\n    var temp60: Int = 0\n    var temp61: Int = 0\n    var temp62: Int\
    \ = 0\n    var temp63: Int = 0\n    var temp64: Int = 0\n    var temp65: Int =\
    \ 0\n    var temp66: Int = 0\n    var temp67: Int = 0\n    var temp68: Int = 0\n\
    \    var temp69: Int = 0\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmplg2ho2hq.swift:16:9: warning: variable 'result' was never used;\
    \ consider replacing with '_' or removing it\n    var result: String = \"\"\n\
    \        ^~~~~~\n        _\n/tmp/tmplg2ho2hq.swift:17:9: warning: variable 'remainder'\
    \ was never used; consider replacing with '_' or removing it\n    var remainder:\
    \ Int = 0\n        ^~~~~~~~~\n        _\n/tmp/tmplg2ho2hq.swift:18:9: warning:\
    \ variable 'digit' was never used; consider replacing with '_' or removing it\n\
    \    var digit: Int = 0\n        ^~~~~\n        _\n/tmp/tmplg2ho2hq.swift:19:9:\
    \ warning: variable 'temp' was never used; consider replacing with '_' or removing\
    \ it\n    var temp: Int = 0\n        ^~~~\n        _\n/tmp/tmplg2ho2hq.swift:20:9:\
    \ warning: variable 'i' was never used; consider replacing with '_' or removing\
    \ it\n    var i: Int = 0\n        ^\n        _\n/tmp/tmplg2ho2hq.swift:21:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int = 0\n        ^\n        _\n/tmp/tmplg2ho2hq.swift:22:9: warning:\
    \ variable 'k' was never used; consider replacing with '_' or removing it\n  \
    \  var k: Int = 0\n        ^\n        _\n/tmp/tmplg2ho2hq.swift:23:9: warning:\
    \ variable 'temp2' was never used; consider replacing with '_' or removing it\n\
    \    var temp2: Int = 0\n        ^~~~~\n        _\n/tmp/tmplg2ho2hq.swift:24:9:\
    \ warning: variable 'temp3' was never used; consider replacing with '_' or removing\
    \ it\n    var temp3: Int = 0\n        ^~~~~\n        _\n/tmp/tmplg2ho2hq.swift:25:9:\
    \ warning: variable 'temp4' was never used; consider replacing with '_' or removing\
    \ it\n    var temp4: Int = 0\n        ^~~~~\n        _\n/tmp/tmplg2ho2hq.swift:26:9:\
    \ warning: variable 'temp5' was never used; consider replacing with '_' or removing\
    \ it\n    var temp5: Int = 0\n        ^~~~~\n        _\n/tmp/tmplg2ho2hq.swift:27:9:\
    \ warning: variable 'temp6' was never used; consider replacing with '_' or removing\
    \ it\n    var temp6: Int = 0\n        ^~~~~\n        _\n/tmp/tmplg2ho2hq.swift:28:9:\
    \ warning: variable 'temp7' was never used; consider replacing with '_' or removing\
    \ it\n    var temp7: Int = 0"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var sum =\
    \ 0\n    var remainder = 0\n    var power = 1\n    while N > 0 {\n        remainder\
    \ = N % 2\n        sum += remainder\n        N /= 2\n    }\n    while sum > 0\
    \ {\n        remainder = sum % 10\n        result += String(remainder)\n     \
    \   sum /= 10\n    }\n    while result != \"\" {\n        remainder = result.characters.last!\n\
    \        result += String(remainder)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpk7e27gdl.swift:23:11: error: left side of mutating operator isn't\
    \ mutable: 'N' is a 'let' constant\n        N /= 2\n        ~ ^\n/tmp/tmpk7e27gdl.swift:27:16:\
    \ error: left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \        result += String(remainder)\n        ~~~~~~ ^\n/tmp/tmpk7e27gdl.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n\
    \    var\n/tmp/tmpk7e27gdl.swift:31:43: error: cannot assign value of type 'String.Element'\
    \ (aka 'Character') to type 'Int'\n        remainder = result.characters.last!\n\
    \                    ~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpk7e27gdl.swift:32:16: error:\
    \ left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \        result += String(remainder)\n        ~~~~~~ ^\n/tmp/tmpk7e27gdl.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var digit = 0\n    while remainder > 0 {\n        digit = remainder\
    \ % 2\n        remainder = remainder / 2\n        result = String(digit) + result\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpr6l_vfct/tmpr6l_vfct.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2e45fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2e42f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2e42f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2e42f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr6l_vfct                        0x00005638e463a493 <unavailable> + 5267

    5    libc.so.6                          0x00002ac2e47e6460 __libc_start_main +
    245

    6    tmpr6l_vfct                        0x00005638e463a0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    let binaryDigits = digits.map { String($0) }\n    let binaryDigitCount =\
    \ binaryDigits.count\n    let binaryDigitSum = binaryDigits.reduce(\"\") { $0\
    \ + String($1) }\n    return binaryDigitSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpvjghfarz.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpvjghfarz.swift:18:9: warning: initialization of immutable value 'binaryDigitCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let binaryDigitCount = binaryDigits.count\n    ~~~~^~~~~~~~~~~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var sum = 0\n    var remainder = N\n    var binaryString = \"\"\n\
    \    while remainder > 0 {\n        sum += remainder % 2\n        remainder =\
    \ remainder / 2\n    }\n    binaryString = String(sum) + binaryString\n    return\
    \ binaryString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpdg2myssx/tmpdg2myssx.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab874671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab874368b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab874368988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8743677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdg2myssx                        0x00005563115d4493 <unavailable> + 5267

    5    libc.so.6                          0x00002ab87485d460 __libc_start_main +
    245

    6    tmpdg2myssx                        0x00005563115d40f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder = remainder % 2\n    }\n    remainderSum +=\
    \ remainder\n    while remainderSum > 0 {\n        result = String(remainderSum)\
    \ + result\n        remainderSum = remainderSum / 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmp7ybt0a_6/tmp7ybt0a_6.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab25b903c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab25b5fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab25b5fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab25b5f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ybt0a_6                        0x000055a144205493 <unavailable> + 5267

    5    libc.so.6                          0x00002ab25baef460 __libc_start_main +
    245

    6    tmp7ybt0a_6                        0x000055a1442050f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 0 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmpatchcy00/tmpatchcy00.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1854a41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1854738b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1854738988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b18547377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpatchcy00                        0x0000558e7cad33c3 <unavailable> + 5059

    5    libc.so.6                          0x00002b1854c2d460 __libc_start_main +
    245

    6    tmpatchcy00                        0x0000558e7cad3029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var sum: Int = 0\n    var power: Int = 0\n    var i:\
    \ Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var temp: Int = 0\n   \
    \ var temp2: Int = 0\n    var temp3: Int = 0\n    var temp4: Int = 0\n    var\
    \ temp5: Int = 0\n    var temp6: Int = 0\n    var temp7: Int = 0\n    var temp8:\
    \ Int = 0\n    var temp9: Int = 0\n    var temp10: Int = 0\n    var temp11: Int\
    \ = 0\n    var temp12: Int = 0\n    var temp13: Int = 0\n    var temp14: Int =\
    \ 0\n    var temp15: Int = 0\n    var temp16: Int = 0\n    var temp17: Int = 0\n\
    \    var temp18: Int = 0\n    var temp19: Int = 0\n    var temp20: Int = 0\n \
    \   var temp21: Int = 0\n    var temp22: Int = 0\n    var temp23: Int = 0\n  \
    \  var temp24: Int = 0\n    var temp25: Int = 0\n    var temp26: Int = 0\n   \
    \ var temp27: Int = 0\n    var temp28: Int = 0\n    var temp29: Int = 0\n    var\
    \ temp30: Int = 0\n    var temp31: Int = 0\n    var temp32: Int = 0\n    var temp33:\
    \ Int = 0\n    var temp34: Int = 0\n    var temp35: Int = 0\n    var temp36: Int\
    \ = 0\n    var temp37: Int = 0\n    var temp38: Int = 0\n    var temp39: Int =\
    \ 0\n    var temp40: Int = 0\n    var temp41: Int = 0\n    var temp42: Int = 0\n\
    \    var temp43: Int = 0\n    var temp44: Int = 0\n    var temp45: Int = 0\n \
    \   var temp46: Int = 0\n    var temp47: Int = 0\n    var temp48: Int = 0\n  \
    \  var temp49: Int = 0\n    var temp50: Int = 0\n    var temp51: Int = 0\n   \
    \ var temp52: Int = 0\n    var temp53: Int = 0\n    var temp54: Int = 0\n    var\
    \ temp55: Int = 0\n    var temp56: Int = 0\n    var temp57: Int = 0\n    var temp58:\
    \ Int = 0\n    var temp59: Int = 0\n    var temp60: Int = 0\n    var temp61: Int\
    \ = 0\n    var temp62: Int = 0\n    var temp63: Int = 0\n    var temp64: Int =\
    \ 0\n    var temp65: Int = 0\n    var temp66: Int = 0\n    var temp67: Int = 0\n\
    \    var temp68: Int = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpnpuhzhky.swift:91:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpnpuhzhky.swift:16:9: warning: variable 'result' was never used; consider\
    \ replacing with '_' or removing it\n    var result: String = \"\"\n        ^~~~~~\n\
    \        _\n/tmp/tmpnpuhzhky.swift:17:9: warning: variable 'remainder' was never\
    \ used; consider replacing with '_' or removing it\n    var remainder: Int = 0\n\
    \        ^~~~~~~~~\n        _\n/tmp/tmpnpuhzhky.swift:18:9: warning: variable\
    \ 'sum' was never used; consider replacing with '_' or removing it\n    var sum:\
    \ Int = 0\n        ^~~\n        _\n/tmp/tmpnpuhzhky.swift:19:9: warning: variable\
    \ 'power' was never used; consider replacing with '_' or removing it\n    var\
    \ power: Int = 0\n        ^~~~~\n        _\n/tmp/tmpnpuhzhky.swift:20:9: warning:\
    \ variable 'i' was never used; consider replacing with '_' or removing it\n  \
    \  var i: Int = 0\n        ^\n        _\n/tmp/tmpnpuhzhky.swift:21:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int = 0\n        ^\n        _\n/tmp/tmpnpuhzhky.swift:22:9: warning:\
    \ variable 'k' was never used; consider replacing with '_' or removing it\n  \
    \  var k: Int = 0\n        ^\n        _\n/tmp/tmpnpuhzhky.swift:23:9: warning:\
    \ variable 'temp' was never used; consider replacing with '_' or removing it\n\
    \    var temp: Int = 0\n        ^~~~\n        _\n/tmp/tmpnpuhzhky.swift:24:9:\
    \ warning: variable 'temp2' was never used; consider replacing with '_' or removing\
    \ it\n    var temp2: Int = 0\n        ^~~~~\n        _\n/tmp/tmpnpuhzhky.swift:25:9:\
    \ warning: variable 'temp3' was never used; consider replacing with '_' or removing\
    \ it\n    var temp3: Int = 0\n        ^~~~~\n        _\n/tmp/tmpnpuhzhky.swift:26:9:\
    \ warning: variable 'temp4' was never used; consider replacing with '_' or removing\
    \ it\n    var temp4: Int = 0\n        ^~~~~\n        _\n/tmp/tmpnpuhzhky.swift:27:9:\
    \ warning: variable 'temp5' was never used; consider replacing with '_' or removing\
    \ it\n    var temp5: Int = 0\n        ^~~~~\n        _\n/tmp/tmpnpuhzhky.swift:28:9:\
    \ warning: variable 'temp6' was never used; "
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder = remainder % 2\n        result\
    \ = String(remainder) + result\n        remainder = Int(remainder) / 2\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpd74ik04_/tmpd74ik04_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aded1253c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aded0f4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aded0f4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aded0f497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd74ik04_                        0x000055976c6b25c3 <unavailable> + 5571

    5    libc.so.6                          0x00002aded143f460 __libc_start_main +
    245

    6    tmpd74ik04_                        0x000055976c6b2229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderCount = 0\n    while remainder > 0 {\n        remainderCount\
    \ += 1\n        remainder /= 2\n    }\n    for _ in 0..<remainderCount {\n   \
    \     result += \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmpwalggf6i/tmpwalggf6i.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f227dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f224d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f224d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f224d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwalggf6i                        0x000055d2af6974c3 <unavailable> + 5315

    5    libc.so.6                          0x00002b3f229c7460 __libc_start_main +
    245

    6    tmpwalggf6i                        0x000055d2af697129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainder2 = N\n    var remainder3 = N\n    var remainder4 = N\n\
    \    var remainder5 = N\n    var remainder6 = N\n    var remainder7 = N\n    var\
    \ remainder8 = N\n    var remainder9 = N\n    var remainder10 = N\n    var remainder11\
    \ = N\n    var remainder12 = N\n    var remainder13 = N\n    var remainder14 =\
    \ N\n    var remainder15 = N\n    var remainder16 = N\n    var remainder17 = N\n\
    \    var remainder18 = N\n    var remainder19 = N\n    var remainder20 = N\n \
    \   var remainder21 = N\n    var remainder22 = N\n    var remainder23 = N\n  \
    \  var remainder24 = N\n    var remainder25 = N\n    var remainder26 = N\n   \
    \ var remainder27 = N\n    var remainder28 = N\n    var remainder29 = N\n    var\
    \ remainder30 = N\n    var remainder31 = N\n    var remainder32 = N\n    var remainder33\
    \ = N\n    var remainder34 = N\n    var remainder35 = N\n    var remainder36 =\
    \ N\n    var remainder37 = N\n    var remainder38 = N\n    var remainder39 = N\n\
    \    var remainder40 = N\n    var remainder41 = N\n    var remainder42 = N\n \
    \   var remainder43 = N\n    var remainder44 = N\n    var remainder45 = N\n  \
    \  var remainder46 = N\n    var remainder47 = N\n    var remainder48 = N\n   \
    \ var remainder49 = N\n    var remainder50 = N\n    var remainder51 = N\n    var\
    \ remainder52 = N\n    var remainder53 = N\n    var remainder54 = N\n    var remainder55\
    \ = N\n    var remainder56 = N\n    var remainder57 = N\n    var remainder58 =\
    \ N\n    var remainder59 = N\n    var remainder60 = N\n    var remainder61 = N\n\
    \    var remainder62 = N\n    var remainder63 = N\n    var remainder64 = N\n \
    \   var remainder65 = N\n    var remainder66 = N\n    var remainder67 = N\n  \
    \  var remainder68 = N\n    var remainder69 = N\n    var remainder70 = N\n   \
    \ var remainder71 = N\n    var remainder72 = N\n    var remainder73 = N\n    var\
    \ remainder74 = N\n    var remainder\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpxi9v61u1.swift:91:9: error: type annotation missing in pattern\n\
    \    var remainder\n        ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    for _ in 0..<N {\n        remainder = N % 2\n        result += String(remainder)\n\
    \        N = N / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmprrde74us.swift:21:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    while remainder > 0\
    \ {\n        let remainderString = String(remainder)\n        let remainderInt\
    \ = Int(remainderString)\n        if remainderInt > 0 {\n            result +=\
    \ String(remainderInt % 2)\n        }\n        remainder = Int(remainderString)\
    \ / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpg9ap2r2s.swift:24:12: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if remainderInt > 0 {\n     \
    \      ^\n/tmp/tmpg9ap2r2s.swift:24:12: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        if remainderInt > 0\
    \ {\n           ^\n                        ?? <#default value#>\n/tmp/tmpg9ap2r2s.swift:24:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if remainderInt > 0 {\n           ^\n                       !\n\
    /tmp/tmpg9ap2r2s.swift:25:30: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n            result += String(remainderInt % 2)\n \
    \                            ^\n/tmp/tmpg9ap2r2s.swift:25:30: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   result += String(remainderInt % 2)\n                             ^\n     \
    \                        (            ?? <#default value#>)\n/tmp/tmpg9ap2r2s.swift:25:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            result += String(remainderInt % 2)\n                    \
    \         ^\n                                         !\n/tmp/tmpg9ap2r2s.swift:27:21:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        remainder = Int(remainderString) / 2\n                    ^\n/tmp/tmpg9ap2r2s.swift:27:21:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        remainder = Int(remainderString) / 2\n                    ^\n\
    \                    (                    ?? <#default value#>)\n/tmp/tmpg9ap2r2s.swift:27:21:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        remainder = Int(remainderString) / 2\n                    ^\n\
    \                                        !\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderInt = remainder % 2\n \
    \       remainder = remainder / 2\n        result = String(remainderInt) + result\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmp71k_ruov/tmp71k_ruov.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aabc5b7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aabc5871b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aabc5871988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aabc58707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71k_ruov                        0x00005593323a6493 <unavailable> + 5267

    5    libc.so.6                          0x00002aabc5d66460 __libc_start_main +
    245

    6    tmp71k_ruov                        0x00005593323a60f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var sum =\
    \ 0\n    var remainder = 0\n    var power = 1\n    for _ in 0..<N {\n        remainder\
    \ = N % power\n        sum += remainder\n        N /= power\n        power = power\
    \ * 2\n    }\n    if sum > 0 {\n        result += \"1\"\n    }\n    if sum < 0\
    \ {\n        result += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpnu32_gxs.swift:23:11: error: left side of mutating operator isn't\
    \ mutable: 'N' is a 'let' constant\n        N /= power\n        ~ ^\n/tmp/tmpnu32_gxs.swift:27:16:\
    \ error: left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \        result += \"1\"\n        ~~~~~~ ^\n/tmp/tmpnu32_gxs.swift:16:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n \
    \   var\n/tmp/tmpnu32_gxs.swift:30:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result += \"0\"\n        ~~~~~~\
    \ ^\n/tmp/tmpnu32_gxs.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters.map\
    \ { Int(String($0)) }\n    let sum = digits.reduce(0) { $0 + $1 }\n    let result\
    \ = String(sum)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp31sd9gdw.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters.map { Int(String($0))\
    \ }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp31sd9gdw.swift:17:39: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n    let sum = digits.reduce(0)\
    \ { $0 + $1 }\n                                      ^\n/tmp/tmp31sd9gdw.swift:17:39:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let sum = digits.reduce(0) { $0 + $1 }\n                        \
    \              ^\n                                      (  ?? <#default value#>)\n\
    /tmp/tmp31sd9gdw.swift:17:39: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    let sum = digits.reduce(0) { $0 +\
    \ $1 }\n                                      ^\n                            \
    \            !\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var power: Int = 0\n    var sum: Int = 0\n    var i:\
    \ Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var temp: Int = 0\n   \
    \ var temp2: Int = 0\n    var temp3: Int = 0\n    var temp4: Int = 0\n    var\
    \ temp5: Int = 0\n    var temp6: Int = 0\n    var temp7: Int = 0\n    var temp8:\
    \ Int = 0\n    var temp9: Int = 0\n    var temp10: Int = 0\n    var temp11: Int\
    \ = 0\n    var temp12: Int = 0\n    var temp13: Int = 0\n    var temp14: Int =\
    \ 0\n    var temp15: Int = 0\n    var temp16: Int = 0\n    var temp17: Int = 0\n\
    \    var temp18: Int = 0\n    var temp19: Int = 0\n    var temp20: Int = 0\n \
    \   var temp21: Int = 0\n    var temp22: Int = 0\n    var temp23: Int = 0\n  \
    \  var temp24: Int = 0\n    var temp25: Int = 0\n    var temp26: Int = 0\n   \
    \ var temp27: Int = 0\n    var temp28: Int = 0\n    var temp29: Int = 0\n    var\
    \ temp30: Int = 0\n    var temp31: Int = 0\n    var temp32: Int = 0\n    var temp33:\
    \ Int = 0\n    var temp34: Int = 0\n    var temp35: Int = 0\n    var temp36: Int\
    \ = 0\n    var temp37: Int = 0\n    var temp38: Int = 0\n    var temp39: Int =\
    \ 0\n    var temp40: Int = 0\n    var temp41: Int = 0\n    var temp42: Int = 0\n\
    \    var temp43: Int = 0\n    var temp44: Int = 0\n    var temp45: Int = 0\n \
    \   var temp46: Int = 0\n    var temp47: Int = 0\n    var temp48: Int = 0\n  \
    \  var temp49: Int = 0\n    var temp50: Int = 0\n    var temp51: Int = 0\n   \
    \ var temp52: Int = 0\n    var temp53: Int = 0\n    var temp54: Int = 0\n    var\
    \ temp55: Int = 0\n    var temp56: Int = 0\n    var temp57: Int = 0\n    var temp58:\
    \ Int = 0\n    var temp59: Int = 0\n    var temp60: Int = 0\n    var temp61: Int\
    \ = 0\n    var temp62: Int = 0\n    var temp63: Int = 0\n    var temp64: Int =\
    \ 0\n    var temp65: Int = 0\n    var temp66: Int = 0\n    var temp67: Int = 0\n\
    \    var temp68: Int = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp10_a97p2.swift:91:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmp10_a97p2.swift:16:9: warning: variable 'result' was never used; consider\
    \ replacing with '_' or removing it\n    var result: String = \"\"\n        ^~~~~~\n\
    \        _\n/tmp/tmp10_a97p2.swift:17:9: warning: variable 'remainder' was never\
    \ used; consider replacing with '_' or removing it\n    var remainder: Int = 0\n\
    \        ^~~~~~~~~\n        _\n/tmp/tmp10_a97p2.swift:18:9: warning: variable\
    \ 'power' was never used; consider replacing with '_' or removing it\n    var\
    \ power: Int = 0\n        ^~~~~\n        _\n/tmp/tmp10_a97p2.swift:19:9: warning:\
    \ variable 'sum' was never used; consider replacing with '_' or removing it\n\
    \    var sum: Int = 0\n        ^~~\n        _\n/tmp/tmp10_a97p2.swift:20:9: warning:\
    \ variable 'i' was never used; consider replacing with '_' or removing it\n  \
    \  var i: Int = 0\n        ^\n        _\n/tmp/tmp10_a97p2.swift:21:9: warning:\
    \ variable 'j' was never used; consider replacing with '_' or removing it\n  \
    \  var j: Int = 0\n        ^\n        _\n/tmp/tmp10_a97p2.swift:22:9: warning:\
    \ variable 'k' was never used; consider replacing with '_' or removing it\n  \
    \  var k: Int = 0\n        ^\n        _\n/tmp/tmp10_a97p2.swift:23:9: warning:\
    \ variable 'temp' was never used; consider replacing with '_' or removing it\n\
    \    var temp: Int = 0\n        ^~~~\n        _\n/tmp/tmp10_a97p2.swift:24:9:\
    \ warning: variable 'temp2' was never used; consider replacing with '_' or removing\
    \ it\n    var temp2: Int = 0\n        ^~~~~\n        _\n/tmp/tmp10_a97p2.swift:25:9:\
    \ warning: variable 'temp3' was never used; consider replacing with '_' or removing\
    \ it\n    var temp3: Int = 0\n        ^~~~~\n        _\n/tmp/tmp10_a97p2.swift:26:9:\
    \ warning: variable 'temp4' was never used; consider replacing with '_' or removing\
    \ it\n    var temp4: Int = 0\n        ^~~~~\n        _\n/tmp/tmp10_a97p2.swift:27:9:\
    \ warning: variable 'temp5' was never used; consider replacing with '_' or removing\
    \ it\n    var temp5: Int = 0\n        ^~~~~\n        _\n/tmp/tmp10_a97p2.swift:28:9:\
    \ warning: variable 'temp6' was never used; "
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    remainder = N\n    while remainder > 0 {\n        remainder /=\
    \ 2\n        result += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpgv2dqc8b/tmpgv2dqc8b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4f493ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4f4631b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4f4631988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4f46307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgv2dqc8b                        0x0000560772e0d3c3 <unavailable> + 5059

    5    libc.so.6                          0x00002af4f4b26460 __libc_start_main +
    245

    6    tmpgv2dqc8b                        0x0000560772e0d029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = Int(remainder / 2)\n    }\n    if remainderSum\
    \ == 0 {\n        remainderSum = 1\n    }\n    for _ in 0..<remainderSum {\n \
    \       result += \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmp74r4gig0/tmp74r4gig0.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ffecb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ffe9aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ffe9aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ffe9a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp74r4gig0                        0x0000557b1993d5f3 <unavailable> + 5619

    5    libc.so.6                          0x00002b5ffee9f460 __libc_start_main +
    245

    6    tmp74r4gig0                        0x0000557b1993d259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = 0\n    var binary = \"\
    \"\n    for _ in 0..<N {\n        sum += N % 2\n        N = N / 2\n    }\n   \
    \ for _ in 0..<N {\n        binary = String(sum) + binary\n        sum += N %\
    \ 2\n        N = N / 2\n    }\n    return binary\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpybzhrcur.swift:20:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n/tmp/tmpybzhrcur.swift:25:9: error:\
    \ cannot assign to value: 'N' is a 'let' constant\n        N = N / 2\n       \
    \ ^\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp6d5fff7x/tmp6d5fff7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc04413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc0410ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc0410a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc041097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6d5fff7x                        0x000055963ebe63c3 <unavailable> + 5059

    5    libc.so.6                          0x00002abc045ff460 __libc_start_main +
    245

    6    tmp6d5fff7x                        0x000055963ebe6029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    remainderSum\
    \ += remainder\n    while remainderSum > 0 {\n        result = String(remainderSum)\
    \ + result\n        remainderSum = remainderSum / 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmptlf2f7bv/tmptlf2f7bv.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b617e929c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b617e620b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b617e620988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b617e61f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptlf2f7bv                        0x0000556f35f83493 <unavailable> + 5267

    5    libc.so.6                          0x00002b617eb15460 __libc_start_main +
    245

    6    tmptlf2f7bv                        0x0000556f35f830f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var lastDigit = 0\n    for _ in 0..<N {\n        remainder = N % 2\n\
    \        result += String(lastDigit)\n        lastDigit = remainder\n        N\
    \ /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpx3vp4zjk.swift:23:11: error: left side of mutating operator isn't\
    \ mutable: 'N' is a 'let' constant\n        N /= 2\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var currentDigit = 0\n    for _ in 0..<N {\n        remainder = N %\
    \ 10\n        result += String(UInt8(remainder))\n        N /= 10\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmppjgziq4c.swift:22:11: error: left side of mutating operator isn't\
    \ mutable: 'N' is a 'let' constant\n        N /= 10\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    while remainderSum\
    \ > 0 {\n        result = String(remainderSum) + result\n        remainderSum\
    \ = remainderSum / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmponninzy2/tmponninzy2.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b683ff96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b683fc8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b683fc8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b683fc8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmponninzy2                        0x000055b1807f0493 <unavailable> + 5267

    5    libc.so.6                          0x00002b6840182460 __libc_start_main +
    245

    6    tmponninzy2                        0x000055b1807f00f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainder2 = remainder\n    var remainder3 = remainder2\n    var\
    \ remainder4 = remainder3\n    while remainder != 0 {\n        remainder4 = remainder3\
    \ % 2\n        remainder3 = remainder2 % 2\n        remainder2 = remainder % 2\n\
    \        remainder = remainder4 % 2\n        result = String(remainder4) + String(remainder3)\
    \ + String(remainder2) + String(remainder) + result\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpax2q2s7b/tmpax2q2s7b.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ab38e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ab35dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ab35da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ab35d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpax2q2s7b                        0x00005650fe735493 <unavailable> + 5267

    5    libc.so.6                          0x00002b2ab3acf460 __libc_start_main +
    245

    6    tmpax2q2s7b                        0x00005650fe7350f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N < 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    while remainder > 0\
    \ {\n        remainder, remainder = remainder / 2, remainder % 2\n        result\
    \ += String(remainder)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpr6kf8na6.swift:22:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmpr6kf8na6.swift:22:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmpr6kf8na6.swift:22:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmpr6kf8na6.swift:19:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmpr6kf8na6.swift:20:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder:\
    \ Int = 0\n    var remainder2: Int = 0\n    var remainder3: Int = 0\n    var remainder4:\
    \ Int = 0\n    var remainder5: Int = 0\n    var remainder6: Int = 0\n    var remainder7:\
    \ Int = 0\n    var remainder8: Int = 0\n    var remainder9: Int = 0\n    var remainder10:\
    \ Int = 0\n    var remainder11: Int = 0\n    var remainder12: Int = 0\n    var\
    \ remainder13: Int = 0\n    var remainder14: Int = 0\n    var remainder15: Int\
    \ = 0\n    var remainder16: Int = 0\n    var remainder17: Int = 0\n    var remainder18:\
    \ Int = 0\n    var remainder19: Int = 0\n    var remainder20: Int = 0\n    var\
    \ remainder21: Int = 0\n    var remainder22: Int = 0\n    var remainder23: Int\
    \ = 0\n    var remainder24: Int = 0\n    var remainder25: Int = 0\n    var remainder26:\
    \ Int = 0\n    var remainder27: Int = 0\n    var remainder28: Int = 0\n    var\
    \ remainder29: Int = 0\n    var remainder30: Int = 0\n    var remainder31: Int\
    \ = 0\n    var remainder32: Int = 0\n    var remainder33: Int = 0\n    var remainder34:\
    \ Int = 0\n    var remainder35: Int = 0\n    var remainder36: Int = 0\n    var\
    \ remainder37: Int = 0\n    var remainder38: Int = 0\n    var remainder39: Int\
    \ = 0\n    var remainder40: Int = 0\n    var remainder41: Int = 0\n    var remainder42:\
    \ Int = 0\n    var remainder43: Int = 0\n    var remainder44: Int = 0\n    var\
    \ remainder45: Int = 0\n    var remainder46: Int = 0\n    var remainder47: Int\
    \ = 0\n    var remainder48: Int = 0\n    var remainder49: Int = 0\n    var remainder50:\
    \ Int = 0\n    var remainder51: Int = 0\n    var remainder52: Int = 0\n    var\
    \ remainder53: Int = 0\n    var remainder54: Int = 0\n    var remainder55: Int\
    \ = 0\n    var remainder56: Int = 0\n    var remainder57: Int = 0\n    var remainder58:\
    \ Int = 0\n    var remainder59: Int = 0\n    var remainder60: Int = 0\n    var\
    \ remainder61: Int = 0\n    var remainder62: Int = 0\n    var remainder63: Int\
    \ = 0\n    var remainder64: Int = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpuotevvp1.swift:81:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpuotevvp1.swift:16:9: warning: initialization of variable 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var result = \"\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpuotevvp1.swift:17:9: warning:\
    \ variable 'remainder' was never used; consider replacing with '_' or removing\
    \ it\n    var remainder: Int = 0\n        ^~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:18:9:\
    \ warning: variable 'remainder2' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder2: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:19:9:\
    \ warning: variable 'remainder3' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder3: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:20:9:\
    \ warning: variable 'remainder4' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder4: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:21:9:\
    \ warning: variable 'remainder5' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder5: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:22:9:\
    \ warning: variable 'remainder6' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder6: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:23:9:\
    \ warning: variable 'remainder7' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder7: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:24:9:\
    \ warning: variable 'remainder8' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder8: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:25:9:\
    \ warning: variable 'remainder9' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder9: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpuotevvp1.swift:26:9:\
    \ warning: variable 'remainder10' was never used; consider replacing with '_'\
    \ or removing it\n    var remainder10: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpuotevvp1.swift:27:9: "
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, digits: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmppdcka1n3.swift:16:32: error: extra argument 'digits' in call\n\
    \    return solve(N: N, digits: 0)\n                ~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder:\
    \ Int = 0\n    var power: Int = 0\n    var digit: Int = 0\n    while N > 0 {\n\
    \        remainder = N % 2\n        digit = N / 2\n        power = digit * 10\n\
    \        result += String(remainder)\n        result += String(digit)\n      \
    \  result += String(power)\n        N = N / 10\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmphw7niams.swift:27:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 10\n        ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += String(remainder)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpv7qmlgmy/tmpv7qmlgmy.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b07d7445c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07d713cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b07d713c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07d713b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv7qmlgmy                        0x0000559ccf00b493 <unavailable> + 5267

    5    libc.so.6                          0x00002b07d7631460 __libc_start_main +
    245

    6    tmpv7qmlgmy                        0x0000559ccf00b0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    var remainderSumDigit = 0\n    while remainder\
    \ > 0 {\n        remainderSum += remainder\n        remainderSumDigit += 1\n \
    \       remainder *= 10\n    }\n    while remainderSumDigit > 0 {\n        result\
    \ += String(remainderSumDigit % 2)\n        remainderSumDigit /= 2\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        sum += String(remainder % 2)\n     \
    \   remainder = remainder / 2\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpwcto2ybd/tmpwcto2ybd.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b54a01b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b549fea8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b549fea8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b549fea77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwcto2ybd                        0x0000564447582493 <unavailable> + 5267

    5    libc.so.6                          0x00002b54a039d460 __libc_start_main +
    245

    6    tmpwcto2ybd                        0x00005644475820f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = \"\"\n    for i in 0..<digits.count {\n        let digit = digits[i]\n\
    \        sum += digit\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpg0xuwbbt.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpg0xuwbbt.swift:19:21: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        let digit = digits[i]\n\
    \                    ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpg0xuwbbt.swift:20:16: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n        sum += digit\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp6d5fff7x/tmp6d5fff7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc04413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc0410ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc0410a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc041097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6d5fff7x                        0x000055963ebe63c3 <unavailable> + 5059

    5    libc.so.6                          0x00002abc045ff460 __libc_start_main +
    245

    6    tmp6d5fff7x                        0x000055963ebe6029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var remainder2: Int = 0\n    var remainder3: Int = 0\n\
    \    var remainder4: Int = 0\n    var remainder5: Int = 0\n    var remainder6:\
    \ Int = 0\n    var remainder7: Int = 0\n    var remainder8: Int = 0\n    var remainder9:\
    \ Int = 0\n    var remainder10: Int = 0\n    var remainder11: Int = 0\n    var\
    \ remainder12: Int = 0\n    var remainder13: Int = 0\n    var remainder14: Int\
    \ = 0\n    var remainder15: Int = 0\n    var remainder16: Int = 0\n    var remainder17:\
    \ Int = 0\n    var remainder18: Int = 0\n    var remainder19: Int = 0\n    var\
    \ remainder20: Int = 0\n    var remainder21: Int = 0\n    var remainder22: Int\
    \ = 0\n    var remainder23: Int = 0\n    var remainder24: Int = 0\n    var remainder25:\
    \ Int = 0\n    var remainder26: Int = 0\n    var remainder27: Int = 0\n    var\
    \ remainder28: Int = 0\n    var remainder29: Int = 0\n    var remainder30: Int\
    \ = 0\n    var remainder31: Int = 0\n    var remainder32: Int = 0\n    var remainder33:\
    \ Int = 0\n    var remainder34: Int = 0\n    var remainder35: Int = 0\n    var\
    \ remainder36: Int = 0\n    var remainder37: Int = 0\n    var remainder38: Int\
    \ = 0\n    var remainder39: Int = 0\n    var remainder40: Int = 0\n    var remainder41:\
    \ Int = 0\n    var remainder42: Int = 0\n    var remainder43: Int = 0\n    var\
    \ remainder44: Int = 0\n    var remainder45: Int = 0\n    var remainder46: Int\
    \ = 0\n    var remainder47: Int = 0\n    var remainder48: Int = 0\n    var remainder49:\
    \ Int = 0\n    var remainder50: Int = 0\n    var remainder51: Int = 0\n    var\
    \ remainder52: Int = 0\n    var remainder53: Int = 0\n    var remainder54: Int\
    \ = 0\n    var remainder55: Int = 0\n    var remainder56: Int = 0\n    var remainder57:\
    \ Int = 0\n    var remainder58: Int = 0\n    var remainder59: Int = 0\n    var\
    \ remainder60: Int = 0\n    var remainder61: Int = 0\n    var remainder62: Int\
    \ = 0\n    var remainder63: Int = 0\n    var remainder64: Int = 0\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpi4uxy9ms.swift:16:9: warning: variable 'result' was never used;\
    \ consider replacing with '_' or removing it\n    var result: String = \"\"\n\
    \        ^~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:17:9: warning: variable 'remainder'\
    \ was never used; consider replacing with '_' or removing it\n    var remainder:\
    \ Int = 0\n        ^~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:18:9: warning:\
    \ variable 'remainder2' was never used; consider replacing with '_' or removing\
    \ it\n    var remainder2: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:19:9:\
    \ warning: variable 'remainder3' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder3: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:20:9:\
    \ warning: variable 'remainder4' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder4: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:21:9:\
    \ warning: variable 'remainder5' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder5: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:22:9:\
    \ warning: variable 'remainder6' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder6: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:23:9:\
    \ warning: variable 'remainder7' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder7: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:24:9:\
    \ warning: variable 'remainder8' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder8: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:25:9:\
    \ warning: variable 'remainder9' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder9: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:26:9:\
    \ warning: variable 'remainder10' was never used; consider replacing with '_'\
    \ or removing it\n    var remainder10: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpi4uxy9ms.swift:27:9: warning: variable 'remainder11' was never used; consider\
    \ replacing with '_' or removing it\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var remainder2: Int = 0\n    var remainder3: Int = 0\n\
    \    var remainder4: Int = 0\n    var remainder5: Int = 0\n    var remainder6:\
    \ Int = 0\n    var remainder7: Int = 0\n    var remainder8: Int = 0\n    var remainder9:\
    \ Int = 0\n    var remainder10: Int = 0\n    var remainder11: Int = 0\n    var\
    \ remainder12: Int = 0\n    var remainder13: Int = 0\n    var remainder14: Int\
    \ = 0\n    var remainder15: Int = 0\n    var remainder16: Int = 0\n    var remainder17:\
    \ Int = 0\n    var remainder18: Int = 0\n    var remainder19: Int = 0\n    var\
    \ remainder20: Int = 0\n    var remainder21: Int = 0\n    var remainder22: Int\
    \ = 0\n    var remainder23: Int = 0\n    var remainder24: Int = 0\n    var remainder25:\
    \ Int = 0\n    var remainder26: Int = 0\n    var remainder27: Int = 0\n    var\
    \ remainder28: Int = 0\n    var remainder29: Int = 0\n    var remainder30: Int\
    \ = 0\n    var remainder31: Int = 0\n    var remainder32: Int = 0\n    var remainder33:\
    \ Int = 0\n    var remainder34: Int = 0\n    var remainder35: Int = 0\n    var\
    \ remainder36: Int = 0\n    var remainder37: Int = 0\n    var remainder38: Int\
    \ = 0\n    var remainder39: Int = 0\n    var remainder40: Int = 0\n    var remainder41:\
    \ Int = 0\n    var remainder42: Int = 0\n    var remainder43: Int = 0\n    var\
    \ remainder44: Int = 0\n    var remainder45: Int = 0\n    var remainder46: Int\
    \ = 0\n    var remainder47: Int = 0\n    var remainder48: Int = 0\n    var remainder49:\
    \ Int = 0\n    var remainder50: Int = 0\n    var remainder51: Int = 0\n    var\
    \ remainder52: Int = 0\n    var remainder53: Int = 0\n    var remainder54: Int\
    \ = 0\n    var remainder55: Int = 0\n    var remainder56: Int = 0\n    var remainder57:\
    \ Int = 0\n    var remainder58: Int = 0\n    var remainder59: Int = 0\n    var\
    \ remainder60: Int = 0\n    var remainder61: Int = 0\n    var remainder62: Int\
    \ = 0\n    var remainder63: Int = 0\n    var remainder64: Int = 0\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpi4uxy9ms.swift:16:9: warning: variable 'result' was never used;\
    \ consider replacing with '_' or removing it\n    var result: String = \"\"\n\
    \        ^~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:17:9: warning: variable 'remainder'\
    \ was never used; consider replacing with '_' or removing it\n    var remainder:\
    \ Int = 0\n        ^~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:18:9: warning:\
    \ variable 'remainder2' was never used; consider replacing with '_' or removing\
    \ it\n    var remainder2: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:19:9:\
    \ warning: variable 'remainder3' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder3: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:20:9:\
    \ warning: variable 'remainder4' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder4: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:21:9:\
    \ warning: variable 'remainder5' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder5: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:22:9:\
    \ warning: variable 'remainder6' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder6: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:23:9:\
    \ warning: variable 'remainder7' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder7: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:24:9:\
    \ warning: variable 'remainder8' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder8: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:25:9:\
    \ warning: variable 'remainder9' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder9: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:26:9:\
    \ warning: variable 'remainder10' was never used; consider replacing with '_'\
    \ or removing it\n    var remainder10: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpi4uxy9ms.swift:27:9: warning: variable 'remainder11' was never used; consider\
    \ replacing with '_' or removing it\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = 0\n    for digit in digits {\n        sum += Int(digit)\n    }\n\
    \    return String(sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpeunwajgj.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpeunwajgj.swift:19:16: error: no exact matches in call to initializer \n\
    \        sum += Int(digit)\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reverse\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp2lmlwxzs.swift:88:33: error: expected '}' at end of brace statement\n\
    assert(solve(N: 963) == \"10010\")\n                                ^\n/tmp/tmp2lmlwxzs.swift:15:30:\
    \ note: to match this opening '{'\nfunc solve(N: Int) -> String {\n          \
    \                   ^\n/tmp/tmp2lmlwxzs.swift:20:13: error: invalid redeclaration\
    \ of 'remainderString'\n        let remainderString = remainderString.reversed()\n\
    \            ^\n/tmp/tmp2lmlwxzs.swift:19:13: note: 'remainderString' previously\
    \ declared here\n        let remainderString = String(remainder)\n           \
    \ ^\n/tmp/tmp2lmlwxzs.swift:72:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var sum =\
    \ 0\n    var remainder = 0\n    var remainderSum = 0\n    var remainderRemainder\
    \ = 0\n    var remainderRemainderSum = 0\n    var remainderRemainderSum2 = 0\n\
    \    var remainderRemainderSum3 = 0\n    var remainderRemainderSum4 = 0\n    var\
    \ remainderRemainderSum5 = 0\n    var remainderRemainderSum6 = 0\n    var remainderRemainderSum7\
    \ = 0\n    var remainderRemainderSum8 = 0\n    var remainderRemainderSum9 = 0\n\
    \    var remainderRemainderSum10 = 0\n    var remainderRemainderSum11 = 0\n  \
    \  var remainderRemainderSum12 = 0\n    var remainderRemainderSum13 = 0\n    var\
    \ remainderRemainderSum14 = 0\n    var remainderRemainderSum15 = 0\n    var remainderRemainderSum16\
    \ = 0\n    var remainderRemainderSum17 = 0\n    var remainderRemainderSum18 =\
    \ 0\n    var remainderRemainderSum19 = 0\n    var remainderRemainderSum20 = 0\n\
    \    var remainderRemainderSum21 = 0\n    var remainderRemainderSum22 = 0\n  \
    \  var remainderRemainderSum23 = 0\n    var remainderRemainderSum24 = 0\n    var\
    \ remainderRemainderSum25 = 0\n    var remainderRemainderSum26 = 0\n    var remainderRemainderSum27\
    \ = 0\n    var remainderRemainderSum28 = 0\n    var remainderRemainderSum29 =\
    \ 0\n    var remainderRemainderSum30 = 0\n    var remainderRemainderSum31 = 0\n\
    \    var remainderRemainderSum32 = 0\n    var remainderRemainderSum33 = 0\n  \
    \  var remainderRemainderSum34 = 0\n    var remainderRemainderSum35 = 0\n    var\
    \ remainderRemainderSum36 = 0\n    var remainderRemainderSum37 = 0\n    var remainderRemainderSum38\
    \ = 0\n    var remainderRemainderSum39 = 0\n    var remainderRemainderSum40 =\
    \ 0\n    var remainderRemainderSum41 = 0\n    var remainderRemainderSum42 = 0\n\
    \    var remainderRemainderSum43 = 0\n    var remainderRemainderSum44 = 0\n  \
    \  var remainderRemainderSum45 = 0\n    var remainderRemainderSum46 = 0\n    var\
    \ remainderRemainderSum47 = 0\n    var remainderRemainderSum48 = 0\n    var remainderRemainderSum49\
    \ = 0\n    var remainderRemainderSum50 = 0\n    var remainderRemainderSum51 =\
    \ 0\n    var remainderRemainderSum52 = 0\n    var remainderRemainderSum53 = 0\n\
    \    var remainderRemainderSum54 = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpmy4srbga.swift:75:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpmy4srbga.swift:16:9: warning: initialization of immutable value 'result'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   let result = \"\"\n    ~~~~^~~~~~\n    _\n/tmp/tmpmy4srbga.swift:17:9: warning:\
    \ initialization of variable 'sum' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var sum = 0\n    ~~~~^~~\n    _\n/tmp/tmpmy4srbga.swift:18:9:\
    \ warning: initialization of variable 'remainder' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var remainder = 0\n    ~~~~^~~~~~~~~\n\
    \    _\n/tmp/tmpmy4srbga.swift:19:9: warning: initialization of variable 'remainderSum'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var remainderSum = 0\n    ~~~~^~~~~~~~~~~~\n    _\n/tmp/tmpmy4srbga.swift:20:9:\
    \ warning: initialization of variable 'remainderRemainder' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var remainderRemainder\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmy4srbga.swift:21:9: warning:\
    \ initialization of variable 'remainderRemainderSum' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var remainderRemainderSum\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmy4srbga.swift:22:9: warning:\
    \ initialization of variable 'remainderRemainderSum2' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var remainderRemainderSum2\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmy4srbga.swift:23:9: warning:\
    \ initialization of variable 'remainderRemainderSum3' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var remainderRemainderSum3\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmy4srbga.swift:24:9: warning:\
    \ initialization of variable 'remainderRemainderSum4' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var remainderRemainderSum4\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpmy4srbga.swift:25:9: warning:\
    \ initi"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).reversed().map({\
    \ String($0) }).reversed()\n    let result = \"\"\n    for digit in digits {\n\
    \        result += digit\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmps2l7igms.swift:19:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result += digit\n        ~~~~~~\
    \ ^\n/tmp/tmps2l7igms.swift:17:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderAsString = String(remainder)\n\
    \        let remainderAsInt = Int(remainder)\n        let remainderAsBinaryString\
    \ = String(remainderAsInt, radix: 2)\n        let remainderAsBinaryInt = Int(remainderAsBinaryString,\
    \ radix: 2)\n        let remainderAsBinaryStringWithZeros = String(remainderAsBinaryInt,\
    \ radix: 2)\n        let remainderAsBinaryIntWithZeros = Int(remainderAsBinaryStringWithZeros,\
    \ radix: 2)\n        let remainderAsBinaryStringWithOnes = String(remainderAsBinaryIntWithZeros,\
    \ radix: 2)\n        let remainderAsBinaryIntWithOnes = Int(remainderAsBinaryStringWithOnes,\
    \ radix: 2)\n        let remainderAsBinaryStringWithTwos = String(remainderAsBinaryIntWithOnes,\
    \ radix: 2)\n        let remainderAsBinaryIntWithTwos = Int(remainderAsBinaryStringWithTwos,\
    \ radix: 2)\n        let remainderAsBinaryStringWithThrees = String(remainderAsBinaryIntWithTwos,\
    \ radix: 2)\n        let remainderAsBinaryIntWithThrees = Int(remainderAsBinaryStringWithThrees,\
    \ radix: 2)\n        let remainderAsBinaryStringWithFours = String(remainderAsBinaryIntWithThrees,\
    \ radix: 2)\n        let remainderAsBinaryIntWithFours = Int(remainderAsBinaryStringWithFours,\
    \ radix: 2)\n        let remainderAsBinaryStringWithFives = String(remainderAsBinaryIntWithFours,\
    \ radix: 2)\n        let remainderAsBinaryIntWithFives = Int(remainderAsBinaryStringWithFives,\
    \ radix: 2)\n        let remainderAsBinaryStringWithSixes = String(remainderAsBinaryIntWithFives,\
    \ radix: 2)\n        let remainderAsBinaryIntWithSixes = Int(remainderAsBinaryStringWithSixes,\
    \ radix: 2)\n        let remainderAsBinaryStringWithSevens = String(remainderAsBinaryIntWithSixes,\
    \ radix: 2)\n        let remainderAsBinaryIntWithSevens = Int(remainderAsBinaryStringWithSevens,\
    \ radix: 2)\n        let remainderAsBinaryStringWithEights = String(remainderAsBinaryIntWithSevens,\
    \ radix: 2)\n        let remainderAsBinaryIntWithEights = Int(remainderAsBinaryStringWithEights,\
    \ radix: 2)\n        let remainderAsBinaryStringWithNines = String(remainderAsBinaryIntWithEights,\
    \ radix: 2)\n        let remainderAsBinaryIntWithNines = \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpbi81lf1q.swift:42:44: error: expected initial value after '='\n\
    \        let remainderAsBinaryIntWithNines = \n                              \
    \             ^\n/tmp/tmpbi81lf1q.swift:62:33: error: expected '}' at end of brace\
    \ statement\nassert(solve(N: 963) == \"10010\")\n                            \
    \    ^\n/tmp/tmpbi81lf1q.swift:15:30: note: to match this opening '{'\nfunc solve(N:\
    \ Int) -> String {\n                             ^\n/tmp/tmpbi81lf1q.swift:23:55:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        let remainderAsBinaryStringWithZeros = String(remainderAsBinaryInt, radix:\
    \ 2)\n                                                      ^\n/tmp/tmpbi81lf1q.swift:22:13:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n        let remainderAsBinaryInt = Int(remainderAsBinaryString,\
    \ radix: 2)\n            ^\n        guard                                    \
    \                         else { return <#default value#> }\n/tmp/tmpbi81lf1q.swift:22:36:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let remainderAsBinaryInt = Int(remainderAsBinaryString, radix:\
    \ 2)\n                                   ^\n                                 \
    \                                         ?? <#default value#>\n/tmp/tmpbi81lf1q.swift:22:36:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let remainderAsBinaryInt = Int(remainderAsBinaryString, radix:\
    \ 2)\n                                   ^\n                                 \
    \                                        !\n/tmp/tmpbi81lf1q.swift:23:55: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        let remainderAsBinaryStringWithZeros = String(remainderAsBinaryInt, radix:\
    \ 2)\n                                                      ^\n              \
    \                                                             ?? <#default value#>\n\
    /tmp/tmpbi81lf1q.swift:23:55: note: force-unwrap using '!' to abort"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    let remainder\
    \ = N % 2\n    let remainder2 = N % 4\n    let remainder4 = N % 8\n    let remainder8\
    \ = N % 16\n    let remainder16 = N % 32\n    let remainder32 = N % 64\n    let\
    \ remainder64 = N % 128\n    let remainder128 = N % 256\n    let remainder256\
    \ = N % 512\n    let remainder512 = N % 1024\n    let remainder1024 = N % 2048\n\
    \    let remainder2048 = N % 4096\n    let remainder4096 = N % 8192\n    let remainder8192\
    \ = N % 16384\n    let remainder16384 = N % 32768\n    let remainder32768 = N\
    \ % 65536\n    let remainder65536 = N % 131072\n    let remainder131072 = N %\
    \ 262144\n    let remainder262144 = N % 524288\n    let remainder524288 = N %\
    \ 1048576\n    let remainder1048576 = N % 2097152\n    let remainder2097152 =\
    \ N % 4194304\n    let remainder4194304 = N % 8388608\n    let remainder8388608\
    \ = N % 16777216\n    let remainder16777216 = N % 33554432\n    let remainder33554432\
    \ = N % 67108864\n    let remainder67108864 = N % 134217728\n    let remainder134217728\
    \ = N % 268435456\n    let remainder268435456 = N % 536870912\n    let remainder536870912\
    \ = N % 1073741824\n    let remainder1073741824 = N % 2147483648\n    let remainder2147483648\
    \ = N % 4294967296\n    let remainder4294967296 = N % 8589934592\n    let remainder8589934592\
    \ = N % 17179869184\n    let remainder17179869184 = N % 34359738368\n    let remainder34359738368\
    \ = N % 68719476736\n    let remainder68719476736 = N % 137438953472\n    let\
    \ remainder137438953472 = N % 274877906944\n    let remainder274877906944 = N\
    \ % 549755813888\n    let remainder549755813888 = N % 1099511627776\n    let remainder10995116\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp892scvbn.swift:57:9: error: type annotation missing in pattern\n\
    \    let remainder10995116\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    let remainder\
    \ = N % 2\n    let remainderString = String(remainder)\n    let remainderString\
    \ = String(remainderString.characters)\n    let remainderString = String(remainderString.dropLast())\n\
    \    let remainderString = String(remainderString.dropFirst())\n    let remainderString\
    \ = String(remainderString.dropLast())\n    let remainderString = String(remainderString.dropFirst())\n\
    \    let remainderString = String(remainderString.dropLast())\n    let remainderString\
    \ = String(remainderString.dropFirst())\n    let remainderString = String(remainderString.dropLast())\n\
    \    let remainderString = String(remainderString.dropFirst())\n    let remainderString\
    \ = String(remainderString.dropLast())\n    let remainderString = String(remainderString.dropFirst())\n\
    \    let remainderString = String(remainderString.dropLast())\n    let remainderString\
    \ = String(remainderString.dropFirst())\n    let remainderString = String(remainderString.dropLast())\n\
    \    let remainderString = String(remainderString.dropFirst())\n    let remainderString\
    \ = String(remainderString.dropLast())\n    let remainderString = String(remainderString.dropFirst())\n\
    \    let remainderString = String(remainderString.dropLast())\n    let remainderString\
    \ = String(remainderString.dropFirst())\n    let remainderString = String(remainderString.dropLast())\n\
    \    let remainderString = String(remainderString.dropFirst())\n    let remainderString\
    \ = String(remainderString.dropLast())\n    let remainderString = String(remainderString.dropFirst())\n\
    \    let remainderString = String(remainderString.dropLast())\n    let remainderString\
    \ = String(remainderString.dropFirst())\n    let remainderString = String(remainderString.dropLast())\n\
    \    let remainderString = String(remainderString.dropFirst())\n    let remainderString\
    \ = String(remainderString.dropLast())\n    let remainderString = String(remainderString.dropFirst())\n\
    \    let remainderString = String(remainderString.dropLast())\n    let remainderString\
    \ = String(remainderString.dropFirst())\n    let remainderString = String(remainderString.dropLast())\n\
    \    let remainderString = String(remainderString.dropFirst())\n    let remainderString\
    \ = String(remainderString.dropLast())\n    let remainderString = String(remainderString.dropFirst())\n\
    \    let remainderString = String(remainderString.dropLast())\n    let remainderString\
    \ = String(remainderString.dropFirst())\n    let remainderString = String(remainderString.dropLast())\n\
    \    let remainderString = String(remainderString.dropFirst())\n    let remainderString\
    \ = String(remainderString.dropLast())\n    let remainderString = String(remainderString.dropFirst())\n\
    \    let \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"\
    1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp2jx06hc1.swift:60:8: error: expected pattern\n    let \n      \
    \ ^\n/tmp/tmp2jx06hc1.swift:19:50: error: 'characters' is unavailable: Please\
    \ use String directly\n    let remainderString = String(remainderString.characters)\n\
    \                                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp2jx06hc1.swift:19:9: error: invalid redeclaration\
    \ of 'remainderString'\n    let remainderString = String(remainderString.characters)\n\
    \        ^\n/tmp/tmp2jx06hc1.swift:18:9: note: 'remainderString' previously declared\
    \ here\n    let remainderString = String(remainder)\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    for _ in 0..<N {\n        remainder = N % 2\n        result += String(remainder)\n\
    \        N = N / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmprrde74us.swift:21:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).reversed().map\
    \ { String($0) }\n    let sum: Int = digits.reduce(0) { (sum, digit) -> Int in\n\
    \        return sum + Int(digit)\n    }\n    return String(sum)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpa46b5c3p.swift:18:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        return sum + Int(digit)\n   \
    \                  ^\n/tmp/tmpa46b5c3p.swift:18:22: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        return\
    \ sum + Int(digit)\n                     ^\n                     (          ??\
    \ <#default value#>)\n/tmp/tmpa46b5c3p.swift:18:22: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        return sum\
    \ + Int(digit)\n                     ^\n                               !\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014030
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderInt = Int(remainderString)\n        remainder -= remainderInt\n\
    \        result = remainderString + result\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp4sk6q78b.swift:21:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        remainder -= remainderInt\n \
    \                    ^\n/tmp/tmp4sk6q78b.swift:20:13: note: short-circuit using\
    \ 'guard' to exit this function early if the optional value contains 'nil'\n \
    \       let remainderInt = Int(remainderString)\n            ^\n        guard\
    \                                   else { return <#default value#> }\n/tmp/tmp4sk6q78b.swift:20:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let remainderInt = Int(remainderString)\n                   \
    \        ^\n                                                ?? <#default value#>\n\
    /tmp/tmp4sk6q78b.swift:20:28: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let remainderInt = Int(remainderString)\n\
    \                           ^\n                                              \
    \ !\n/tmp/tmp4sk6q78b.swift:21:22: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        remainder -= remainderInt\n\
    \                     ^\n                                  ?? <#default value#>\n\
    /tmp/tmp4sk6q78b.swift:21:22: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        remainder -= remainderInt\n  \
    \                   ^\n                                 !\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    while remainderSum\
    \ > 0 {\n        result = String(remainderSum) + result\n        remainderSum\
    \ = remainderSum / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmponninzy2/tmponninzy2.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b683ff96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b683fc8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b683fc8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b683fc8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmponninzy2                        0x000055b1807f0493 <unavailable> + 5267

    5    libc.so.6                          0x00002b6840182460 __libc_start_main +
    245

    6    tmponninzy2                        0x000055b1807f00f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    for _ in\
    \ 0..<N {\n        let remainder = N % 2\n        result += String(remainder)\n\
    \        N = N / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpfrmr0ivu.swift:20:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    let binaryDigits = digits.map { String($0) }\n    let binarySum = binaryDigits.reduce(\"\
    \") { $0 + String($1) }\n    return binarySum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6gcd_kdk.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: -1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014030
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    remainderSum\
    \ = remainderSum * 2\n    while remainderSum > 0 {\n        result = String(remainderSum)\
    \ + result\n        remainderSum = remainderSum / 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmp8qt0jv4u/tmp8qt0jv4u.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2eb982c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2eb679b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2eb679988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2eb6787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8qt0jv4u                        0x0000560e1cf2f493 <unavailable> + 5267

    5    libc.so.6                          0x00002af2ebb6e460 __libc_start_main +
    245

    6    tmp8qt0jv4u                        0x0000560e1cf2f0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    let remainder\
    \ = N % 2\n    let remainderAsString = String(remainder)\n    let remainderAsStringAsArray\
    \ = remainderAsString.characters\n    let remainderAsStringAsArrayAsString = String(remainderAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArray = remainderAsStringAsArrayAsString.characters\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsString = String(remainderAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArray = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsString = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray\
    \ = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray\
    \ = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray\
    \ = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray\
    \ = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray\
    \ = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsString\
    \ = String(remainderAsStringAsArray\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp4gkdcxz7.swift:31:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp4gkdcxz7.swift:30:155: note: to match this opening '('\n    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArrayAsString\
    \ = String(remainderAsStringAsArray\n                                        \
    \                                                                            \
    \                                      ^\n/tmp/tmp4gkdcxz7.swift:19:54: error:\
    \ 'characters' is unavailable: Please use String directly\n    let remainderAsStringAsArray\
    \ = remainderAsString.characters\n                                           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp4gkdcxz7.swift:21:84: error: 'characters' is unavailable: Please use String\
    \ directly\n    let remainderAsStringAsArrayAsStringAsArray = remainderAsStringAsArrayAsString.characters\n\
    \                                                                            \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp4gkdcxz7.swift:23:73:\
    \ error: use of local variable 'remainderAsStringAsArrayAsStringAsArrayAsStringAsArray'\
    \ before its declaration\n    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArray\
    \ = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArray)\n         \
    \                                                               ^\n/tmp/tmp4gkdcxz7.swift:23:9:\
    \ note: 'remainderAsStringAsArrayAsStringAsArrayAsStringAsArray' declared here\n\
    \    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArray = String(remainderAsStringAsArrayAsStringAsArrayAsStringAsArray)\n\
    \        ^\n/tmp/tmp4gkdcxz7.swift:24:81: error: use of local variable 'remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsStringAsArray'\
    \ before its declaration\n    let remainderAsStringAsArrayAsStringAsArrayAsStringAsArrayAsString\
    \ = String("
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp6d5fff7x/tmp6d5fff7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc04413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc0410ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc0410a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc041097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6d5fff7x                        0x000055963ebe63c3 <unavailable> + 5059

    5    libc.so.6                          0x00002abc045ff460 __libc_start_main +
    245

    6    tmp6d5fff7x                        0x000055963ebe6029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var remainder2: Int = 0\n    var remainder3: Int = 0\n\
    \    var remainder4: Int = 0\n    var remainder5: Int = 0\n    var remainder6:\
    \ Int = 0\n    var remainder7: Int = 0\n    var remainder8: Int = 0\n    var remainder9:\
    \ Int = 0\n    var remainder10: Int = 0\n    var remainder11: Int = 0\n    var\
    \ remainder12: Int = 0\n    var remainder13: Int = 0\n    var remainder14: Int\
    \ = 0\n    var remainder15: Int = 0\n    var remainder16: Int = 0\n    var remainder17:\
    \ Int = 0\n    var remainder18: Int = 0\n    var remainder19: Int = 0\n    var\
    \ remainder20: Int = 0\n    var remainder21: Int = 0\n    var remainder22: Int\
    \ = 0\n    var remainder23: Int = 0\n    var remainder24: Int = 0\n    var remainder25:\
    \ Int = 0\n    var remainder26: Int = 0\n    var remainder27: Int = 0\n    var\
    \ remainder28: Int = 0\n    var remainder29: Int = 0\n    var remainder30: Int\
    \ = 0\n    var remainder31: Int = 0\n    var remainder32: Int = 0\n    var remainder33:\
    \ Int = 0\n    var remainder34: Int = 0\n    var remainder35: Int = 0\n    var\
    \ remainder36: Int = 0\n    var remainder37: Int = 0\n    var remainder38: Int\
    \ = 0\n    var remainder39: Int = 0\n    var remainder40: Int = 0\n    var remainder41:\
    \ Int = 0\n    var remainder42: Int = 0\n    var remainder43: Int = 0\n    var\
    \ remainder44: Int = 0\n    var remainder45: Int = 0\n    var remainder46: Int\
    \ = 0\n    var remainder47: Int = 0\n    var remainder48: Int = 0\n    var remainder49:\
    \ Int = 0\n    var remainder50: Int = 0\n    var remainder51: Int = 0\n    var\
    \ remainder52: Int = 0\n    var remainder53: Int = 0\n    var remainder54: Int\
    \ = 0\n    var remainder55: Int = 0\n    var remainder56: Int = 0\n    var remainder57:\
    \ Int = 0\n    var remainder58: Int = 0\n    var remainder59: Int = 0\n    var\
    \ remainder60: Int = 0\n    var remainder61: Int = 0\n    var remainder62: Int\
    \ = 0\n    var remainder63: Int = 0\n    var remainder64: Int = 0\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpi4uxy9ms.swift:16:9: warning: variable 'result' was never used;\
    \ consider replacing with '_' or removing it\n    var result: String = \"\"\n\
    \        ^~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:17:9: warning: variable 'remainder'\
    \ was never used; consider replacing with '_' or removing it\n    var remainder:\
    \ Int = 0\n        ^~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:18:9: warning:\
    \ variable 'remainder2' was never used; consider replacing with '_' or removing\
    \ it\n    var remainder2: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:19:9:\
    \ warning: variable 'remainder3' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder3: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:20:9:\
    \ warning: variable 'remainder4' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder4: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:21:9:\
    \ warning: variable 'remainder5' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder5: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:22:9:\
    \ warning: variable 'remainder6' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder6: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:23:9:\
    \ warning: variable 'remainder7' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder7: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:24:9:\
    \ warning: variable 'remainder8' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder8: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:25:9:\
    \ warning: variable 'remainder9' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder9: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:26:9:\
    \ warning: variable 'remainder10' was never used; consider replacing with '_'\
    \ or removing it\n    var remainder10: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpi4uxy9ms.swift:27:9: warning: variable 'remainder11' was never used; consider\
    \ replacing with '_' or removing it\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderStringLength = remainderString.count\n        let remainderStringArray\
    \ = remainderString.characters\n        let remainderStringArrayLength = remainderStringArray.count\n\
    \        let remainderStringArrayToInt = remainderStringArray\n            .map\
    \ { Int(String($0)) }\n            .filter { $0 != nil }\n            .map { $0!\
    \ }\n            .map { String($0) }\n            .map { String($0, radix: 2)\
    \ }\n            .map { String($0, radix: 10) }\n            .map { String($0,\
    \ radix: 2) }\n            .map { String($0, radix: 10) }\n            .map {\
    \ String($0, radix: 2) }\n            .map { String($0, radix: 10) }\n       \
    \     .map { String($0, radix: 2) }\n            .map { String($0, radix: 10)\
    \ }\n            .map { String($0, radix: 2) }\n            .map { String($0,\
    \ radix: 10) }\n            .map { String($0, radix: 2) }\n            .map {\
    \ String($0, radix: 10) }\n            .map { String($0, radix: 2) }\n       \
    \     .map { String($0, radix: 10) }\n            .map { String($0, radix: 2)\
    \ }\n            .map { String($0, radix: 10) }\n            .map { String($0,\
    \ radix: 2) }\n            .map { String($0, radix: 10) }\n            .map {\
    \ String($0, radix: 2) }\n            .map { String($0, radix: 10) }\n       \
    \     .map { String($0, radix: 2) }\n            .map { String($0, radix: 10)\
    \ }\n            .map { String($0, radix: 2) }\n            .map { String($0,\
    \ radix: 10) }\n            .map { String($0, radix: 2) }\n            .map {\
    \ String($0, radix: 10) }\n            .map { String($0, radix: 2) }\n       \
    \     .map { String($0, radix: 10) }\n            .map { String($0, radix: 2)\
    \ }\n            .map { String($0, radix: 10) }\n            .map { String($0,\
    \ radix: 2) }\n            .map { String($0, radix: 10) }\n            .map {\
    \ String($0, radix: 2) }\n            .map { String($0, radix: 10) }\n       \
    \     .map { String($0, radix: 2) }\n            .map { String($0, radix: 10)\
    \ }\n            .map { String($0, radix: 2) }\n            .\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpkmf7yv24.swift:65:14: error: expected member name following '.'\n\
    \            .\n             ^\n/tmp/tmpkmf7yv24.swift:85:33: error: expected\
    \ '}' at end of brace statement\nassert(solve(N: 963) == \"10010\")\n        \
    \                        ^\n/tmp/tmpkmf7yv24.swift:15:30: note: to match this\
    \ opening '{'\nfunc solve(N: Int) -> String {\n                             ^\n\
    /tmp/tmpkmf7yv24.swift:21:52: error: 'characters' is unavailable: Please use String\
    \ directly\n        let remainderStringArray = remainderString.characters\n  \
    \                                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpkmf7yv24.swift:69:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder = remainder % 2\n    }\n    remainderSum +=\
    \ remainder\n    for _ in 0..<remainderSum {\n        result += \"1\"\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpp610h64n/tmpp610h64n.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6620ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f65f05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f65f05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f65f047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp610h64n                        0x000055c5df8024c3 <unavailable> + 5315

    5    libc.so.6                          0x00002b8f663fa460 __libc_start_main +
    245

    6    tmpp610h64n                        0x000055c5df802129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    for _ in 0..<N {\n        remainder = N % 2\n        result += String(remainder)\n\
    \        N = N / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmprrde74us.swift:21:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N < 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    var remainderDigit\
    \ = 0\n    while remainder > 0 {\n        remainderDigit = remainder % 2\n   \
    \     remainder = remainder / 2\n        result = String(remainderDigit) + result\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpvl_ln1u7/tmpvl_ln1u7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b909570cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9095403b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9095403988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90954027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvl_ln1u7                        0x000055b3c023c493 <unavailable> + 5267

    5    libc.so.6                          0x00002b90958f8460 __libc_start_main +
    245

    6    tmpvl_ln1u7                        0x000055b3c023c0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder = remainder % 2\n        result\
    \ = String(remainder) + result\n        remainder = Int(remainder) / 2\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmpd74ik04_/tmpd74ik04_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aded1253c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aded0f4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aded0f4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aded0f497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd74ik04_                        0x000055976c6b25c3 <unavailable> + 5571

    5    libc.so.6                          0x00002aded143f460 __libc_start_main +
    245

    6    tmpd74ik04_                        0x000055976c6b2229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = \"\"\n    for i in 0..<digits.count {\n        let digit = digits[i]\n\
    \        sum += digit\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpg0xuwbbt.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpg0xuwbbt.swift:19:21: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        let digit = digits[i]\n\
    \                    ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpg0xuwbbt.swift:20:16: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n        sum += digit\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N == 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    var digit = 1\n   \
    \ while remainder > 0 {\n        remainder /= 10\n        digit *= 2\n    }\n\
    \    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        if remainderString.isEmpty {\n            remainderString = \"0\"\n \
    \       }\n        result += String(digit) + remainderString\n        digit /=\
    \ 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmportxep1r.swift:29:13: error: cannot assign to value: 'remainderString'\
    \ is a 'let' constant\n            remainderString = \"0\"\n            ^~~~~~~~~~~~~~~\n\
    /tmp/tmportxep1r.swift:27:9: note: change 'let' to 'var' to make it mutable\n\
    \        let remainderString = String(remainder)\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder -= 10\n        result += \"\
    1\"\n    }\n    while remainder > 0 {\n        remainder -= 10\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpj0dslzxo.swift:20:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result += \"1\"\n        ~~~~~~\
    \ ^\n/tmp/tmpj0dslzxo.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = \"\"\n    ^~~\n    var\n/tmp/tmpj0dslzxo.swift:24:16: error:\
    \ left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \        result += \"0\"\n        ~~~~~~ ^\n/tmp/tmpj0dslzxo.swift:16:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = \"\"\n    for digit in digits {\n        sum += digit\n    }\n\
    \    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpopibkf2o.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpopibkf2o.swift:19:16: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        sum += digit\n               ^\n"
  stdout: ''
  timestamp: 1660014026
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = 0\n    var result: String\
    \ = \"\"\n    var remainder: Int\n    for _ in 0..<N {\n        remainder = N\
    \ % 2\n        sum += remainder\n        N = N / 2\n    }\n    if sum > 0 {\n\
    \        result = \"1\"\n    }\n    for _ in 0..<sum {\n        result = \"0\"\
    \ + result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpakbaji5e.swift:22:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var remainderSum = 0\n    var remainderSumString = \"\"\n    var remainderSumStringString\
    \ = \"\"\n    var remainderSumStringStringString = \"\"\n    var remainderSumStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringString = \"\"\n    var remainderSumStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringString = \"\"\
    \n    var remainderSumStringStringStringStringStringStringStringString = \"\"\n\
    \    var remainderSumStringStringStringStringStringStringStringStringString =\
    \ \"\"\n    var remainderSumStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n    var remainderSumString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpvm1_k5s5.swift:28:9: error: invalid redeclaration of 'remainderSumStringStringStringStringStringStringStringStringString'\n\
    \    var remainderSumStringStringStringStringStringStringStringStringString =\
    \ \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:27:9: note: 'remainderSumStringStringStringStringStringStringStringStringString'\
    \ previously declared here\n    var remainderSumStringStringStringStringStringStringStringStringString\
    \ = \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:31:9: error: invalid redeclaration\
    \ of 'remainderSumStringStringStringStringStringStringStringStringStringStringString'\n\
    \    var remainderSumStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:30:9: note: 'remainderSumStringStringStringStringStringStringStringStringStringStringString'\
    \ previously declared here\n    var remainderSumStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:34:9: error: invalid redeclaration\
    \ of 'remainderSumStringStringStringStringStringStringStringStringStringStringStringStringString'\n\
    \    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:33:9: note: 'remainderSumStringStringStringStringStringStringStringStringStringStringStringStringString'\
    \ previously declared here\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:36:9: error: invalid redeclaration\
    \ of 'remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringString'\n\
    \    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:35:9: note: 'remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringString'\
    \ previously declared here\n    var remainderSumStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = \"\"\n        ^\n/tmp/tmpvm1_k5s5.swift:39:9:"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderInt = Int(remainderString)\n        result = remainderString\
    \ + result\n        remainder = remainderInt % 10\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpat043ujd.swift:22:21: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        remainder = remainderInt % 10\n\
    \                    ^\n/tmp/tmpat043ujd.swift:22:21: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        remainder\
    \ = remainderInt % 10\n                    ^\n                    (          \
    \  ?? <#default value#>)\n/tmp/tmpat043ujd.swift:22:21: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        remainder\
    \ = remainderInt % 10\n                    ^\n                               \
    \ !\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    if remainderSum\
    \ > 0 {\n        remainderSum += 1\n    }\n    for _ in 0..<remainderSum {\n \
    \       result = \"1\" + result\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmp664ywirl/tmp664ywirl.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba3d159c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba3ce50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba3ce50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba3ce4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp664ywirl                        0x000055a7ed81f4c3 <unavailable> + 5315

    5    libc.so.6                          0x00002aba3d345460 __libc_start_main +
    245

    6    tmp664ywirl                        0x000055a7ed81f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var sum: Int = 0\n    var power: Int = 0\n    var digit:\
    \ Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var\
    \ temp: Int = 0\n    var temp2: Int = 0\n    var temp3: Int = 0\n    var temp4:\
    \ Int = 0\n    var temp5: Int = 0\n    var temp6: Int = 0\n    var temp7: Int\
    \ = 0\n    var temp8: Int = 0\n    var temp9: Int = 0\n    var temp10: Int = 0\n\
    \    var temp11: Int = 0\n    var temp12: Int = 0\n    var temp13: Int = 0\n \
    \   var temp14: Int = 0\n    var temp15: Int = 0\n    var temp16: Int = 0\n  \
    \  var temp17: Int = 0\n    var temp18: Int = 0\n    var temp19: Int = 0\n   \
    \ var temp20: Int = 0\n    var temp21: Int = 0\n    var temp22: Int = 0\n    var\
    \ temp23: Int = 0\n    var temp24: Int = 0\n    var temp25: Int = 0\n    var temp26:\
    \ Int = 0\n    var temp27: Int = 0\n    var temp28: Int = 0\n    var temp29: Int\
    \ = 0\n    var temp30: Int = 0\n    var temp31: Int = 0\n    var temp32: Int =\
    \ 0\n    var temp33: Int = 0\n    var temp34: Int = 0\n    var temp35: Int = 0\n\
    \    var temp36: Int = 0\n    var temp37: Int = 0\n    var temp38: Int = 0\n \
    \   var temp39: Int = 0\n    var temp40: Int = 0\n    var temp41: Int = 0\n  \
    \  var temp42: Int = 0\n    var temp43: Int = 0\n    var temp44: Int = 0\n   \
    \ var temp45: Int = 0\n    var temp46: Int = 0\n    var temp47: Int = 0\n    var\
    \ temp48: Int = 0\n    var temp49: Int = 0\n    var temp50: Int = 0\n    var temp51:\
    \ Int = 0\n    var temp52: Int = 0\n    var temp53: Int = 0\n    var temp54: Int\
    \ = 0\n    var temp55: Int = 0\n    var temp56: Int = 0\n    var temp57: Int =\
    \ 0\n    var temp58: Int = 0\n    var temp59: Int = 0\n    var temp60: Int = 0\n\
    \    var temp61: Int = 0\n    var temp62: Int = 0\n    var temp63: Int = 0\n \
    \   var temp64: Int = 0\n    var temp65: Int = 0\n    var temp66: Int = 0\n  \
    \  var temp67: Int = 0\n    var temp\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpqp37u4xw.swift:91:9: error: type annotation missing in pattern\n\
    \    var temp\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = \"\"\n    for _ in 0..<N\
    \ {\n        sum += String(Int(N % 2)) + \"0\"\n        N = N / 2\n    }\n   \
    \ return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpq63x0ffj.swift:19:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var sum: Int = 0\n    var remainderSum: Int = 0\n  \
    \  var remainderSum2: Int = 0\n    var remainderSum3: Int = 0\n    var remainderSum4:\
    \ Int = 0\n    var remainderSum5: Int = 0\n    var remainderSum6: Int = 0\n  \
    \  var remainderSum7: Int = 0\n    var remainderSum8: Int = 0\n    var remainderSum9:\
    \ Int = 0\n    var remainderSum10: Int = 0\n    var remainderSum11: Int = 0\n\
    \    var remainderSum12: Int = 0\n    var remainderSum13: Int = 0\n    var remainderSum14:\
    \ Int = 0\n    var remainderSum15: Int = 0\n    var remainderSum16: Int = 0\n\
    \    var remainderSum17: Int = 0\n    var remainderSum18: Int = 0\n    var remainderSum19:\
    \ Int = 0\n    var remainderSum20: Int = 0\n    var remainderSum21: Int = 0\n\
    \    var remainderSum22: Int = 0\n    var remainderSum23: Int = 0\n    var remainderSum24:\
    \ Int = 0\n    var remainderSum25: Int = 0\n    var remainderSum26: Int = 0\n\
    \    var remainderSum27: Int = 0\n    var remainderSum28: Int = 0\n    var remainderSum29:\
    \ Int = 0\n    var remainderSum30: Int = 0\n    var remainderSum31: Int = 0\n\
    \    var remainderSum32: Int = 0\n    var remainderSum33: Int = 0\n    var remainderSum34:\
    \ Int = 0\n    var remainderSum35: Int = 0\n    var remainderSum36: Int = 0\n\
    \    var remainderSum37: Int = 0\n    var remainderSum38: Int = 0\n    var remainderSum39:\
    \ Int = 0\n    var remainderSum40: Int = 0\n    var remainderSum41: Int = 0\n\
    \    var remainderSum42: Int = 0\n    var remainderSum43: Int = 0\n    var remainderSum44:\
    \ Int = 0\n    var remainderSum45: Int = 0\n    var remainderSum46: Int = 0\n\
    \    var remainderSum47: Int = 0\n    var remainderSum48: Int = 0\n    var remainderSum49:\
    \ Int = 0\n    var remainderSum50: Int = 0\n    var remainderSum51: Int = 0\n\
    \    var remainderSum52: Int = 0\n    var remainderSum53: Int = 0\n    var remainderSum54:\
    \ Int = 0\n    var remainderSum55: Int = 0\n    var remainderSum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpq41wb2dn.swift:74:9: error: type annotation missing in pattern\n\
    \    var remainderSum\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderStringLength = remainderString.count\n        let remainderStringArray\
    \ = remainderString.characters\n        let remainderStringArrayLength = remainderStringArray.count\n\
    \        let remainderStringArrayLength = remainderStringArray.length\n      \
    \  let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n        let remainderStringArrayLength = remainderStringArray.length\n\
    \        let remainderStringArray = remainderString.characters\n        let remainderStringArrayLength\
    \ = remainderStringArray.count\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpymvb_c43.swift:82:33: error: expected '}' at end of brace statement\n\
    assert(solve(N: 963) == \"10010\")\n                                ^\n/tmp/tmpymvb_c43.swift:15:30:\
    \ note: to match this opening '{'\nfunc solve(N: Int) -> String {\n          \
    \                   ^\n/tmp/tmpymvb_c43.swift:21:52: error: 'characters' is unavailable:\
    \ Please use String directly\n        let remainderStringArray = remainderString.characters\n\
    \                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpymvb_c43.swift:23:63: error: value of\
    \ type 'String' has no member 'length'\n        let remainderStringArrayLength\
    \ = remainderStringArray.length\n                                         ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpymvb_c43.swift:24:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        let remainderStringArray = remainderString.characters\n\
    \                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpymvb_c43.swift:24:13: error: invalid\
    \ redeclaration of 'remainderStringArray'\n        let remainderStringArray =\
    \ remainderString.characters\n            ^\n/tmp/tmpymvb_c43.swift:21:13: note:\
    \ 'remainderStringArray' previously declared here\n        let remainderStringArray\
    \ = remainderString.characters\n            ^\n/tmp/tmpymvb_c43.swift:27:52: error:\
    \ 'characters' is unavailable: Please use String directly\n        let remainderStringArray\
    \ = remainderString.characters\n                                             \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpymvb_c43.swift:27:13:\
    \ error: invalid redeclaration of 'remainderStringArray'\n        let remainderStringArray\
    \ = remainderString.characters\n            ^\n/tmp/tmpymvb_c43.swift:21:13: note:\
    \ 'remain"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var remainder2: Int = 0\n    var remainder3: Int = 0\n\
    \    var remainder4: Int = 0\n    var remainder5: Int = 0\n    var remainder6:\
    \ Int = 0\n    var remainder7: Int = 0\n    var remainder8: Int = 0\n    var remainder9:\
    \ Int = 0\n    var remainder10: Int = 0\n    var remainder11: Int = 0\n    var\
    \ remainder12: Int = 0\n    var remainder13: Int = 0\n    var remainder14: Int\
    \ = 0\n    var remainder15: Int = 0\n    var remainder16: Int = 0\n    var remainder17:\
    \ Int = 0\n    var remainder18: Int = 0\n    var remainder19: Int = 0\n    var\
    \ remainder20: Int = 0\n    var remainder21: Int = 0\n    var remainder22: Int\
    \ = 0\n    var remainder23: Int = 0\n    var remainder24: Int = 0\n    var remainder25:\
    \ Int = 0\n    var remainder26: Int = 0\n    var remainder27: Int = 0\n    var\
    \ remainder28: Int = 0\n    var remainder29: Int = 0\n    var remainder30: Int\
    \ = 0\n    var remainder31: Int = 0\n    var remainder32: Int = 0\n    var remainder33:\
    \ Int = 0\n    var remainder34: Int = 0\n    var remainder35: Int = 0\n    var\
    \ remainder36: Int = 0\n    var remainder37: Int = 0\n    var remainder38: Int\
    \ = 0\n    var remainder39: Int = 0\n    var remainder40: Int = 0\n    var remainder41:\
    \ Int = 0\n    var remainder42: Int = 0\n    var remainder43: Int = 0\n    var\
    \ remainder44: Int = 0\n    var remainder45: Int = 0\n    var remainder46: Int\
    \ = 0\n    var remainder47: Int = 0\n    var remainder48: Int = 0\n    var remainder49:\
    \ Int = 0\n    var remainder50: Int = 0\n    var remainder51: Int = 0\n    var\
    \ remainder52: Int = 0\n    var remainder53: Int = 0\n    var remainder54: Int\
    \ = 0\n    var remainder55: Int = 0\n    var remainder56: Int = 0\n    var remainder57:\
    \ Int = 0\n    var remainder58: Int = 0\n    var remainder59: Int = 0\n    var\
    \ remainder60: Int = 0\n    var remainder61: Int = 0\n    var remainder62: Int\
    \ = 0\n    var remainder63: Int = 0\n    var remainder64: Int = 0\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpi4uxy9ms.swift:16:9: warning: variable 'result' was never used;\
    \ consider replacing with '_' or removing it\n    var result: String = \"\"\n\
    \        ^~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:17:9: warning: variable 'remainder'\
    \ was never used; consider replacing with '_' or removing it\n    var remainder:\
    \ Int = 0\n        ^~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:18:9: warning:\
    \ variable 'remainder2' was never used; consider replacing with '_' or removing\
    \ it\n    var remainder2: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:19:9:\
    \ warning: variable 'remainder3' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder3: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:20:9:\
    \ warning: variable 'remainder4' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder4: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:21:9:\
    \ warning: variable 'remainder5' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder5: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:22:9:\
    \ warning: variable 'remainder6' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder6: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:23:9:\
    \ warning: variable 'remainder7' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder7: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:24:9:\
    \ warning: variable 'remainder8' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder8: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:25:9:\
    \ warning: variable 'remainder9' was never used; consider replacing with '_' or\
    \ removing it\n    var remainder9: Int = 0\n        ^~~~~~~~~~\n        _\n/tmp/tmpi4uxy9ms.swift:26:9:\
    \ warning: variable 'remainder10' was never used; consider replacing with '_'\
    \ or removing it\n    var remainder10: Int = 0\n        ^~~~~~~~~~~\n        _\n\
    /tmp/tmpi4uxy9ms.swift:27:9: warning: variable 'remainder11' was never used; consider\
    \ replacing with '_' or removing it\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = 0\n    var remainderSum = 0\n    var remainderSumDigit = 0\n    var remainderSumDigit2\
    \ = 0\n    var remainderSumDigit3 = 0\n    var remainderSumDigit4 = 0\n    var\
    \ remainderSumDigit5 = 0\n    var remainderSumDigit6 = 0\n    var remainderSumDigit7\
    \ = 0\n    var remainderSumDigit8 = 0\n    var remainderSumDigit9 = 0\n    var\
    \ remainderSumDigit10 = 0\n    var remainderSumDigit11 = 0\n    var remainderSumDigit12\
    \ = 0\n    var remainderSumDigit13 = 0\n    var remainderSumDigit14 = 0\n    var\
    \ remainderSumDigit15 = 0\n    var remainderSumDigit16 = 0\n    var remainderSumDigit17\
    \ = 0\n    var remainderSumDigit18 = 0\n    var remainderSumDigit19 = 0\n    var\
    \ remainderSumDigit20 = 0\n    var remainderSumDigit21 = 0\n    var remainderSumDigit22\
    \ = 0\n    var remainderSumDigit23 = 0\n    var remainderSumDigit24 = 0\n    var\
    \ remainderSumDigit25 = 0\n    var remainderSumDigit26 = 0\n    var remainderSumDigit27\
    \ = 0\n    var remainderSumDigit28 = 0\n    var remainderSumDigit29 = 0\n    var\
    \ remainderSumDigit30 = 0\n    var remainderSumDigit31 = 0\n    var remainderSumDigit32\
    \ = 0\n    var remainderSumDigit33 = 0\n    var remainderSumDigit34 = 0\n    var\
    \ remainderSumDigit35 = 0\n    var remainderSumDigit36 = 0\n    var remainderSumDigit37\
    \ = 0\n    var remainderSumDigit38 = 0\n    var remainderSumDigit39 = 0\n    var\
    \ remainderSumDigit40 = 0\n    var remainderSumDigit41 = 0\n    var remainderSumDigit42\
    \ = 0\n    var remainderSumDigit43 = 0\n    var remainderSumDigit44 = 0\n    var\
    \ remainderSumDigit45 = 0\n    var remainderSumDigit46 = 0\n    var remainderSumDigit47\
    \ = 0\n    var remainderSumDigit48 = 0\n    var remainderSumDigit49 = 0\n    var\
    \ remainderSumDigit50 = 0\n    var remainderSumDigit51 = 0\n    var remainderSumDigit52\
    \ = 0\n    var remainderSumDigit53 = 0\n    var remainderSumDigit54 = 0\n    var\
    \ remainderSumDigit55 = 0\n    var remainderSumDigit56 = 0\n    var remainderSumDigit57\
    \ = 0\n    var remainderSumDigit58 = 0\n    var remainderSumDigit59 = 0\n    var\
    \ remainderSumDigit60 = 0\n    var remainderSumDigit61 = 0\n    var remainderSumDigit62\
    \ = 0\n    var remain\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpn29lp_v_.swift:81:9: error: type annotation missing in pattern\n\
    \    var remain\n        ^\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, digits: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmppdcka1n3.swift:16:32: error: extra argument 'digits' in call\n\
    \    return solve(N: N, digits: 0)\n                ~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters.map\
    \ { Int(String($0)) }\n    let sum = digits.reduce(0) { $0 + $1 }\n    let result\
    \ = String(sum)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp31sd9gdw.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters.map { Int(String($0))\
    \ }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp31sd9gdw.swift:17:39: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n    let sum = digits.reduce(0)\
    \ { $0 + $1 }\n                                      ^\n/tmp/tmp31sd9gdw.swift:17:39:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let sum = digits.reduce(0) { $0 + $1 }\n                        \
    \              ^\n                                      (  ?? <#default value#>)\n\
    /tmp/tmp31sd9gdw.swift:17:39: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    let sum = digits.reduce(0) { $0 +\
    \ $1 }\n                                      ^\n                            \
    \            !\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    while remainderSum\
    \ > 0 {\n        result = String(remainderSum) + result\n        remainderSum\
    \ = remainderSum / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmponninzy2/tmponninzy2.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b683ff96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b683fc8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b683fc8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b683fc8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmponninzy2                        0x000055b1807f0493 <unavailable> + 5267

    5    libc.so.6                          0x00002b6840182460 __libc_start_main +
    245

    6    tmponninzy2                        0x000055b1807f00f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    for _ in\
    \ 0..<N {\n        let remainder = N % 2\n        result += String(remainder)\n\
    \        N = N / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpfrmr0ivu.swift:20:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderAsString = String(remainder)\n\
    \        let remainderAsInt = Int(remainder)\n        let remainderAsBinaryString\
    \ = String(remainderAsInt, radix: 2)\n        result += remainderAsBinaryString\n\
    \        remainder = remainder - remainderAsInt\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmplm_uu9h4/tmplm_uu9h4.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b646cfabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b646cca2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b646cca2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b646cca17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplm_uu9h4                        0x0000560cf8de35a3 <unavailable> + 5539

    5    libc.so.6                          0x00002b646d197460 __libc_start_main +
    245

    6    tmplm_uu9h4                        0x0000560cf8de3209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder % 2\n        remainder = remainder / 2\n    }\n    if remainderSum\
    \ == 0 {\n        remainderSum = 1\n    }\n    for _ in 0..<remainderSum {\n \
    \       result += \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpwu26022_/tmpwu26022_.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2314fa0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2314c97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2314c97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2314c967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwu26022_                        0x0000564ea71d64c3 <unavailable> + 5315

    5    libc.so.6                          0x00002b231518c460 __libc_start_main +
    245

    6    tmpwu26022_                        0x0000564ea71d6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderInt = Int(remainderString)\n        result += remainderString\n\
    \        remainder -= remainderInt\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp1uxm8sks.swift:22:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        remainder -= remainderInt\n \
    \                    ^\n/tmp/tmp1uxm8sks.swift:20:13: note: short-circuit using\
    \ 'guard' to exit this function early if the optional value contains 'nil'\n \
    \       let remainderInt = Int(remainderString)\n            ^\n        guard\
    \                                   else { return <#default value#> }\n/tmp/tmp1uxm8sks.swift:20:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let remainderInt = Int(remainderString)\n                   \
    \        ^\n                                                ?? <#default value#>\n\
    /tmp/tmp1uxm8sks.swift:20:28: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let remainderInt = Int(remainderString)\n\
    \                           ^\n                                              \
    \ !\n/tmp/tmp1uxm8sks.swift:22:22: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        remainder -= remainderInt\n\
    \                     ^\n                                  ?? <#default value#>\n\
    /tmp/tmp1uxm8sks.swift:22:22: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        remainder -= remainderInt\n  \
    \                   ^\n                                 !\n"
  stdout: ''
  timestamp: 1660014530
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder % 2,\
    \ remainder / 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmplsae1mbp.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder % 2, remainder\
    \ / 2\n                 ^\n                 ;\n/tmp/tmplsae1mbp.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder % 2, remainder\
    \ / 2\n                 ^\n/tmp/tmplsae1mbp.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder % 2, remainder / 2\n        ^~~~~~~~~\n\
    /tmp/tmplsae1mbp.swift:17:9: warning: variable 'remainder' was never mutated;\
    \ consider changing to 'let' constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var sum =\
    \ 0\n    for _ in 0..<N {\n        sum += N % 2\n        N = N / 2\n    }\n  \
    \  sum += N\n    for _ in 0..<sum {\n        result += \"1\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"\
    1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N:\
    \ 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpyc5pfe6c.swift:20:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n/tmp/tmpyc5pfe6c.swift:24:16: error:\
    \ left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \        result += \"1\"\n        ~~~~~~ ^\n/tmp/tmpyc5pfe6c.swift:16:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = 0\n    var current = 0\n    var sum = 0\n    for _ in 0..<N {\n        remainder\
    \ = N % 10\n        current = N / 10\n        sum += Int(current) * remainder\n\
    \        N = current\n    }\n    result += String(sum)\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmptdzjcz2y.swift:24:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = current\n        ^\n/tmp/tmptdzjcz2y.swift:26:12: error:\
    \ left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \    result += String(sum)\n    ~~~~~~ ^\n/tmp/tmptdzjcz2y.swift:16:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder /= 2\n    }\n    while remainderSum != 0 {\n\
    \        result = String(remainderSum) + result\n        remainderSum /= 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: 'tmp3mqd3dxu/tmp3mqd3dxu.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06554dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06551d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06551d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06551d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3mqd3dxu                        0x0000561beae7c493 <unavailable> + 5267

    5    libc.so.6                          0x00002b06556c7460 __libc_start_main +
    245

    6    tmp3mqd3dxu                        0x0000561beae7c0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderDigit = 0\n    while remainder > 0 {\n        remainderDigit\
    \ = remainder % 2\n        remainder = remainder / 2\n        result = String(remainderDigit)\
    \ + result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmph9doz0me/tmph9doz0me.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2238756c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b223844db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b223844d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b223844c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph9doz0me                        0x000055bfb11d4493 <unavailable> + 5267

    5    libc.so.6                          0x00002b2238942460 __libc_start_main +
    245

    6    tmph9doz0me                        0x000055bfb11d40f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014026
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    if N < 0 {\n        return \"0\"\
    \n    }\n    var result = \"\"\n    var remainder = N\n    var remainderSum =\
    \ 0\n    while remainder > 0 {\n        remainderSum += remainder\n        remainder--\n\
    \    }\n    while remainderSum >= 2 {\n        result = \"1\" + result\n     \
    \   remainderSum -= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpv5zfcvzx.swift:24:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n        remainder--\n                 ^~\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return String(solve(N: N))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014030
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder *= 2\n    }\n    while remainderSum > 0 {\n\
    \        result += String(remainderSum % 2)\n        remainderSum /= 2\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = \"\"\n    for _ in 0..<N\
    \ {\n        sum += String(N % 2)\n        N = N / 2\n    }\n    return sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpiom3u1le.swift:19:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    remainder = N\n    while remainder > 0 {\n        remainder /=\
    \ 2\n        result += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpgv2dqc8b/tmpgv2dqc8b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4f493ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4f4631b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4f4631988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4f46307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgv2dqc8b                        0x0000560772e0d3c3 <unavailable> + 5059

    5    libc.so.6                          0x00002af4f4b26460 __libc_start_main +
    245

    6    tmpgv2dqc8b                        0x0000560772e0d029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp6d5fff7x/tmp6d5fff7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc04413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc0410ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc0410a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc041097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6d5fff7x                        0x000055963ebe63c3 <unavailable> + 5059

    5    libc.so.6                          0x00002abc045ff460 __libc_start_main +
    245

    6    tmp6d5fff7x                        0x000055963ebe6029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderString = String(remainder)\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reversed()\n        let remainderString\
    \ = remainderString.reversed()\n        let remainderString = remainderString.reversed()\n\
    \        let remainderString = remainderString.reverse\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp2xhzanv_.swift:88:33: error: expected '}' at end of brace statement\n\
    assert(solve(N: 963) == \"10010\")\n                                ^\n/tmp/tmp2xhzanv_.swift:15:30:\
    \ note: to match this opening '{'\nfunc solve(N: Int) -> String {\n          \
    \                   ^\n/tmp/tmp2xhzanv_.swift:20:13: error: invalid redeclaration\
    \ of 'remainderString'\n        let remainderString = remainderString.reversed()\n\
    \            ^\n/tmp/tmp2xhzanv_.swift:19:13: note: 'remainderString' previously\
    \ declared here\n        let remainderString = String(remainder)\n           \
    \ ^\n/tmp/tmp2xhzanv_.swift:72:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder = remainder / 2\n    }\n    while remainderSum\
    \ > 0 {\n        result = String(remainderSum) + result\n        remainderSum\
    \ = remainderSum / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmpff7wwc1s/tmpff7wwc1s.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b1d120c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b1ce17b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8b1ce17988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8b1ce167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpff7wwc1s                        0x0000564440511493 <unavailable> + 5267

    5    libc.so.6                          0x00002b8b1d30c460 __libc_start_main +
    245

    6    tmpff7wwc1s                        0x00005644405110f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ remainder: Int = 0\n    var power: Int = 0\n    var sum: Int = 0\n    var digit:\
    \ Int = 0\n    var binary: String = String()\n    \n    while N > 0 {\n      \
    \  remainder = N % 2\n        N = N / 2\n        power = 1\n        \n       \
    \ while N > 0 {\n            digit = N % 10\n            sum = sum * 10 + digit\n\
    \            N = N / 10\n            power = power * 10\n        }\n        \n\
    \        binary = String(sum) + String(remainder)\n        \n        if power\
    \ > 0 {\n            binary = String(power) + String(binary)\n        }\n    \
    \    \n        result = String(sum) + String(remainder) + String(binary)\n   \
    \ }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp3isjvem6.swift:25:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n/tmp/tmp3isjvem6.swift:31:13: error:\
    \ cannot assign to value: 'N' is a 'let' constant\n            N = N / 10\n  \
    \          ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder /= 2\n        result += \"\
    1\"\n    }\n    while remainder > 1 {\n        remainder /= 2\n        result\
    \ += \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: Exception
  stderr: 'tmp6d5fff7x/tmp6d5fff7x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc04413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc0410ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc0410a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc041097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6d5fff7x                        0x000055963ebe63c3 <unavailable> + 5059

    5    libc.so.6                          0x00002abc045ff460 __libc_start_main +
    245

    6    tmp6d5fff7x                        0x000055963ebe6029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = 0\n    for digit in digits {\n        sum += Int(digit)\n    }\n\
    \    return String(sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpeunwajgj.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpeunwajgj.swift:19:16: error: no exact matches in call to initializer \n\
    \        sum += Int(digit)\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder -= 1\n        result += \"\
    1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N:\
    \ 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"\
    1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpidgk6ri4.swift:20:16: error: left side of mutating operator isn't\
    \ mutable: 'result' is a 'let' constant\n        result += \"1\"\n        ~~~~~~\
    \ ^\n/tmp/tmpidgk6ri4.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = 0\n    for digit in digits {\n        sum += Int(digit)\n    }\n\
    \    return String(sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpeunwajgj.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpeunwajgj.swift:19:16: error: no exact matches in call to initializer \n\
    \        sum += Int(digit)\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters.map({\
    \ Int(String($0)) })\n    var sum = 0\n    for digit in digits {\n        sum\
    \ += digit\n    }\n    return String(sum)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpjoh9a655.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters.map({ Int(String($0))\
    \ })\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjoh9a655.swift:19:16: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n        sum += digit\n  \
    \             ^\n/tmp/tmpjoh9a655.swift:19:16: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        sum += digit\n   \
    \            ^\n                     ?? <#default value#>\n/tmp/tmpjoh9a655.swift:19:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        sum += digit\n               ^\n                    !\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder--\n    }\n    while remainderSum > 0 {\n   \
    \     result = String(remainderSum) + result\n        remainderSum--\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) ==\
    \ \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\n\
    assert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpac9etbxx.swift:21:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n        remainder--\n                 ^~\n/tmp/tmpac9etbxx.swift:25:21:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        remainderSum--\n\
    \                    ^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: -4
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    var remainderSum = 0\n    while remainder > 0 {\n        remainderSum\
    \ += remainder\n        remainder = remainder % 2\n    }\n    if remainderSum\
    \ == 0 {\n        remainderSum = 1\n    }\n    for _ in 0..<remainderSum {\n \
    \       result += \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\"\
    )\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N:\
    \ 963) == \"10010\")"
  status: Exception
  stderr: 'tmpfyk74xlr/tmpfyk74xlr.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7619d86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7619a7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7619a7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7619a7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfyk74xlr                        0x000055cdf48c24c3 <unavailable> + 5315

    5    libc.so.6                          0x00002b7619f72460 __libc_start_main +
    245

    6    tmpfyk74xlr                        0x000055cdf48c2129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = 0\n    var result: String\
    \ = \"\"\n    var remainder: Int = 0\n    for _ in 0..<N {\n        remainder\
    \ = N % 2\n        sum += remainder\n        N = N / 2\n    }\n    if N > 0 {\n\
    \        remainder = N % 2\n        sum += remainder\n    }\n    if sum > 0 {\n\
    \        result = \"1\"\n    }\n    if sum < 0 {\n        result = \"0\"\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp86w61ogc.swift:22:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let digits = String(N).characters\n\
    \    var sum = 0\n    for digit in digits {\n        sum += Int(digit)\n    }\n\
    \    return String(sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpeunwajgj.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let digits = String(N).characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpeunwajgj.swift:19:16: error: no exact matches in call to initializer \n\
    \        sum += Int(digit)\n               ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Double)\n           ^\nSwift.Int:14:12: note: candidate expects value of type\
    \ 'Float80' for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n\
    \           ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Character')\n    public init(_ _v: Builtin.Word)\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    let result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        let remainderDigit = remainder % 2\n\
    \        remainder = remainder / 2\n        result = String(remainderDigit) +\
    \ result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N:\
    \ 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) ==\
    \ \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmplzijiudz.swift:21:9: error: cannot assign to value: 'result' is\
    \ a 'let' constant\n        result = String(remainderDigit) + result\n       \
    \ ^~~~~~\n/tmp/tmplzijiudz.swift:16:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var sum = 0\n    var binary = \"\
    \"\n    for _ in 0..<N {\n        sum += N % 2\n        N = N / 2\n    }\n   \
    \ for _ in 0..<N {\n        binary += String(sum % 2)\n        sum = sum / 2\n\
    \    }\n    return binary\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000)\
    \ == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\"\
    )\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpxdbj8x1x.swift:20:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014531
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result = \"\"\n    var remainder\
    \ = N\n    while remainder > 0 {\n        remainder, remainder = remainder / 2,\
    \ remainder % 2\n        result += String(remainder)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wg86fzu.swift:19:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n                 ;\n/tmp/tmp6wg86fzu.swift:19:18: error:\
    \ expected expression\n        remainder, remainder = remainder / 2, remainder\
    \ % 2\n                 ^\n/tmp/tmp6wg86fzu.swift:19:9: warning: variable is unused\n\
    \        remainder, remainder = remainder / 2, remainder % 2\n        ^~~~~~~~~\n\
    /tmp/tmp6wg86fzu.swift:16:9: warning: variable 'result' was never mutated; consider\
    \ changing to 'let' constant\n    var result = \"\"\n    ~~~ ^\n    let\n/tmp/tmp6wg86fzu.swift:17:9:\
    \ warning: variable 'remainder' was never mutated; consider changing to 'let'\
    \ constant\n    var remainder = N\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014024
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    return solve(N: N, base: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmp5r0fr23b.swift:16:30: error: extra argument 'base' in call\n  \
    \  return solve(N: N, base: 2)\n                ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Given a positive integer N, return the total sum of its digits in\
    \ binary.\n/// Example\n/// >>> solve(N: 1000)\n/// \"1\"\n/// >>> solve(N: 150)\n\
    /// \"110\"\n/// >>> solve(N: 147)\n/// \"1100\"\n/// Variables:\n/// @N integer\n\
    /// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary\
    \ number\nfunc solve(N: Int) -> String {\n    var result: String = \"\"\n    var\
    \ sum: Int = 0\n    var remainder: Int = 0\n    for _ in 0..<N {\n        sum\
    \ += remainder\n        remainder = N % 2\n        result += \"1\"\n        N\
    \ = N / 2\n    }\n    result += \"0\"\n    return String(sum) + result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150)\
    \ == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\"\
    )\nassert(solve(N: 963) == \"10010\")"
  status: SyntaxError
  stderr: "/tmp/tmpymlyxfg5.swift:23:9: error: cannot assign to value: 'N' is a 'let'\
    \ constant\n        N = N / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014531
